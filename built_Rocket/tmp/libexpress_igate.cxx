/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/express -Ipanda/src/express -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libexpress_igate.cxx -od built_Rocket/pandac/input/libexpress.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/express -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sthirdparty/win-libs-vc9/openssl/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAEXPRESS -module pandaexpress -library libexpress buffer.h checksumHashGenerator.h circBuffer.h compress_string.h config_express.h copy_stream.h datagram.h datagramGenerator.h datagramIterator.h datagramSink.h dcast.h encrypt_string.h error_utils.h export_dtool.h express_composite.cxx hashGeneratorBase.h hashVal.h indirectLess.h memoryInfo.h memoryUsage.h memoryUsagePointerCounts.h memoryUsagePointers.h multifile.h namable.h nodePointerTo.h nodePointerToBase.h nodeReferenceCount.h openSSLWrapper.h ordered_vector.h pStatCollectorForwardBase.h password_hash.h patchfile.h pointerTo.h pointerToArray.h pointerToArrayBase.h pointerToBase.h pointerToVoid.h profileTimer.h pta_float.h pta_int.h pta_uchar.h ramfile.h referenceCount.h stringDecoder.h subStream.h subStreamBuf.h textEncoder.h threadSafePointerTo.h threadSafePointerToBase.h trueClock.h typedReferenceCount.h typedef.h unicodeLatinMap.h vector_float.h vector_uchar.h virtualFile.h virtualFileComposite.h virtualFileList.h virtualFileMount.h virtualFileMountMultifile.h virtualFileMountSystem.h virtualFileSimple.h virtualFileSystem.h weakPointerCallback.h weakPointerTo.h weakPointerToBase.h weakPointerToVoid.h weakReferenceList.h windowsRegistry.h zStream.h zStreamBuf.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libexpress
#include "py_panda.h"  

#include "bigEndian.h"
#include "buffer.h"
#include "checksumHashGenerator.h"
#include "circBuffer.h"
#include "compress_string.h"
#include "configFlags.h"
#include "configPage.h"
#include "configPageManager.h"
#include "configVariable.h"
#include "configVariableBase.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "configVariableInt64.h"
#include "configVariableList.h"
#include "configVariableManager.h"
#include "configVariableSearchPath.h"
#include "configVariableString.h"
#include "config_express.h"
#include "copy_stream.h"
#include "datagram.h"
#include "datagramGenerator.h"
#include "datagramIterator.h"
#include "datagramSink.h"
#include "dcast.h"
#include "encryptStream.h"
#include "encrypt_string.h"
#include "error_utils.h"
#include "export_dtool.h"
#include "filename.h"
#include "globPattern.h"
#include "hashGeneratorBase.h"
#include "hashVal.h"
#include "indirectLess.h"
#include "littleEndian.h"
#include "memoryInfo.h"
#include "memoryUsage.h"
#include "memoryUsagePointerCounts.h"
#include "memoryUsagePointers.h"
#include "multifile.h"
#include "namable.h"
#include "nodePointerTo.h"
#include "nodePointerToBase.h"
#include "nodeReferenceCount.h"
#include "numeric_types.h"
#include "openSSLWrapper.h"
#include "ordered_vector.h"
#include "pStatCollectorForwardBase.h"
#include "pandaFileStream.h"
#include "pandaSystem.h"
#include "pandabase.h"
#include "password_hash.h"
#include "patchfile.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pointerToArrayBase.h"
#include "pointerToBase.h"
#include "pointerToVoid.h"
#include "profileTimer.h"
#include "pta_float.h"
#include "pta_int.h"
#include "pta_uchar.h"
#include "ramfile.h"
#include "referenceCount.h"
#include "stringDecoder.h"
#include "subStream.h"
#include "subStreamBuf.h"
#include "textEncoder.h"
#include "threadSafePointerTo.h"
#include "threadSafePointerToBase.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedef.h"
#include "unicodeLatinMap.h"
#include "vector_float.h"
#include "vector_uchar.h"
#include "virtualFile.h"
#include "virtualFileComposite.h"
#include "virtualFileList.h"
#include "virtualFileMount.h"
#include "virtualFileMountMultifile.h"
#include "virtualFileMountSystem.h"
#include "virtualFileSimple.h"
#include "virtualFileSystem.h"
#include "weakPointerCallback.h"
#include "weakPointerTo.h"
#include "weakPointerToBase.h"
#include "weakPointerToVoid.h"
#include "weakReferenceList.h"
#include "windowsRegistry.h"
#include "zStream.h"
#include "zStreamBuf.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ConfigFlags
//********************************************************************
typedef  ConfigFlags  ConfigFlags_localtype;
Define_Module_Class(pandaexpress,ConfigFlags,ConfigFlags_localtype,ConfigFlags);
//********************************************************************
//*** prototypes for .. ConfigPage
//********************************************************************
typedef  ConfigPage  ConfigPage_localtype;
Define_Module_Class_Private(pandaexpress,ConfigPage,ConfigPage_localtype,ConfigPage);
//********************************************************************
//*** prototypes for .. ConfigPageManager
//********************************************************************
typedef  ConfigPageManager  ConfigPageManager_localtype;
Define_Module_Class_Private(pandaexpress,ConfigPageManager,ConfigPageManager_localtype,ConfigPageManager);
//********************************************************************
//*** prototypes for .. ConfigVariable
//********************************************************************
typedef  ConfigVariable  ConfigVariable_localtype;
Define_Module_Class(pandaexpress,ConfigVariable,ConfigVariable_localtype,ConfigVariable);
//********************************************************************
//*** prototypes for .. ConfigVariableBase
//********************************************************************
typedef  ConfigVariableBase  ConfigVariableBase_localtype;
Define_Module_Class_Private(pandaexpress,ConfigVariableBase,ConfigVariableBase_localtype,ConfigVariableBase);
//********************************************************************
//*** prototypes for .. ConfigVariableBool
//********************************************************************
typedef  ConfigVariableBool  ConfigVariableBool_localtype;
Define_Module_Class(pandaexpress,ConfigVariableBool,ConfigVariableBool_localtype,ConfigVariableBool);
//********************************************************************
//*** prototypes for .. ConfigVariableDouble
//********************************************************************
typedef  ConfigVariableDouble  ConfigVariableDouble_localtype;
Define_Module_Class(pandaexpress,ConfigVariableDouble,ConfigVariableDouble_localtype,ConfigVariableDouble);
//********************************************************************
//*** prototypes for .. ConfigVariableFilename
//********************************************************************
typedef  ConfigVariableFilename  ConfigVariableFilename_localtype;
Define_Module_Class(pandaexpress,ConfigVariableFilename,ConfigVariableFilename_localtype,ConfigVariableFilename);
//********************************************************************
//*** prototypes for .. ConfigVariableInt
//********************************************************************
typedef  ConfigVariableInt  ConfigVariableInt_localtype;
Define_Module_Class(pandaexpress,ConfigVariableInt,ConfigVariableInt_localtype,ConfigVariableInt);
//********************************************************************
//*** prototypes for .. ConfigVariableInt64
//********************************************************************
typedef  ConfigVariableInt64  ConfigVariableInt64_localtype;
Define_Module_Class(pandaexpress,ConfigVariableInt64,ConfigVariableInt64_localtype,ConfigVariableInt64);
//********************************************************************
//*** prototypes for .. ConfigVariableList
//********************************************************************
typedef  ConfigVariableList  ConfigVariableList_localtype;
Define_Module_Class(pandaexpress,ConfigVariableList,ConfigVariableList_localtype,ConfigVariableList);
//********************************************************************
//*** prototypes for .. ConfigVariableManager
//********************************************************************
typedef  ConfigVariableManager  ConfigVariableManager_localtype;
Define_Module_Class_Private(pandaexpress,ConfigVariableManager,ConfigVariableManager_localtype,ConfigVariableManager);
//********************************************************************
//*** prototypes for .. ConfigVariableSearchPath
//********************************************************************
typedef  ConfigVariableSearchPath  ConfigVariableSearchPath_localtype;
Define_Module_Class(pandaexpress,ConfigVariableSearchPath,ConfigVariableSearchPath_localtype,ConfigVariableSearchPath);
//********************************************************************
//*** prototypes for .. ConfigVariableString
//********************************************************************
typedef  ConfigVariableString  ConfigVariableString_localtype;
Define_Module_Class(pandaexpress,ConfigVariableString,ConfigVariableString_localtype,ConfigVariableString);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_float
//********************************************************************
typedef  ConstPointerToArray< float >  ConstPointerToArray_float_localtype;
Define_Module_Class(pandaexpress,ConstPointerToArray_float,ConstPointerToArray_float_localtype,ConstPointerToArrayFloat);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_float
//********************************************************************
typedef  PointerToArrayBase< float >  PointerToArrayBase_float_localtype;
Define_Module_Class(pandaexpress,PointerToArrayBase_float,PointerToArrayBase_float_localtype,PointerToArrayBaseFloat);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_float
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< float > >  PointerToBase_ReferenceCountedVector_float_localtype;
Define_Module_Class_Private(pandaexpress,PointerToBase_ReferenceCountedVector_float,PointerToBase_ReferenceCountedVector_float_localtype,PointerToBaseReferenceCountedVectorFloat);
//********************************************************************
//*** prototypes for .. PointerToVoid
//********************************************************************
typedef  PointerToVoid  PointerToVoid_localtype;
Define_Module_Class_Private(pandaexpress,PointerToVoid,PointerToVoid_localtype,PointerToVoid);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_int
//********************************************************************
typedef  ConstPointerToArray< int >  ConstPointerToArray_int_localtype;
Define_Module_Class(pandaexpress,ConstPointerToArray_int,ConstPointerToArray_int_localtype,ConstPointerToArrayInt);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_int
//********************************************************************
typedef  PointerToArrayBase< int >  PointerToArrayBase_int_localtype;
Define_Module_Class(pandaexpress,PointerToArrayBase_int,PointerToArrayBase_int_localtype,PointerToArrayBaseInt);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_int
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< int > >  PointerToBase_ReferenceCountedVector_int_localtype;
Define_Module_Class_Private(pandaexpress,PointerToBase_ReferenceCountedVector_int,PointerToBase_ReferenceCountedVector_int_localtype,PointerToBaseReferenceCountedVectorInt);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_unsigned_char
//********************************************************************
typedef  ConstPointerToArray< unsigned char >  ConstPointerToArray_unsigned_char_localtype;
Define_Module_Class(pandaexpress,ConstPointerToArray_unsigned_char,ConstPointerToArray_unsigned_char_localtype,ConstPointerToArrayUnsignedChar);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_unsigned_char
//********************************************************************
typedef  PointerToArrayBase< unsigned char >  PointerToArrayBase_unsigned_char_localtype;
Define_Module_Class(pandaexpress,PointerToArrayBase_unsigned_char,PointerToArrayBase_unsigned_char_localtype,PointerToArrayBaseUnsignedChar);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_unsigned_char
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< unsigned char > >  PointerToBase_ReferenceCountedVector_unsigned_char_localtype;
Define_Module_Class_Private(pandaexpress,PointerToBase_ReferenceCountedVector_unsigned_char,PointerToBase_ReferenceCountedVector_unsigned_char_localtype,PointerToBaseReferenceCountedVectorUnsignedChar);
//********************************************************************
//*** prototypes for .. DConfig
//********************************************************************
typedef  DConfig  DConfig_localtype;
Define_Module_Class(pandaexpress,DConfig,DConfig_localtype,DConfig);
//********************************************************************
//*** prototypes for .. DSearchPath
//********************************************************************
typedef  DSearchPath  DSearchPath_localtype;
Define_Module_Class(pandaexpress,DSearchPath,DSearchPath_localtype,DSearchPath);
//********************************************************************
//*** prototypes for .. DSearchPath_Results
//********************************************************************
typedef  DSearchPath::Results  DSearchPath_Results_localtype;
Define_Module_Class(pandaexpress,DSearchPath_Results,DSearchPath_Results_localtype,DSearchPath::Results);
//********************************************************************
//*** prototypes for .. ExecutionEnvironment
//********************************************************************
typedef  ExecutionEnvironment  ExecutionEnvironment_localtype;
Define_Module_Class(pandaexpress,ExecutionEnvironment,ExecutionEnvironment_localtype,ExecutionEnvironment);
//********************************************************************
//*** prototypes for .. FileStream
//********************************************************************
typedef  FileStream  FileStream_localtype;
Define_Module_Class(pandaexpress,FileStream,FileStream_localtype,FileStream);
//********************************************************************
//*** prototypes for .. iostream
//********************************************************************
typedef  iostream  iostream_localtype;
Define_Module_Class(pandaexpress,iostream,iostream_localtype,Iostream);
//********************************************************************
//*** prototypes for .. istream
//********************************************************************
typedef  istream  istream_localtype;
Define_Module_Class(pandaexpress,istream,istream_localtype,Istream);
//********************************************************************
//*** prototypes for .. ios
//********************************************************************
typedef  ios  ios_localtype;
Define_Module_Class(pandaexpress,ios,ios_localtype,Ios);
//********************************************************************
//*** prototypes for .. ios_base
//********************************************************************
typedef  ios_base  ios_base_localtype;
Define_Module_Class(pandaexpress,ios_base,ios_base_localtype,IosBase);
//********************************************************************
//*** prototypes for .. ostream
//********************************************************************
typedef  ostream  ostream_localtype;
Define_Module_Class(pandaexpress,ostream,ostream_localtype,Ostream);
//********************************************************************
//*** prototypes for .. Filename
//********************************************************************
typedef  Filename  Filename_localtype;
Define_Module_Class(pandaexpress,Filename,Filename_localtype,Filename);
//********************************************************************
//*** prototypes for .. GlobPattern
//********************************************************************
typedef  GlobPattern  GlobPattern_localtype;
Define_Module_Class(pandaexpress,GlobPattern,GlobPattern_localtype,GlobPattern);
//********************************************************************
//*** prototypes for .. IDecryptStream
//********************************************************************
typedef  IDecryptStream  IDecryptStream_localtype;
Define_Module_Class(pandaexpress,IDecryptStream,IDecryptStream_localtype,IDecryptStream);
//********************************************************************
//*** prototypes for .. IFileStream
//********************************************************************
typedef  IFileStream  IFileStream_localtype;
Define_Module_Class(pandaexpress,IFileStream,IFileStream_localtype,IFileStream);
//********************************************************************
//*** prototypes for .. IStreamWrapper
//********************************************************************
typedef  IStreamWrapper  IStreamWrapper_localtype;
Define_Module_Class(pandaexpress,IStreamWrapper,IStreamWrapper_localtype,IStreamWrapper);
//********************************************************************
//*** prototypes for .. StreamWrapperBase
//********************************************************************
typedef  StreamWrapperBase  StreamWrapperBase_localtype;
Define_Module_Class(pandaexpress,StreamWrapperBase,StreamWrapperBase_localtype,StreamWrapperBase);
//********************************************************************
//*** prototypes for .. NeverFreeMemory
//********************************************************************
typedef  NeverFreeMemory  NeverFreeMemory_localtype;
Define_Module_Class(pandaexpress,NeverFreeMemory,NeverFreeMemory_localtype,NeverFreeMemory);
//********************************************************************
//*** prototypes for .. Notify
//********************************************************************
typedef  Notify  Notify_localtype;
Define_Module_Class(pandaexpress,Notify,Notify_localtype,Notify);
//********************************************************************
//*** prototypes for .. NotifyCategory
//********************************************************************
typedef  NotifyCategory  NotifyCategory_localtype;
Define_Module_Class(pandaexpress,NotifyCategory,NotifyCategory_localtype,NotifyCategory);
//********************************************************************
//*** prototypes for .. OEncryptStream
//********************************************************************
typedef  OEncryptStream  OEncryptStream_localtype;
Define_Module_Class(pandaexpress,OEncryptStream,OEncryptStream_localtype,OEncryptStream);
//********************************************************************
//*** prototypes for .. OFileStream
//********************************************************************
typedef  OFileStream  OFileStream_localtype;
Define_Module_Class(pandaexpress,OFileStream,OFileStream_localtype,OFileStream);
//********************************************************************
//*** prototypes for .. OStreamWrapper
//********************************************************************
typedef  OStreamWrapper  OStreamWrapper_localtype;
Define_Module_Class(pandaexpress,OStreamWrapper,OStreamWrapper_localtype,OStreamWrapper);
//********************************************************************
//*** prototypes for .. PandaSystem
//********************************************************************
typedef  PandaSystem  PandaSystem_localtype;
Define_Module_Class_Private(pandaexpress,PandaSystem,PandaSystem_localtype,PandaSystem);
//********************************************************************
//*** prototypes for .. PointerToArray_float
//********************************************************************
typedef  PointerToArray< float >  PointerToArray_float_localtype;
Define_Module_Class(pandaexpress,PointerToArray_float,PointerToArray_float_localtype,PointerToArrayFloat);
//********************************************************************
//*** prototypes for .. PointerToArray_int
//********************************************************************
typedef  PointerToArray< int >  PointerToArray_int_localtype;
Define_Module_Class(pandaexpress,PointerToArray_int,PointerToArray_int_localtype,PointerToArrayInt);
//********************************************************************
//*** prototypes for .. PointerToArray_unsigned_char
//********************************************************************
typedef  PointerToArray< unsigned char >  PointerToArray_unsigned_char_localtype;
Define_Module_Class(pandaexpress,PointerToArray_unsigned_char,PointerToArray_unsigned_char_localtype,PointerToArrayUnsignedChar);
//********************************************************************
//*** prototypes for .. StreamReader
//********************************************************************
typedef  StreamReader  StreamReader_localtype;
Define_Module_Class(pandaexpress,StreamReader,StreamReader_localtype,StreamReader);
//********************************************************************
//*** prototypes for .. StreamWrapper
//********************************************************************
typedef  StreamWrapper  StreamWrapper_localtype;
Define_Module_Class(pandaexpress,StreamWrapper,StreamWrapper_localtype,StreamWrapper);
//********************************************************************
//*** prototypes for .. StreamWriter
//********************************************************************
typedef  StreamWriter  StreamWriter_localtype;
Define_Module_Class(pandaexpress,StreamWriter,StreamWriter_localtype,StreamWriter);
//********************************************************************
//*** prototypes for .. TypeHandle
//********************************************************************
typedef  TypeHandle  TypeHandle_localtype;
Define_Module_Class(pandaexpress,TypeHandle,TypeHandle_localtype,TypeHandle);
//********************************************************************
//*** prototypes for .. TypeRegistry
//********************************************************************
typedef  TypeRegistry  TypeRegistry_localtype;
Define_Module_Class(pandaexpress,TypeRegistry,TypeRegistry_localtype,TypeRegistry);
//********************************************************************
//*** prototypes for .. TypedObject
//********************************************************************
typedef  TypedObject  TypedObject_localtype;
Define_Module_Class(pandaexpress,TypedObject,TypedObject_localtype,TypedObject);
//********************************************************************
//*** prototypes for .. fstream
//********************************************************************
typedef  fstream  fstream_localtype;
Define_Module_Class(pandaexpress,fstream,fstream_localtype,Fstream);
//********************************************************************
//*** prototypes for .. ifstream
//********************************************************************
typedef  ifstream  ifstream_localtype;
Define_Module_Class(pandaexpress,ifstream,ifstream_localtype,Ifstream);
//********************************************************************
//*** prototypes for .. ofstream
//********************************************************************
typedef  ofstream  ofstream_localtype;
Define_Module_Class(pandaexpress,ofstream,ofstream_localtype,Ofstream);
//********************************************************************
//*** prototypes for .. ReferenceCount
//********************************************************************
typedef  ReferenceCount  ReferenceCount_localtype;
Define_Module_ClassRef(pandaexpress,ReferenceCount,ReferenceCount_localtype,ReferenceCount);
//********************************************************************
//*** prototypes for .. Buffer
//********************************************************************
typedef  Buffer  Buffer_localtype;
Define_Module_ClassRef(pandaexpress,Buffer,Buffer_localtype,Buffer);
//********************************************************************
//*** prototypes for .. PStatCollectorForwardBase
//********************************************************************
typedef  PStatCollectorForwardBase  PStatCollectorForwardBase_localtype;
Define_Module_ClassRef(pandaexpress,PStatCollectorForwardBase,PStatCollectorForwardBase_localtype,PStatCollectorForwardBase);
//********************************************************************
//*** prototypes for .. NodeReferenceCount
//********************************************************************
typedef  NodeReferenceCount  NodeReferenceCount_localtype;
Define_Module_ClassRef_Private(pandaexpress,NodeReferenceCount,NodeReferenceCount_localtype,NodeReferenceCount);
//********************************************************************
//*** prototypes for .. Datagram
//********************************************************************
typedef  Datagram  Datagram_localtype;
Define_Module_Class(pandaexpress,Datagram,Datagram_localtype,Datagram);
//********************************************************************
//*** prototypes for .. DatagramGenerator
//********************************************************************
typedef  DatagramGenerator  DatagramGenerator_localtype;
Define_Module_Class(pandaexpress,DatagramGenerator,DatagramGenerator_localtype,DatagramGenerator);
//********************************************************************
//*** prototypes for .. DatagramIterator
//********************************************************************
typedef  DatagramIterator  DatagramIterator_localtype;
Define_Module_Class(pandaexpress,DatagramIterator,DatagramIterator_localtype,DatagramIterator);
//********************************************************************
//*** prototypes for .. DatagramSink
//********************************************************************
typedef  DatagramSink  DatagramSink_localtype;
Define_Module_Class(pandaexpress,DatagramSink,DatagramSink_localtype,DatagramSink);
//********************************************************************
//*** prototypes for .. TextEncoder
//********************************************************************
typedef  TextEncoder  TextEncoder_localtype;
Define_Module_Class(pandaexpress,TextEncoder,TextEncoder_localtype,TextEncoder);
//********************************************************************
//*** prototypes for .. TypedReferenceCount
//********************************************************************
typedef  TypedReferenceCount  TypedReferenceCount_localtype;
Define_Module_ClassRef(pandaexpress,TypedReferenceCount,TypedReferenceCount_localtype,TypedReferenceCount);
//********************************************************************
//*** prototypes for .. VirtualFile
//********************************************************************
typedef  VirtualFile  VirtualFile_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFile,VirtualFile_localtype,VirtualFile);
//********************************************************************
//*** prototypes for .. VirtualFileComposite
//********************************************************************
typedef  VirtualFileComposite  VirtualFileComposite_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileComposite,VirtualFileComposite_localtype,VirtualFileComposite);
//********************************************************************
//*** prototypes for .. VirtualFileMount
//********************************************************************
typedef  VirtualFileMount  VirtualFileMount_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileMount,VirtualFileMount_localtype,VirtualFileMount);
//********************************************************************
//*** prototypes for .. ISubStream
//********************************************************************
typedef  ISubStream  ISubStream_localtype;
Define_Module_Class(pandaexpress,ISubStream,ISubStream_localtype,ISubStream);
//********************************************************************
//*** prototypes for .. Multifile
//********************************************************************
typedef  Multifile  Multifile_localtype;
Define_Module_ClassRef(pandaexpress,Multifile,Multifile_localtype,Multifile);
//********************************************************************
//*** prototypes for .. Multifile_CertRecord
//********************************************************************
typedef  Multifile::CertRecord  Multifile_CertRecord_localtype;
Define_Module_Class(pandaexpress,Multifile_CertRecord,Multifile_CertRecord_localtype,Multifile::CertRecord);
//********************************************************************
//*** prototypes for .. VirtualFileMountMultifile
//********************************************************************
typedef  VirtualFileMountMultifile  VirtualFileMountMultifile_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileMountMultifile,VirtualFileMountMultifile_localtype,VirtualFileMountMultifile);
//********************************************************************
//*** prototypes for .. VirtualFileMountSystem
//********************************************************************
typedef  VirtualFileMountSystem  VirtualFileMountSystem_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileMountSystem,VirtualFileMountSystem_localtype,VirtualFileMountSystem);
//********************************************************************
//*** prototypes for .. VirtualFileSimple
//********************************************************************
typedef  VirtualFileSimple  VirtualFileSimple_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileSimple,VirtualFileSimple_localtype,VirtualFileSimple);
//********************************************************************
//*** prototypes for .. Namable
//********************************************************************
typedef  Namable  Namable_localtype;
Define_Module_Class(pandaexpress,Namable,Namable_localtype,Namable);
//********************************************************************
//*** prototypes for .. IDecompressStream
//********************************************************************
typedef  IDecompressStream  IDecompressStream_localtype;
Define_Module_Class(pandaexpress,IDecompressStream,IDecompressStream_localtype,IDecompressStream);
//********************************************************************
//*** prototypes for .. OCompressStream
//********************************************************************
typedef  OCompressStream  OCompressStream_localtype;
Define_Module_Class(pandaexpress,OCompressStream,OCompressStream_localtype,OCompressStream);
//********************************************************************
//*** prototypes for .. VirtualFileList
//********************************************************************
typedef  VirtualFileList  VirtualFileList_localtype;
Define_Module_ClassRef(pandaexpress,VirtualFileList,VirtualFileList_localtype,VirtualFileList);
//********************************************************************
//*** prototypes for .. VirtualFileSystem
//********************************************************************
typedef  VirtualFileSystem  VirtualFileSystem_localtype;
Define_Module_Class(pandaexpress,VirtualFileSystem,VirtualFileSystem_localtype,VirtualFileSystem);
//********************************************************************
//*** prototypes for .. Ramfile
//********************************************************************
typedef  Ramfile  Ramfile_localtype;
Define_Module_Class(pandaexpress,Ramfile,Ramfile_localtype,Ramfile);
//********************************************************************
//*** prototypes for .. HashVal
//********************************************************************
typedef  HashVal  HashVal_localtype;
Define_Module_Class(pandaexpress,HashVal,HashVal_localtype,HashVal);
//********************************************************************
//*** prototypes for .. Patchfile
//********************************************************************
typedef  Patchfile  Patchfile_localtype;
Define_Module_Class(pandaexpress,Patchfile,Patchfile_localtype,Patchfile);
//********************************************************************
//*** prototypes for .. TrueClock
//********************************************************************
typedef  TrueClock  TrueClock_localtype;
Define_Module_Class_Private(pandaexpress,TrueClock,TrueClock_localtype,TrueClock);
//********************************************************************
//*** prototypes for .. ProfileTimer
//********************************************************************
typedef  ProfileTimer  ProfileTimer_localtype;
Define_Module_Class(pandaexpress,ProfileTimer,ProfileTimer_localtype,ProfileTimer);
//********************************************************************
//*** prototypes for .. WeakPointerToVoid
//********************************************************************
typedef  WeakPointerToVoid  WeakPointerToVoid_localtype;
Define_Module_Class_Private(pandaexpress,WeakPointerToVoid,WeakPointerToVoid_localtype,WeakPointerToVoid);
//********************************************************************
//*** prototypes for .. WindowsRegistry
//********************************************************************
typedef  WindowsRegistry  WindowsRegistry_localtype;
Define_Module_Class(pandaexpress,WindowsRegistry,WindowsRegistry_localtype,WindowsRegistry);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DConfig &get_config_express(void)
 *******************************************************************/
static PyObject *Dtool_get_config_express_764(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-DConfig &get_config_express(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getConfigExpress", key_word_list))
        {
            DConfig *return_value = &(get_config_express());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DConfig,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConfigExpress()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_config_express_764_comment =
    "C++ Interface:\n"
    "getConfigExpress()\n"
    "\n"
    "// Expose the Config variable for Python access.\n"
    "\n"
    "// Returns the configure object for accessing config variables from a\n"
    "// scripting language.\n"
    "";
#else
static const char * Dtool_get_config_express_764_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > compress_string(basic_string< char > const &source, int compression_level)
 *******************************************************************/
static PyObject *Dtool_compress_string_777(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > compress_string(basic_string< char > const &source, int compression_level)
        char *param0_str; int param0_len;
        int param1;
        static char * key_word_list[] = {(char *)"source", (char *)"compression_level", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:compressString", key_word_list, &param0_str, &param0_len, &param1))
        {
            basic_string< char > return_value = compress_string(basic_string<char>(param0_str, param0_len), (int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compressString(string source, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_compress_string_777_comment =
    "C++ Interface:\n"
    "compressString(string source, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: compress_string\n"
    "//       Access: Published\n"
    "//  Description: Compress the indicated source string at the given\n"
    "//               compression level (1 through 9).  Returns the\n"
    "//               compressed string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_compress_string_777_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > decompress_string(basic_string< char > const &source)
 *******************************************************************/
static PyObject *Dtool_decompress_string_778(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > decompress_string(basic_string< char > const &source)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"source", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:decompressString", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:decompressString", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = decompress_string(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decompressString(string source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decompress_string_778_comment =
    "C++ Interface:\n"
    "decompressString(string source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decompress_string\n"
    "//       Access: Published\n"
    "//  Description: Decompresss the previously-compressed string()).  The\n"
    "//               return value is the decompressed string.\n"
    "//\n"
    "//               Note that a decompression error cannot easily be\n"
    "//               detected, and the return value may simply be a\n"
    "//               garbage or truncated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decompress_string_778_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool compress_file(Filename const &source, Filename const &dest, int compression_level)
 *******************************************************************/
static PyObject *Dtool_compress_file_779(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool compress_file(Filename const &source, Filename const &dest, int compression_level)
            PyObject *param0;
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"compression_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:compressFile", key_word_list, &param0, &param1, &param2))
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "compressFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "compressFile", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = compress_file(*param0_this, *param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compressFile(const Filename source, const Filename dest, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_compress_file_779_comment =
    "C++ Interface:\n"
    "compressFile(const Filename source, const Filename dest, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: compress_file\n"
    "//       Access: Published\n"
    "//  Description: Compresss the data from the source file at the given\n"
    "//               compression level (1 through 9).  The source file is\n"
    "//               read in its entirety, and the compressed results are\n"
    "//               written to the dest file, overwriting its contents.\n"
    "//               The return value is bool on success, or false on\n"
    "//               failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_compress_file_779_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool decompress_file(Filename const &source, Filename const &dest)
 *******************************************************************/
static PyObject *Dtool_decompress_file_780(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool decompress_file(Filename const &source, Filename const &dest)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:decompressFile", key_word_list, &param0, &param1))
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "decompressFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "decompressFile", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = decompress_file(*param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decompressFile(const Filename source, const Filename dest)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decompress_file_780_comment =
    "C++ Interface:\n"
    "decompressFile(const Filename source, const Filename dest)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decompress_file\n"
    "//       Access: Published\n"
    "//  Description: Decompresss the data from the source file.  The\n"
    "//               source file is read in its entirety, and the\n"
    "//               decompressed results are written to the dest file,\n"
    "//               overwriting its contents.  The return value is bool\n"
    "//               on success, or false on failure.\n"
    "//\n"
    "//               Note that a decompression error cannot easily be\n"
    "//               detected, and the output may simply be a garbage\n"
    "//               or truncated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decompress_file_780_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool compress_stream(istream &source, ostream &dest, int compression_level)
 *******************************************************************/
static PyObject *Dtool_compress_stream_781(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool compress_stream(istream &source, ostream &dest, int compression_level)
            PyObject *param0;
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"compression_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:compressStream", key_word_list, &param0, &param1, &param2))
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "compressStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "compressStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = compress_stream(*param0_this, *param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compressStream(non-const Istream source, non-const Ostream dest, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_compress_stream_781_comment =
    "C++ Interface:\n"
    "compressStream(non-const Istream source, non-const Ostream dest, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: compress_stream\n"
    "//       Access: Published\n"
    "//  Description: Compresss the data from the source stream at the\n"
    "//               given compression level (1 through 9).  The source\n"
    "//               stream is read from its current position to the\n"
    "//               end-of-file, and the compressed results are written\n"
    "//               to the dest stream.  The return value is bool on\n"
    "//               success, or false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_compress_stream_781_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool decompress_stream(istream &source, ostream &dest)
 *******************************************************************/
static PyObject *Dtool_decompress_stream_782(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool decompress_stream(istream &source, ostream &dest)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:decompressStream", key_word_list, &param0, &param1))
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "decompressStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "decompressStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = decompress_stream(*param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decompressStream(non-const Istream source, non-const Ostream dest)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decompress_stream_782_comment =
    "C++ Interface:\n"
    "decompressStream(non-const Istream source, non-const Ostream dest)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decompress_stream\n"
    "//       Access: Published\n"
    "//  Description: Decompresss the data from the previously-compressed\n"
    "//               source stream.  The source stream is read from its\n"
    "//               current position to the end-of-file, and the\n"
    "//               decompressed results are written to the dest stream.\n"
    "//               The return value is bool on success, or false on\n"
    "//               failure.\n"
    "//\n"
    "//               Note that a decompression error cannot easily be\n"
    "//               detected, and the output may simply be a garbage\n"
    "//               or truncated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decompress_stream_782_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool copy_stream(istream &source, ostream &dest)
 *******************************************************************/
static PyObject *Dtool_copy_stream_783(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool copy_stream(istream &source, ostream &dest)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:copyStream", key_word_list, &param0, &param1))
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "copyStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "copyStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = copy_stream(*param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyStream(non-const Istream source, non-const Ostream dest)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_copy_stream_783_comment =
    "C++ Interface:\n"
    "copyStream(non-const Istream source, non-const Ostream dest)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: copy_stream\n"
    "//       Access: Published\n"
    "//  Description: Reads the source stream from its current position to\n"
    "//               the end of the stream, and writes that data to the\n"
    "//               dest stream at its current position.  Returns true on\n"
    "//               success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_copy_stream_783_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
 * basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
 * basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
 * basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
 *******************************************************************/
static PyObject *Dtool_encrypt_string_886(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"source", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:encryptString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                basic_string< char > return_value = encrypt_string(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"source", (char *)"password", (char *)"algorithm", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:encryptString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                basic_string< char > return_value = encrypt_string(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"source", (char *)"password", (char *)"algorithm", (char *)"key_length", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:encryptString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                basic_string< char > return_value = encrypt_string(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-basic_string< char > encrypt_string(basic_string< char > const &source, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"source", (char *)"password", (char *)"algorithm", (char *)"key_length", (char *)"iteration_count", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#ii:encryptString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4))
            {
                basic_string< char > return_value = encrypt_string(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3, (int)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "encryptString() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "encryptString(string source, string password)\n"
          "encryptString(string source, string password, string algorithm)\n"
          "encryptString(string source, string password, string algorithm, int key_length)\n"
          "encryptString(string source, string password, string algorithm, int key_length, int iteration_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_encrypt_string_886_comment =
    "C++ Interface:\n"
    "encryptString(string source, string password)\n"
    "encryptString(string source, string password, string algorithm)\n"
    "encryptString(string source, string password, string algorithm, int key_length)\n"
    "encryptString(string source, string password, string algorithm, int key_length, int iteration_count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: encrypt_string\n"
    "//       Access: Published\n"
    "//  Description: Encrypts the indicated source string using the given\n"
    "//               password, and the algorithm specified by\n"
    "//               encryption-algorithm.  Returns the encrypted string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_encrypt_string_886_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > decrypt_string(basic_string< char > const &source, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_decrypt_string_887(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > decrypt_string(basic_string< char > const &source, basic_string< char > const &password)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"source", (char *)"password", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:decryptString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
        {
            basic_string< char > return_value = decrypt_string(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decryptString(string source, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decrypt_string_887_comment =
    "C++ Interface:\n"
    "decryptString(string source, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decrypt_string\n"
    "//       Access: Published\n"
    "//  Description: Decrypts the previously-encrypted string using the\n"
    "//               given password (which must be the same password\n"
    "//               passed to encrypt()).  The return value is the\n"
    "//               decrypted string.\n"
    "//\n"
    "//               Note that a decryption error, including an incorrect\n"
    "//               password, cannot easily be detected, and the return\n"
    "//               value may simply be a garbage string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decrypt_string_887_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
 * bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
 * bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
 * bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
 *******************************************************************/
static PyObject *Dtool_encrypt_file_888(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:encryptFile", key_word_list, &param0, &param1, &param2_str, &param2_len))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "encryptFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "encryptFile", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_file(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#:encryptFile", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "encryptFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "encryptFile", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_file(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                int param4;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", (char *)"key_length", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#i:encryptFile", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "encryptFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "encryptFile", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_file(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", (char *)"key_length", (char *)"iteration_count", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#ii:encryptFile", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "encryptFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "encryptFile", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_file(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "encryptFile() takes 3, 4, 5, or 6 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "encryptFile(const Filename source, const Filename dest, string password)\n"
          "encryptFile(const Filename source, const Filename dest, string password, string algorithm)\n"
          "encryptFile(const Filename source, const Filename dest, string password, string algorithm, int key_length)\n"
          "encryptFile(const Filename source, const Filename dest, string password, string algorithm, int key_length, int iteration_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_encrypt_file_888_comment =
    "C++ Interface:\n"
    "encryptFile(const Filename source, const Filename dest, string password)\n"
    "encryptFile(const Filename source, const Filename dest, string password, string algorithm)\n"
    "encryptFile(const Filename source, const Filename dest, string password, string algorithm, int key_length)\n"
    "encryptFile(const Filename source, const Filename dest, string password, string algorithm, int key_length, int iteration_count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: encrypt_file\n"
    "//       Access: Published\n"
    "//  Description: Encrypts the data from the source file using the\n"
    "//               given password.  The source file is read in its\n"
    "//               entirety, and the encrypted results are written to\n"
    "//               the dest file, overwriting its contents.  The return\n"
    "//               value is bool on success, or false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_encrypt_file_888_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool decrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_decrypt_file_889(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool decrypt_file(Filename const &source, Filename const &dest, basic_string< char > const &password)
            PyObject *param0;
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:decryptFile", key_word_list, &param0, &param1, &param2_str, &param2_len))
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "decryptFile", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "decryptFile", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = decrypt_file(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decryptFile(const Filename source, const Filename dest, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decrypt_file_889_comment =
    "C++ Interface:\n"
    "decryptFile(const Filename source, const Filename dest, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decrypt_file\n"
    "//       Access: Published\n"
    "//  Description: Decrypts the data from the source file using the\n"
    "//               given password (which must match the same password\n"
    "//               passed to encrypt()).  The source file is read in its\n"
    "//               entirety, and the decrypted results are written to\n"
    "//               the dest file, overwriting its contents.  The return\n"
    "//               value is bool on success, or false on failure.\n"
    "//\n"
    "//               Note that a decryption error, including an incorrect\n"
    "//               password, cannot easily be detected, and the output\n"
    "//               may simply be a garbage string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decrypt_file_889_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
 * bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
 * bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
 * bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
 *******************************************************************/
static PyObject *Dtool_encrypt_stream_890(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm = ((string())), int key_length = (-1), int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:encryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "encryptStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "encryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_stream(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length = (-1), int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#:encryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "encryptStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "encryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_stream(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count = (-1))
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                int param4;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", (char *)"key_length", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#i:encryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "encryptStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "encryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_stream(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool encrypt_stream(istream &source, ostream &dest, basic_string< char > const &password, basic_string< char > const &algorithm, int key_length, int iteration_count)
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", (char *)"algorithm", (char *)"key_length", (char *)"iteration_count", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#ii:encryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "encryptStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "encryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = encrypt_stream(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "encryptStream() takes 3, 4, 5, or 6 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "encryptStream(non-const Istream source, non-const Ostream dest, string password)\n"
          "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm)\n"
          "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm, int key_length)\n"
          "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm, int key_length, int iteration_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_encrypt_stream_890_comment =
    "C++ Interface:\n"
    "encryptStream(non-const Istream source, non-const Ostream dest, string password)\n"
    "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm)\n"
    "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm, int key_length)\n"
    "encryptStream(non-const Istream source, non-const Ostream dest, string password, string algorithm, int key_length, int iteration_count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: encrypt_stream\n"
    "//       Access: Published\n"
    "//  Description: Encrypts the data from the source stream using the\n"
    "//               given password.  The source stream is read from its\n"
    "//               current position to the end-of-file, and the\n"
    "//               encrypted results are written to the dest stream.\n"
    "//               The return value is bool on success, or false on\n"
    "//               failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_encrypt_stream_890_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool decrypt_stream(istream &source, ostream &dest, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_decrypt_stream_891(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool decrypt_stream(istream &source, ostream &dest, basic_string< char > const &password)
            PyObject *param0;
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"source", (char *)"dest", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:decryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len))
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "decryptStream", 0, coerced_ptr, report_errors);
ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "decryptStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = decrypt_stream(*param0_this, *param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decryptStream(non-const Istream source, non-const Ostream dest, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_decrypt_stream_891_comment =
    "C++ Interface:\n"
    "decryptStream(non-const Istream source, non-const Ostream dest, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: decrypt_stream\n"
    "//       Access: Published\n"
    "//  Description: Decrypts the data from the previously-encrypted\n"
    "//               source stream using the given password (which must be\n"
    "//               the same password passed to encrypt()).  The source\n"
    "//               stream is read from its current position to the\n"
    "//               end-of-file, and the decrypted results are written to\n"
    "//               the dest stream.  The return value is bool on\n"
    "//               success, or false on failure.\n"
    "//\n"
    "//               Note that a decryption error, including an incorrect\n"
    "//               password, cannot easily be detected, and the output\n"
    "//               may simply be a garbage string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_decrypt_stream_891_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > error_to_text(ErrorUtilCode err)
 *******************************************************************/
static PyObject *Dtool_error_to_text_893(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > error_to_text(ErrorUtilCode err)
        int param0;
        static char * key_word_list[] = {(char *)"err", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:errorToText", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:errorToText", &param0));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = error_to_text((ErrorUtilCode)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "errorToText(int err)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_error_to_text_893_comment =
    "C++ Interface:\n"
    "errorToText(int err)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: error_to_text\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_error_to_text_893_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int get_write_error(void)
 *******************************************************************/
static PyObject *Dtool_get_write_error_894(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-int get_write_error(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getWriteError", key_word_list))
        {
            int return_value = get_write_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWriteError()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_write_error_894_comment =
    "C++ Interface:\n"
    "getWriteError()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_write_error\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_get_write_error_894_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > handle_socket_error(void)
 *******************************************************************/
static PyObject *Dtool_handle_socket_error_895(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > handle_socket_error(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":handleSocketError", key_word_list))
        {
            basic_string< char > return_value = handle_socket_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "handleSocketError()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_handle_socket_error_895_comment =
    "C++ Interface:\n"
    "handleSocketError()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: handle_socket_error\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_handle_socket_error_895_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int get_network_error(void)
 *******************************************************************/
static PyObject *Dtool_get_network_error_896(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-int get_network_error(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNetworkError", key_word_list))
        {
            int return_value = get_network_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNetworkError()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_network_error_896_comment =
    "C++ Interface:\n"
    "getNetworkError()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_network_error\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_get_network_error_896_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > password_hash(basic_string< char > const &password, basic_string< char > const &salt, int iters, int keylen)
 *******************************************************************/
static PyObject *Dtool_password_hash_1171(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > password_hash(basic_string< char > const &password, basic_string< char > const &salt, int iters, int keylen)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"password", (char *)"salt", (char *)"iters", (char *)"keylen", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#ii:passwordHash", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3))
        {
            basic_string< char > return_value = password_hash(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "passwordHash(string password, string salt, int iters, int keylen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_password_hash_1171_comment =
    "C++ Interface:\n"
    "passwordHash(string password, string salt, int iters, int keylen)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: password_hash\n"
    "//       Access: Published\n"
    "//  Description: Generates a non-reversible hash of a particular\n"
    "//               length based on an arbitrary password and a random\n"
    "//               salt.  This is much stronger than the algorithm\n"
    "//               implemented by the standard Unix crypt().\n"
    "//\n"
    "//               The resulting hash can be useful for two primary\n"
    "//               purposes: (1) the hash may be recorded to disk in\n"
    "//               lieu of recording plaintext passwords, for validation\n"
    "//               against a password entered by the user later (which\n"
    "//               should produce the same hash given a particular\n"
    "//               salt), or (2) the hash may be used as input to an\n"
    "//               encryption algorithm that requires a key of a\n"
    "//               particular length.\n"
    "//\n"
    "//               password is the text password provided by a user.\n"
    "//\n"
    "//               salt should be a string of arbitrary random bytes (it\n"
    "//               need not be crypotographically secure, just different\n"
    "//               for each different hash).\n"
    "//\n"
    "//               iters should be a number in the thousands to indicate\n"
    "//               the number of times the hash algorithm should be\n"
    "//               applied.  In general, iters should be chosen to make\n"
    "//               the computation as expensive as it can be and still\n"
    "//               be tolerable, to reduce the attractiveness of a\n"
    "//               brute-force attack.\n"
    "//\n"
    "//               keylen is the length in bytes of the required key\n"
    "//               hash.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_password_hash_1171_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. ConfigFlags 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * NotifyCategory *ConfigFlags::downcast_to_NotifyCategory(void)
 *******************************************************************/
static PyObject *Dtool_ConfigFlags_downcast_to_NotifyCategory_510(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigFlags * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigFlags,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NotifyCategory *ConfigFlags::downcast_to_NotifyCategory(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNotifyCategory", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNotifyCategory"));
        if(!PyErr_Occurred())
        {
            NotifyCategory *return_value = (NotifyCategory *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigFlags.downcastToNotifyCategory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNotifyCategory(non-const ConfigFlags this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigFlags_downcast_to_NotifyCategory_510_comment =
    "C++ Interface:\n"
    "downcastToNotifyCategory(non-const ConfigFlags this)\n"
    "\n"
    "downcast from ConfigFlags to NotifyCategory\n"
    "";
#else
static const char * Dtool_ConfigFlags_downcast_to_NotifyCategory_510_comment = NULL;
#endif

int  Dtool_Init_ConfigFlags(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConfigFlags)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConfigFlags(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigFlags)
    {
        printf("ConfigFlags ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigFlags * local_this = (ConfigFlags *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigFlags)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigFlags(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigFlags)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigPage 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static ConfigPage *ConfigPage::get_default_page(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_default_page_6(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ConfigPage *ConfigPage::get_default_page(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultPage", key_word_list))
        {
            ConfigPage *return_value = ConfigPage::get_default_page();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultPage()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_default_page_6_comment =
    "C++ Interface:\n"
    "getDefaultPage()\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_get_default_page_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ConfigPage *ConfigPage::get_local_page(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_local_page_7(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ConfigPage *ConfigPage::get_local_page(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalPage", key_word_list))
        {
            ConfigPage *return_value = ConfigPage::get_local_page();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalPage()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_local_page_7_comment =
    "C++ Interface:\n"
    "getLocalPage()\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_get_local_page_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigPage::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_name_8(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigPage::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigPage*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_name_8_comment =
    "C++ Interface:\n"
    "getName(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the page.  If the page was loaded\n"
    "//               from a .prc file, this is usually the filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_get_name_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigPage::is_special(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_is_special_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigPage::is_special(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSpecial", key_word_list));
        else
            (PyArg_Parse(args, ":isSpecial"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigPage*)local_this)->is_special();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSpecial(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_is_special_9_comment =
    "C++ Interface:\n"
    "isSpecial(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::is_special\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this is the special \"default\" or\n"
    "//               \"local\" page, or false if it is an ordinary page,\n"
    "//               e.g. an implicit page loaded from a prc file at\n"
    "//               startup, or an explicit page created by\n"
    "//               ConfigPageManager::make_explicit_page().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_is_special_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigPage::is_implicit(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_is_implicit_10(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigPage::is_implicit(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isImplicit", key_word_list));
        else
            (PyArg_Parse(args, ":isImplicit"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigPage*)local_this)->is_implicit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isImplicit(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_is_implicit_10_comment =
    "C++ Interface:\n"
    "isImplicit(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::is_implicit\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the page was loaded by implicitly\n"
    "//               searching the config path on startup, or false if it\n"
    "//               was explicitly loaded by dynamic code after initial\n"
    "//               startup.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_is_implicit_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPage::get_page_seq(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_page_seq_11(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPage::get_page_seq(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageSeq", key_word_list));
        else
            (PyArg_Parse(args, ":getPageSeq"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPage*)local_this)->get_page_seq();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageSeq(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_page_seq_11_comment =
    "C++ Interface:\n"
    "getPageSeq(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::get_page_seq\n"
    "//       Access: Published\n"
    "//  Description: Returns the sequence number of the page.  \n"
    "//\n"
    "//               Sequence numbers for a particular class (implicit\n"
    "//               vs. explicit) of pages are assigned as each page is\n"
    "//               loaded; each page is given a higher sequence number\n"
    "//               than all the pages loaded before it.\n"
    "//\n"
    "//               The implicit_load pages, which are discovered in the\n"
    "//               file system automatically, have a different set of\n"
    "//               sequence numbers than the explicit pages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_get_page_seq_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPage::get_trust_level(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_trust_level_12(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPage::get_trust_level(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrustLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getTrustLevel"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPage*)local_this)->get_trust_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrustLevel(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_trust_level_12_comment =
    "C++ Interface:\n"
    "getTrustLevel(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::get_trust_level\n"
    "//       Access: Published\n"
    "//  Description: Returns the trust level associated with this page.\n"
    "//               An untrusted page is trust level 0; if the page was\n"
    "//               loaded from a signed .prc file, its trust level is\n"
    "//               the index number of the certificate that signed it.\n"
    "//               Generally, a higher trust level value represents\n"
    "//               a greater level of trust.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_get_trust_level_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigPage::set_trust_level(int trust_level)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_set_trust_level_13(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigPage::set_trust_level(int trust_level)
        int param1;
        static char * key_word_list[] = {(char *)"trust_level", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTrustLevel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTrustLevel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_trust_level((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPage.setTrustLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTrustLevel(non-const ConfigPage this, int trust_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_set_trust_level_13_comment =
    "C++ Interface:\n"
    "setTrustLevel(non-const ConfigPage this, int trust_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::set_trust_level\n"
    "//       Access: Published\n"
    "//  Description: Explicitly sets the trust level on this particular\n"
    "//               page.  Note that any subsequent changes to the page,\n"
    "//               or to any variable declarations on it, will reset the\n"
    "//               trust level to zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_set_trust_level_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigPage::get_signature(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_signature_14(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigPage::get_signature(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSignature", key_word_list));
        else
            (PyArg_Parse(args, ":getSignature"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigPage*)local_this)->get_signature();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignature(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_signature_14_comment =
    "C++ Interface:\n"
    "getSignature(const ConfigPage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPage::get_signature\n"
    "//       Access: Published\n"
    "//  Description: Returns the raw binary signature that was found in\n"
    "//               the prc file, if any.  This method is probably not\n"
    "//               terribly useful for most applications.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPage_get_signature_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPage::clear(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_clear_15(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConfigPage::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPage.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_clear_15_comment =
    "C++ Interface:\n"
    "clear(non-const ConfigPage this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_clear_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConfigPage::read_prc(istream &in)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_read_prc_16(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConfigPage::read_prc(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:readPrc", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:readPrc", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "ConfigPage.readPrc", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->read_prc(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigPage.readPrc() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readPrc(non-const ConfigPage this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_read_prc_16_comment =
    "C++ Interface:\n"
    "readPrc(non-const ConfigPage this, non-const Istream in)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_read_prc_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConfigPage::read_encrypted_prc(istream &in, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_ConfigPage_read_encrypted_prc_17(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConfigPage::read_encrypted_prc(istream &in, basic_string< char > const &password)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"in", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:readEncryptedPrc", key_word_list, &param1, &param2_str, &param2_len))
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "ConfigPage.readEncryptedPrc", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->read_encrypted_prc(*param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigPage.readEncryptedPrc() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readEncryptedPrc(non-const ConfigPage this, non-const Istream in, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_read_encrypted_prc_17_comment =
    "C++ Interface:\n"
    "readEncryptedPrc(non-const ConfigPage this, non-const Istream in, string password)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_read_encrypted_prc_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConfigPage::get_num_declarations(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_num_declarations_20(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConfigPage::get_num_declarations(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDeclarations", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDeclarations"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPage*)local_this)->get_num_declarations();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDeclarations(const ConfigPage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_num_declarations_20_comment =
    "C++ Interface:\n"
    "getNumDeclarations(const ConfigPage this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_get_num_declarations_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > ConfigPage::get_variable_name(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_variable_name_22(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > ConfigPage::get_variable_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVariableName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVariableName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigPage*)local_this)->get_variable_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVariableName(const ConfigPage this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_variable_name_22_comment =
    "C++ Interface:\n"
    "getVariableName(const ConfigPage this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_get_variable_name_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > ConfigPage::get_string_value(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_get_string_value_23(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > ConfigPage::get_string_value(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getStringValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getStringValue", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigPage*)local_this)->get_string_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStringValue(const ConfigPage this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_get_string_value_23_comment =
    "C++ Interface:\n"
    "getStringValue(const ConfigPage this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_get_string_value_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConfigPage::is_variable_used(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_is_variable_used_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ConfigPage::is_variable_used(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isVariableUsed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isVariableUsed", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigPage*)local_this)->is_variable_used((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isVariableUsed(const ConfigPage this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_is_variable_used_24_comment =
    "C++ Interface:\n"
    "isVariableUsed(const ConfigPage this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_is_variable_used_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPage::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_output_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigPage::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigPage.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigPage*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigPage this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_output_25_comment =
    "C++ Interface:\n"
    "output(const ConfigPage this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_output_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPage::output_brief_signature(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_output_brief_signature_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigPage::output_brief_signature(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBriefSignature", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputBriefSignature", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigPage.outputBriefSignature", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigPage*)local_this)->output_brief_signature(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputBriefSignature(const ConfigPage this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_output_brief_signature_26_comment =
    "C++ Interface:\n"
    "outputBriefSignature(const ConfigPage this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_output_brief_signature_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPage::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigPage_write_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigPage::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigPage.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigPage*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigPage this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPage_write_27_comment =
    "C++ Interface:\n"
    "write(const ConfigPage this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPage_write_27_comment = NULL;
#endif

int  Dtool_Init_ConfigPage(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConfigPage)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConfigPage(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigPage)
    {
        printf("ConfigPage ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigPage * local_this = (ConfigPage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigPage)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigPage(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigPage)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigPageManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigPageManager::loaded_implicit_pages(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_loaded_implicit_pages_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigPageManager::loaded_implicit_pages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":loadedImplicitPages", key_word_list));
        else
            (PyArg_Parse(args, ":loadedImplicitPages"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigPageManager*)local_this)->loaded_implicit_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadedImplicitPages(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_loaded_implicit_pages_29_comment =
    "C++ Interface:\n"
    "loadedImplicitPages(const ConfigPageManager this)\n"
    "\n"
    "// Filename: configPageManager.I\n"
    "// Created by:  drose (15Oct04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::loaded_implicit_pages\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the implicit *.prc files have already\n"
    "//               been loaded, false otherwise.  Normally this will\n"
    "//               only be false briefly before startup.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_loaded_implicit_pages_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigPageManager::load_implicit_pages(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_load_implicit_pages_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigPageManager::load_implicit_pages(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":loadImplicitPages", key_word_list));
        else
            (PyArg_Parse(args, ":loadImplicitPages"));
        if(!PyErr_Occurred())
        {
            (local_this)->load_implicit_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPageManager.loadImplicitPages() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadImplicitPages(non-const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_load_implicit_pages_30_comment =
    "C++ Interface:\n"
    "loadImplicitPages(non-const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::load_implicit_pages\n"
    "//       Access: Published\n"
    "//  Description: Searches the PRC_DIR and/or PRC_PATH directories for\n"
    "//               *.prc files and loads them in as pages.  This is\n"
    "//               normally called automatically at startup time, when\n"
    "//               the first variable's value is referenced.  See also\n"
    "//               reload_implicit_pages().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_load_implicit_pages_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPageManager::reload_implicit_pages(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_reload_implicit_pages_31(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConfigPageManager::reload_implicit_pages(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reloadImplicitPages", key_word_list));
        else
            (PyArg_Parse(args, ":reloadImplicitPages"));
        if(!PyErr_Occurred())
        {
            (local_this)->reload_implicit_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPageManager.reloadImplicitPages() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reloadImplicitPages(non-const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_reload_implicit_pages_31_comment =
    "C++ Interface:\n"
    "reloadImplicitPages(non-const ConfigPageManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_reload_implicit_pages_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath &ConfigPageManager::get_search_path(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_search_path_32(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline DSearchPath &ConfigPageManager::get_search_path(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSearchPath", key_word_list));
        else
            (PyArg_Parse(args, ":getSearchPath"));
        if(!PyErr_Occurred())
        {
            DSearchPath *return_value = &((local_this)->get_search_path());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPageManager.getSearchPath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSearchPath(non-const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_search_path_32_comment =
    "C++ Interface:\n"
    "getSearchPath(non-const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_search_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the search path used to locate implicit .prc\n"
    "//               files.  This is determined by the PRC_DIR and\n"
    "//               PRC_PATH environment variables.  The object returned\n"
    "//               by this method may be modified to change the path at\n"
    "//               runtime, and then reload_implicit_pages() called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_search_path_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPageManager::get_num_prc_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_num_prc_patterns_33(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPageManager::get_num_prc_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPrcPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPrcPatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPageManager*)local_this)->get_num_prc_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPrcPatterns(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_num_prc_patterns_33_comment =
    "C++ Interface:\n"
    "getNumPrcPatterns(const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_num_prc_patterns\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of patterns, like \"*.prc\", that\n"
    "//               are compiled in that will be searched for as default\n"
    "//               config filenames.  Normally there is only one\n"
    "//               pattern, and it is \"*.prc\", but others may be\n"
    "//               specified with the PRC_FILENAME variable in\n"
    "//               Config.pp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_num_prc_patterns_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigPageManager::get_prc_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_prc_pattern_34(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigPageManager::get_prc_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPrcPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPrcPattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigPageManager*)local_this)->get_prc_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrcPattern(const ConfigPageManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_prc_pattern_34_comment =
    "C++ Interface:\n"
    "getPrcPattern(const ConfigPageManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_prc_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth filename pattern that will be\n"
    "//               considered a match as a valid config file.  See\n"
    "//               get_num_prc_patterns().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_prc_pattern_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPageManager::get_num_prc_encrypted_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_35(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPageManager::get_num_prc_encrypted_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPrcEncryptedPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPrcEncryptedPatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPageManager*)local_this)->get_num_prc_encrypted_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPrcEncryptedPatterns(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_35_comment =
    "C++ Interface:\n"
    "getNumPrcEncryptedPatterns(const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_num_prc_encrypted_patterns\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of patterns, like \"*.pre\", that\n"
    "//               are compiled in that will be searched for as special\n"
    "//               config files that are understood to be encrypted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigPageManager::get_prc_encrypted_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_prc_encrypted_pattern_36(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigPageManager::get_prc_encrypted_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPrcEncryptedPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPrcEncryptedPattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigPageManager*)local_this)->get_prc_encrypted_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrcEncryptedPattern(const ConfigPageManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_prc_encrypted_pattern_36_comment =
    "C++ Interface:\n"
    "getPrcEncryptedPattern(const ConfigPageManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_prc_encrypted_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth filename pattern that will be\n"
    "//               considered a match as a valid encrypted config\n"
    "//               file.  See get_num_prc_encrypted_patterns().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_prc_encrypted_pattern_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPageManager::get_num_prc_executable_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_num_prc_executable_patterns_37(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPageManager::get_num_prc_executable_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPrcExecutablePatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPrcExecutablePatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPageManager*)local_this)->get_num_prc_executable_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPrcExecutablePatterns(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_num_prc_executable_patterns_37_comment =
    "C++ Interface:\n"
    "getNumPrcExecutablePatterns(const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_num_prc_executable_patterns\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of patterns, like \"*.exe\", that\n"
    "//               are compiled in that will be searched for as special\n"
    "//               config files that are to be executed as a program,\n"
    "//               and their output taken to be input.  This is normally\n"
    "//               empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_num_prc_executable_patterns_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigPageManager::get_prc_executable_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_prc_executable_pattern_38(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigPageManager::get_prc_executable_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPrcExecutablePattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPrcExecutablePattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigPageManager*)local_this)->get_prc_executable_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrcExecutablePattern(const ConfigPageManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_prc_executable_pattern_38_comment =
    "C++ Interface:\n"
    "getPrcExecutablePattern(const ConfigPageManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_prc_executable_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth filename pattern that will be\n"
    "//               considered a match as a valid executable-style config\n"
    "//               file.  See get_num_prc_executable_patterns().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_prc_executable_pattern_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigPage *ConfigPageManager::make_explicit_page(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_make_explicit_page_39(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConfigPage *ConfigPageManager::make_explicit_page(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeExplicitPage", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:makeExplicitPage", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            ConfigPage *return_value = (local_this)->make_explicit_page(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigPageManager.makeExplicitPage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeExplicitPage(non-const ConfigPageManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_make_explicit_page_39_comment =
    "C++ Interface:\n"
    "makeExplicitPage(non-const ConfigPageManager this, string name)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_make_explicit_page_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_delete_explicit_page_40(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"page", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:deleteExplicitPage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:deleteExplicitPage", &param1));
            if(!PyErr_Occurred())
            {
                ConfigPage *param1_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ConfigPage, 1, "ConfigPageManager.deleteExplicitPage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->delete_explicit_page(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigPageManager.deleteExplicitPage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "deleteExplicitPage(non-const ConfigPageManager this, non-const ConfigPage page)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_delete_explicit_page_40_comment =
    "C++ Interface:\n"
    "deleteExplicitPage(non-const ConfigPageManager this, non-const ConfigPage page)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_delete_explicit_page_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPageManager::get_num_implicit_pages(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_num_implicit_pages_41(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPageManager::get_num_implicit_pages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumImplicitPages", key_word_list));
        else
            (PyArg_Parse(args, ":getNumImplicitPages"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPageManager*)local_this)->get_num_implicit_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumImplicitPages(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_num_implicit_pages_41_comment =
    "C++ Interface:\n"
    "getNumImplicitPages(const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_num_implicit_pages\n"
    "//       Access: Published\n"
    "//  Description: Returns the current number of implicitly-loaded\n"
    "//               ConfigPages in the world.  These represent files that\n"
    "//               were automatically discovered on the disk as .prc\n"
    "//               files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_num_implicit_pages_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigPage *ConfigPageManager::get_implicit_page(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_implicit_page_42(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConfigPage *ConfigPageManager::get_implicit_page(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getImplicitPage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getImplicitPage", &param1));
        if(!PyErr_Occurred())
        {
            ConfigPage *return_value = ((const ConfigPageManager*)local_this)->get_implicit_page((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getImplicitPage(const ConfigPageManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_implicit_page_42_comment =
    "C++ Interface:\n"
    "getImplicitPage(const ConfigPageManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_implicit_page\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth implicit ConfigPage in the world.\n"
    "//               See get_num_implicit_pages().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_implicit_page_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigPageManager::get_num_explicit_pages(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_num_explicit_pages_43(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigPageManager::get_num_explicit_pages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumExplicitPages", key_word_list));
        else
            (PyArg_Parse(args, ":getNumExplicitPages"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigPageManager*)local_this)->get_num_explicit_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumExplicitPages(const ConfigPageManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_num_explicit_pages_43_comment =
    "C++ Interface:\n"
    "getNumExplicitPages(const ConfigPageManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_num_explicit_pages\n"
    "//       Access: Published\n"
    "//  Description: Returns the current number of explicitly-loaded\n"
    "//               ConfigPages in the world.  These represent pages that\n"
    "//               were loaded dynamically at runtime by explicit calls\n"
    "//               to ConfigPageManager::make_explicit_page().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_num_explicit_pages_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigPage *ConfigPageManager::get_explicit_page(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_explicit_page_44(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConfigPage *ConfigPageManager::get_explicit_page(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getExplicitPage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getExplicitPage", &param1));
        if(!PyErr_Occurred())
        {
            ConfigPage *return_value = ((const ConfigPageManager*)local_this)->get_explicit_page((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPage,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExplicitPage(const ConfigPageManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_explicit_page_44_comment =
    "C++ Interface:\n"
    "getExplicitPage(const ConfigPageManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigPageManager::get_explicit_page\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth explicit ConfigPage in the world.\n"
    "//               See get_num_explicit_pages().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_explicit_page_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPageManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_output_45(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigPageManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigPageManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigPageManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigPageManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_output_45_comment =
    "C++ Interface:\n"
    "output(const ConfigPageManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_output_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigPageManager::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_write_46(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigPageManager::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigPageManager.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigPageManager*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigPageManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_write_46_comment =
    "C++ Interface:\n"
    "write(const ConfigPageManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_write_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_ConfigPageManager_get_global_ptr_47(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            ConfigPageManager *return_value = ConfigPageManager::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigPageManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigPageManager_get_global_ptr_47_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigPageManager_get_global_ptr_47_comment = NULL;
#endif

int  Dtool_Init_ConfigPageManager(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConfigPageManager)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConfigPageManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigPageManager)
    {
        printf("ConfigPageManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigPageManager * local_this = (ConfigPageManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigPageManager)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigPageManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigPageManager)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigPageManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigVariable::get_string_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_string_value_65(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigVariable::get_string_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStringValue", key_word_list));
        else
            (PyArg_Parse(args, ":getStringValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigVariable*)local_this)->get_string_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStringValue(const ConfigVariable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_string_value_65_comment =
    "C++ Interface:\n"
    "getStringValue(const ConfigVariable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_string_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the toplevel value of the variable, formatted\n"
    "//               as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_string_value_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_string_value(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_string_value_66(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_string_value(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setStringValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setStringValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_string_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setStringValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStringValue(non-const ConfigVariable this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_string_value_66_comment =
    "C++ Interface:\n"
    "setStringValue(non-const ConfigVariable this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_string_value\n"
    "//       Access: Published\n"
    "//  Description: Changes the value assigned to this variable.  This\n"
    "//               creates a local value that shadows any values defined\n"
    "//               in the .prc files, until clear_local_value() is\n"
    "//               called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_string_value_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::clear_value(void)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_clear_value_67(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::clear_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearValue", key_word_list));
        else
            (PyArg_Parse(args, ":clearValue"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.clearValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearValue(non-const ConfigVariable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_clear_value_67_comment =
    "C++ Interface:\n"
    "clearValue(non-const ConfigVariable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::clear_value\n"
    "//       Access: Published\n"
    "//  Description: Removes the value assigned to this variable, and lets\n"
    "//               its original value (as read from the prc files) show\n"
    "//               through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_clear_value_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariable::get_num_words(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_num_words_68(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariable::get_num_words(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumWords", key_word_list));
        else
            (PyArg_Parse(args, ":getNumWords"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariable*)local_this)->get_num_words();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumWords(const ConfigVariable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_num_words_68_comment =
    "C++ Interface:\n"
    "getNumWords(const ConfigVariable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_num_words\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of words in the variable's\n"
    "//               value.  A word is defined as a sequence of\n"
    "//               non-whitespace characters delimited by whitespace.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_num_words_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::has_string_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_has_string_word_69(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::has_string_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasStringWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasStringWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->has_string_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasStringWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_has_string_word_69_comment =
    "C++ Interface:\n"
    "hasStringWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::has_string_word\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the variable's value has a valid\n"
    "//               string value for the nth word.  This is really the\n"
    "//               same thing as asking if there are at least n words in\n"
    "//               the value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_has_string_word_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::has_bool_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_has_bool_word_70(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::has_bool_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasBoolWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasBoolWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->has_bool_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBoolWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_has_bool_word_70_comment =
    "C++ Interface:\n"
    "hasBoolWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::has_bool_word\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the variable's value has a valid\n"
    "//               boolean value for the nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_has_bool_word_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::has_int_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_has_int_word_71(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::has_int_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasIntWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasIntWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->has_int_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasIntWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_has_int_word_71_comment =
    "C++ Interface:\n"
    "hasIntWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::has_int_word\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the variable's value has a valid\n"
    "//               integer value for the nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_has_int_word_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::has_int64_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_has_int64_word_72(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::has_int64_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasInt64Word", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasInt64Word", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->has_int64_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasInt64Word(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_has_int64_word_72_comment =
    "C++ Interface:\n"
    "hasInt64Word(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::has_int64_word\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the variable's value has a valid\n"
    "//               64-bit integer value for the nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_has_int64_word_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::has_double_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_has_double_word_73(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::has_double_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasDoubleWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasDoubleWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->has_double_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDoubleWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_has_double_word_73_comment =
    "C++ Interface:\n"
    "hasDoubleWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::has_double_word\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the variable's value has a valid\n"
    "//               integer value for the nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_has_double_word_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariable::get_string_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_string_word_74(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariable::get_string_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getStringWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getStringWord", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariable*)local_this)->get_string_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStringWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_string_word_74_comment =
    "C++ Interface:\n"
    "getStringWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_string_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the string value of the nth word of the\n"
    "//               variable's value, or empty string if there is no\n"
    "//               nth value.  See also has_string_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_string_word_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariable::get_bool_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_bool_word_75(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariable::get_bool_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBoolWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBoolWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariable*)local_this)->get_bool_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBoolWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_bool_word_75_comment =
    "C++ Interface:\n"
    "getBoolWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_bool_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the boolean value of the nth word of the\n"
    "//               variable's value, or false if there is no nth\n"
    "//               value.  See also has_bool_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_bool_word_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariable::get_int_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_int_word_76(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariable::get_int_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getIntWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getIntWord", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariable*)local_this)->get_int_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_int_word_76_comment =
    "C++ Interface:\n"
    "getIntWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_int_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the integer value of the nth word of the\n"
    "//               variable's value, or 0 if there is no nth value.\n"
    "//               See also has_int_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_int_word_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariable::get_int64_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_int64_word_77(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariable::get_int64_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getInt64Word", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getInt64Word", &param1));
        if(!PyErr_Occurred())
        {
            __int64 return_value = ((const ConfigVariable*)local_this)->get_int64_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt64Word(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_int64_word_77_comment =
    "C++ Interface:\n"
    "getInt64Word(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_int64_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the int64 value of the nth word of the\n"
    "//               variable's value, or 0 if there is no nth value.\n"
    "//               See also has_int_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_int64_word_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariable::get_double_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_get_double_word_78(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariable::get_double_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDoubleWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDoubleWord", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ConfigVariable*)local_this)->get_double_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoubleWord(const ConfigVariable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_get_double_word_78_comment =
    "C++ Interface:\n"
    "getDoubleWord(const ConfigVariable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::get_double_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the integer value of the nth word of the\n"
    "//               variable's value, or 0 if there is no nth value.\n"
    "//               See also has_double_word().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_get_double_word_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_string_word(int n, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_string_word_79(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_string_word(int n, basic_string< char > const &value)
        int param1;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "is#:setStringWord", key_word_list, &param1, &param2_str, &param2_len))
        {
            (local_this)->set_string_word((int)param1, basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setStringWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStringWord(non-const ConfigVariable this, int n, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_string_word_79_comment =
    "C++ Interface:\n"
    "setStringWord(non-const ConfigVariable this, int n, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_string_word\n"
    "//       Access: Published\n"
    "//  Description: Changes the nth word to the indicated value without\n"
    "//               affecting the other words.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_string_word_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_bool_word(int n, bool value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_bool_word_80(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_bool_word(int n, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setBoolWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_bool_word((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setBoolWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBoolWord(non-const ConfigVariable this, int n, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_bool_word_80_comment =
    "C++ Interface:\n"
    "setBoolWord(non-const ConfigVariable this, int n, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_bool_word\n"
    "//       Access: Published\n"
    "//  Description: Changes the nth word to the indicated value without\n"
    "//               affecting the other words.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_bool_word_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_int_word(int n, int value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_int_word_81(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_int_word(int n, int value)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setIntWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_int_word((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setIntWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIntWord(non-const ConfigVariable this, int n, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_int_word_81_comment =
    "C++ Interface:\n"
    "setIntWord(non-const ConfigVariable this, int n, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_int_word\n"
    "//       Access: Published\n"
    "//  Description: Changes the nth word to the indicated value without\n"
    "//               affecting the other words.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_int_word_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_int64_word(int n, __int64 value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_int64_word_82(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_int64_word(int n, __int64 value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setInt64Word", key_word_list, &param1, &param2))
        {
             PyObject *param2_long = PyNumber_Long(param2);
            if (!((param2_long == NULL)))
            {
                (local_this)->set_int64_word((int)param1, PyLong_AsLongLong(param2_long));
                 Py_XDECREF(param2_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setInt64Word() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInt64Word(non-const ConfigVariable this, int n, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_int64_word_82_comment =
    "C++ Interface:\n"
    "setInt64Word(non-const ConfigVariable this, int n, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_int64_word\n"
    "//       Access: Published\n"
    "//  Description: Changes the nth word to the indicated value without\n"
    "//               affecting the other words.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_int64_word_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariable::set_double_word(int n, double value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariable_set_double_word_83(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariable::set_double_word(int n, double value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setDoubleWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_double_word((int)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariable.setDoubleWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDoubleWord(non-const ConfigVariable this, int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariable_set_double_word_83_comment =
    "C++ Interface:\n"
    "setDoubleWord(non-const ConfigVariable this, int n, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariable::set_double_word\n"
    "//       Access: Published\n"
    "//  Description: Changes the nth word to the indicated value without\n"
    "//               affecting the other words.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariable_set_double_word_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariable::ConfigVariable(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_ConfigVariable(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline ConfigVariable::ConfigVariable(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariable", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:ConfigVariable", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            ConfigVariable *return_value = new ConfigVariable(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariable,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConfigVariable(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariable)
    {
        printf("ConfigVariable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariable * local_this = (ConfigVariable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariable)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariable)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariable*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigVariableBase::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_get_name_50(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigVariableBase::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigVariableBase*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_get_name_50_comment =
    "C++ Interface:\n"
    "getName(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_get_name_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_get_value_type_51(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueType", key_word_list));
        else
            (PyArg_Parse(args, ":getValueType"));
        if(!PyErr_Occurred())
        {
            ConfigFlags::ValueType return_value = ((const ConfigVariableBase*)local_this)->get_value_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueType(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_get_value_type_51_comment =
    "C++ Interface:\n"
    "getValueType(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::get_value_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the stated type of this variable.  This\n"
    "//               should be VT_list, unless a later variable\n"
    "//               declaration has changed it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_get_value_type_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigVariableBase::get_description(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_get_description_52(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigVariableBase::get_description(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDescription", key_word_list));
        else
            (PyArg_Parse(args, ":getDescription"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigVariableBase*)local_this)->get_description();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDescription(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_get_description_52_comment =
    "C++ Interface:\n"
    "getDescription(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::get_description\n"
    "//       Access: Published\n"
    "//  Description: Returns the brief description of this variable, if\n"
    "//               it has been defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_get_description_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableBase::get_flags(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_get_flags_53(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableBase::get_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableBase*)local_this)->get_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlags(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_get_flags_53_comment =
    "C++ Interface:\n"
    "getFlags(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::get_flags\n"
    "//       Access: Public\n"
    "//  Description: Returns the flags value as set by set_flags().  This\n"
    "//               includes the trust level and some other settings.\n"
    "//               See the individual methods is_closed(),\n"
    "//               get_trust_level(), etc. to pull out the semantic\n"
    "//               meaning of these flags individually.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_get_flags_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBase::is_closed(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_is_closed_54(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBase::is_closed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClosed", key_word_list));
        else
            (PyArg_Parse(args, ":isClosed"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBase*)local_this)->is_closed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClosed(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_is_closed_54_comment =
    "C++ Interface:\n"
    "isClosed(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::is_closed\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the variable is not trusted by any\n"
    "//               prc file (and hence cannot be modified from its\n"
    "//               compiled-in default value), or false for the normal\n"
    "//               case, in which the variable can be modified by any\n"
    "//               prc file at or above its trust level (see\n"
    "//               get_trust_level()).\n"
    "//\n"
    "//               This value only has effect in a release build\n"
    "//               (specifically, when PRC_RESPECT_TRUST_LEVEL is\n"
    "//               defined true in Config.pp).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_is_closed_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableBase::get_trust_level(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_get_trust_level_55(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableBase::get_trust_level(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrustLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getTrustLevel"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableBase*)local_this)->get_trust_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrustLevel(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_get_trust_level_55_comment =
    "C++ Interface:\n"
    "getTrustLevel(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::get_trust_level\n"
    "//       Access: Public\n"
    "//  Description: Returns the minimum trust_level a prc file must\n"
    "//               demonstrate in order to redefine the value for this\n"
    "//               variable.  Arguably, this should be called the\n"
    "//               \"mistrust level\", since the larger the value, the\n"
    "//               more suspicious we are of prc files.  This value is\n"
    "//               not used if is_closed() returns true, which indicates\n"
    "//               no file may be trusted.\n"
    "//\n"
    "//               This value only has effect in a release build\n"
    "//               (specifically, when PRC_RESPECT_TRUST_LEVEL is\n"
    "//               defined true in Config.pp).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_get_trust_level_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBase::is_dynamic(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_is_dynamic_56(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBase::is_dynamic(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDynamic", key_word_list));
        else
            (PyArg_Parse(args, ":isDynamic"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBase*)local_this)->is_dynamic();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDynamic(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_is_dynamic_56_comment =
    "C++ Interface:\n"
    "isDynamic(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::is_dynamic\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the variable was indicated as\n"
    "//               \"dynamic\" by its constructor, indicating that its\n"
    "//               name was dynamically generated, possibly from a large\n"
    "//               pool, and it should not be listed along with the\n"
    "//               other variables.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_is_dynamic_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBase::clear_local_value(void)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_clear_local_value_57(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool ConfigVariableBase::clear_local_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLocalValue", key_word_list));
        else
            (PyArg_Parse(args, ":clearLocalValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->clear_local_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableBase.clearLocalValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLocalValue(non-const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_clear_local_value_57_comment =
    "C++ Interface:\n"
    "clearLocalValue(non-const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::clear_local_value\n"
    "//       Access: Published\n"
    "//  Description: Removes the local value defined for this variable,\n"
    "//               and allows its value to be once again retrieved from\n"
    "//               the .prc files.\n"
    "//\n"
    "//               Returns true if the value was successfully removed,\n"
    "//               false if it did not exist in the first place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_clear_local_value_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBase::has_local_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_has_local_value_58(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBase::has_local_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasLocalValue", key_word_list));
        else
            (PyArg_Parse(args, ":hasLocalValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBase*)local_this)->has_local_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasLocalValue(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_has_local_value_58_comment =
    "C++ Interface:\n"
    "hasLocalValue(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::has_local_value\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this variable's value has been\n"
    "//               shadowed by a local assignment (as created via\n"
    "//               make_local_value()), or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_has_local_value_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBase::has_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_has_value_59(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBase::has_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasValue", key_word_list));
        else
            (PyArg_Parse(args, ":hasValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBase*)local_this)->has_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasValue(const ConfigVariableBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_has_value_59_comment =
    "C++ Interface:\n"
    "hasValue(const ConfigVariableBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::has_value\n"
    "//       Access: Public\n"
    "//  Description: Returns true if this variable has an explicit value,\n"
    "//               either from a prc file or locally set, or false if\n"
    "//               variable has its default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_has_value_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableBase::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_output_60(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void ConfigVariableBase::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableBase*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigVariableBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_output_60_comment =
    "C++ Interface:\n"
    "output(const ConfigVariableBase this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_output_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableBase::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBase_write_61(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void ConfigVariableBase::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableBase.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableBase*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigVariableBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBase_write_61_comment =
    "C++ Interface:\n"
    "write(const ConfigVariableBase this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBase::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBase_write_61_comment = NULL;
#endif

int  Dtool_Init_ConfigVariableBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConfigVariableBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConfigVariableBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableBase)
    {
        printf("ConfigVariableBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableBase * local_this = (ConfigVariableBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableBase)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableBase)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableBool 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableBool::operator =(bool value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_operator_86(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableBool::operator =(bool value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:assign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator =((PyObject_IsTrue(param1)!=0));
            ConfigVariableBool *return_value = local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableBool,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableBool.assign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableBool this, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_operator_86_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableBool this, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_operator_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableBool::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_size_88(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableBool::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableBool*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConfigVariableBool this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_size_88_comment =
    "C++ Interface:\n"
    "size(const ConfigVariableBool this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::size()\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique words in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_size_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBool::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_operator_89(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBool::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const ConfigVariableBool*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            bool return_value = ((const ConfigVariableBool*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableBool this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_operator_89_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableBool this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the variable's nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_operator_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableBool::set_value(bool value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_set_value_90(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableBool::set_value(bool value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableBool.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableBool this, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_set_value_90_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableBool this, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_set_value_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBool::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_get_value_91(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBool::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBool*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableBool this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_get_value_91_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableBool this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_get_value_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBool::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_get_default_value_92(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBool::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBool*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableBool this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_get_default_value_92_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableBool this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_get_default_value_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBool::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_get_word_93(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBool::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableBool*)local_this)->get_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableBool this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_get_word_93_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableBool this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_get_word_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableBool::set_word(int n, bool value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_set_word_94(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableBool::set_word(int n, bool value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_word((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableBool.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableBool this, int n, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_set_word_94_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableBool this, int n, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_set_word_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableBool::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableBool_operator_typecast_bool_87(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableBool * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBool,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableBool::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const ConfigVariableBool*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const ConfigVariableBool this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableBool_operator_typecast_bool_87_comment =
    "C++ Interface:\n"
    "__nonzero__(const ConfigVariableBool this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableBool::typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableBool_operator_typecast_bool_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name)
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableBool(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableBool", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableBool", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), (PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(3):
        {
        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), (PyObject_IsTrue(param1)!=0), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(4):
        {
        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableBool::ConfigVariableBool(basic_string< char > const &name, bool default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#i:ConfigVariableBool", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
            {
                ConfigVariableBool *return_value = new ConfigVariableBool(basic_string<char>(param0_str, param0_len), (PyObject_IsTrue(param1)!=0), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableBool,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableBool() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableBool(string name)\n"
          "ConfigVariableBool(string name, string default_value)\n"
          "ConfigVariableBool(string name, bool default_value)\n"
          "ConfigVariableBool(string name, string default_value, string description)\n"
          "ConfigVariableBool(string name, bool default_value, string description)\n"
          "ConfigVariableBool(string name, string default_value, string description, int flags)\n"
          "ConfigVariableBool(string name, bool default_value, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableBool(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableBool)
    {
        printf("ConfigVariableBool ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableBool * local_this = (ConfigVariableBool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableBool)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableBool(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableBool)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableBool*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableBool*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableBool*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableDouble 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableDouble::operator =(double value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_operator_98(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableDouble::operator =(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:assign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:assign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator =((double)param1);
            ConfigVariableDouble *return_value = local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableDouble,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableDouble.assign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableDouble this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_operator_98_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableDouble this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_operator_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableDouble::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_size_100(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableDouble::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableDouble*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConfigVariableDouble this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_size_100_comment =
    "C++ Interface:\n"
    "size(const ConfigVariableDouble this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::size()\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique words in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_size_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariableDouble::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_operator_101(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariableDouble::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const ConfigVariableDouble*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            double return_value = ((const ConfigVariableDouble*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableDouble this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_operator_101_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableDouble this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the variable's nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_operator_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableDouble::set_value(double value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_set_value_102(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableDouble::set_value(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableDouble.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableDouble this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_set_value_102_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableDouble this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_set_value_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariableDouble::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_get_value_103(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariableDouble::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ConfigVariableDouble*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableDouble this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_get_value_103_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableDouble this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_get_value_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariableDouble::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_get_default_value_104(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariableDouble::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ConfigVariableDouble*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableDouble this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_get_default_value_104_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableDouble this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_get_default_value_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariableDouble::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_get_word_105(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariableDouble::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ConfigVariableDouble*)local_this)->get_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableDouble this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_get_word_105_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableDouble this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_get_word_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableDouble::set_word(int n, double value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_set_word_106(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableDouble::set_word(int n, double value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_word((int)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableDouble.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableDouble this, int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_set_word_106_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableDouble this, int n, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_set_word_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ConfigVariableDouble::operator typecast double(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableDouble_operator_typecast_double_99(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableDouble * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableDouble,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ConfigVariableDouble::operator typecast double(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecastDouble", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecastDouble"));
        if(!PyErr_Occurred())
        {
            double return_value = (double)(*(const ConfigVariableDouble*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecastDouble(const ConfigVariableDouble this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableDouble_operator_typecast_double_99_comment =
    "C++ Interface:\n"
    "operatorTypecastDouble(const ConfigVariableDouble this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableDouble::typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableDouble_operator_typecast_double_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name)
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableDouble(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableDouble", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableDouble", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            double param1;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), (double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(3):
        {
        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            double param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ds#:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), (double)param1, basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(4):
        {
        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableDouble::ConfigVariableDouble(basic_string< char > const &name, double default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            double param1;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ds#i:ConfigVariableDouble", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
            {
                ConfigVariableDouble *return_value = new ConfigVariableDouble(basic_string<char>(param0_str, param0_len), (double)param1, basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableDouble,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableDouble() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableDouble(string name)\n"
          "ConfigVariableDouble(string name, string default_value)\n"
          "ConfigVariableDouble(string name, float default_value)\n"
          "ConfigVariableDouble(string name, string default_value, string description)\n"
          "ConfigVariableDouble(string name, float default_value, string description)\n"
          "ConfigVariableDouble(string name, string default_value, string description, int flags)\n"
          "ConfigVariableDouble(string name, float default_value, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableDouble(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableDouble)
    {
        printf("ConfigVariableDouble ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableDouble * local_this = (ConfigVariableDouble *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableDouble)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableDouble(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableDouble)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableDouble*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableDouble*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableDouble*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableFilename 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableFilename::operator =(Filename const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_110(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableFilename::operator =(Filename const &value)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    ConfigVariableFilename *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableFilename,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableFilename.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableFilename this, const Filename value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_110_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableFilename this, const Filename value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char const *ConfigVariableFilename::c_str(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_c_str_112(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char const *ConfigVariableFilename::c_str(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cStr", key_word_list));
        else
            (PyArg_Parse(args, ":cStr"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const ConfigVariableFilename*)local_this)->c_str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cStr(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_c_str_112_comment =
    "C++ Interface:\n"
    "cStr(const ConfigVariableFilename this)\n"
    "\n"
    "// These methods help the ConfigVariableFilename act like a Filename\n"
    "// object.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::c_str\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_c_str_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableFilename::empty(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_empty_113(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableFilename::empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":empty", key_word_list));
        else
            (PyArg_Parse(args, ":empty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableFilename*)local_this)->empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "empty(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_empty_113_comment =
    "C++ Interface:\n"
    "empty(const ConfigVariableFilename this)\n"
    "\n"
    "// These methods help the ConfigVariableFilename act like a Filename\n"
    "// object.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::empty\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_empty_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ConfigVariableFilename::length(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_length_114(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ConfigVariableFilename::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConfigVariableFilename*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_length_114_comment =
    "C++ Interface:\n"
    "length(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::length\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_length_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char ConfigVariableFilename::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_115(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char ConfigVariableFilename::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            char return_value = ((const ConfigVariableFilename*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableFilename this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_115_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableFilename this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::Indexing operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_fullpath(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_116(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_fullpath(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullpath", key_word_list));
        else
            (PyArg_Parse(args, ":getFullpath"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_fullpath();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullpath(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_fullpath_116_comment =
    "C++ Interface:\n"
    "getFullpath(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_fullpath\n"
    "//       Access: Public\n"
    "//  Description: Returns the entire filename: directory, basename,\n"
    "//               extension.  This is the same thing returned by the\n"
    "//               string typecast operator, so this function is a\n"
    "//               little redundant.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_fullpath_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_dirname(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_dirname_117(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_dirname(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirname", key_word_list));
        else
            (PyArg_Parse(args, ":getDirname"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_dirname();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirname(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_dirname_117_comment =
    "C++ Interface:\n"
    "getDirname(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_dirname\n"
    "//       Access: Public\n"
    "//  Description: Returns the directory part of the filename.  This is\n"
    "//               everything in the filename up to, but not including\n"
    "//               the rightmost slash.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_dirname_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_basename(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_basename_118(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_basename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBasename", key_word_list));
        else
            (PyArg_Parse(args, ":getBasename"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_basename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasename(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_basename_118_comment =
    "C++ Interface:\n"
    "getBasename(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_basename\n"
    "//       Access: Public\n"
    "//  Description: Returns the basename part of the filename.  This is\n"
    "//               everything in the filename after the rightmost slash,\n"
    "//               including any extensions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_basename_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_fullpath_wo_extension(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_119(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_fullpath_wo_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullpathWoExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getFullpathWoExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_fullpath_wo_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullpathWoExtension(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_fullpath_wo_extension_119_comment =
    "C++ Interface:\n"
    "getFullpathWoExtension(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_fullpath_wo_extension\n"
    "//       Access: Public\n"
    "//  Description: Returns the full filename--directory and basename\n"
    "//               parts--except for the extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_fullpath_wo_extension_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_basename_wo_extension(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_basename_wo_extension_120(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_basename_wo_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBasenameWoExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getBasenameWoExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_basename_wo_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasenameWoExtension(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_basename_wo_extension_120_comment =
    "C++ Interface:\n"
    "getBasenameWoExtension(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_basename_wo_extension\n"
    "//       Access: Public\n"
    "//  Description: Returns the basename part of the filename, without\n"
    "//               the file extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_basename_wo_extension_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableFilename::get_extension(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_extension_121(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableFilename::get_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableFilename*)local_this)->get_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtension(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_extension_121_comment =
    "C++ Interface:\n"
    "getExtension(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_extension\n"
    "//       Access: Public\n"
    "//  Description: Returns the file extension.  This is everything after\n"
    "//               the rightmost dot, if there is one, or the empty\n"
    "//               string if there is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_extension_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableFilename::operator ==(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_122(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ConfigVariableFilename::operator ==(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ConfigVariableFilename*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const ConfigVariableFilename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_122_comment =
    "C++ Interface:\n"
    "eq(const ConfigVariableFilename this, const Filename other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::Equality operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableFilename::operator !=(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_123(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ConfigVariableFilename::operator !=(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ConfigVariableFilename*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const ConfigVariableFilename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_123_comment =
    "C++ Interface:\n"
    "ne(const ConfigVariableFilename this, const Filename other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::Inequality operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableFilename::operator <(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_124(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool ConfigVariableFilename::operator <(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ConfigVariableFilename*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const ConfigVariableFilename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_124_comment =
    "C++ Interface:\n"
    "lessThan(const ConfigVariableFilename this, const Filename other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::Ordering operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableFilename::set_value(Filename const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_set_value_125(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableFilename::set_value(Filename const &value)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValue", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.setValue", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableFilename.setValue() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableFilename this, const Filename value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_set_value_125_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableFilename this, const Filename value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_set_value_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &ConfigVariableFilename::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_value_126(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &ConfigVariableFilename::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const ConfigVariableFilename*)local_this)->get_value());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_value_126_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_value_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename ConfigVariableFilename::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_default_value_127(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename ConfigVariableFilename::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            Filename result = ((const ConfigVariableFilename*)local_this)->get_default_value();
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_default_value_127_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_default_value_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename ConfigVariableFilename::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_get_word_128(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename ConfigVariableFilename::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            Filename result = ((const ConfigVariableFilename*)local_this)->get_word((int)param1);
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableFilename this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_get_word_128_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableFilename this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_get_word_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableFilename::set_word(int n, Filename const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_set_word_129(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableFilename::set_word(int n, Filename const &value)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setWord", key_word_list, &param1, &param2))
            {
                Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "ConfigVariableFilename.setWord", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_word((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableFilename.setWord() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableFilename this, int n, const Filename value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_set_word_129_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableFilename this, int n, const Filename value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_set_word_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &ConfigVariableFilename::operator typecast(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableFilename_operator_typecast_111(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableFilename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableFilename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &ConfigVariableFilename::operator typecast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecast", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecast"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &((Filename const &)(*(const ConfigVariableFilename*)local_this));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecast(const ConfigVariableFilename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableFilename_operator_typecast_111_comment =
    "C++ Interface:\n"
    "operatorTypecast(const ConfigVariableFilename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableFilename::Filename typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value as a Filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableFilename_operator_typecast_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name)
 * inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableFilename(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableFilename", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableFilename", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableFilename *return_value = new ConfigVariableFilename(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableFilename,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:ConfigVariableFilename", key_word_list, &param0_str, &param0_len, &param1))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.ConfigVariableFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ConfigVariableFilename *return_value = new ConfigVariableFilename(basic_string<char>(param0_str, param0_len), *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableFilename,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description, int flags = (0))
                char *param0_str; int param0_len;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:ConfigVariableFilename", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.ConfigVariableFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ConfigVariableFilename *return_value = new ConfigVariableFilename(basic_string<char>(param0_str, param0_len), *param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableFilename,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ConfigVariableFilename::ConfigVariableFilename(basic_string< char > const &name, Filename const &default_value, basic_string< char > const &description, int flags)
                char *param0_str; int param0_len;
                PyObject *param1;
                char *param2_str; int param2_len;
                int param3;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#i:ConfigVariableFilename", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableFilename.ConfigVariableFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ConfigVariableFilename *return_value = new ConfigVariableFilename(basic_string<char>(param0_str, param0_len), *param1_this, basic_string<char>(param2_str, param2_len), (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableFilename,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableFilename() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableFilename(string name)\n"
          "ConfigVariableFilename(string name, const Filename default_value)\n"
          "ConfigVariableFilename(string name, const Filename default_value, string description)\n"
          "ConfigVariableFilename(string name, const Filename default_value, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableFilename(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableFilename)
    {
        printf("ConfigVariableFilename ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableFilename * local_this = (ConfigVariableFilename *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableFilename)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableFilename(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableFilename)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableFilename*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableFilename*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableFilename*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableInt 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt::operator =(int value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_operator_133(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt::operator =(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:assign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:assign", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator =((int)param1);
            ConfigVariableInt *return_value = local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableInt,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt.assign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableInt this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_operator_133_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableInt this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_operator_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_size_135(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableInt*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConfigVariableInt this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_size_135_comment =
    "C++ Interface:\n"
    "size(const ConfigVariableInt this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::size()\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique words in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_size_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_operator_136(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const ConfigVariableInt*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            int return_value = ((const ConfigVariableInt*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableInt this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_operator_136_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableInt this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the variable's nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_operator_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt::set_value(int value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_set_value_137(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt::set_value(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableInt this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_set_value_137_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableInt this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_set_value_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_get_value_138(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableInt*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableInt this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_get_value_138_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableInt this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_get_value_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_get_default_value_139(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableInt*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableInt this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_get_default_value_139_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableInt this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_get_default_value_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_get_word_140(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableInt*)local_this)->get_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableInt this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_get_word_140_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableInt this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_get_word_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt::set_word(int n, int value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_set_word_141(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt::set_word(int n, int value)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setWord", key_word_list, &param1, &param2))
        {
            (local_this)->set_word((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableInt this, int n, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_set_word_141_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableInt this, int n, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_set_word_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableInt::operator typecast int(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt_operator_typecast_int_134(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableInt::operator typecast int(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecastInt", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecastInt"));
        if(!PyErr_Occurred())
        {
            int return_value = (int)(*(const ConfigVariableInt*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecastInt(const ConfigVariableInt this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt_operator_typecast_int_134_comment =
    "C++ Interface:\n"
    "operatorTypecastInt(const ConfigVariableInt this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt::typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt_operator_typecast_int_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name)
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableInt(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableInt", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableInt", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), (int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(3):
        {
        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            int param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#is#:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), (int)param1, basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(4):
        {
        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt::ConfigVariableInt(basic_string< char > const &name, int default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            int param1;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#is#i:ConfigVariableInt", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
            {
                ConfigVariableInt *return_value = new ConfigVariableInt(basic_string<char>(param0_str, param0_len), (int)param1, basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableInt() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableInt(string name)\n"
          "ConfigVariableInt(string name, string default_value)\n"
          "ConfigVariableInt(string name, int default_value)\n"
          "ConfigVariableInt(string name, string default_value, string description)\n"
          "ConfigVariableInt(string name, int default_value, string description)\n"
          "ConfigVariableInt(string name, string default_value, string description, int flags)\n"
          "ConfigVariableInt(string name, int default_value, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableInt(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableInt)
    {
        printf("ConfigVariableInt ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableInt * local_this = (ConfigVariableInt *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableInt)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableInt(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableInt)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableInt*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableInt*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableInt*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableInt64 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt64::operator =(__int64 value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_operator_145(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt64::operator =(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:assign", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->operator =(PyLong_AsLongLong(param1_long));
                ConfigVariableInt64 *return_value = local_this;
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableInt64,false, false);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt64.assign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableInt64 this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_operator_145_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableInt64 this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_operator_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_size_147(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = ((const ConfigVariableInt64*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConfigVariableInt64 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_size_147_comment =
    "C++ Interface:\n"
    "size(const ConfigVariableInt64 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::size()\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique words in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_size_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_operator_148(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const ConfigVariableInt64*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            __int64 return_value = ((const ConfigVariableInt64*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableInt64 this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_operator_148_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableInt64 this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of the variable's nth word.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_operator_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt64::set_value(__int64 value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_set_value_149(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt64::set_value(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setValue", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->set_value(PyLong_AsLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt64.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableInt64 this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_set_value_149_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableInt64 this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_set_value_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_get_value_150(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = ((const ConfigVariableInt64*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableInt64 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_get_value_150_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableInt64 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_get_value_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_get_default_value_151(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = ((const ConfigVariableInt64*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableInt64 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_get_default_value_151_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableInt64 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_get_default_value_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_get_word_152(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            __int64 return_value = ((const ConfigVariableInt64*)local_this)->get_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableInt64 this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_get_word_152_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableInt64 this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_get_word_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableInt64::set_word(int n, __int64 value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_set_word_153(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableInt64::set_word(int n, __int64 value)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setWord", key_word_list, &param1, &param2))
        {
             PyObject *param2_long = PyNumber_Long(param2);
            if (!((param2_long == NULL)))
            {
                (local_this)->set_word((int)param1, PyLong_AsLongLong(param2_long));
                 Py_XDECREF(param2_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableInt64.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableInt64 this, int n, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_set_word_153_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableInt64 this, int n, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_set_word_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 ConfigVariableInt64::operator typecast __int64(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableInt64_operator_typecast_int64_146(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableInt64 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableInt64,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline __int64 ConfigVariableInt64::operator typecast __int64(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecastInt64", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecastInt64"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = (__int64)(*(const ConfigVariableInt64*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecastInt64(const ConfigVariableInt64 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableInt64_operator_typecast_int64_146_comment =
    "C++ Interface:\n"
    "operatorTypecastInt64(const ConfigVariableInt64 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableInt64::typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableInt64_operator_typecast_int64_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name)
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description, __int64 flags)
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description, __int64 flags = (0))
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description = ((string())), __int64 flags = (0))
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, __int64 flags)
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, __int64 flags = (0))
 * inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), __int64 flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableInt64(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableInt64", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableInt64", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), __int64 flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description = ((string())), __int64 flags = (0))
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1))
            {
                 PyObject *param1_long = PyNumber_Long(param1);
                if (!((param1_long == NULL)))
                {
                    ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), PyLong_AsLongLong(param1_long));
                     Py_XDECREF(param1_long);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(3):
        {
        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, __int64 flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description, __int64 flags = (0))
            char *param0_str; int param0_len;
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
            {
                 PyObject *param1_long = PyNumber_Long(param1);
                if (!((param1_long == NULL)))
                {
                    ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), PyLong_AsLongLong(param1_long), basic_string<char>(param2_str, param2_len));
                     Py_XDECREF(param1_long);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(4):
        {
        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, __int64 flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#O:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                 PyObject *param3_long = PyNumber_Long(param3);
                if (!((param3_long == NULL)))
                {
                    ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), PyLong_AsLongLong(param3_long));
                     Py_XDECREF(param3_long);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ConfigVariableInt64::ConfigVariableInt64(basic_string< char > const &name, __int64 default_value, basic_string< char > const &description, __int64 flags)
            char *param0_str; int param0_len;
            PyObject *param1;
            char *param2_str; int param2_len;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#O:ConfigVariableInt64", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
            {
                 PyObject *param1_long = PyNumber_Long(param1); PyObject *param3_long = PyNumber_Long(param3);
                if (!((param1_long == NULL)|| (param3_long == NULL)))
                {
                    ConfigVariableInt64 *return_value = new ConfigVariableInt64(basic_string<char>(param0_str, param0_len), PyLong_AsLongLong(param1_long), basic_string<char>(param2_str, param2_len), PyLong_AsLongLong(param3_long));
                     Py_XDECREF(param1_long); Py_XDECREF(param3_long);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableInt64,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableInt64() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableInt64(string name)\n"
          "ConfigVariableInt64(string name, string default_value)\n"
          "ConfigVariableInt64(string name, long long default_value)\n"
          "ConfigVariableInt64(string name, string default_value, string description)\n"
          "ConfigVariableInt64(string name, long long default_value, string description)\n"
          "ConfigVariableInt64(string name, string default_value, string description, long long flags)\n"
          "ConfigVariableInt64(string name, long long default_value, string description, long long flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableInt64(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableInt64)
    {
        printf("ConfigVariableInt64 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableInt64 * local_this = (ConfigVariableInt64 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableInt64)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableInt64(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableInt64)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableInt64*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableInt64*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableInt64*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableList 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableList::get_num_values(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_get_num_values_158(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableList::get_num_values(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumValues", key_word_list));
        else
            (PyArg_Parse(args, ":getNumValues"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableList*)local_this)->get_num_values();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumValues(const ConfigVariableList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_get_num_values_158_comment =
    "C++ Interface:\n"
    "getNumValues(const ConfigVariableList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::get_num_values\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of values in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_get_num_values_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableList::get_string_value(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_get_string_value_159(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableList::get_string_value(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getStringValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getStringValue", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableList*)local_this)->get_string_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStringValue(const ConfigVariableList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_get_string_value_159_comment =
    "C++ Interface:\n"
    "getStringValue(const ConfigVariableList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::get_string_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth value of the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_get_string_value_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableList::get_num_unique_values(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_get_num_unique_values_160(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableList::get_num_unique_values(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUniqueValues", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUniqueValues"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableList*)local_this)->get_num_unique_values();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUniqueValues(const ConfigVariableList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_get_num_unique_values_160_comment =
    "C++ Interface:\n"
    "getNumUniqueValues(const ConfigVariableList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::get_num_unique_values\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique values in the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_get_num_unique_values_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableList::get_unique_value(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_get_unique_value_161(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableList::get_unique_value(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getUniqueValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getUniqueValue", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableList*)local_this)->get_unique_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUniqueValue(const ConfigVariableList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_get_unique_value_161_comment =
    "C++ Interface:\n"
    "getUniqueValue(const ConfigVariableList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::get_unique_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth unique value of the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_get_unique_value_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableList::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_size_162(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableList::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableList*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConfigVariableList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_size_162_comment =
    "C++ Interface:\n"
    "size(const ConfigVariableList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::size()\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique values of the variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_size_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableList::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_operator_163(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableList::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const ConfigVariableList*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            basic_string< char > return_value = ((const ConfigVariableList*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_operator_163_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableList::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth unique value of the variable.  Note\n"
    "//               that the indexing operator returns the list of unique\n"
    "//               values, and so the maximum range is\n"
    "//               get_num_unique_values().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableList_operator_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableList::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_output_164(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigVariableList::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableList.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableList*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigVariableList this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_output_164_comment =
    "C++ Interface:\n"
    "output(const ConfigVariableList this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableList_output_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableList::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableList_write_165(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigVariableList::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableList.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableList*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigVariableList this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableList_write_165_comment =
    "C++ Interface:\n"
    "write(const ConfigVariableList this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableList_write_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description, int flags)
 * inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableList(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableList", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableList", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableList *return_value = new ConfigVariableList(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableList,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableList", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableList *return_value = new ConfigVariableList(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableList,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-inline ConfigVariableList::ConfigVariableList(basic_string< char > const &name, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"name", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#i:ConfigVariableList", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2))
            {
                ConfigVariableList *return_value = new ConfigVariableList(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableList,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableList() takes 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableList(string name)\n"
          "ConfigVariableList(string name, string description)\n"
          "ConfigVariableList(string name, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableList(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableList)
    {
        printf("ConfigVariableList ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableList * local_this = (ConfigVariableList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableList)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableList(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableList)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableList*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableList*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableManager::get_num_variables(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_get_num_variables_169(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableManager::get_num_variables(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVariables", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVariables"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableManager*)local_this)->get_num_variables();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVariables(const ConfigVariableManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_get_num_variables_169_comment =
    "C++ Interface:\n"
    "getNumVariables(const ConfigVariableManager this)\n"
    "\n"
    "// Filename: configVariableManager.I\n"
    "// Created by:  drose (15Oct04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableManager::get_num_variables\n"
    "//       Access: Published\n"
    "//  Description: Returns the current number of active ConfigVariableCores in\n"
    "//               the world.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_get_num_variables_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > ConfigVariableManager::get_variable_name(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_get_variable_name_171(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > ConfigVariableManager::get_variable_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVariableName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVariableName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableManager*)local_this)->get_variable_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVariableName(const ConfigVariableManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_get_variable_name_171_comment =
    "C++ Interface:\n"
    "getVariableName(const ConfigVariableManager this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_get_variable_name_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConfigVariableManager::is_variable_used(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_is_variable_used_172(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ConfigVariableManager::is_variable_used(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isVariableUsed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isVariableUsed", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableManager*)local_this)->is_variable_used((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isVariableUsed(const ConfigVariableManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_is_variable_used_172_comment =
    "C++ Interface:\n"
    "isVariableUsed(const ConfigVariableManager this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_is_variable_used_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_output_173(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigVariableManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigVariableManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_output_173_comment =
    "C++ Interface:\n"
    "output(const ConfigVariableManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_output_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_write_174(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigVariableManager::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableManager.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableManager*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigVariableManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_write_174_comment =
    "C++ Interface:\n"
    "write(const ConfigVariableManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_write_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::write_prc_variables(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_write_prc_variables_175(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConfigVariableManager::write_prc_variables(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePrcVariables", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writePrcVariables", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableManager.writePrcVariables", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableManager*)local_this)->write_prc_variables(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writePrcVariables(const ConfigVariableManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_write_prc_variables_175_comment =
    "C++ Interface:\n"
    "writePrcVariables(const ConfigVariableManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_write_prc_variables_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::list_unused_variables(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_list_unused_variables_176(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void ConfigVariableManager::list_unused_variables(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":listUnusedVariables", key_word_list));
        else
            (PyArg_Parse(args, ":listUnusedVariables"));
        if(!PyErr_Occurred())
        {
            ((const ConfigVariableManager*)local_this)->list_unused_variables();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "listUnusedVariables(const ConfigVariableManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_list_unused_variables_176_comment =
    "C++ Interface:\n"
    "listUnusedVariables(const ConfigVariableManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_list_unused_variables_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::list_variables(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_list_variables_177(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void ConfigVariableManager::list_variables(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":listVariables", key_word_list));
        else
            (PyArg_Parse(args, ":listVariables"));
        if(!PyErr_Occurred())
        {
            ((const ConfigVariableManager*)local_this)->list_variables();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "listVariables(const ConfigVariableManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_list_variables_177_comment =
    "C++ Interface:\n"
    "listVariables(const ConfigVariableManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_list_variables_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConfigVariableManager::list_dynamic_variables(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_list_dynamic_variables_178(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void ConfigVariableManager::list_dynamic_variables(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":listDynamicVariables", key_word_list));
        else
            (PyArg_Parse(args, ":listDynamicVariables"));
        if(!PyErr_Occurred())
        {
            ((const ConfigVariableManager*)local_this)->list_dynamic_variables();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "listDynamicVariables(const ConfigVariableManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_list_dynamic_variables_178_comment =
    "C++ Interface:\n"
    "listDynamicVariables(const ConfigVariableManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_list_dynamic_variables_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableManager_get_global_ptr_179(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            ConfigVariableManager *return_value = ConfigVariableManager::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableManager_get_global_ptr_179_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "";
#else
static const char * Dtool_ConfigVariableManager_get_global_ptr_179_comment = NULL;
#endif

int  Dtool_Init_ConfigVariableManager(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConfigVariableManager)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConfigVariableManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableManager)
    {
        printf("ConfigVariableManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableManager * local_this = (ConfigVariableManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableSearchPath 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath const &ConfigVariableSearchPath::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_get_value_184(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DSearchPath const &ConfigVariableSearchPath::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            DSearchPath const *return_value = &(((const ConfigVariableSearchPath*)local_this)->get_value());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_get_value_184_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::get_value\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_get_value_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_get_default_value_185(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            DSearchPath const *return_value = &(((const ConfigVariableSearchPath*)local_this)->get_default_value());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_get_default_value_185_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_get_default_value_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableSearchPath::clear_local_value(void)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_clear_local_value_186(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool ConfigVariableSearchPath::clear_local_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLocalValue", key_word_list));
        else
            (PyArg_Parse(args, ":clearLocalValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->clear_local_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableSearchPath.clearLocalValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLocalValue(non-const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_clear_local_value_186_comment =
    "C++ Interface:\n"
    "clearLocalValue(non-const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::clear_local_value\n"
    "//       Access: Published\n"
    "//  Description: Removes all the directories locally added to the\n"
    "//               search list, and restores it to its original form.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_clear_local_value_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::clear(void)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_clear_187(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableSearchPath::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableSearchPath.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_clear_187_comment =
    "C++ Interface:\n"
    "clear(non-const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all the directories locally added to the\n"
    "//               search list, and restores it to its original form.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_clear_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_append_directory_188(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:appendDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableSearchPath.appendDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->append_directory(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableSearchPath.appendDirectory() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendDirectory(non-const ConfigVariableSearchPath this, const Filename directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_append_directory_188_comment =
    "C++ Interface:\n"
    "appendDirectory(non-const ConfigVariableSearchPath this, const Filename directory)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::append_directory\n"
    "//       Access: Published\n"
    "//  Description: Adds a new directory to the end of the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_append_directory_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_prepend_directory_189(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:prependDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:prependDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableSearchPath.prependDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->prepend_directory(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableSearchPath.prependDirectory() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prependDirectory(non-const ConfigVariableSearchPath this, const Filename directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_prepend_directory_189_comment =
    "C++ Interface:\n"
    "prependDirectory(non-const ConfigVariableSearchPath this, const Filename directory)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::prepend_directory\n"
    "//       Access: Published\n"
    "//  Description: Adds a new directory to the front of the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_prepend_directory_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
 * inline void ConfigVariableSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator)
 * inline void ConfigVariableSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_append_path_190(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendPath", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:appendPath", &param1));
                if(!PyErr_Occurred())
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "ConfigVariableSearchPath.appendPath", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->append_path(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void ConfigVariableSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendPath", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:appendPath", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    (local_this)->append_path(basic_string<char>(param1_str, param1_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator)
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"path", (char *)"separator", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:appendPath", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                (local_this)->append_path(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableSearchPath.appendPath() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "appendPath() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "appendPath(non-const ConfigVariableSearchPath this, const DSearchPath path)\n"
          "appendPath(non-const ConfigVariableSearchPath this, string path)\n"
          "appendPath(non-const ConfigVariableSearchPath this, string path, string separator)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_append_path_190_comment =
    "C++ Interface:\n"
    "appendPath(non-const ConfigVariableSearchPath this, const DSearchPath path)\n"
    "appendPath(non-const ConfigVariableSearchPath this, string path)\n"
    "appendPath(non-const ConfigVariableSearchPath this, string path, string separator)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::append_path\n"
    "//       Access: Published\n"
    "//  Description: Adds all of the directories listed in the search path\n"
    "//               to the end of the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::append_path\n"
    "//       Access: Published\n"
    "//  Description: Adds all of the directories listed in the search path\n"
    "//               to the end of the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_append_path_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_prepend_path_191(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"path", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:prependPath", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:prependPath", &param1));
            if(!PyErr_Occurred())
            {
                DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "ConfigVariableSearchPath.prependPath", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->prepend_path(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConfigVariableSearchPath.prependPath() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prependPath(non-const ConfigVariableSearchPath this, const DSearchPath path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_prepend_path_191_comment =
    "C++ Interface:\n"
    "prependPath(non-const ConfigVariableSearchPath this, const DSearchPath path)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::prepend_path\n"
    "//       Access: Published\n"
    "//  Description: Adds all of the directories listed in the search path\n"
    "//               to the beginning of the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_prepend_path_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableSearchPath::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_is_empty_192(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableSearchPath::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableSearchPath*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_is_empty_192_comment =
    "C++ Interface:\n"
    "isEmpty(const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the search list is empty, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_is_empty_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ConfigVariableSearchPath::get_num_directories(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_get_num_directories_193(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ConfigVariableSearchPath::get_num_directories(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDirectories", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDirectories"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConfigVariableSearchPath*)local_this)->get_num_directories();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDirectories(const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_get_num_directories_193_comment =
    "C++ Interface:\n"
    "getNumDirectories(const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::get_num_directories\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of directories on the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_get_num_directories_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &ConfigVariableSearchPath::get_directory(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_get_directory_194(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &ConfigVariableSearchPath::get_directory(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDirectory", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDirectory", &param1));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const ConfigVariableSearchPath*)local_this)->get_directory((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirectory(const ConfigVariableSearchPath this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_get_directory_194_comment =
    "C++ Interface:\n"
    "getDirectory(const ConfigVariableSearchPath this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::get_directory\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth directory on the search list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_get_directory_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_find_file_195(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableSearchPath.findFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Filename result = ((const ConfigVariableSearchPath*)local_this)->find_file(*param1_this);
                    Filename *return_value = new Filename(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findFile(const ConfigVariableSearchPath this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_find_file_195_comment =
    "C++ Interface:\n"
    "findFile(const ConfigVariableSearchPath this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::find_file\n"
    "//       Access: Published\n"
    "//  Description: Searches all the directories in the search list for\n"
    "//               the indicated file, in order.  Returns the full\n"
    "//               matching pathname of the first match if found, or the\n"
    "//               empty string if not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_find_file_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
 * inline int ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_find_all_files_196(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:findAllFiles", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:findAllFiles", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableSearchPath.findAllFiles", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        DSearchPath::Results result = ((const ConfigVariableSearchPath*)local_this)->find_all_files(*param1_this);
                        DSearchPath::Results *return_value = new DSearchPath::Results(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath_Results,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline int ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"results", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:findAllFiles", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "ConfigVariableSearchPath.findAllFiles", 1, coerced_ptr, report_errors);
DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath_Results, 2, "ConfigVariableSearchPath.findAllFiles", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        int return_value = ((const ConfigVariableSearchPath*)local_this)->find_all_files(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "findAllFiles() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "findAllFiles(const ConfigVariableSearchPath this, const Filename filename)\n"
          "findAllFiles(const ConfigVariableSearchPath this, const Filename filename, non-const Results results)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_find_all_files_196_comment =
    "C++ Interface:\n"
    "findAllFiles(const ConfigVariableSearchPath this, const Filename filename)\n"
    "findAllFiles(const ConfigVariableSearchPath this, const Filename filename, non-const Results results)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::find_all_files\n"
    "//       Access: Published\n"
    "//  Description: Searches all the directories in the search list for\n"
    "//               the indicated file, in order.  Fills up the results\n"
    "//               list with *all* of the matching filenames found, if\n"
    "//               any.  Returns the number of matches found.\n"
    "//\n"
    "//               It is the responsibility of the the caller to clear\n"
    "//               the results list first; otherwise, the newly-found\n"
    "//               files will be appended to the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::find_all_files\n"
    "//       Access: Published\n"
    "//  Description: This variant of find_all_files() returns the new\n"
    "//               Results object, instead of filling on in on the\n"
    "//               parameter list.  This is a little more convenient to\n"
    "//               call from Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_find_all_files_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_output_197(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void ConfigVariableSearchPath::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableSearchPath.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableSearchPath*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConfigVariableSearchPath this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_output_197_comment =
    "C++ Interface:\n"
    "output(const ConfigVariableSearchPath this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_output_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableSearchPath::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_write_198(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void ConfigVariableSearchPath::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConfigVariableSearchPath.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConfigVariableSearchPath*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const ConfigVariableSearchPath this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_write_198_comment =
    "C++ Interface:\n"
    "write(const ConfigVariableSearchPath this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_write_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath const &ConfigVariableSearchPath::operator typecast(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableSearchPath_operator_typecast_183(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DSearchPath const &ConfigVariableSearchPath::operator typecast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecast", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecast"));
        if(!PyErr_Occurred())
        {
            DSearchPath const *return_value = &((DSearchPath const &)(*(const ConfigVariableSearchPath*)local_this));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecast(const ConfigVariableSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableSearchPath_operator_typecast_183_comment =
    "C++ Interface:\n"
    "operatorTypecast(const ConfigVariableSearchPath this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableSearchPath::DSearchPath typecast\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableSearchPath_operator_typecast_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, DSearchPath const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, DSearchPath const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description, int flags)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableSearchPath(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableSearchPath", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
                char *param0_str; int param0_len;
                char *param1_str; int param1_len;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
                {
                    ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, DSearchPath const &default_value, basic_string< char > const &description, int flags = (0))
                char *param0_str; int param0_len;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len))
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "ConfigVariableSearchPath.ConfigVariableSearchPath", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), *param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &description, int flags)
                char *param0_str; int param0_len;
                char *param1_str; int param1_len;
                int param2;
                static char * key_word_list[] = {(char *)"name", (char *)"description", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#i:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2))
                {
                    ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, DSearchPath const &default_value, basic_string< char > const &description, int flags)
                char *param0_str; int param0_len;
                PyObject *param1;
                char *param2_str; int param2_len;
                int param3;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#i:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3))
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "ConfigVariableSearchPath.ConfigVariableSearchPath", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), *param1_this, basic_string<char>(param2_str, param2_len), (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
                char *param0_str; int param0_len;
                char *param1_str; int param1_len;
                char *param2_str; int param2_len;
                int param3;
                static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:ConfigVariableSearchPath", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
                {
                    ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableSearchPath,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableSearchPath() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableSearchPath(string name)\n"
          "ConfigVariableSearchPath(string name, string description)\n"
          "ConfigVariableSearchPath(string name, string default_value, string description)\n"
          "ConfigVariableSearchPath(string name, const DSearchPath default_value, string description)\n"
          "ConfigVariableSearchPath(string name, string description, int flags)\n"
          "ConfigVariableSearchPath(string name, const DSearchPath default_value, string description, int flags)\n"
          "ConfigVariableSearchPath(string name, string default_value, string description, int flags)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ConfigVariableSearchPath_get_directories(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumDirectories", "getDirectory");
}
inline void  * Dtool_UpcastInterface_ConfigVariableSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableSearchPath)
    {
        printf("ConfigVariableSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableSearchPath * local_this = (ConfigVariableSearchPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableSearchPath)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableSearchPath(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableSearchPath)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableSearchPath*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableSearchPath*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConfigVariableString 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableString::operator =(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_201(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableString::operator =(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:assign", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:assign", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->operator =(basic_string<char>(param1_str, param1_len));
            ConfigVariableString *return_value = local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableString,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableString.assign() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const ConfigVariableString this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_201_comment =
    "C++ Interface:\n"
    "assign(non-const ConfigVariableString this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::operator =\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char const *ConfigVariableString::c_str(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_c_str_203(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char const *ConfigVariableString::c_str(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cStr", key_word_list));
        else
            (PyArg_Parse(args, ":cStr"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const ConfigVariableString*)local_this)->c_str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cStr(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_c_str_203_comment =
    "C++ Interface:\n"
    "cStr(const ConfigVariableString this)\n"
    "\n"
    "// These methods help the ConfigVariableString act like a C++ string\n"
    "// object.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::c_str\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_c_str_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableString::empty(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_empty_204(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableString::empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":empty", key_word_list));
        else
            (PyArg_Parse(args, ":empty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableString*)local_this)->empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "empty(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_empty_204_comment =
    "C++ Interface:\n"
    "empty(const ConfigVariableString this)\n"
    "\n"
    "// These methods help the ConfigVariableString act like a C++ string\n"
    "// object.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::empty\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_empty_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ConfigVariableString::length(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_length_205(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ConfigVariableString::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConfigVariableString*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_length_205_comment =
    "C++ Interface:\n"
    "length(const ConfigVariableString this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::length\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_length_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char ConfigVariableString::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_206(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char ConfigVariableString::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            char return_value = ((const ConfigVariableString*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const ConfigVariableString this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_206_comment =
    "C++ Interface:\n"
    "__getitem__(const ConfigVariableString this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::Indexing operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableString::operator ==(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_207(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableString::operator ==(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:eq", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:eq", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableString*)local_this)->operator ==(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const ConfigVariableString this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_207_comment =
    "C++ Interface:\n"
    "eq(const ConfigVariableString this, string other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::Equality operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableString::operator !=(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_208(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableString::operator !=(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ne", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:ne", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableString*)local_this)->operator !=(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const ConfigVariableString this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_208_comment =
    "C++ Interface:\n"
    "ne(const ConfigVariableString this, string other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::Inequality operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConfigVariableString::operator <(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_209(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConfigVariableString::operator <(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:lessThan", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:lessThan", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConfigVariableString*)local_this)->operator <(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const ConfigVariableString this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_209_comment =
    "C++ Interface:\n"
    "lessThan(const ConfigVariableString this, string other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::Ordering operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableString::set_value(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_set_value_210(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableString::set_value(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableString.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const ConfigVariableString this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_set_value_210_comment =
    "C++ Interface:\n"
    "setValue(non-const ConfigVariableString this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::set_value\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's local value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_set_value_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigVariableString::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_get_value_211(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigVariableString::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ConfigVariableString*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_get_value_211_comment =
    "C++ Interface:\n"
    "getValue(const ConfigVariableString this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_get_value_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableString::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_get_default_value_212(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableString::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableString*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_get_default_value_212_comment =
    "C++ Interface:\n"
    "getDefaultValue(const ConfigVariableString this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's default value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_get_default_value_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ConfigVariableString::get_word(int n) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_get_word_213(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ConfigVariableString::get_word(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getWord", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getWord", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConfigVariableString*)local_this)->get_word((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWord(const ConfigVariableString this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_get_word_213_comment =
    "C++ Interface:\n"
    "getWord(const ConfigVariableString this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::get_word\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's nth value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_get_word_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConfigVariableString::set_word(int n, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_set_word_214(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConfigVariableString::set_word(int n, basic_string< char > const &value)
        int param1;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "is#:setWord", key_word_list, &param1, &param2_str, &param2_len))
        {
            (local_this)->set_word((int)param1, basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConfigVariableString.setWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWord(non-const ConfigVariableString this, int n, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_set_word_214_comment =
    "C++ Interface:\n"
    "setWord(non-const ConfigVariableString this, int n, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::set_word\n"
    "//       Access: Published\n"
    "//  Description: Reassigns the variable's nth value.  This makes a\n"
    "//               local copy of the variable's overall value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_set_word_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ConfigVariableString::operator typecast(void) const
 *******************************************************************/
static PyObject *Dtool_ConfigVariableString_operator_typecast_202(PyObject *self, PyObject *args,PyObject *kwds) {
    ConfigVariableString * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableString,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ConfigVariableString::operator typecast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecast", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecast"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = (basic_string< char > const &)(*(const ConfigVariableString*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecast(const ConfigVariableString this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConfigVariableString_operator_typecast_202_comment =
    "C++ Interface:\n"
    "operatorTypecast(const ConfigVariableString this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConfigVariableString::string typecast operator\n"
    "//       Access: Published\n"
    "//  Description: Returns the variable's value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConfigVariableString_operator_typecast_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name)
 * inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
 * inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
 * inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
 *******************************************************************/
int  Dtool_Init_ConfigVariableString(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ConfigVariableString", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ConfigVariableString", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ConfigVariableString *return_value = new ConfigVariableString(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableString,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description = ((string())), int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:ConfigVariableString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                ConfigVariableString *return_value = new ConfigVariableString(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableString,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags = (0))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:ConfigVariableString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                ConfigVariableString *return_value = new ConfigVariableString(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableString,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline ConfigVariableString::ConfigVariableString(basic_string< char > const &name, basic_string< char > const &default_value, basic_string< char > const &description, int flags)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"default_value", (char *)"description", (char *)"flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:ConfigVariableString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                ConfigVariableString *return_value = new ConfigVariableString(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ConfigVariableString,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConfigVariableString() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConfigVariableString(string name)\n"
          "ConfigVariableString(string name, string default_value)\n"
          "ConfigVariableString(string name, string default_value, string description)\n"
          "ConfigVariableString(string name, string default_value, string description, int flags)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConfigVariableString(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConfigVariableString)
    {
        printf("ConfigVariableString ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConfigVariableString * local_this = (ConfigVariableString *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConfigVariableString)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *)( ConfigVariableBase *)( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariable)
        return ( ConfigVariable *) local_this;
    if(requested_type == &Dtool_ConfigVariableBase)
        return ( ConfigVariableBase *)( ConfigVariable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConfigVariableString(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConfigVariableString)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (ConfigVariableString*)other_this;
    }
    if(from_type == &Dtool_ConfigVariable)
    {
          ConfigVariable* other_this = (ConfigVariable*)from_this;
          return (ConfigVariableString*)other_this;
    }
    if(from_type == &Dtool_ConfigVariableBase)
    {
          ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
          return (ConfigVariableString*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< float > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< float >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_size_227(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< float >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< float >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_size_227_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_size_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::ConstPointerToArray< float >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_get_element_228(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::ConstPointerToArray< float >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                float return_value = ((const ConstPointerToArray< float >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_get_element_228_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_get_element_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::ConstPointerToArray< float >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_getitem_229(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::ConstPointerToArray< float >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< float >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                float return_value = ((const ConstPointerToArray< float >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_getitem_229_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_getitem_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< float >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_get_data_230(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< float >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< float >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_get_data_230_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_get_data_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< float >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_get_subdata_231(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< float >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< float >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_get_subdata_231_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_get_subdata_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< float >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_get_ref_count_232(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< float >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< float >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_get_ref_count_232_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_get_ref_count_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< float >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_float_get_node_ref_count_233(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< float >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< float >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_float_get_node_ref_count_233_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_float_get_node_ref_count_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
 * inline ::ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< float > *param0_this = (PointerToArray< float > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_float, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_float,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< float > *param0_this = (ConstPointerToArray< float > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_float, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_float,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_float)
    {
        printf("ConstPointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< float > * local_this = (ConstPointerToArray< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_float)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_float)
        return ( PointerToArrayBase< float > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
        return ( PointerToBase< ReferenceCountedVector< float > > *)( PointerToArrayBase< float > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< float > > *)( PointerToArrayBase< float > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_float)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_float)
    {
          PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
          return (ConstPointerToArray< float >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
    {
          PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
          return (ConstPointerToArray< float >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< float >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< float > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_float(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< float >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_float)
    {
        printf("PointerToArrayBase_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< float > * local_this = (PointerToArrayBase< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_float)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
        return ( PointerToBase< ReferenceCountedVector< float > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< float > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_float)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
    {
          PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
          return (PointerToArrayBase< float >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< float >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< float > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< float > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_clear_223(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< float > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< float > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_float_clear_223_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_float_clear_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< float > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_output_224(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< float > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< float > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< float > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_float_output_224_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_float_output_224_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_float(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< float > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_float)
    {
        printf("PointerToBase_ReferenceCountedVector_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< float > > * local_this = (PointerToBase< ReferenceCountedVector< float > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< float > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToVoid 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool PointerToVoid::is_null(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToVoid_is_null_221(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToVoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToVoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PointerToVoid::is_null(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isNull", key_word_list));
        else
            (PyArg_Parse(args, ":isNull"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PointerToVoid*)local_this)->is_null();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isNull(const PointerToVoid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToVoid_is_null_221_comment =
    "C++ Interface:\n"
    "isNull(const PointerToVoid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerToVoid::is_null\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the PointerTo is a NULL pointer,\n"
    "//               false otherwise.  (Direct comparison to a NULL\n"
    "//               pointer also works.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerToVoid_is_null_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int PointerToVoid::get_hash(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToVoid_get_hash_222(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToVoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToVoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int PointerToVoid::get_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHash", key_word_list));
        else
            (PyArg_Parse(args, ":getHash"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToVoid*)local_this)->get_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHash(const PointerToVoid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToVoid_get_hash_222_comment =
    "C++ Interface:\n"
    "getHash(const PointerToVoid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerToVoid::get_hash\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerToVoid_get_hash_222_comment = NULL;
#endif

int  Dtool_Init_PointerToVoid(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToVoid)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToVoid)
    {
        printf("PointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToVoid * local_this = (PointerToVoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToVoid)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToVoid(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToVoid)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< int >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_size_242(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< int >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< int >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_size_242_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_size_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::ConstPointerToArray< int >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_get_element_243(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::ConstPointerToArray< int >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const ConstPointerToArray< int >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_get_element_243_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_get_element_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::ConstPointerToArray< int >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_getitem_244(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::ConstPointerToArray< int >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< int >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                int return_value = ((const ConstPointerToArray< int >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_getitem_244_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_getitem_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< int >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_get_data_245(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< int >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< int >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_get_data_245_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_get_data_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< int >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_get_subdata_246(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< int >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< int >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_get_subdata_246_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_get_subdata_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< int >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_get_ref_count_247(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< int >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< int >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_get_ref_count_247_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_get_ref_count_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< int >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_int_get_node_ref_count_248(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< int >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< int >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_int_get_node_ref_count_248_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_int_get_node_ref_count_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
 * inline ::ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< int > *param0_this = (ConstPointerToArray< int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_int, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_int,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< int > *param0_this = (PointerToArray< int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_int, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_int,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_int)
    {
        printf("ConstPointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< int > * local_this = (ConstPointerToArray< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_int)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_int)
        return ( PointerToArrayBase< int > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
        return ( PointerToBase< ReferenceCountedVector< int > > *)( PointerToArrayBase< int > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< int > > *)( PointerToArrayBase< int > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_int)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_int)
    {
          PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
          return (ConstPointerToArray< int >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
    {
          PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
          return (ConstPointerToArray< int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< int > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< int >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_int)
    {
        printf("PointerToArrayBase_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< int > * local_this = (PointerToArrayBase< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_int)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
        return ( PointerToBase< ReferenceCountedVector< int > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< int > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_int)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
    {
          PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
          return (PointerToArrayBase< int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< int > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< int > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_clear_238(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< int > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_int_clear_238_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_int_clear_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< int > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_output_239(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< int > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< int > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_int_output_239_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_int_output_239_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< int > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_int)
    {
        printf("PointerToBase_ReferenceCountedVector_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< int > > * local_this = (PointerToBase< ReferenceCountedVector< int > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< int > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< unsigned char > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< unsigned char >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_size_257(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< unsigned char >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_size_257_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_size_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char const &::ConstPointerToArray< unsigned char >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_element_258(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned char const &::ConstPointerToArray< unsigned char >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                unsigned char return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_get_element_258_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_get_element_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char const &::ConstPointerToArray< unsigned char >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_getitem_259(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned char const &::ConstPointerToArray< unsigned char >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< unsigned char >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                unsigned char return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_getitem_259_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_getitem_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< unsigned char >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_data_260(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< unsigned char >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_get_data_260_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_get_data_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< unsigned char >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_subdata_261(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< unsigned char >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_get_subdata_261_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_get_subdata_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< unsigned char >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_262(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< unsigned char >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_get_ref_count_262_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_get_ref_count_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_263(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< unsigned char >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_263_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
 * inline ::ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< unsigned char > *param0_this = (PointerToArray< unsigned char > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_unsigned_char, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_unsigned_char,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< unsigned char > *param0_this = (ConstPointerToArray< unsigned char > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_unsigned_char, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_unsigned_char,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_unsigned_char)
    {
        printf("ConstPointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< unsigned char > * local_this = (ConstPointerToArray< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_unsigned_char)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_char)
        return ( PointerToArrayBase< unsigned char > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
        return ( PointerToBase< ReferenceCountedVector< unsigned char > > *)( PointerToArrayBase< unsigned char > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned char > > *)( PointerToArrayBase< unsigned char > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_unsigned_char)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_char)
    {
          PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
          return (ConstPointerToArray< unsigned char >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
    {
          PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
          return (ConstPointerToArray< unsigned char >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< unsigned char >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< unsigned char > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< unsigned char >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_unsigned_char)
    {
        printf("PointerToArrayBase_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< unsigned char > * local_this = (PointerToArrayBase< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_char)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
        return ( PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_char)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
    {
          PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
          return (PointerToArrayBase< unsigned char >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< unsigned char >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< unsigned char > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_253(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< unsigned char > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_253_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< unsigned char > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_254(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< unsigned char > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< unsigned char > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< unsigned char > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_254_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_254_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< unsigned char > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
    {
        printf("PointerToBase_ReferenceCountedVector_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< unsigned char > > * local_this = (PointerToBase< ReferenceCountedVector< unsigned char > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< unsigned char > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DConfig 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool DConfig::GetBool(basic_string< char > const &sym, bool def)
 * static inline bool DConfig::GetBool(basic_string< char > const &sym, bool def = (0))
 *******************************************************************/
static PyObject *Dtool_DConfig_GetBool_266(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline bool DConfig::GetBool(basic_string< char > const &sym, bool def = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"sym", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetBool", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:GetBool", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                bool return_value = DConfig::GetBool(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline bool DConfig::GetBool(basic_string< char > const &sym, bool def)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"sym", (char *)"def", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:GetBool", key_word_list, &param0_str, &param0_len, &param1))
            {
                bool return_value = DConfig::GetBool(basic_string<char>(param0_str, param0_len), (PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GetBool() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GetBool(string sym)\n"
          "GetBool(string sym, bool def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DConfig_GetBool_266_comment =
    "C++ Interface:\n"
    "GetBool(string sym)\n"
    "GetBool(string sym, bool def)\n"
    "\n"
    "";
#else
static const char * Dtool_DConfig_GetBool_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int DConfig::GetInt(basic_string< char > const &sym, int def)
 * static inline int DConfig::GetInt(basic_string< char > const &sym, int def = (0))
 *******************************************************************/
static PyObject *Dtool_DConfig_GetInt_267(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline int DConfig::GetInt(basic_string< char > const &sym, int def = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"sym", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetInt", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:GetInt", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                int return_value = DConfig::GetInt(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline int DConfig::GetInt(basic_string< char > const &sym, int def)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"sym", (char *)"def", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:GetInt", key_word_list, &param0_str, &param0_len, &param1))
            {
                int return_value = DConfig::GetInt(basic_string<char>(param0_str, param0_len), (int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GetInt() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GetInt(string sym)\n"
          "GetInt(string sym, int def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DConfig_GetInt_267_comment =
    "C++ Interface:\n"
    "GetInt(string sym)\n"
    "GetInt(string sym, int def)\n"
    "\n"
    "";
#else
static const char * Dtool_DConfig_GetInt_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float DConfig::GetFloat(basic_string< char > const &sym, float def)
 * static inline float DConfig::GetFloat(basic_string< char > const &sym, float def = (0))
 *******************************************************************/
static PyObject *Dtool_DConfig_GetFloat_268(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline float DConfig::GetFloat(basic_string< char > const &sym, float def = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"sym", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetFloat", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:GetFloat", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                float return_value = DConfig::GetFloat(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline float DConfig::GetFloat(basic_string< char > const &sym, float def)
            char *param0_str; int param0_len;
            double param1;
            static char * key_word_list[] = {(char *)"sym", (char *)"def", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:GetFloat", key_word_list, &param0_str, &param0_len, &param1))
            {
                float return_value = DConfig::GetFloat(basic_string<char>(param0_str, param0_len), (float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GetFloat() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GetFloat(string sym)\n"
          "GetFloat(string sym, float def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DConfig_GetFloat_268_comment =
    "C++ Interface:\n"
    "GetFloat(string sym)\n"
    "GetFloat(string sym, float def)\n"
    "\n"
    "";
#else
static const char * Dtool_DConfig_GetFloat_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline double DConfig::GetDouble(basic_string< char > const &sym, double def)
 * static inline double DConfig::GetDouble(basic_string< char > const &sym, double def = (0))
 *******************************************************************/
static PyObject *Dtool_DConfig_GetDouble_269(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline double DConfig::GetDouble(basic_string< char > const &sym, double def = (0))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"sym", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetDouble", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:GetDouble", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                double return_value = DConfig::GetDouble(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline double DConfig::GetDouble(basic_string< char > const &sym, double def)
            char *param0_str; int param0_len;
            double param1;
            static char * key_word_list[] = {(char *)"sym", (char *)"def", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:GetDouble", key_word_list, &param0_str, &param0_len, &param1))
            {
                double return_value = DConfig::GetDouble(basic_string<char>(param0_str, param0_len), (double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GetDouble() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GetDouble(string sym)\n"
          "GetDouble(string sym, float def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DConfig_GetDouble_269_comment =
    "C++ Interface:\n"
    "GetDouble(string sym)\n"
    "GetDouble(string sym, float def)\n"
    "\n"
    "";
#else
static const char * Dtool_DConfig_GetDouble_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > DConfig::GetString(basic_string< char > const &sym, basic_string< char > const &def)
 * static inline basic_string< char > DConfig::GetString(basic_string< char > const &sym, basic_string< char > const &def = (""))
 *******************************************************************/
static PyObject *Dtool_DConfig_GetString_270(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline basic_string< char > DConfig::GetString(basic_string< char > const &sym, basic_string< char > const &def = (""))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"sym", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetString", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:GetString", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = DConfig::GetString(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline basic_string< char > DConfig::GetString(basic_string< char > const &sym, basic_string< char > const &def)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"sym", (char *)"def", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:GetString", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                basic_string< char > return_value = DConfig::GetString(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GetString() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GetString(string sym)\n"
          "GetString(string sym, string def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DConfig_GetString_270_comment =
    "C++ Interface:\n"
    "GetString(string sym)\n"
    "GetString(string sym, string def)\n"
    "\n"
    "";
#else
static const char * Dtool_DConfig_GetString_270_comment = NULL;
#endif

int  Dtool_Init_DConfig(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DConfig)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DConfig(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DConfig)
    {
        printf("DConfig ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DConfig * local_this = (DConfig *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DConfig)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DConfig(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DConfig)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DSearchPath 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::operator =(DSearchPath const &copy)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_operator_285(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::operator =(DSearchPath const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "DSearchPath.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DSearchPath *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DSearchPath.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DSearchPath this, const DSearchPath copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_operator_285_comment =
    "C++ Interface:\n"
    "assign(non-const DSearchPath this, const DSearchPath copy)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_operator_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::clear(void)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_clear_287(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DSearchPath::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DSearchPath.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_clear_287_comment =
    "C++ Interface:\n"
    "clear(non-const DSearchPath this)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_clear_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::append_directory(Filename const &directory)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_append_directory_288(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::append_directory(Filename const &directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:appendDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DSearchPath.appendDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->append_directory(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DSearchPath.appendDirectory() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendDirectory(non-const DSearchPath this, const Filename directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_append_directory_288_comment =
    "C++ Interface:\n"
    "appendDirectory(non-const DSearchPath this, const Filename directory)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_append_directory_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::prepend_directory(Filename const &directory)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_prepend_directory_289(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::prepend_directory(Filename const &directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:prependDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:prependDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DSearchPath.prependDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->prepend_directory(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DSearchPath.prependDirectory() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prependDirectory(non-const DSearchPath this, const Filename directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_prepend_directory_289_comment =
    "C++ Interface:\n"
    "prependDirectory(non-const DSearchPath this, const Filename directory)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_prepend_directory_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::append_path(DSearchPath const &path)
 * void DSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator)
 * void DSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
 *******************************************************************/
static PyObject *Dtool_DSearchPath_append_path_290(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void DSearchPath::append_path(DSearchPath const &path)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:appendPath", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:appendPath", &param1));
                if(!PyErr_Occurred())
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "DSearchPath.appendPath", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->append_path(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void DSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendPath", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:appendPath", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    (local_this)->append_path(basic_string<char>(param1_str, param1_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::append_path(basic_string< char > const &path, basic_string< char > const &separator)
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"path", (char *)"separator", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:appendPath", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                (local_this)->append_path(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DSearchPath.appendPath() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "appendPath() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "appendPath(non-const DSearchPath this, const DSearchPath path)\n"
          "appendPath(non-const DSearchPath this, string path)\n"
          "appendPath(non-const DSearchPath this, string path, string separator)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_append_path_290_comment =
    "C++ Interface:\n"
    "appendPath(non-const DSearchPath this, const DSearchPath path)\n"
    "appendPath(non-const DSearchPath this, string path)\n"
    "appendPath(non-const DSearchPath this, string path, string separator)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_append_path_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::prepend_path(DSearchPath const &path)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_prepend_path_291(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::prepend_path(DSearchPath const &path)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"path", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:prependPath", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:prependPath", &param1));
            if(!PyErr_Occurred())
            {
                DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "DSearchPath.prependPath", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->prepend_path(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DSearchPath.prependPath() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prependPath(non-const DSearchPath this, const DSearchPath path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_prepend_path_291_comment =
    "C++ Interface:\n"
    "prependPath(non-const DSearchPath this, const DSearchPath path)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_prepend_path_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DSearchPath::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_is_empty_292(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DSearchPath::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DSearchPath*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const DSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_is_empty_292_comment =
    "C++ Interface:\n"
    "isEmpty(const DSearchPath this)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_is_empty_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DSearchPath::get_num_directories(void) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_get_num_directories_293(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DSearchPath::get_num_directories(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDirectories", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDirectories"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DSearchPath*)local_this)->get_num_directories();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDirectories(const DSearchPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_get_num_directories_293_comment =
    "C++ Interface:\n"
    "getNumDirectories(const DSearchPath this)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_get_num_directories_293_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename const &DSearchPath::get_directory(int n) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_get_directory_294(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Filename const &DSearchPath::get_directory(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDirectory", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDirectory", &param1));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const DSearchPath*)local_this)->get_directory((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirectory(const DSearchPath this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_get_directory_294_comment =
    "C++ Interface:\n"
    "getDirectory(const DSearchPath this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_get_directory_294_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename DSearchPath::find_file(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_find_file_295(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-Filename DSearchPath::find_file(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DSearchPath.findFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Filename result = ((const DSearchPath*)local_this)->find_file(*param1_this);
                    Filename *return_value = new Filename(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findFile(const DSearchPath this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_find_file_295_comment =
    "C++ Interface:\n"
    "findFile(const DSearchPath this, const Filename filename)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_find_file_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
 * int DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_find_all_files_296(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:findAllFiles", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:findAllFiles", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DSearchPath.findAllFiles", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        DSearchPath::Results result = ((const DSearchPath*)local_this)->find_all_files(*param1_this);
                        DSearchPath::Results *return_value = new DSearchPath::Results(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath_Results,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-int DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"results", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:findAllFiles", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DSearchPath.findAllFiles", 1, coerced_ptr, report_errors);
DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath_Results, 2, "DSearchPath.findAllFiles", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        int return_value = ((const DSearchPath*)local_this)->find_all_files(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "findAllFiles() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "findAllFiles(const DSearchPath this, const Filename filename)\n"
          "findAllFiles(const DSearchPath this, const Filename filename, non-const Results results)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_find_all_files_296_comment =
    "C++ Interface:\n"
    "findAllFiles(const DSearchPath this, const Filename filename)\n"
    "findAllFiles(const DSearchPath this, const Filename filename, non-const Results results)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DSearchPath::find_all_files\n"
    "//       Access: Published\n"
    "//  Description: This variant of find_all_files() returns the new\n"
    "//               Results object, instead of filling on in on the\n"
    "//               parameter list.  This is a little more convenient to\n"
    "//               call from Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DSearchPath_find_all_files_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename DSearchPath::search_path(Filename const &filename, basic_string< char > const &path, basic_string< char > const &separator)
 * static inline Filename DSearchPath::search_path(Filename const &filename, basic_string< char > const &path, basic_string< char > const &separator = ((string())))
 *******************************************************************/
static PyObject *Dtool_DSearchPath_search_path_297(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline Filename DSearchPath::search_path(Filename const &filename, basic_string< char > const &path, basic_string< char > const &separator = ((string())))
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"filename", (char *)"path", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:searchPath", key_word_list, &param0, &param1_str, &param1_len))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DSearchPath.searchPath", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Filename result = DSearchPath::search_path(*param0_this, basic_string<char>(param1_str, param1_len));
                        Filename *return_value = new Filename(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline Filename DSearchPath::search_path(Filename const &filename, basic_string< char > const &path, basic_string< char > const &separator)
                PyObject *param0;
                char *param1_str; int param1_len;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"filename", (char *)"path", (char *)"separator", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#:searchPath", key_word_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DSearchPath.searchPath", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Filename result = DSearchPath::search_path(*param0_this, basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                        Filename *return_value = new Filename(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "searchPath() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "searchPath(const Filename filename, string path)\n"
          "searchPath(const Filename filename, string path, string separator)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_search_path_297_comment =
    "C++ Interface:\n"
    "searchPath(const Filename filename, string path)\n"
    "searchPath(const Filename filename, string path, string separator)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DSearchPath::search_path\n"
    "//       Access: Published, Static\n"
    "//  Description: A quick-and-easy way to search a searchpath for a\n"
    "//               file when you don't feel like building or keeping\n"
    "//               around a DSearchPath object.  This simply\n"
    "//               constructs a temporary DSearchPath based on the\n"
    "//               indicated path string, and searches that.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DSearchPath_search_path_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::output(ostream &out, basic_string< char > const &separator) const
 * void DSearchPath::output(ostream &out, basic_string< char > const &separator = ((string()))) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_output_298(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::output(ostream &out, basic_string< char > const &separator = ((string()))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:output", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DSearchPath.output", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath*)local_this)->output(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::output(ostream &out, basic_string< char > const &separator) const
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"out", (char *)"separator", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:output", key_word_list, &param1, &param2_str, &param2_len))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DSearchPath.output", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath*)local_this)->output(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "output() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "output(const DSearchPath this, non-const Ostream out)\n"
          "output(const DSearchPath this, non-const Ostream out, string separator)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_output_298_comment =
    "C++ Interface:\n"
    "output(const DSearchPath this, non-const Ostream out)\n"
    "output(const DSearchPath this, non-const Ostream out, string separator)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_output_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::write(ostream &out, int indent_level) const
 * void DSearchPath::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_write_299(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DSearchPath.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DSearchPath.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DSearchPath this, non-const Ostream out)\n"
          "write(const DSearchPath this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_write_299_comment =
    "C++ Interface:\n"
    "write(const DSearchPath this, non-const Ostream out)\n"
    "write(const DSearchPath this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_write_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DSearchPath::DSearchPath(void)
 * DSearchPath::DSearchPath(DSearchPath const &copy)
 * DSearchPath::DSearchPath(Filename const &directory)
 * DSearchPath::DSearchPath(basic_string< char > const &path, basic_string< char > const &separator)
 * DSearchPath::DSearchPath(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
 *******************************************************************/
int  Dtool_Init_DSearchPath(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DSearchPath::DSearchPath(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DSearchPath", key_word_list))
            {
                DSearchPath *return_value = new DSearchPath();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DSearchPath::DSearchPath(Filename const &directory)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"directory", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DSearchPath", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DSearchPath", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DSearchPath.DSearchPath", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DSearchPath *return_value = new DSearchPath(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DSearchPath::DSearchPath(DSearchPath const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DSearchPath", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DSearchPath", &param0));
                if(!PyErr_Occurred())
                {
                    DSearchPath *param0_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DSearchPath, 0, "DSearchPath.DSearchPath", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DSearchPath *return_value = new DSearchPath(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DSearchPath::DSearchPath(basic_string< char > const &path, basic_string< char > const &separator = ((string())))
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DSearchPath", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DSearchPath", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DSearchPath *return_value = new DSearchPath(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-DSearchPath::DSearchPath(basic_string< char > const &path, basic_string< char > const &separator)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"path", (char *)"separator", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:DSearchPath", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                DSearchPath *return_value = new DSearchPath(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DSearchPath() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DSearchPath()\n"
          "DSearchPath(const Filename directory)\n"
          "DSearchPath(const DSearchPath copy)\n"
          "DSearchPath(string path)\n"
          "DSearchPath(string path, string separator)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_DSearchPath_get_directories(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumDirectories", "getDirectory");
}
inline void  * Dtool_UpcastInterface_DSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DSearchPath)
    {
        printf("DSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DSearchPath * local_this = (DSearchPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DSearchPath)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DSearchPath(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DSearchPath)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DSearchPath::Results 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_operator_275(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DSearchPath::Results *param1_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath_Results, 1, "Results.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DSearchPath::Results *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DSearchPath_Results,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Results.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Results this, const Results copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_operator_275_comment =
    "C++ Interface:\n"
    "assign(non-const Results this, const Results copy)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_operator_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::Results::clear(void)
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_clear_277(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DSearchPath::Results::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Results.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const Results this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_clear_277_comment =
    "C++ Interface:\n"
    "clear(non-const Results this)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_clear_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DSearchPath::Results::get_num_files(void) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_get_num_files_278(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DSearchPath::Results::get_num_files(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFiles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DSearchPath::Results*)local_this)->get_num_files();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFiles(const Results this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_get_num_files_278_comment =
    "C++ Interface:\n"
    "getNumFiles(const Results this)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_get_num_files_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename const &DSearchPath::Results::get_file(int n) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_get_file_279(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Filename const &DSearchPath::Results::get_file(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFile", &param1));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const DSearchPath::Results*)local_this)->get_file((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFile(const Results this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_get_file_279_comment =
    "C++ Interface:\n"
    "getFile(const Results this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_get_file_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename DSearchPath::Results::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_operator_280(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename DSearchPath::Results::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const DSearchPath::Results*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            Filename result = ((const DSearchPath::Results*)local_this)->operator []((int)param1);
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const Results this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_operator_280_comment =
    "C++ Interface:\n"
    "__getitem__(const Results this, int n)\n"
    "\n"
    "// Filename: dSearchPath.I\n"
    "// Created by:  drose (01Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DSearchPath::Results::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth filename in the set.  This method is\n"
    "//               defined to make the Results object appear to be a\n"
    "//               list in Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_operator_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DSearchPath::Results::size(void) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_size_281(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DSearchPath::Results::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DSearchPath::Results*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const Results this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_size_281_comment =
    "C++ Interface:\n"
    "size(const Results this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DSearchPath::Results::size\n"
    "//       Access: Published\n"
    "//  Description: Returns the num of filenames in the set.  This method\n"
    "//               is defined to make the Results object appear to be a\n"
    "//               list in Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_size_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::Results::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_output_282(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DSearchPath::Results::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Results.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DSearchPath::Results*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Results this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_output_282_comment =
    "C++ Interface:\n"
    "output(const Results this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_output_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DSearchPath::Results::write(ostream &out, int indent_level) const
 * void DSearchPath::Results::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DSearchPath_Results_write_283(PyObject *self, PyObject *args,PyObject *kwds) {
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::Results::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Results.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath::Results*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DSearchPath::Results::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Results.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DSearchPath::Results*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Results this, non-const Ostream out)\n"
          "write(const Results this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DSearchPath_Results_write_283_comment =
    "C++ Interface:\n"
    "write(const Results this, non-const Ostream out)\n"
    "write(const Results this, non-const Ostream out, int indent_level)\n"
    "\n"
    "";
#else
static const char * Dtool_DSearchPath_Results_write_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DSearchPath::Results::Results(void)
 * DSearchPath::Results::Results(DSearchPath::Results const &copy)
 *******************************************************************/
int  Dtool_Init_DSearchPath_Results(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DSearchPath::Results::Results(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Results", key_word_list))
            {
                DSearchPath::Results *return_value = new DSearchPath::Results();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath_Results,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DSearchPath::Results::Results(DSearchPath::Results const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Results", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Results", &param0));
                if(!PyErr_Occurred())
                {
                    DSearchPath::Results *param0_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DSearchPath_Results, 0, "Results.Results", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DSearchPath::Results *return_value = new DSearchPath::Results(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DSearchPath_Results,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Results() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Results()\n"
          "Results(const Results copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DSearchPath_Results(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DSearchPath_Results)
    {
        printf("DSearchPath_Results ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DSearchPath::Results * local_this = (DSearchPath::Results *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DSearchPath_Results)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DSearchPath_Results(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DSearchPath_Results)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ExecutionEnvironment 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool ExecutionEnvironment::has_environment_variable(basic_string< char > const &var)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_has_environment_variable_301(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool ExecutionEnvironment::has_environment_variable(basic_string< char > const &var)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"var", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasEnvironmentVariable", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:hasEnvironmentVariable", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ExecutionEnvironment::has_environment_variable(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasEnvironmentVariable(string var)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_has_environment_variable_301_comment =
    "C++ Interface:\n"
    "hasEnvironmentVariable(string var)\n"
    "\n"
    "// Filename: executionEnvironment.I\n"
    "// Created by:  drose (15May00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::has_environment_variable\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns true if the indicated environment variable\n"
    "//               is defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_has_environment_variable_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > ExecutionEnvironment::get_environment_variable(basic_string< char > const &var)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_environment_variable_302(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > ExecutionEnvironment::get_environment_variable(basic_string< char > const &var)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"var", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getEnvironmentVariable", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:getEnvironmentVariable", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ExecutionEnvironment::get_environment_variable(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnvironmentVariable(string var)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_environment_variable_302_comment =
    "C++ Interface:\n"
    "getEnvironmentVariable(string var)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::get_environment_variable\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the definition of the indicated environment\n"
    "//               variable, or the empty string if the variable is\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_environment_variable_302_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void ExecutionEnvironment::set_environment_variable(basic_string< char > const &var, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_set_environment_variable_303(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void ExecutionEnvironment::set_environment_variable(basic_string< char > const &var, basic_string< char > const &value)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"var", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:setEnvironmentVariable", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
        {
            ExecutionEnvironment::set_environment_variable(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEnvironmentVariable(string var, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_set_environment_variable_303_comment =
    "C++ Interface:\n"
    "setEnvironmentVariable(string var, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::set_environment_variable\n"
    "//       Access: Public, Static\n"
    "//  Description: Changes the definition of the indicated environment\n"
    "//               variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_set_environment_variable_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void ExecutionEnvironment::shadow_environment_variable(basic_string< char > const &var, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_shadow_environment_variable_304(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void ExecutionEnvironment::shadow_environment_variable(basic_string< char > const &var, basic_string< char > const &value)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"var", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:shadowEnvironmentVariable", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
        {
            ExecutionEnvironment::shadow_environment_variable(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shadowEnvironmentVariable(string var, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_shadow_environment_variable_304_comment =
    "C++ Interface:\n"
    "shadowEnvironmentVariable(string var, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::shadow_environment_variable\n"
    "//       Access: Public, Static\n"
    "//  Description: Changes the apparent definition of the indicated\n"
    "//               environment variable by masking it within this class\n"
    "//               with a new value.  This does not change the actual\n"
    "//               environment variable, but future calls to\n"
    "//               get_environment_variable() will return this new\n"
    "//               value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_shadow_environment_variable_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void ExecutionEnvironment::clear_shadow(basic_string< char > const &var)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_clear_shadow_305(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void ExecutionEnvironment::clear_shadow(basic_string< char > const &var)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"var", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clearShadow", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:clearShadow", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            ExecutionEnvironment::clear_shadow(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadow(string var)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_clear_shadow_305_comment =
    "C++ Interface:\n"
    "clearShadow(string var)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::clear_shadow\n"
    "//       Access: Public, Static\n"
    "//  Description: Removes a value set by a previous call to\n"
    "//               shadow_environment_variable(), and lets the actual\n"
    "//               value of the variable show again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_clear_shadow_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > ExecutionEnvironment::expand_string(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_expand_string_306(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > ExecutionEnvironment::expand_string(basic_string< char > const &str)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:expandString", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:expandString", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ExecutionEnvironment::expand_string(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "expandString(string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_expand_string_306_comment =
    "C++ Interface:\n"
    "expandString(string str)\n"
    "\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_expand_string_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int ExecutionEnvironment::get_num_args(void)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_num_args_307(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int ExecutionEnvironment::get_num_args(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumArgs", key_word_list))
        {
            int return_value = ExecutionEnvironment::get_num_args();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumArgs()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_num_args_307_comment =
    "C++ Interface:\n"
    "getNumArgs()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::get_num_args\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the number of command-line arguments\n"
    "//               available, not counting arg 0, the binary name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_num_args_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > ExecutionEnvironment::get_arg(int n)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_arg_308(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > ExecutionEnvironment::get_arg(int n)
        int param0;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getArg", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getArg", &param0));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ExecutionEnvironment::get_arg((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArg(int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_arg_308_comment =
    "C++ Interface:\n"
    "getArg(int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::get_arg\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the nth command-line argument.  The index n\n"
    "//               must be in the range [0 .. get_num_args()).  The\n"
    "//               first parameter, n == 0, is the first actual\n"
    "//               parameter, not the binary name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_arg_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > ExecutionEnvironment::get_binary_name(void)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_binary_name_309(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > ExecutionEnvironment::get_binary_name(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getBinaryName", key_word_list))
        {
            basic_string< char > return_value = ExecutionEnvironment::get_binary_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBinaryName()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_binary_name_309_comment =
    "C++ Interface:\n"
    "getBinaryName()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::get_binary_name\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the name of the binary executable that\n"
    "//               started this program, if it can be determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_binary_name_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > ExecutionEnvironment::get_dtool_name(void)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_dtool_name_310(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > ExecutionEnvironment::get_dtool_name(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDtoolName", key_word_list))
        {
            basic_string< char > return_value = ExecutionEnvironment::get_dtool_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDtoolName()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_dtool_name_310_comment =
    "C++ Interface:\n"
    "getDtoolName()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ExecutionEnvironment::get_dtool_name\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the name of the libdtool DLL that\n"
    "//               is used in this program, if it can be determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_dtool_name_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename ExecutionEnvironment::get_cwd(void)
 *******************************************************************/
static PyObject *Dtool_ExecutionEnvironment_get_cwd_311(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename ExecutionEnvironment::get_cwd(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCwd", key_word_list))
        {
            Filename result = ExecutionEnvironment::get_cwd();
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCwd()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExecutionEnvironment_get_cwd_311_comment =
    "C++ Interface:\n"
    "getCwd()\n"
    "\n"
    "";
#else
static const char * Dtool_ExecutionEnvironment_get_cwd_311_comment = NULL;
#endif

int  Dtool_Init_ExecutionEnvironment(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ExecutionEnvironment)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ExecutionEnvironment(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ExecutionEnvironment)
    {
        printf("ExecutionEnvironment ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ExecutionEnvironment * local_this = (ExecutionEnvironment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ExecutionEnvironment)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ExecutionEnvironment(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ExecutionEnvironment)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FileStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void FileStream::open(char const *filename, ios_base::openmode mode)
 * inline void FileStream::open(char const *filename, ios_base::openmode mode = (ios::in))
 *******************************************************************/
static PyObject *Dtool_FileStream_open_347(PyObject *self, PyObject *args,PyObject *kwds) {
    FileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void FileStream::open(char const *filename, ios_base::openmode mode = (ios::in))
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:open", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:open", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->open((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void FileStream::open(char const *filename, ios_base::openmode mode)
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:open", key_word_list, &param1, &param2))
            {
                (local_this)->open((char const *)param1, (ios_base::openmode)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "open() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "open(non-const FileStream this, string filename)\n"
          "open(non-const FileStream this, string filename, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FileStream_open_347_comment =
    "C++ Interface:\n"
    "open(non-const FileStream this, string filename)\n"
    "open(non-const FileStream this, string filename, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FileStream::open\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FileStream_open_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FileStream::close(void)
 *******************************************************************/
static PyObject *Dtool_FileStream_close_348(PyObject *self, PyObject *args,PyObject *kwds) {
    FileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FileStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FileStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const FileStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FileStream_close_348_comment =
    "C++ Interface:\n"
    "close(non-const FileStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FileStream::close\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FileStream_close_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline FileStream::FileStream(void)
 * inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
 * inline FileStream::FileStream(char const *filename, ios_base::openmode mode = (ios::in))
 *******************************************************************/
int  Dtool_Init_FileStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline FileStream::FileStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":FileStream", key_word_list))
            {
                FileStream *return_value = new FileStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FileStream,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode = (ios::in))
            char *param0;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FileStream", key_word_list, &param0));
            else
                (PyArg_Parse(args, "s:FileStream", &param0));
            if(!PyErr_Occurred())
            {
                FileStream *return_value = new FileStream((char const *)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FileStream,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
            char *param0;
            int param1;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:FileStream", key_word_list, &param0, &param1))
            {
                FileStream *return_value = new FileStream((char const *)param0, (ios_base::openmode)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_FileStream,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FileStream() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FileStream()\n"
          "FileStream(string filename)\n"
          "FileStream(string filename, int mode)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FileStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FileStream)
    {
        printf("FileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FileStream * local_this = (FileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FileStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_iostream)
        return ( iostream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *)( iostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FileStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FileStream)
        return from_this;
    if(from_type == &Dtool_iostream)
    {
          iostream* other_this = (iostream*)from_this;
          return (FileStream*)other_this;
    }
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (FileStream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (FileStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. iostream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void iostream::flush(void)
 *******************************************************************/
static PyObject *Dtool_iostream_flush_343(PyObject *self, PyObject *args,PyObject *kwds) {
    iostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_iostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void iostream::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Iostream.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const Iostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_iostream_flush_343_comment =
    "C++ Interface:\n"
    "flush(non-const Iostream this)\n"
    "\n"
    "";
#else
static const char * Dtool_iostream_flush_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * istream *iostream::upcast_to_istream(void)
 *******************************************************************/
static PyObject *Dtool_iostream_upcast_to_istream_332(PyObject *self, PyObject *args,PyObject *kwds) {
    iostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_iostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-istream *iostream::upcast_to_istream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIstream", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIstream"));
        if(!PyErr_Occurred())
        {
            istream *return_value = (istream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Iostream.upcastToIstream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIstream(non-const Iostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_iostream_upcast_to_istream_332_comment =
    "C++ Interface:\n"
    "upcastToIstream(non-const Iostream this)\n"
    "\n"
    "upcast from iostream to istream\n"
    "";
#else
static const char * Dtool_iostream_upcast_to_istream_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ostream *iostream::upcast_to_ostream(void)
 *******************************************************************/
static PyObject *Dtool_iostream_upcast_to_ostream_341(PyObject *self, PyObject *args,PyObject *kwds) {
    iostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_iostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ostream *iostream::upcast_to_ostream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToOstream", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToOstream"));
        if(!PyErr_Occurred())
        {
            ostream *return_value = (ostream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Iostream.upcastToOstream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToOstream(non-const Iostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_iostream_upcast_to_ostream_341_comment =
    "C++ Interface:\n"
    "upcastToOstream(non-const Iostream this)\n"
    "\n"
    "upcast from iostream to ostream\n"
    "";
#else
static const char * Dtool_iostream_upcast_to_ostream_341_comment = NULL;
#endif

int  Dtool_Init_iostream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (iostream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_iostream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_iostream)
    {
        printf("iostream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    iostream * local_this = (iostream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_iostream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_iostream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_iostream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (iostream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (iostream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. istream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int istream::get(void)
 *******************************************************************/
static PyObject *Dtool_istream_get_328(PyObject *self, PyObject *args,PyObject *kwds) {
    istream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_istream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int istream::get(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get", key_word_list));
        else
            (PyArg_Parse(args, ":get"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Istream.get() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get(non-const Istream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_istream_get_328_comment =
    "C++ Interface:\n"
    "get(non-const Istream this)\n"
    "\n"
    "";
#else
static const char * Dtool_istream_get_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned long int istream::tellg(void)
 *******************************************************************/
static PyObject *Dtool_istream_tellg_329(PyObject *self, PyObject *args,PyObject *kwds) {
    istream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_istream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned long int istream::tellg(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tellg", key_word_list));
        else
            (PyArg_Parse(args, ":tellg"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = (local_this)->tellg();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Istream.tellg() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tellg(non-const Istream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_istream_tellg_329_comment =
    "C++ Interface:\n"
    "tellg(non-const Istream this)\n"
    "\n"
    "";
#else
static const char * Dtool_istream_tellg_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void istream::seekg(long int off, ios_base::seekdir dir)
 * void istream::seekg(unsigned long int pos)
 *******************************************************************/
static PyObject *Dtool_istream_seekg_330(PyObject *self, PyObject *args,PyObject *kwds) {
    istream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_istream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void istream::seekg(unsigned long int pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:seekg", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:seekg", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->seekg(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Istream.seekg() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void istream::seekg(long int off, ios_base::seekdir dir)
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"off", (char *)"dir", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:seekg", key_word_list, &param1, &param2))
            {
                (local_this)->seekg((long int)param1, (ios_base::seekdir)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Istream.seekg() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "seekg() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "seekg(non-const Istream this, unsigned int pos)\n"
          "seekg(non-const Istream this, int off, int dir)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_istream_seekg_330_comment =
    "C++ Interface:\n"
    "seekg(non-const Istream this, unsigned int pos)\n"
    "seekg(non-const Istream this, int off, int dir)\n"
    "\n"
    "";
#else
static const char * Dtool_istream_seekg_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ios *istream::upcast_to_ios(void)
 *******************************************************************/
static PyObject *Dtool_istream_upcast_to_ios_327(PyObject *self, PyObject *args,PyObject *kwds) {
    istream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_istream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ios *istream::upcast_to_ios(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIos", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIos"));
        if(!PyErr_Occurred())
        {
            ios *return_value = (ios *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ios,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Istream.upcastToIos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIos(non-const Istream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_istream_upcast_to_ios_327_comment =
    "C++ Interface:\n"
    "upcastToIos(non-const Istream this)\n"
    "\n"
    "upcast from istream to ios\n"
    "";
#else
static const char * Dtool_istream_upcast_to_ios_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * iostream *istream::downcast_to_iostream(void)
 *******************************************************************/
static PyObject *Dtool_istream_downcast_to_iostream_333(PyObject *self, PyObject *args,PyObject *kwds) {
    istream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_istream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-iostream *istream::downcast_to_iostream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToIostream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToIostream"));
        if(!PyErr_Occurred())
        {
            iostream *return_value = (iostream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_iostream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Istream.downcastToIostream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToIostream(non-const Istream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_istream_downcast_to_iostream_333_comment =
    "C++ Interface:\n"
    "downcastToIostream(non-const Istream this)\n"
    "\n"
    "downcast from istream to iostream\n"
    "";
#else
static const char * Dtool_istream_downcast_to_iostream_333_comment = NULL;
#endif

int  Dtool_Init_istream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (istream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_istream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_istream)
    {
        printf("istream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    istream * local_this = (istream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_istream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_istream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_istream)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ios 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool ios::good(void) const
 *******************************************************************/
static PyObject *Dtool_ios_good_321(PyObject *self, PyObject *args,PyObject *kwds) {
    ios * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ios,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ios::good(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":good", key_word_list));
        else
            (PyArg_Parse(args, ":good"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ios*)local_this)->good();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "good(const Ios this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ios_good_321_comment =
    "C++ Interface:\n"
    "good(const Ios this)\n"
    "\n"
    "";
#else
static const char * Dtool_ios_good_321_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ios::eof(void) const
 *******************************************************************/
static PyObject *Dtool_ios_eof_322(PyObject *self, PyObject *args,PyObject *kwds) {
    ios * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ios,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ios::eof(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":eof", key_word_list));
        else
            (PyArg_Parse(args, ":eof"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ios*)local_this)->eof();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eof(const Ios this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ios_eof_322_comment =
    "C++ Interface:\n"
    "eof(const Ios this)\n"
    "\n"
    "";
#else
static const char * Dtool_ios_eof_322_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ios::fail(void) const
 *******************************************************************/
static PyObject *Dtool_ios_fail_323(PyObject *self, PyObject *args,PyObject *kwds) {
    ios * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ios,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ios::fail(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":fail", key_word_list));
        else
            (PyArg_Parse(args, ":fail"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ios*)local_this)->fail();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fail(const Ios this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ios_fail_323_comment =
    "C++ Interface:\n"
    "fail(const Ios this)\n"
    "\n"
    "";
#else
static const char * Dtool_ios_fail_323_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ios::bad(void) const
 *******************************************************************/
static PyObject *Dtool_ios_bad_324(PyObject *self, PyObject *args,PyObject *kwds) {
    ios * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ios,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ios::bad(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":bad", key_word_list));
        else
            (PyArg_Parse(args, ":bad"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ios*)local_this)->bad();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bad(const Ios this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ios_bad_324_comment =
    "C++ Interface:\n"
    "bad(const Ios this)\n"
    "\n"
    "";
#else
static const char * Dtool_ios_bad_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ios::clear(void)
 *******************************************************************/
static PyObject *Dtool_ios_clear_325(PyObject *self, PyObject *args,PyObject *kwds) {
    ios * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ios,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ios::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ios.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const Ios this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ios_clear_325_comment =
    "C++ Interface:\n"
    "clear(non-const Ios this)\n"
    "\n"
    "";
#else
static const char * Dtool_ios_clear_325_comment = NULL;
#endif

int  Dtool_Init_ios(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ios)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ios(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ios)
    {
        printf("ios ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ios * local_this = (ios *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ios)
        return local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ios(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ios)
        return from_this;
    if(from_type == &Dtool_ios_base)
    {
          ios_base* other_this = (ios_base*)from_this;
          return (ios*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ios_base 
//********************************************************************
int  Dtool_Init_ios_base(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ios_base)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ios_base(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ios_base)
    {
        printf("ios_base ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ios_base * local_this = (ios_base *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ios_base)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ios_base(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ios_base)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ostream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ostream::put(char c)
 *******************************************************************/
static PyObject *Dtool_ostream_put_336(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ostream::put(char c)
        int param1;
        static char * key_word_list[] = {(char *)"c", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:put", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:put", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->put((char)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ostream.put() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "put(non-const Ostream this, int c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_put_336_comment =
    "C++ Interface:\n"
    "put(non-const Ostream this, int c)\n"
    "\n"
    "";
#else
static const char * Dtool_ostream_put_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ostream::flush(void)
 *******************************************************************/
static PyObject *Dtool_ostream_flush_337(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ostream::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ostream.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const Ostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_flush_337_comment =
    "C++ Interface:\n"
    "flush(non-const Ostream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ostream_flush_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned long int ostream::tellp(void)
 *******************************************************************/
static PyObject *Dtool_ostream_tellp_338(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned long int ostream::tellp(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tellp", key_word_list));
        else
            (PyArg_Parse(args, ":tellp"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = (local_this)->tellp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ostream.tellp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tellp(non-const Ostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_tellp_338_comment =
    "C++ Interface:\n"
    "tellp(non-const Ostream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ostream_tellp_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ostream::seekp(long int off, ios_base::seekdir dir)
 * void ostream::seekp(unsigned long int pos)
 *******************************************************************/
static PyObject *Dtool_ostream_seekp_339(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ostream::seekp(unsigned long int pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:seekp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:seekp", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->seekp(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Ostream.seekp() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ostream::seekp(long int off, ios_base::seekdir dir)
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"off", (char *)"dir", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:seekp", key_word_list, &param1, &param2))
            {
                (local_this)->seekp((long int)param1, (ios_base::seekdir)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Ostream.seekp() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "seekp() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "seekp(non-const Ostream this, unsigned int pos)\n"
          "seekp(non-const Ostream this, int off, int dir)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_seekp_339_comment =
    "C++ Interface:\n"
    "seekp(non-const Ostream this, unsigned int pos)\n"
    "seekp(non-const Ostream this, int off, int dir)\n"
    "\n"
    "";
#else
static const char * Dtool_ostream_seekp_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ios *ostream::upcast_to_ios(void)
 *******************************************************************/
static PyObject *Dtool_ostream_upcast_to_ios_335(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ios *ostream::upcast_to_ios(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIos", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIos"));
        if(!PyErr_Occurred())
        {
            ios *return_value = (ios *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ios,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ostream.upcastToIos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIos(non-const Ostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_upcast_to_ios_335_comment =
    "C++ Interface:\n"
    "upcastToIos(non-const Ostream this)\n"
    "\n"
    "upcast from ostream to ios\n"
    "";
#else
static const char * Dtool_ostream_upcast_to_ios_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * iostream *ostream::downcast_to_iostream(void)
 *******************************************************************/
static PyObject *Dtool_ostream_downcast_to_iostream_342(PyObject *self, PyObject *args,PyObject *kwds) {
    ostream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ostream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-iostream *ostream::downcast_to_iostream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToIostream", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToIostream"));
        if(!PyErr_Occurred())
        {
            iostream *return_value = (iostream *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_iostream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ostream.downcastToIostream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToIostream(non-const Ostream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ostream_downcast_to_iostream_342_comment =
    "C++ Interface:\n"
    "downcastToIostream(non-const Ostream this)\n"
    "\n"
    "downcast from ostream to iostream\n"
    "";
#else
static const char * Dtool_ostream_downcast_to_iostream_342_comment = NULL;
#endif

int  Dtool_Init_ostream(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ostream)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ostream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ostream)
    {
        printf("ostream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ostream * local_this = (ostream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ostream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ostream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ostream)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Filename 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PyObject *Filename::__reduce__(PyObject *self) const
 *******************************************************************/
static PyObject *Dtool_Filename_reduce_353(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *Filename::__reduce__(PyObject *self) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__reduce__", key_word_list));
        else
            (PyArg_Parse(args, ":__reduce__"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const Filename*)local_this)->__reduce__(self);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__reduce__(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_reduce_353_comment =
    "C++ Interface:\n"
    "__reduce__(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_reduce_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename Filename::text_filename(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_Filename_text_filename_354(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Filename Filename::text_filename(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:textFilename", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:textFilename", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Filename result = Filename::text_filename(basic_string<char>(param0_str, param0_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "textFilename(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_text_filename_354_comment =
    "C++ Interface:\n"
    "textFilename(string filename)\n"
    "\n"
    "// Static constructors to explicitly create a filename that refers\n"
    "// to a text or binary file.  This is in lieu of calling set_text()\n"
    "// or set_binary() or set_type().\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::text_filename named constructor\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_text_filename_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename Filename::binary_filename(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_Filename_binary_filename_355(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Filename Filename::binary_filename(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:binaryFilename", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:binaryFilename", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Filename result = Filename::binary_filename(basic_string<char>(param0_str, param0_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "binaryFilename(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_binary_filename_355_comment =
    "C++ Interface:\n"
    "binaryFilename(string filename)\n"
    "\n"
    "// Static constructors to explicitly create a filename that refers\n"
    "// to a text or binary file.  This is in lieu of calling set_text()\n"
    "// or set_binary() or set_type().\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::binary_filename named constructor\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_binary_filename_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename Filename::dso_filename(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_Filename_dso_filename_356(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Filename Filename::dso_filename(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:dsoFilename", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:dsoFilename", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Filename result = Filename::dso_filename(basic_string<char>(param0_str, param0_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dsoFilename(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_dso_filename_356_comment =
    "C++ Interface:\n"
    "dsoFilename(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::dso_filename named constructor\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_dso_filename_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename Filename::executable_filename(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_Filename_executable_filename_357(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Filename Filename::executable_filename(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:executableFilename", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:executableFilename", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Filename result = Filename::executable_filename(basic_string<char>(param0_str, param0_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "executableFilename(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_executable_filename_357_comment =
    "C++ Interface:\n"
    "executableFilename(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::executable_filename named constructor\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_executable_filename_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Filename Filename::pattern_filename(basic_string< char > const &filename)
 *******************************************************************/
static PyObject *Dtool_Filename_pattern_filename_358(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Filename Filename::pattern_filename(basic_string< char > const &filename)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:patternFilename", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:patternFilename", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Filename result = Filename::pattern_filename(basic_string<char>(param0_str, param0_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "patternFilename(string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_pattern_filename_358_comment =
    "C++ Interface:\n"
    "patternFilename(string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::pattern_filename named constructor\n"
    "//       Access: Published\n"
    "//  Description: Constructs a filename that represents a sequence of\n"
    "//               numbered files.  See set_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_pattern_filename_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename Filename::from_os_specific(basic_string< char > const &os_specific, Filename::Type type)
 * static Filename Filename::from_os_specific(basic_string< char > const &os_specific, Filename::Type type = (T_general))
 *******************************************************************/
static PyObject *Dtool_Filename_from_os_specific_359(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static Filename Filename::from_os_specific(basic_string< char > const &os_specific, Filename::Type type = (T_general))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"os_specific", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:fromOsSpecific", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:fromOsSpecific", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Filename result = Filename::from_os_specific(basic_string<char>(param0_str, param0_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static Filename Filename::from_os_specific(basic_string< char > const &os_specific, Filename::Type type)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"os_specific", (char *)"type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:fromOsSpecific", key_word_list, &param0_str, &param0_len, &param1))
            {
                Filename result = Filename::from_os_specific(basic_string<char>(param0_str, param0_len), (Filename::Type)param1);
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "fromOsSpecific() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "fromOsSpecific(string os_specific)\n"
          "fromOsSpecific(string os_specific, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_from_os_specific_359_comment =
    "C++ Interface:\n"
    "fromOsSpecific(string os_specific)\n"
    "fromOsSpecific(string os_specific, int type)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_from_os_specific_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename Filename::expand_from(basic_string< char > const &user_string, Filename::Type type)
 * static Filename Filename::expand_from(basic_string< char > const &user_string, Filename::Type type = (T_general))
 *******************************************************************/
static PyObject *Dtool_Filename_expand_from_360(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static Filename Filename::expand_from(basic_string< char > const &user_string, Filename::Type type = (T_general))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"user_string", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:expandFrom", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:expandFrom", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Filename result = Filename::expand_from(basic_string<char>(param0_str, param0_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static Filename Filename::expand_from(basic_string< char > const &user_string, Filename::Type type)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"user_string", (char *)"type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:expandFrom", key_word_list, &param0_str, &param0_len, &param1))
            {
                Filename result = Filename::expand_from(basic_string<char>(param0_str, param0_len), (Filename::Type)param1);
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "expandFrom() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "expandFrom(string user_string)\n"
          "expandFrom(string user_string, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_expand_from_360_comment =
    "C++ Interface:\n"
    "expandFrom(string user_string)\n"
    "expandFrom(string user_string, int type)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_expand_from_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix, Filename::Type type)
 * static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix, Filename::Type type = (T_general))
 * static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix = ((string())), Filename::Type type = (T_general))
 *******************************************************************/
static PyObject *Dtool_Filename_temporary_361(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix = ((string())), Filename::Type type = (T_general))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"dirname", (char *)"prefix", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:temporary", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                Filename result = Filename::temporary(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix, Filename::Type type = (T_general))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"dirname", (char *)"prefix", (char *)"suffix", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:temporary", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                Filename result = Filename::temporary(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-static Filename Filename::temporary(basic_string< char > const &dirname, basic_string< char > const &prefix, basic_string< char > const &suffix, Filename::Type type)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"dirname", (char *)"prefix", (char *)"suffix", (char *)"type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:temporary", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                Filename result = Filename::temporary(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (Filename::Type)param3);
                Filename *return_value = new Filename(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "temporary() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "temporary(string dirname, string prefix)\n"
          "temporary(string dirname, string prefix, string suffix)\n"
          "temporary(string dirname, string prefix, string suffix, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_temporary_361_comment =
    "C++ Interface:\n"
    "temporary(string dirname, string prefix)\n"
    "temporary(string dirname, string prefix, string suffix)\n"
    "temporary(string dirname, string prefix, string suffix, int type)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_temporary_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename const &Filename::get_home_directory(void)
 *******************************************************************/
static PyObject *Dtool_Filename_get_home_directory_362(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename const &Filename::get_home_directory(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getHomeDirectory", key_word_list))
        {
            Filename const *return_value = &(Filename::get_home_directory());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHomeDirectory()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_home_directory_362_comment =
    "C++ Interface:\n"
    "getHomeDirectory()\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_home_directory_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename const &Filename::get_temp_directory(void)
 *******************************************************************/
static PyObject *Dtool_Filename_get_temp_directory_363(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename const &Filename::get_temp_directory(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTempDirectory", key_word_list))
        {
            Filename const *return_value = &(Filename::get_temp_directory());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTempDirectory()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_temp_directory_363_comment =
    "C++ Interface:\n"
    "getTempDirectory()\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_temp_directory_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename const &Filename::get_user_appdata_directory(void)
 *******************************************************************/
static PyObject *Dtool_Filename_get_user_appdata_directory_364(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename const &Filename::get_user_appdata_directory(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getUserAppdataDirectory", key_word_list))
        {
            Filename const *return_value = &(Filename::get_user_appdata_directory());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUserAppdataDirectory()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_user_appdata_directory_364_comment =
    "C++ Interface:\n"
    "getUserAppdataDirectory()\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_user_appdata_directory_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename const &Filename::get_common_appdata_directory(void)
 *******************************************************************/
static PyObject *Dtool_Filename_get_common_appdata_directory_365(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename const &Filename::get_common_appdata_directory(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCommonAppdataDirectory", key_word_list))
        {
            Filename const *return_value = &(Filename::get_common_appdata_directory());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCommonAppdataDirectory()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_common_appdata_directory_365_comment =
    "C++ Interface:\n"
    "getCommonAppdataDirectory()\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_common_appdata_directory_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename &Filename::operator =(Filename const &copy)
 * inline Filename &Filename::operator =(basic_string< char > const &filename)
 * inline Filename &Filename::operator =(char const *filename)
 *******************************************************************/
static PyObject *Dtool_Filename_operator_366(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline Filename &Filename::operator =(Filename const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Filename *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline Filename &Filename::operator =(basic_string< char > const &filename)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:assign", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:assign", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->operator =(basic_string<char>(param1_str, param1_len));
                Filename *return_value = local_this;
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, false);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline Filename &Filename::operator =(char const *filename)
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:assign", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->operator =((char const *)param1);
                Filename *return_value = local_this;
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Filename this, const Filename copy)\n"
          "assign(non-const Filename this, string filename)\n"
          "assign(non-const Filename this, string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_366_comment =
    "C++ Interface:\n"
    "assign(non-const Filename this, const Filename copy)\n"
    "assign(non-const Filename this, string filename)\n"
    "assign(non-const Filename this, string filename)\n"
    "\n"
    "// Assignment is via the = operator.\n"
    "\n"
    "// Assignment is via the = operator.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Assignment operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Assignment operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Copy assignment operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char const *Filename::c_str(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_c_str_368(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char const *Filename::c_str(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cStr", key_word_list));
        else
            (PyArg_Parse(args, ":cStr"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const Filename*)local_this)->c_str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cStr(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_c_str_368_comment =
    "C++ Interface:\n"
    "cStr(const Filename this)\n"
    "\n"
    "// And retrieval is by any of the classic string operations.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::c_str\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_c_str_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::empty(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_empty_369(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":empty", key_word_list));
        else
            (PyArg_Parse(args, ":empty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "empty(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_empty_369_comment =
    "C++ Interface:\n"
    "empty(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::empty\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_empty_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Filename::length(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_length_370(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Filename::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Filename*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_length_370_comment =
    "C++ Interface:\n"
    "length(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::length\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_length_370_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline char Filename::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_371(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline char Filename::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            char return_value = ((const Filename*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const Filename this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_371_comment =
    "C++ Interface:\n"
    "__getitem__(const Filename this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Indexing operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::substr(unsigned int begin, unsigned int end) const
 * inline basic_string< char > Filename::substr(unsigned int begin, unsigned int end = (string::npos)) const
 *******************************************************************/
static PyObject *Dtool_Filename_substr_372(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline basic_string< char > Filename::substr(unsigned int begin, unsigned int end = (string::npos)) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"begin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:substr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:substr", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    basic_string< char > return_value = ((const Filename*)local_this)->substr(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline basic_string< char > Filename::substr(unsigned int begin, unsigned int end) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"begin", (char *)"end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:substr", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param1_uint == NULL)|| (param2_uint == NULL)))
                {
                    basic_string< char > return_value = ((const Filename*)local_this)->substr(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "substr() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "substr(const Filename this, unsigned int begin)\n"
          "substr(const Filename this, unsigned int begin, unsigned int end)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_substr_372_comment =
    "C++ Interface:\n"
    "substr(const Filename this, unsigned int begin)\n"
    "substr(const Filename this, unsigned int begin, unsigned int end)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::substr\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_substr_372_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::operator +=(basic_string< char > const &other)
 *******************************************************************/
static PyObject *Dtool_Filename_operator_373(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Filename::operator +=(basic_string< char > const &other)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:__iadd__", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:__iadd__", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->operator +=(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.__iadd__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const Filename this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_373_comment =
    "C++ Interface:\n"
    "__iadd__(non-const Filename this, string other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Appends the other filename onto the end of this one.\n"
    "//               This does not introduce an intervening slash, but see\n"
    "//               the Filename constructor that takes two parameters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_373_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename Filename::operator +(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_374(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-inline Filename Filename::operator +(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:__add__", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:__add__", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            Filename result = ((const Filename*)local_this)->operator +(basic_string<char>(param1_str, param1_len));
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const Filename this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_374_comment =
    "C++ Interface:\n"
    "__add__(const Filename this, string other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a new Filename representing the concatenation\n"
    "//               of the two filenames.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_374_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_fullpath(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_fullpath_375(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_fullpath(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullpath", key_word_list));
        else
            (PyArg_Parse(args, ":getFullpath"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_fullpath();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullpath(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_fullpath_375_comment =
    "C++ Interface:\n"
    "getFullpath(const Filename this)\n"
    "\n"
    "// Or, you can use any of these.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_fullpath\n"
    "//       Access: Published\n"
    "//  Description: Returns the entire filename: directory, basename,\n"
    "//               extension.  This is the same thing returned by the\n"
    "//               string typecast operator, so this function is a\n"
    "//               little redundant.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_fullpath_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_dirname(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_dirname_376(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_dirname(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirname", key_word_list));
        else
            (PyArg_Parse(args, ":getDirname"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_dirname();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirname(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_dirname_376_comment =
    "C++ Interface:\n"
    "getDirname(const Filename this)\n"
    "\n"
    "// Or, you can use any of these.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_dirname\n"
    "//       Access: Published\n"
    "//  Description: Returns the directory part of the filename.  This is\n"
    "//               everything in the filename up to, but not including\n"
    "//               the rightmost slash.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_dirname_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_basename(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_basename_377(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_basename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBasename", key_word_list));
        else
            (PyArg_Parse(args, ":getBasename"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_basename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasename(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_basename_377_comment =
    "C++ Interface:\n"
    "getBasename(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_basename\n"
    "//       Access: Published\n"
    "//  Description: Returns the basename part of the filename.  This is\n"
    "//               everything in the filename after the rightmost slash,\n"
    "//               including any extensions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_basename_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_fullpath_wo_extension(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_fullpath_wo_extension_378(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_fullpath_wo_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullpathWoExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getFullpathWoExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_fullpath_wo_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullpathWoExtension(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_fullpath_wo_extension_378_comment =
    "C++ Interface:\n"
    "getFullpathWoExtension(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_fullpath_wo_extension\n"
    "//       Access: Published\n"
    "//  Description: Returns the full filename--directory and basename\n"
    "//               parts--except for the extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_fullpath_wo_extension_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_basename_wo_extension(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_basename_wo_extension_379(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_basename_wo_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBasenameWoExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getBasenameWoExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_basename_wo_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasenameWoExtension(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_basename_wo_extension_379_comment =
    "C++ Interface:\n"
    "getBasenameWoExtension(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_basename_wo_extension\n"
    "//       Access: Published\n"
    "//  Description: Returns the basename part of the filename, without\n"
    "//               the file extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_basename_wo_extension_379_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_extension(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_extension_380(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtension(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_extension_380_comment =
    "C++ Interface:\n"
    "getExtension(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_extension\n"
    "//       Access: Published\n"
    "//  Description: Returns the file extension.  This is everything after\n"
    "//               the rightmost dot, if there is one, or the empty\n"
    "//               string if there is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_extension_380_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_fullpath(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_fullpath_381(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_fullpath(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFullpath", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFullpath", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fullpath(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setFullpath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFullpath(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_fullpath_381_comment =
    "C++ Interface:\n"
    "setFullpath(non-const Filename this, string s)\n"
    "\n"
    "// You can also use any of these to reassign pieces of the filename.\n"
    "";
#else
static const char * Dtool_Filename_set_fullpath_381_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_dirname(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_dirname_382(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_dirname(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDirname", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDirname", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_dirname(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setDirname() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDirname(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_dirname_382_comment =
    "C++ Interface:\n"
    "setDirname(non-const Filename this, string s)\n"
    "\n"
    "// You can also use any of these to reassign pieces of the filename.\n"
    "";
#else
static const char * Dtool_Filename_set_dirname_382_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_basename(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_basename_383(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_basename(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setBasename", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setBasename", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_basename(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setBasename() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBasename(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_basename_383_comment =
    "C++ Interface:\n"
    "setBasename(non-const Filename this, string s)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_set_basename_383_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_fullpath_wo_extension(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_fullpath_wo_extension_384(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_fullpath_wo_extension(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFullpathWoExtension", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFullpathWoExtension", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fullpath_wo_extension(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setFullpathWoExtension() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFullpathWoExtension(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_fullpath_wo_extension_384_comment =
    "C++ Interface:\n"
    "setFullpathWoExtension(non-const Filename this, string s)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_set_fullpath_wo_extension_384_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_basename_wo_extension(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_basename_wo_extension_385(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_basename_wo_extension(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setBasenameWoExtension", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setBasenameWoExtension", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_basename_wo_extension(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setBasenameWoExtension() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBasenameWoExtension(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_basename_wo_extension_385_comment =
    "C++ Interface:\n"
    "setBasenameWoExtension(non-const Filename this, string s)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_set_basename_wo_extension_385_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_extension(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_extension_386(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_extension(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setExtension", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setExtension", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_extension(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setExtension() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExtension(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_extension_386_comment =
    "C++ Interface:\n"
    "setExtension(non-const Filename this, string s)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_set_extension_386_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::set_binary(void)
 *******************************************************************/
static PyObject *Dtool_Filename_set_binary_387(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Filename::set_binary(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setBinary", key_word_list));
        else
            (PyArg_Parse(args, ":setBinary"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_binary();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setBinary() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBinary(non-const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_binary_387_comment =
    "C++ Interface:\n"
    "setBinary(non-const Filename this)\n"
    "\n"
    "// Setting these flags appropriately is helpful when opening or\n"
    "// searching for a file; it helps the Filename resolve OS-specific\n"
    "// conventions (for instance, that dynamic library names should\n"
    "// perhaps be changed from .so to .dll).\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::set_binary\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the filename represents a binary file.\n"
    "//               This is primarily relevant to the read_file() and\n"
    "//               write_file() methods, so they can set the appropriate\n"
    "//               flags to the OS.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_set_binary_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::set_text(void)
 *******************************************************************/
static PyObject *Dtool_Filename_set_text_388(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Filename::set_text(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setText", key_word_list));
        else
            (PyArg_Parse(args, ":setText"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setText(non-const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_text_388_comment =
    "C++ Interface:\n"
    "setText(non-const Filename this)\n"
    "\n"
    "// Setting these flags appropriately is helpful when opening or\n"
    "// searching for a file; it helps the Filename resolve OS-specific\n"
    "// conventions (for instance, that dynamic library names should\n"
    "// perhaps be changed from .so to .dll).\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::set_text\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the filename represents a text file.\n"
    "//               This is primarily relevant to the read_file() and\n"
    "//               write_file() methods, so they can set the appropriate\n"
    "//               flags to the OS.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_set_text_388_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::is_binary(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_binary_389(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::is_binary(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBinary", key_word_list));
        else
            (PyArg_Parse(args, ":isBinary"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_binary();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBinary(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_binary_389_comment =
    "C++ Interface:\n"
    "isBinary(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::is_binary\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Filename has been indicated to\n"
    "//               represent a binary file via a previous call to\n"
    "//               set_binary().  It is possible that neither\n"
    "//               is_binary() nor is_text() will be true, if neither\n"
    "//               set_binary() nor set_text() was ever called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_is_binary_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::is_text(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_text_390(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::is_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isText", key_word_list));
        else
            (PyArg_Parse(args, ":isText"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isText(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_text_390_comment =
    "C++ Interface:\n"
    "isText(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::is_text\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Filename has been indicated to\n"
    "//               represent a text file via a previous call to\n"
    "//               set_text().  It is possible that neither is_binary()\n"
    "//               nor is_text() will be true, if neither set_binary()\n"
    "//               nor set_text() was ever called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_is_text_390_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::set_type(Filename::Type type)
 *******************************************************************/
static PyObject *Dtool_Filename_set_type_391(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Filename::set_type(Filename::Type type)
        int param1;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_type((Filename::Type)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setType(non-const Filename this, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_type_391_comment =
    "C++ Interface:\n"
    "setType(non-const Filename this, int type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::set_type\n"
    "//       Access: Published\n"
    "//  Description: Sets the type of the file represented by the\n"
    "//               filename.  This is useful for to_os_specific(),\n"
    "//               resolve_filename(), test_existence(), and all such\n"
    "//               real-world access functions.  It helps the Filename\n"
    "//               know how to map the internal filename to the\n"
    "//               OS-specific filename (for instance, maybe executables\n"
    "//               should have an .exe extension).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_set_type_391_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename::Type Filename::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_type_392(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename::Type Filename::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            Filename::Type return_value = ((const Filename*)local_this)->get_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_type_392_comment =
    "C++ Interface:\n"
    "getType(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of the file represented by the\n"
    "//               filename, as previously set by set_type().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_type_392_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::set_pattern(bool pattern)
 *******************************************************************/
static PyObject *Dtool_Filename_set_pattern_393(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Filename::set_pattern(bool pattern)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPattern", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pattern((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPattern(non-const Filename this, bool pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_pattern_393_comment =
    "C++ Interface:\n"
    "setPattern(non-const Filename this, bool pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::set_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating whether this is a filename\n"
    "//               pattern.  When this is true, the filename is\n"
    "//               understood to be a placeholder for a numbered\n"
    "//               sequence of filename, such as an image sequence.  In\n"
    "//               this case, a sequence of one or more hash characters\n"
    "//               (\"#\") should appear in the filename string; these\n"
    "//               characters will be filled in with the corresponding\n"
    "//               number (or more) of digits representing the sequence\n"
    "//               number.  Sequence numbers always begin counting at 0.\n"
    "//\n"
    "//               When this is true, methods like has_hash() and\n"
    "//               get_hash_to_end() and get_filename_index() may be\n"
    "//               called.  Methods like is_exists() will implicitly\n"
    "//               test for existance of filename sequence 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_set_pattern_393_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::get_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_pattern_394(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::get_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getPattern"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->get_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPattern(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_pattern_394_comment =
    "C++ Interface:\n"
    "getPattern(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag indicating whether this is a\n"
    "//               filename pattern.  See set_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_pattern_394_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::has_hash(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_has_hash_395(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::has_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasHash", key_word_list));
        else
            (PyArg_Parse(args, ":hasHash"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->has_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasHash(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_has_hash_395_comment =
    "C++ Interface:\n"
    "hasHash(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::has_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the filename is indicated to be a\n"
    "//               filename pattern (that is, set_pattern(true) was\n"
    "//               called), and the filename pattern did include a\n"
    "//               sequence of hash marks, or false if it was not a\n"
    "//               filename pattern or did not include hash marks.  If\n"
    "//               this is true, then get_filename_index() will return a\n"
    "//               different filename each time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_has_hash_395_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename Filename::get_filename_index(int index) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_filename_index_396(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Filename Filename::get_filename_index(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFilenameIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFilenameIndex", &param1));
        if(!PyErr_Occurred())
        {
            Filename result = ((const Filename*)local_this)->get_filename_index((int)param1);
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilenameIndex(const Filename this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_filename_index_396_comment =
    "C++ Interface:\n"
    "getFilenameIndex(const Filename this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_filename_index_396_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Filename::get_hash_to_end(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_hash_to_end_397(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Filename::get_hash_to_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHashToEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getHashToEnd"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->get_hash_to_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHashToEnd(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_hash_to_end_397_comment =
    "C++ Interface:\n"
    "getHashToEnd(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::get_hash_to_end\n"
    "//       Access: Published\n"
    "//  Description: Returns the part of the filename beginning at the\n"
    "//               hash sequence (if any), and continuing to the end of\n"
    "//               the filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_get_hash_to_end_397_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::set_hash_to_end(basic_string< char > const &s)
 *******************************************************************/
static PyObject *Dtool_Filename_set_hash_to_end_398(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::set_hash_to_end(basic_string< char > const &s)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setHashToEnd", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setHashToEnd", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_hash_to_end(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.setHashToEnd() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHashToEnd(non-const Filename this, string s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_set_hash_to_end_398_comment =
    "C++ Interface:\n"
    "setHashToEnd(non-const Filename this, string s)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_set_hash_to_end_398_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::standardize(void)
 *******************************************************************/
static PyObject *Dtool_Filename_standardize_400(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Filename::standardize(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":standardize", key_word_list));
        else
            (PyArg_Parse(args, ":standardize"));
        if(!PyErr_Occurred())
        {
            (local_this)->standardize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.standardize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "standardize(non-const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_standardize_400_comment =
    "C++ Interface:\n"
    "standardize(non-const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_standardize_400_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::is_local(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_local_401(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::is_local(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isLocal", key_word_list));
        else
            (PyArg_Parse(args, ":isLocal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_local();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isLocal(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_local_401_comment =
    "C++ Interface:\n"
    "isLocal(const Filename this)\n"
    "\n"
    "// The following functions deal with the outside world.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::is_local\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the filename is local, e.g. does not\n"
    "//               begin with a slash, or false if the filename is fully\n"
    "//               specified from the root.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_is_local_401_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::is_fully_qualified(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_fully_qualified_402(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::is_fully_qualified(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFullyQualified", key_word_list));
        else
            (PyArg_Parse(args, ":isFullyQualified"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_fully_qualified();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFullyQualified(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_fully_qualified_402_comment =
    "C++ Interface:\n"
    "isFullyQualified(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::is_fully_qualified\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the filename is fully qualified,\n"
    "//               e.g. begins with a slash.  This is almost, but not\n"
    "//               quite, the same thing as !is_local().  It's not\n"
    "//               exactly the same because a special case is made for\n"
    "//               filenames that begin with a single dot followed by a\n"
    "//               slash--these are considered to be fully qualified\n"
    "//               (they are explicitly relative to the current\n"
    "//               directory, and do not refer to a filename on a search\n"
    "//               path somewhere).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_is_fully_qualified_402_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Filename::make_absolute(void)
 * void Filename::make_absolute(Filename const &start_directory)
 *******************************************************************/
static PyObject *Dtool_Filename_make_absolute_403(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Filename::make_absolute(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeAbsolute", key_word_list));
            else
                (PyArg_Parse(args, ":makeAbsolute"));
            if(!PyErr_Occurred())
            {
                (local_this)->make_absolute();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Filename.makeAbsolute() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void Filename::make_absolute(Filename const &start_directory)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"start_directory", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeAbsolute", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:makeAbsolute", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.makeAbsolute", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->make_absolute(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Filename.makeAbsolute() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeAbsolute() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeAbsolute(non-const Filename this)\n"
          "makeAbsolute(non-const Filename this, const Filename start_directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_make_absolute_403_comment =
    "C++ Interface:\n"
    "makeAbsolute(non-const Filename this)\n"
    "makeAbsolute(non-const Filename this, const Filename start_directory)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_make_absolute_403_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::make_canonical(void)
 *******************************************************************/
static PyObject *Dtool_Filename_make_canonical_404(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Filename::make_canonical(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCanonical", key_word_list));
        else
            (PyArg_Parse(args, ":makeCanonical"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->make_canonical();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.makeCanonical() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCanonical(non-const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_make_canonical_404_comment =
    "C++ Interface:\n"
    "makeCanonical(non-const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_make_canonical_404_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::make_true_case(void)
 *******************************************************************/
static PyObject *Dtool_Filename_make_true_case_405(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Filename::make_true_case(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeTrueCase", key_word_list));
        else
            (PyArg_Parse(args, ":makeTrueCase"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->make_true_case();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Filename.makeTrueCase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeTrueCase(non-const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_make_true_case_405_comment =
    "C++ Interface:\n"
    "makeTrueCase(non-const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_make_true_case_405_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Filename::to_os_specific(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_to_os_specific_406(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Filename::to_os_specific(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":toOsSpecific", key_word_list));
        else
            (PyArg_Parse(args, ":toOsSpecific"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->to_os_specific();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toOsSpecific(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_to_os_specific_406_comment =
    "C++ Interface:\n"
    "toOsSpecific(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_to_os_specific_406_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Filename::to_os_generic(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_to_os_generic_407(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Filename::to_os_generic(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":toOsGeneric", key_word_list));
        else
            (PyArg_Parse(args, ":toOsGeneric"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->to_os_generic();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toOsGeneric(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_to_os_generic_407_comment =
    "C++ Interface:\n"
    "toOsGeneric(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_to_os_generic_407_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Filename::to_os_short_name(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_to_os_short_name_408(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Filename::to_os_short_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":toOsShortName", key_word_list));
        else
            (PyArg_Parse(args, ":toOsShortName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->to_os_short_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toOsShortName(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_to_os_short_name_408_comment =
    "C++ Interface:\n"
    "toOsShortName(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_to_os_short_name_408_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Filename::to_os_long_name(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_to_os_long_name_409(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Filename::to_os_long_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":toOsLongName", key_word_list));
        else
            (PyArg_Parse(args, ":toOsLongName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Filename*)local_this)->to_os_long_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toOsLongName(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_to_os_long_name_409_comment =
    "C++ Interface:\n"
    "toOsLongName(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_to_os_long_name_409_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::exists(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_exists_410(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::exists(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":exists", key_word_list));
        else
            (PyArg_Parse(args, ":exists"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->exists();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "exists(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_exists_410_comment =
    "C++ Interface:\n"
    "exists(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_exists_410_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::is_regular_file(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_regular_file_411(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::is_regular_file(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRegularFile", key_word_list));
        else
            (PyArg_Parse(args, ":isRegularFile"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_regular_file();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRegularFile(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_regular_file_411_comment =
    "C++ Interface:\n"
    "isRegularFile(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_is_regular_file_411_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::is_directory(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_directory_412(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::is_directory(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDirectory", key_word_list));
        else
            (PyArg_Parse(args, ":isDirectory"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_directory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDirectory(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_directory_412_comment =
    "C++ Interface:\n"
    "isDirectory(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_is_directory_412_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::is_executable(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_is_executable_413(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::is_executable(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isExecutable", key_word_list));
        else
            (PyArg_Parse(args, ":isExecutable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->is_executable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isExecutable(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_is_executable_413_comment =
    "C++ Interface:\n"
    "isExecutable(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_is_executable_413_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old, bool other_missing_is_old) const
 * int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old, bool other_missing_is_old = (1)) const
 * int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = (1), bool other_missing_is_old = (1)) const
 *******************************************************************/
static PyObject *Dtool_Filename_compare_timestamps_414(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = (1), bool other_missing_is_old = (1)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTimestamps", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:compareTimestamps", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.compareTimestamps", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const Filename*)local_this)->compare_timestamps(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old, bool other_missing_is_old = (1)) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"other", (char *)"this_missing_is_old", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:compareTimestamps", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.compareTimestamps", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const Filename*)local_this)->compare_timestamps(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old, bool other_missing_is_old) const
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"other", (char *)"this_missing_is_old", (char *)"other_missing_is_old", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:compareTimestamps", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.compareTimestamps", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const Filename*)local_this)->compare_timestamps(*param1_this, (PyObject_IsTrue(param2)!=0), (PyObject_IsTrue(param3)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "compareTimestamps() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "compareTimestamps(const Filename this, const Filename other)\n"
          "compareTimestamps(const Filename this, const Filename other, bool this_missing_is_old)\n"
          "compareTimestamps(const Filename this, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_compare_timestamps_414_comment =
    "C++ Interface:\n"
    "compareTimestamps(const Filename this, const Filename other)\n"
    "compareTimestamps(const Filename this, const Filename other, bool this_missing_is_old)\n"
    "compareTimestamps(const Filename this, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_compare_timestamps_414_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int Filename::get_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_timestamp_415(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int Filename::get_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getTimestamp"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Filename*)local_this)->get_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimestamp(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_timestamp_415_comment =
    "C++ Interface:\n"
    "getTimestamp(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_timestamp_415_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int Filename::get_access_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_access_timestamp_416(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int Filename::get_access_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAccessTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getAccessTimestamp"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Filename*)local_this)->get_access_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAccessTimestamp(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_access_timestamp_416_comment =
    "C++ Interface:\n"
    "getAccessTimestamp(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_access_timestamp_416_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Filename::get_file_size(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_file_size_417(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Filename::get_file_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileSize", key_word_list));
        else
            (PyArg_Parse(args, ":getFileSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Filename*)local_this)->get_file_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileSize(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_file_size_417_comment =
    "C++ Interface:\n"
    "getFileSize(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_file_size_417_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::resolve_filename(DSearchPath const &searchpath, basic_string< char > const &default_extension)
 * bool Filename::resolve_filename(DSearchPath const &searchpath, basic_string< char > const &default_extension = ((string())))
 *******************************************************************/
static PyObject *Dtool_Filename_resolve_filename_418(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Filename::resolve_filename(DSearchPath const &searchpath, basic_string< char > const &default_extension = ((string())))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"searchpath", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:resolveFilename", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:resolveFilename", &param1));
                if(!PyErr_Occurred())
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "Filename.resolveFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->resolve_filename(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Filename.resolveFilename() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Filename::resolve_filename(DSearchPath const &searchpath, basic_string< char > const &default_extension)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"searchpath", (char *)"default_extension", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:resolveFilename", key_word_list, &param1, &param2_str, &param2_len))
                {
                    DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "Filename.resolveFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->resolve_filename(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Filename.resolveFilename() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "resolveFilename() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "resolveFilename(non-const Filename this, const DSearchPath searchpath)\n"
          "resolveFilename(non-const Filename this, const DSearchPath searchpath, string default_extension)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_resolve_filename_418_comment =
    "C++ Interface:\n"
    "resolveFilename(non-const Filename this, const DSearchPath searchpath)\n"
    "resolveFilename(non-const Filename this, const DSearchPath searchpath, string default_extension)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_resolve_filename_418_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::make_relative_to(Filename directory, bool allow_backups)
 * bool Filename::make_relative_to(Filename directory, bool allow_backups = (1))
 *******************************************************************/
static PyObject *Dtool_Filename_make_relative_to_419(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Filename::make_relative_to(Filename directory, bool allow_backups = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"directory", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeRelativeTo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:makeRelativeTo", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.makeRelativeTo", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->make_relative_to(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Filename.makeRelativeTo() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Filename::make_relative_to(Filename directory, bool allow_backups)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"directory", (char *)"allow_backups", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:makeRelativeTo", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.makeRelativeTo", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->make_relative_to(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Filename.makeRelativeTo() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeRelativeTo() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeRelativeTo(non-const Filename this, const Filename directory)\n"
          "makeRelativeTo(non-const Filename this, const Filename directory, bool allow_backups)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_make_relative_to_419_comment =
    "C++ Interface:\n"
    "makeRelativeTo(non-const Filename this, const Filename directory)\n"
    "makeRelativeTo(non-const Filename this, const Filename directory, bool allow_backups)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_make_relative_to_419_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Filename::find_on_searchpath(DSearchPath const &searchpath)
 *******************************************************************/
static PyObject *Dtool_Filename_find_on_searchpath_420(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int Filename::find_on_searchpath(DSearchPath const &searchpath)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"searchpath", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findOnSearchpath", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findOnSearchpath", &param1));
            if(!PyErr_Occurred())
            {
                DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "Filename.findOnSearchpath", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->find_on_searchpath(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Filename.findOnSearchpath() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findOnSearchpath(non-const Filename this, const DSearchPath searchpath)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_find_on_searchpath_420_comment =
    "C++ Interface:\n"
    "findOnSearchpath(non-const Filename this, const DSearchPath searchpath)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_find_on_searchpath_420_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *Filename::scan_directory(void) const
 * Rejected Remap [bool Filename::scan_directory(vector< basic_string< char > > &contents) const]
 *******************************************************************/
static PyObject *Dtool_Filename_scan_directory_421(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *Filename::scan_directory(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":scanDirectory", key_word_list));
        else
            (PyArg_Parse(args, ":scanDirectory"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const Filename*)local_this)->scan_directory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "scanDirectory(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_scan_directory_421_comment =
    "C++ Interface:\n"
    "scanDirectory(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_scan_directory_421_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::open_read(IFileStream &stream) const
 * bool Filename::open_read(ifstream &stream) const
 *******************************************************************/
static PyObject *Dtool_Filename_open_read_422(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool Filename::open_read(IFileStream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openRead", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openRead", &param1));
            if(!PyErr_Occurred())
            {
                IFileStream *param1_this = (IFileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_IFileStream, 1, "Filename.openRead", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_read(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool Filename::open_read(ifstream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openRead", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openRead", &param1));
            if(!PyErr_Occurred())
            {
                ifstream *param1_this = (ifstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ifstream, 1, "Filename.openRead", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_read(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openRead(const Filename this, non-const IFileStream stream)\n"
          "openRead(const Filename this, non-const Ifstream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_open_read_422_comment =
    "C++ Interface:\n"
    "openRead(const Filename this, non-const IFileStream stream)\n"
    "openRead(const Filename this, non-const Ifstream stream)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_open_read_422_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::open_write(OFileStream &stream, bool truncate) const
 * bool Filename::open_write(OFileStream &stream, bool truncate = (1)) const
 * bool Filename::open_write(ofstream &stream, bool truncate) const
 * bool Filename::open_write(ofstream &stream, bool truncate = (1)) const
 *******************************************************************/
static PyObject *Dtool_Filename_open_write_423(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool Filename::open_write(ofstream &stream, bool truncate = (1)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openWrite", &param1));
                if(!PyErr_Occurred())
                {
                    ofstream *param1_this = (ofstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ofstream, 1, "Filename.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool Filename::open_write(OFileStream &stream, bool truncate = (1)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openWrite", &param1));
                if(!PyErr_Occurred())
                {
                    OFileStream *param1_this = (OFileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OFileStream, 1, "Filename.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool Filename::open_write(ofstream &stream, bool truncate) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"stream", (char *)"truncate", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openWrite", key_word_list, &param1, &param2))
                {
                    ofstream *param1_this = (ofstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ofstream, 1, "Filename.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_write(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool Filename::open_write(OFileStream &stream, bool truncate) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"stream", (char *)"truncate", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openWrite", key_word_list, &param1, &param2))
                {
                    OFileStream *param1_this = (OFileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OFileStream, 1, "Filename.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_write(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openWrite() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openWrite(const Filename this, non-const Ofstream stream)\n"
          "openWrite(const Filename this, non-const OFileStream stream)\n"
          "openWrite(const Filename this, non-const Ofstream stream, bool truncate)\n"
          "openWrite(const Filename this, non-const OFileStream stream, bool truncate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_open_write_423_comment =
    "C++ Interface:\n"
    "openWrite(const Filename this, non-const Ofstream stream)\n"
    "openWrite(const Filename this, non-const OFileStream stream)\n"
    "openWrite(const Filename this, non-const Ofstream stream, bool truncate)\n"
    "openWrite(const Filename this, non-const OFileStream stream, bool truncate)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_open_write_423_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::open_append(OFileStream &stream) const
 * bool Filename::open_append(ofstream &stream) const
 *******************************************************************/
static PyObject *Dtool_Filename_open_append_424(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool Filename::open_append(OFileStream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openAppend", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openAppend", &param1));
            if(!PyErr_Occurred())
            {
                OFileStream *param1_this = (OFileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OFileStream, 1, "Filename.openAppend", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_append(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool Filename::open_append(ofstream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openAppend", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openAppend", &param1));
            if(!PyErr_Occurred())
            {
                ofstream *param1_this = (ofstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ofstream, 1, "Filename.openAppend", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_append(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openAppend(const Filename this, non-const OFileStream stream)\n"
          "openAppend(const Filename this, non-const Ofstream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_open_append_424_comment =
    "C++ Interface:\n"
    "openAppend(const Filename this, non-const OFileStream stream)\n"
    "openAppend(const Filename this, non-const Ofstream stream)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_open_append_424_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::open_read_write(FileStream &stream, bool truncate) const
 * bool Filename::open_read_write(FileStream &stream, bool truncate = (0)) const
 * bool Filename::open_read_write(fstream &stream, bool truncate) const
 * bool Filename::open_read_write(fstream &stream, bool truncate = (0)) const
 *******************************************************************/
static PyObject *Dtool_Filename_open_read_write_425(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool Filename::open_read_write(FileStream &stream, bool truncate = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openReadWrite", &param1));
                if(!PyErr_Occurred())
                {
                    FileStream *param1_this = (FileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FileStream, 1, "Filename.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_read_write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool Filename::open_read_write(fstream &stream, bool truncate = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openReadWrite", &param1));
                if(!PyErr_Occurred())
                {
                    fstream *param1_this = (fstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_fstream, 1, "Filename.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_read_write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool Filename::open_read_write(fstream &stream, bool truncate) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"stream", (char *)"truncate", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openReadWrite", key_word_list, &param1, &param2))
                {
                    fstream *param1_this = (fstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_fstream, 1, "Filename.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_read_write(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool Filename::open_read_write(FileStream &stream, bool truncate) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"stream", (char *)"truncate", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openReadWrite", key_word_list, &param1, &param2))
                {
                    FileStream *param1_this = (FileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FileStream, 1, "Filename.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const Filename*)local_this)->open_read_write(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openReadWrite() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openReadWrite(const Filename this, non-const FileStream stream)\n"
          "openReadWrite(const Filename this, non-const Fstream stream)\n"
          "openReadWrite(const Filename this, non-const Fstream stream, bool truncate)\n"
          "openReadWrite(const Filename this, non-const FileStream stream, bool truncate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_open_read_write_425_comment =
    "C++ Interface:\n"
    "openReadWrite(const Filename this, non-const FileStream stream)\n"
    "openReadWrite(const Filename this, non-const Fstream stream)\n"
    "openReadWrite(const Filename this, non-const Fstream stream, bool truncate)\n"
    "openReadWrite(const Filename this, non-const FileStream stream, bool truncate)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_open_read_write_425_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::open_read_append(FileStream &stream) const
 * bool Filename::open_read_append(fstream &stream) const
 *******************************************************************/
static PyObject *Dtool_Filename_open_read_append_426(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool Filename::open_read_append(FileStream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadAppend", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openReadAppend", &param1));
            if(!PyErr_Occurred())
            {
                FileStream *param1_this = (FileStream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FileStream, 1, "Filename.openReadAppend", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_read_append(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool Filename::open_read_append(fstream &stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadAppend", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:openReadAppend", &param1));
            if(!PyErr_Occurred())
            {
                fstream *param1_this = (fstream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_fstream, 1, "Filename.openReadAppend", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->open_read_append(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openReadAppend(const Filename this, non-const FileStream stream)\n"
          "openReadAppend(const Filename this, non-const Fstream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_open_read_append_426_comment =
    "C++ Interface:\n"
    "openReadAppend(const Filename this, non-const FileStream stream)\n"
    "openReadAppend(const Filename this, non-const Fstream stream)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_open_read_append_426_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::chdir(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_chdir_427(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::chdir(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":chdir", key_word_list));
        else
            (PyArg_Parse(args, ":chdir"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->chdir();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "chdir(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_chdir_427_comment =
    "C++ Interface:\n"
    "chdir(const Filename this)\n"
    "\n"
    "// USE_PANDAFILESTREAM\n"
    "";
#else
static const char * Dtool_Filename_chdir_427_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::touch(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_touch_428(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::touch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":touch", key_word_list));
        else
            (PyArg_Parse(args, ":touch"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->touch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "touch(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_touch_428_comment =
    "C++ Interface:\n"
    "touch(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_touch_428_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::unlink(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_unlink_429(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::unlink(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unlink", key_word_list));
        else
            (PyArg_Parse(args, ":unlink"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->unlink();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unlink(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_unlink_429_comment =
    "C++ Interface:\n"
    "unlink(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_unlink_429_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::rename_to(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_rename_to_430(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool Filename::rename_to(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:renameTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:renameTo", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.renameTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->rename_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "renameTo(const Filename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_rename_to_430_comment =
    "C++ Interface:\n"
    "renameTo(const Filename this, const Filename other)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_rename_to_430_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::copy_to(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_copy_to_431(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool Filename::copy_to(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copyTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copyTo", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.copyTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Filename*)local_this)->copy_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyTo(const Filename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_copy_to_431_comment =
    "C++ Interface:\n"
    "copyTo(const Filename this, const Filename other)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_copy_to_431_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::make_dir(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_make_dir_432(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::make_dir(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeDir", key_word_list));
        else
            (PyArg_Parse(args, ":makeDir"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->make_dir();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeDir(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_make_dir_432_comment =
    "C++ Interface:\n"
    "makeDir(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_make_dir_432_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::mkdir(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_mkdir_433(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::mkdir(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":mkdir", key_word_list));
        else
            (PyArg_Parse(args, ":mkdir"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->mkdir();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mkdir(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_mkdir_433_comment =
    "C++ Interface:\n"
    "mkdir(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_mkdir_433_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Filename::rmdir(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_rmdir_434(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Filename::rmdir(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rmdir", key_word_list));
        else
            (PyArg_Parse(args, ":rmdir"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->rmdir();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rmdir(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_rmdir_434_comment =
    "C++ Interface:\n"
    "rmdir(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_rmdir_434_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::operator ==(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_435(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::operator ==(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:eq", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:eq", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->operator ==(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const Filename this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_435_comment =
    "C++ Interface:\n"
    "eq(const Filename this, string other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Equality operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_435_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::operator !=(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_436(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::operator !=(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ne", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:ne", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->operator !=(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const Filename this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_436_comment =
    "C++ Interface:\n"
    "ne(const Filename this, string other)\n"
    "\n"
    "// Comparison operators are handy.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Inequality operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_436_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::operator <(basic_string< char > const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_437(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::operator <(basic_string< char > const &other) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"other", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:lessThan", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:lessThan", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->operator <(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const Filename this, string other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_437_comment =
    "C++ Interface:\n"
    "lessThan(const Filename this, string other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::Ordering operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_437_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Filename::compare_to(Filename const &other) const
 *******************************************************************/
static PyObject *Dtool_Filename_compare_to_438(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int Filename::compare_to(Filename const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const Filename*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const Filename this, const Filename other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_compare_to_438_comment =
    "C++ Interface:\n"
    "compareTo(const Filename this, const Filename other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::compare_to\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_compare_to_438_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Filename::__nonzero__(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_nonzero_439(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Filename::__nonzero__(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Filename*)local_this)->__nonzero__();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_nonzero_439_comment =
    "C++ Interface:\n"
    "__nonzero__(const Filename this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::__nonzero__\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Filename is valid (not empty),\n"
    "//               or false if it is an empty string.\n"
    "//\n"
    "//               This implements the Python equivalent to operator\n"
    "//               bool.  Defining an actual operator bool method for\n"
    "//               C++ use would work too, but it seems to cause too\n"
    "//               many ambiguities for the C++ compiler, so we use this\n"
    "//               Python-only approach instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_nonzero_439_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Filename::get_hash(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_get_hash_440(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Filename::get_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHash", key_word_list));
        else
            (PyArg_Parse(args, ":getHash"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Filename*)local_this)->get_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHash(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_hash_440_comment =
    "C++ Interface:\n"
    "getHash(const Filename this)\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_hash_440_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Filename::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Filename_output_441(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void Filename::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Filename.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Filename*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Filename this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_output_441_comment =
    "C++ Interface:\n"
    "output(const Filename this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_output_441_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Filename::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Filename_get_class_type_442(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Filename::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Filename::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_get_class_type_442_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Filename_get_class_type_442_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Filename::operator typecast(void) const
 *******************************************************************/
static PyObject *Dtool_Filename_operator_typecast_367(PyObject *self, PyObject *args,PyObject *kwds) {
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Filename::operator typecast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":operatorTypecast", key_word_list));
        else
            (PyArg_Parse(args, ":operatorTypecast"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = (basic_string< char > const &)(*(const Filename*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "operatorTypecast(const Filename this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Filename_operator_typecast_367_comment =
    "C++ Interface:\n"
    "operatorTypecast(const Filename this)\n"
    "\n"
    "// And retrieval is by any of the classic string operations.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Filename::string typecast operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Filename_operator_typecast_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename::Filename(Filename const &copy)
 * Filename::Filename(Filename const &dirname, Filename const &basename)
 * inline Filename::Filename(basic_string< char > const &filename)
 * inline Filename::Filename(basic_string< char > const &filename = (""))
 * inline Filename::Filename(char const *filename)
 *******************************************************************/
int  Dtool_Init_Filename(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Filename::Filename(basic_string< char > const &filename = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Filename", key_word_list))
            {
                Filename *return_value = new Filename();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Filename,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline Filename::Filename(Filename const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Filename", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Filename", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "Filename.Filename", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Filename *return_value = new Filename(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Filename,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline Filename::Filename(basic_string< char > const &filename)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Filename", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:Filename", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    Filename *return_value = new Filename(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Filename,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline Filename::Filename(char const *filename)
                char *param0;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s:Filename", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "s:Filename", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *return_value = new Filename((char const *)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Filename,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Filename::Filename(Filename const &dirname, Filename const &basename)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"dirname", (char *)"basename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Filename", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "Filename.Filename", 1, coerced_ptr, report_errors);
Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Filename.Filename", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        Filename *return_value = new Filename(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Filename,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Filename() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Filename()\n"
          "Filename(const Filename copy)\n"
          "Filename(string filename)\n"
          "Filename(string filename)\n"
          "Filename(const Filename dirname, const Filename basename)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Filename(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Filename)
    {
        printf("Filename ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Filename * local_this = (Filename *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Filename)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Filename(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Filename)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GlobPattern 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void GlobPattern::operator =(GlobPattern const &copy)
 *******************************************************************/
static PyObject *Dtool_GlobPattern_operator_445(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GlobPattern::operator =(GlobPattern const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "GlobPattern.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    GlobPattern *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_GlobPattern,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GlobPattern.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const GlobPattern this, const GlobPattern copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_operator_445_comment =
    "C++ Interface:\n"
    "assign(non-const GlobPattern this, const GlobPattern copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_operator_445_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GlobPattern::operator ==(GlobPattern const &other) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_operator_446(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool GlobPattern::operator ==(GlobPattern const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "GlobPattern.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const GlobPattern*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const GlobPattern this, const GlobPattern other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_operator_446_comment =
    "C++ Interface:\n"
    "eq(const GlobPattern this, const GlobPattern other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::operator ==\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_operator_446_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GlobPattern::operator !=(GlobPattern const &other) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_operator_447(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool GlobPattern::operator !=(GlobPattern const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "GlobPattern.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const GlobPattern*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const GlobPattern this, const GlobPattern other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_operator_447_comment =
    "C++ Interface:\n"
    "ne(const GlobPattern this, const GlobPattern other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::operator !=\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_operator_447_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GlobPattern::operator <(GlobPattern const &other) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_operator_448(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool GlobPattern::operator <(GlobPattern const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "GlobPattern.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const GlobPattern*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const GlobPattern this, const GlobPattern other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_operator_448_comment =
    "C++ Interface:\n"
    "lessThan(const GlobPattern this, const GlobPattern other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::operator <\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_operator_448_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GlobPattern::set_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_GlobPattern_set_pattern_449(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GlobPattern::set_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GlobPattern.setPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPattern(non-const GlobPattern this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_set_pattern_449_comment =
    "C++ Interface:\n"
    "setPattern(non-const GlobPattern this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::set_pattern\n"
    "//       Access: Public\n"
    "//  Description: Changes the pattern string that the GlobPattern\n"
    "//               object matches.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_set_pattern_449_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &GlobPattern::get_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_get_pattern_450(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &GlobPattern::get_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const GlobPattern*)local_this)->get_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPattern(const GlobPattern this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_get_pattern_450_comment =
    "C++ Interface:\n"
    "getPattern(const GlobPattern this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::get_pattern\n"
    "//       Access: Public\n"
    "//  Description: Returns the pattern string that the GlobPattern\n"
    "//               object matches.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_get_pattern_450_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GlobPattern::set_case_sensitive(bool case_sensitive)
 *******************************************************************/
static PyObject *Dtool_GlobPattern_set_case_sensitive_451(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GlobPattern::set_case_sensitive(bool case_sensitive)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"case_sensitive", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCaseSensitive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCaseSensitive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_case_sensitive((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GlobPattern.setCaseSensitive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCaseSensitive(non-const GlobPattern this, bool case_sensitive)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_set_case_sensitive_451_comment =
    "C++ Interface:\n"
    "setCaseSensitive(non-const GlobPattern this, bool case_sensitive)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::set_case_sensitive\n"
    "//       Access: Public\n"
    "//  Description: Sets whether the match is case sensitive (true) or\n"
    "//               case insensitive (false).  The default is case\n"
    "//               sensitive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_set_case_sensitive_451_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GlobPattern::get_case_sensitive(void) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_get_case_sensitive_452(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GlobPattern::get_case_sensitive(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCaseSensitive", key_word_list));
        else
            (PyArg_Parse(args, ":getCaseSensitive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GlobPattern*)local_this)->get_case_sensitive();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCaseSensitive(const GlobPattern this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_get_case_sensitive_452_comment =
    "C++ Interface:\n"
    "getCaseSensitive(const GlobPattern this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::get_case_sensitive\n"
    "//       Access: Public\n"
    "//  Description: Returns whether the match is case sensitive (true) or\n"
    "//               case insensitive (false).  The default is case\n"
    "//               sensitive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_get_case_sensitive_452_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GlobPattern::set_nomatch_chars(basic_string< char > const &nomatch_chars)
 *******************************************************************/
static PyObject *Dtool_GlobPattern_set_nomatch_chars_453(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GlobPattern::set_nomatch_chars(basic_string< char > const &nomatch_chars)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"nomatch_chars", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setNomatchChars", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setNomatchChars", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_nomatch_chars(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GlobPattern.setNomatchChars() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNomatchChars(non-const GlobPattern this, string nomatch_chars)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_set_nomatch_chars_453_comment =
    "C++ Interface:\n"
    "setNomatchChars(non-const GlobPattern this, string nomatch_chars)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::set_nomatch_chars\n"
    "//       Access: Public\n"
    "//  Description: Specifies a set of characters that are not matched by\n"
    "//               * or ?.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_set_nomatch_chars_453_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &GlobPattern::get_nomatch_chars(void) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_get_nomatch_chars_454(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &GlobPattern::get_nomatch_chars(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNomatchChars", key_word_list));
        else
            (PyArg_Parse(args, ":getNomatchChars"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const GlobPattern*)local_this)->get_nomatch_chars();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNomatchChars(const GlobPattern this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_get_nomatch_chars_454_comment =
    "C++ Interface:\n"
    "getNomatchChars(const GlobPattern this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::get_nomatch_chars\n"
    "//       Access: Public\n"
    "//  Description: Returns the set of characters that are not matched by\n"
    "//               * or ?.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_get_nomatch_chars_454_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GlobPattern::matches(basic_string< char > const &candidate) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_matches_455(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GlobPattern::matches(basic_string< char > const &candidate) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"candidate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:matches", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:matches", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GlobPattern*)local_this)->matches(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matches(const GlobPattern this, string candidate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_matches_455_comment =
    "C++ Interface:\n"
    "matches(const GlobPattern this, string candidate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::matches\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the candidate string matches the\n"
    "//               pattern, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_matches_455_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GlobPattern::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_output_456(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void GlobPattern::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "GlobPattern.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const GlobPattern*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const GlobPattern this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_output_456_comment =
    "C++ Interface:\n"
    "output(const GlobPattern this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GlobPattern::output\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GlobPattern_output_456_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool GlobPattern::has_glob_characters(void) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_has_glob_characters_457(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool GlobPattern::has_glob_characters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasGlobCharacters", key_word_list));
        else
            (PyArg_Parse(args, ":hasGlobCharacters"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GlobPattern*)local_this)->has_glob_characters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGlobCharacters(const GlobPattern this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_has_glob_characters_457_comment =
    "C++ Interface:\n"
    "hasGlobCharacters(const GlobPattern this)\n"
    "\n"
    "";
#else
static const char * Dtool_GlobPattern_has_glob_characters_457_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > GlobPattern::get_const_prefix(void) const
 *******************************************************************/
static PyObject *Dtool_GlobPattern_get_const_prefix_458(PyObject *self, PyObject *args,PyObject *kwds) {
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > GlobPattern::get_const_prefix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConstPrefix", key_word_list));
        else
            (PyArg_Parse(args, ":getConstPrefix"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const GlobPattern*)local_this)->get_const_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConstPrefix(const GlobPattern this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GlobPattern_get_const_prefix_458_comment =
    "C++ Interface:\n"
    "getConstPrefix(const GlobPattern this)\n"
    "\n"
    "";
#else
static const char * Dtool_GlobPattern_get_const_prefix_458_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline GlobPattern::GlobPattern(GlobPattern const &copy)
 * inline GlobPattern::GlobPattern(basic_string< char > const &pattern)
 * inline GlobPattern::GlobPattern(basic_string< char > const &pattern = ((string())))
 *******************************************************************/
int  Dtool_Init_GlobPattern(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline GlobPattern::GlobPattern(basic_string< char > const &pattern = ((string())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":GlobPattern", key_word_list))
            {
                GlobPattern *return_value = new GlobPattern();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_GlobPattern,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline GlobPattern::GlobPattern(GlobPattern const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:GlobPattern", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:GlobPattern", &param0));
                if(!PyErr_Occurred())
                {
                    GlobPattern *param0_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GlobPattern, 0, "GlobPattern.GlobPattern", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        GlobPattern *return_value = new GlobPattern(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_GlobPattern,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline GlobPattern::GlobPattern(basic_string< char > const &pattern)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"pattern", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GlobPattern", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:GlobPattern", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    GlobPattern *return_value = new GlobPattern(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_GlobPattern,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GlobPattern() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GlobPattern()\n"
          "GlobPattern(const GlobPattern copy)\n"
          "GlobPattern(string pattern)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_GlobPattern(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GlobPattern)
    {
        printf("GlobPattern ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GlobPattern * local_this = (GlobPattern *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GlobPattern)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GlobPattern(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GlobPattern)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. IDecryptStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline IDecryptStream &IDecryptStream::open(istream *source, bool owns_source, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_IDecryptStream_open_463(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline IDecryptStream &IDecryptStream::open(istream *source, bool owns_source, basic_string< char > const &password)
            PyObject *param1;
            PyObject *param2;
            char *param3_str; int param3_len;
            static char * key_word_list[] = {(char *)"source", (char *)"owns_source", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:open", key_word_list, &param1, &param2, &param3_str, &param3_len))
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "IDecryptStream.open", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    IDecryptStream *return_value = &((local_this)->open(param1_this, (PyObject_IsTrue(param2)!=0), basic_string<char>(param3_str, param3_len)));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_IDecryptStream,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call IDecryptStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const IDecryptStream this, non-const Istream source, bool owns_source, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecryptStream_open_463_comment =
    "C++ Interface:\n"
    "open(non-const IDecryptStream this, non-const Istream source, bool owns_source, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecryptStream::open\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecryptStream_open_463_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IDecryptStream &IDecryptStream::close(void)
 *******************************************************************/
static PyObject *Dtool_IDecryptStream_close_464(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline IDecryptStream &IDecryptStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            IDecryptStream *return_value = &((local_this)->close());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_IDecryptStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call IDecryptStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const IDecryptStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecryptStream_close_464_comment =
    "C++ Interface:\n"
    "close(non-const IDecryptStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecryptStream::close\n"
    "//       Access: Published\n"
    "//  Description: Resets the EncryptStream to empty, but does not actually\n"
    "//               close the source istream unless owns_source was true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecryptStream_close_464_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &IDecryptStream::get_algorithm(void) const
 *******************************************************************/
static PyObject *Dtool_IDecryptStream_get_algorithm_465(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &IDecryptStream::get_algorithm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlgorithm", key_word_list));
        else
            (PyArg_Parse(args, ":getAlgorithm"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const IDecryptStream*)local_this)->get_algorithm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlgorithm(const IDecryptStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecryptStream_get_algorithm_465_comment =
    "C++ Interface:\n"
    "getAlgorithm(const IDecryptStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecryptStream::get_algorithm\n"
    "//       Access: Published\n"
    "//  Description: Returns the encryption algorithm that was read from\n"
    "//               the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecryptStream_get_algorithm_465_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int IDecryptStream::get_key_length(void) const
 *******************************************************************/
static PyObject *Dtool_IDecryptStream_get_key_length_466(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int IDecryptStream::get_key_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeyLength", key_word_list));
        else
            (PyArg_Parse(args, ":getKeyLength"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const IDecryptStream*)local_this)->get_key_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeyLength(const IDecryptStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecryptStream_get_key_length_466_comment =
    "C++ Interface:\n"
    "getKeyLength(const IDecryptStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecryptStream::get_key_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the encryption key length, in bits, that was\n"
    "//               read from the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecryptStream_get_key_length_466_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int IDecryptStream::get_iteration_count(void) const
 *******************************************************************/
static PyObject *Dtool_IDecryptStream_get_iteration_count_467(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int IDecryptStream::get_iteration_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIterationCount", key_word_list));
        else
            (PyArg_Parse(args, ":getIterationCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const IDecryptStream*)local_this)->get_iteration_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIterationCount(const IDecryptStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecryptStream_get_iteration_count_467_comment =
    "C++ Interface:\n"
    "getIterationCount(const IDecryptStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecryptStream::get_iteration_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the value that was was read from the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecryptStream_get_iteration_count_467_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IDecryptStream::IDecryptStream(void)
 * inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, basic_string< char > const &password)
 *******************************************************************/
int  Dtool_Init_IDecryptStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline IDecryptStream::IDecryptStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":IDecryptStream", key_word_list))
            {
                IDecryptStream *return_value = new IDecryptStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_IDecryptStream,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, basic_string< char > const &password)
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"source", (char *)"owns_source", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:IDecryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "IDecryptStream.IDecryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        IDecryptStream *return_value = new IDecryptStream(param0_this, (PyObject_IsTrue(param1)!=0), basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_IDecryptStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "IDecryptStream() takes 0 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "IDecryptStream()\n"
          "IDecryptStream(non-const Istream source, bool owns_source, string password)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_IDecryptStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_IDecryptStream)
    {
        printf("IDecryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    IDecryptStream * local_this = (IDecryptStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_IDecryptStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_IDecryptStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_IDecryptStream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (IDecryptStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. IFileStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void IFileStream::open(char const *filename, ios_base::openmode mode)
 * inline void IFileStream::open(char const *filename, ios_base::openmode mode = (ios::in))
 *******************************************************************/
static PyObject *Dtool_IFileStream_open_472(PyObject *self, PyObject *args,PyObject *kwds) {
    IFileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IFileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void IFileStream::open(char const *filename, ios_base::openmode mode = (ios::in))
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:open", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:open", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->open((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call IFileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void IFileStream::open(char const *filename, ios_base::openmode mode)
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:open", key_word_list, &param1, &param2))
            {
                (local_this)->open((char const *)param1, (ios_base::openmode)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call IFileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "open() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "open(non-const IFileStream this, string filename)\n"
          "open(non-const IFileStream this, string filename, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IFileStream_open_472_comment =
    "C++ Interface:\n"
    "open(non-const IFileStream this, string filename)\n"
    "open(non-const IFileStream this, string filename, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IFileStream::open\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IFileStream_open_472_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void IFileStream::close(void)
 *******************************************************************/
static PyObject *Dtool_IFileStream_close_473(PyObject *self, PyObject *args,PyObject *kwds) {
    IFileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IFileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void IFileStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call IFileStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const IFileStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IFileStream_close_473_comment =
    "C++ Interface:\n"
    "close(non-const IFileStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IFileStream::close\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IFileStream_close_473_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IFileStream::IFileStream(void)
 * inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
 * inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode = (ios::in))
 *******************************************************************/
int  Dtool_Init_IFileStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline IFileStream::IFileStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":IFileStream", key_word_list))
            {
                IFileStream *return_value = new IFileStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_IFileStream,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode = (ios::in))
            char *param0;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:IFileStream", key_word_list, &param0));
            else
                (PyArg_Parse(args, "s:IFileStream", &param0));
            if(!PyErr_Occurred())
            {
                IFileStream *return_value = new IFileStream((char const *)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_IFileStream,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
            char *param0;
            int param1;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:IFileStream", key_word_list, &param0, &param1))
            {
                IFileStream *return_value = new IFileStream((char const *)param0, (ios_base::openmode)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_IFileStream,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "IFileStream() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "IFileStream()\n"
          "IFileStream(string filename)\n"
          "IFileStream(string filename, int mode)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_IFileStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_IFileStream)
    {
        printf("IFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    IFileStream * local_this = (IFileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_IFileStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_IFileStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_IFileStream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (IFileStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. IStreamWrapper 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline istream *IStreamWrapper::get_istream(void) const
 *******************************************************************/
static PyObject *Dtool_IStreamWrapper_get_istream_482(PyObject *self, PyObject *args,PyObject *kwds) {
    IStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline istream *IStreamWrapper::get_istream(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIstream", key_word_list));
        else
            (PyArg_Parse(args, ":getIstream"));
        if(!PyErr_Occurred())
        {
            istream *return_value = ((const IStreamWrapper*)local_this)->get_istream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIstream(const IStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IStreamWrapper_get_istream_482_comment =
    "C++ Interface:\n"
    "getIstream(const IStreamWrapper this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IStreamWrapper::get_istream\n"
    "//       Access: Published\n"
    "//  Description: Returns the istream this object is wrapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IStreamWrapper_get_istream_482_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
 *******************************************************************/
static PyObject *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_479(PyObject *self, PyObject *args,PyObject *kwds) {
    IStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToStreamWrapperBase", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToStreamWrapperBase"));
        if(!PyErr_Occurred())
        {
            StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_StreamWrapperBase,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call IStreamWrapper.upcastToStreamWrapperBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToStreamWrapperBase(non-const IStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_479_comment =
    "C++ Interface:\n"
    "upcastToStreamWrapperBase(non-const IStreamWrapper this)\n"
    "\n"
    "upcast from IStreamWrapper to StreamWrapperBase\n"
    "";
#else
static const char * Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_479_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StreamWrapper *IStreamWrapper::downcast_to_StreamWrapper(void)
 *******************************************************************/
static PyObject *Dtool_IStreamWrapper_downcast_to_StreamWrapper_660(PyObject *self, PyObject *args,PyObject *kwds) {
    IStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-StreamWrapper *IStreamWrapper::downcast_to_StreamWrapper(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToStreamWrapper", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToStreamWrapper"));
        if(!PyErr_Occurred())
        {
            StreamWrapper *return_value = (StreamWrapper *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_StreamWrapper,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call IStreamWrapper.downcastToStreamWrapper() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToStreamWrapper(non-const IStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IStreamWrapper_downcast_to_StreamWrapper_660_comment =
    "C++ Interface:\n"
    "downcastToStreamWrapper(non-const IStreamWrapper this)\n"
    "\n"
    "downcast from IStreamWrapper to StreamWrapper\n"
    "";
#else
static const char * Dtool_IStreamWrapper_downcast_to_StreamWrapper_660_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IStreamWrapper::IStreamWrapper(istream &stream)
 *******************************************************************/
int  Dtool_Init_IStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline IStreamWrapper::IStreamWrapper(istream &stream)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:IStreamWrapper", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:IStreamWrapper", &param0));
            if(!PyErr_Occurred())
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "IStreamWrapper.IStreamWrapper", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    IStreamWrapper *return_value = new IStreamWrapper(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_IStreamWrapper,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "IStreamWrapper(non-const Istream stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_IStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_IStreamWrapper)
    {
        printf("IStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    IStreamWrapper * local_this = (IStreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_IStreamWrapper)
        return local_this;
    if(requested_type == &Dtool_StreamWrapperBase)
        return ( StreamWrapperBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_IStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_IStreamWrapper)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StreamWrapperBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void StreamWrapperBase::acquire(void)
 *******************************************************************/
static PyObject *Dtool_StreamWrapperBase_acquire_476(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWrapperBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWrapperBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWrapperBase::acquire(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
        else
            (PyArg_Parse(args, ":acquire"));
        if(!PyErr_Occurred())
        {
            (local_this)->acquire();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWrapperBase.acquire() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "acquire(non-const StreamWrapperBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWrapperBase_acquire_476_comment =
    "C++ Interface:\n"
    "acquire(non-const StreamWrapperBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWrapperBase::acquire\n"
    "//       Access: Published\n"
    "//  Description: Acquires the internal lock.  \n"
    "//\n"
    "//               User code should call this to take temporary\n"
    "//               possession of the stream and perform direct I/O\n"
    "//               operations on it, for instance to make several\n"
    "//               sequential atomic reads.  You may not call any of the\n"
    "//               StreamWrapper methods while the lock is held, other\n"
    "//               than release().\n"
    "//\n"
    "//               Use with extreme caution!  This is a very low-level,\n"
    "//               non-recursive lock.  You must call acquire() only\n"
    "//               once, and you must later call release() exactly once.\n"
    "//               Failing to do so may result in a hard deadlock with\n"
    "//               no available debugging features.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWrapperBase_acquire_476_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWrapperBase::release(void)
 *******************************************************************/
static PyObject *Dtool_StreamWrapperBase_release_477(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWrapperBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWrapperBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWrapperBase::release(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            (local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWrapperBase.release() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(non-const StreamWrapperBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWrapperBase_release_477_comment =
    "C++ Interface:\n"
    "release(non-const StreamWrapperBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWrapperBase::release\n"
    "//       Access: Published\n"
    "//  Description: Releases the internal lock.  Must be called exactly\n"
    "//               once following a call to acquire().  See the cautions\n"
    "//               with acquire().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWrapperBase_release_477_comment = NULL;
#endif

int  Dtool_Init_StreamWrapperBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (StreamWrapperBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_StreamWrapperBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StreamWrapperBase)
    {
        printf("StreamWrapperBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StreamWrapperBase * local_this = (StreamWrapperBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StreamWrapperBase)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StreamWrapperBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StreamWrapperBase)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NeverFreeMemory 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline unsigned int NeverFreeMemory::get_total_alloc(void)
 *******************************************************************/
static PyObject *Dtool_NeverFreeMemory_get_total_alloc_484(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline unsigned int NeverFreeMemory::get_total_alloc(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalAlloc", key_word_list))
        {
            unsigned int return_value = NeverFreeMemory::get_total_alloc();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalAlloc()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NeverFreeMemory_get_total_alloc_484_comment =
    "C++ Interface:\n"
    "getTotalAlloc()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NeverFreeMemory::get_total_alloc\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the total number of bytes consumed by all the\n"
    "//               pages allocated internally by this object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NeverFreeMemory_get_total_alloc_484_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline unsigned int NeverFreeMemory::get_total_used(void)
 *******************************************************************/
static PyObject *Dtool_NeverFreeMemory_get_total_used_485(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline unsigned int NeverFreeMemory::get_total_used(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalUsed", key_word_list))
        {
            unsigned int return_value = NeverFreeMemory::get_total_used();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalUsed()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NeverFreeMemory_get_total_used_485_comment =
    "C++ Interface:\n"
    "getTotalUsed()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NeverFreeMemory::get_total_used\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the total number of bytes requested by the\n"
    "//               application in calls to NeverFreeMemory::alloc().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NeverFreeMemory_get_total_used_485_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline unsigned int NeverFreeMemory::get_total_unused(void)
 *******************************************************************/
static PyObject *Dtool_NeverFreeMemory_get_total_unused_486(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline unsigned int NeverFreeMemory::get_total_unused(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalUnused", key_word_list))
        {
            unsigned int return_value = NeverFreeMemory::get_total_unused();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalUnused()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NeverFreeMemory_get_total_unused_486_comment =
    "C++ Interface:\n"
    "getTotalUnused()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NeverFreeMemory::get_total_unused\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the difference between get_total_alloc() and\n"
    "//               get_total_used().  This represents bytes in allocated\n"
    "//               pages that have not (yet) been used by the\n"
    "//               application.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NeverFreeMemory_get_total_unused_486_comment = NULL;
#endif

int  Dtool_Init_NeverFreeMemory(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NeverFreeMemory)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NeverFreeMemory(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NeverFreeMemory)
    {
        printf("NeverFreeMemory ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NeverFreeMemory * local_this = (NeverFreeMemory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NeverFreeMemory)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NeverFreeMemory(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NeverFreeMemory)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Notify 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void Notify::set_ostream_ptr(ostream *ostream_ptr, bool delete_later)
 *******************************************************************/
static PyObject *Dtool_Notify_set_ostream_ptr_491(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Notify::set_ostream_ptr(ostream *ostream_ptr, bool delete_later)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"ostream_ptr", (char *)"delete_later", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setOstreamPtr", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Notify.setOstreamPtr", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_ostream_ptr(param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Notify.setOstreamPtr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOstreamPtr(non-const Notify this, non-const Ostream ostream_ptr, bool delete_later)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_set_ostream_ptr_491_comment =
    "C++ Interface:\n"
    "setOstreamPtr(non-const Notify this, non-const Ostream ostream_ptr, bool delete_later)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_set_ostream_ptr_491_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ostream *Notify::get_ostream_ptr(void) const
 *******************************************************************/
static PyObject *Dtool_Notify_get_ostream_ptr_492(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ostream *Notify::get_ostream_ptr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOstreamPtr", key_word_list));
        else
            (PyArg_Parse(args, ":getOstreamPtr"));
        if(!PyErr_Occurred())
        {
            ostream *return_value = ((const Notify*)local_this)->get_ostream_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOstreamPtr(const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_get_ostream_ptr_492_comment =
    "C++ Interface:\n"
    "getOstreamPtr(const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_get_ostream_ptr_492_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Notify::clear_assert_handler(void)
 *******************************************************************/
static PyObject *Dtool_Notify_clear_assert_handler_494(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Notify::clear_assert_handler(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAssertHandler", key_word_list));
        else
            (PyArg_Parse(args, ":clearAssertHandler"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_assert_handler();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Notify.clearAssertHandler() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAssertHandler(non-const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_clear_assert_handler_494_comment =
    "C++ Interface:\n"
    "clearAssertHandler(non-const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_clear_assert_handler_494_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Notify::has_assert_handler(void) const
 *******************************************************************/
static PyObject *Dtool_Notify_has_assert_handler_495(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Notify::has_assert_handler(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAssertHandler", key_word_list));
        else
            (PyArg_Parse(args, ":hasAssertHandler"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Notify*)local_this)->has_assert_handler();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAssertHandler(const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_has_assert_handler_495_comment =
    "C++ Interface:\n"
    "hasAssertHandler(const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_has_assert_handler_495_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Notify::has_assert_failed(void) const
 *******************************************************************/
static PyObject *Dtool_Notify_has_assert_failed_497(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Notify::has_assert_failed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAssertFailed", key_word_list));
        else
            (PyArg_Parse(args, ":hasAssertFailed"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Notify*)local_this)->has_assert_failed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAssertFailed(const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_has_assert_failed_497_comment =
    "C++ Interface:\n"
    "hasAssertFailed(const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_has_assert_failed_497_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &Notify::get_assert_error_message(void) const
 *******************************************************************/
static PyObject *Dtool_Notify_get_assert_error_message_498(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &Notify::get_assert_error_message(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAssertErrorMessage", key_word_list));
        else
            (PyArg_Parse(args, ":getAssertErrorMessage"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Notify*)local_this)->get_assert_error_message();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAssertErrorMessage(const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_get_assert_error_message_498_comment =
    "C++ Interface:\n"
    "getAssertErrorMessage(const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_get_assert_error_message_498_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Notify::clear_assert_failed(void)
 *******************************************************************/
static PyObject *Dtool_Notify_clear_assert_failed_499(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Notify::clear_assert_failed(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAssertFailed", key_word_list));
        else
            (PyArg_Parse(args, ":clearAssertFailed"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_assert_failed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Notify.clearAssertFailed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAssertFailed(non-const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_clear_assert_failed_499_comment =
    "C++ Interface:\n"
    "clearAssertFailed(non-const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_clear_assert_failed_499_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NotifyCategory *Notify::get_top_category(void)
 *******************************************************************/
static PyObject *Dtool_Notify_get_top_category_500(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NotifyCategory *Notify::get_top_category(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTopCategory", key_word_list));
        else
            (PyArg_Parse(args, ":getTopCategory"));
        if(!PyErr_Occurred())
        {
            NotifyCategory *return_value = (local_this)->get_top_category();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Notify.getTopCategory() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTopCategory(non-const Notify this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_get_top_category_500_comment =
    "C++ Interface:\n"
    "getTopCategory(non-const Notify this)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_get_top_category_500_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NotifyCategory *Notify::get_category(basic_string< char > const &fullname)
 * NotifyCategory *Notify::get_category(basic_string< char > const &basename, NotifyCategory *parent_category)
 * NotifyCategory *Notify::get_category(basic_string< char > const &basename, basic_string< char > const &parent_fullname)
 *******************************************************************/
static PyObject *Dtool_Notify_get_category_501(PyObject *self, PyObject *args,PyObject *kwds) {
    Notify * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Notify,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-NotifyCategory *Notify::get_category(basic_string< char > const &fullname)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"fullname", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getCategory", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:getCategory", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                NotifyCategory *return_value = (local_this)->get_category(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Notify.getCategory() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 NotifyCategory *Notify::get_category(basic_string< char > const &basename, NotifyCategory *parent_category)
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"basename", (char *)"parent_category", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:getCategory", key_word_list, &param1_str, &param1_len, &param2))
                {
                    NotifyCategory *param2_this = (NotifyCategory *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NotifyCategory, 2, "Notify.getCategory", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        NotifyCategory *return_value = (local_this)->get_category(basic_string<char>(param1_str, param1_len), param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 NotifyCategory *Notify::get_category(basic_string< char > const &basename, basic_string< char > const &parent_fullname)
                char *param1_str; int param1_len;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"basename", (char *)"parent_fullname", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:getCategory", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
                {
                    NotifyCategory *return_value = (local_this)->get_category(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCategory() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCategory(non-const Notify this, string fullname)\n"
          "getCategory(non-const Notify this, string basename, non-const NotifyCategory parent_category)\n"
          "getCategory(non-const Notify this, string basename, string parent_fullname)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_get_category_501_comment =
    "C++ Interface:\n"
    "getCategory(non-const Notify this, string fullname)\n"
    "getCategory(non-const Notify this, string basename, non-const NotifyCategory parent_category)\n"
    "getCategory(non-const Notify this, string basename, string parent_fullname)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_get_category_501_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ostream &Notify::out(void)
 *******************************************************************/
static PyObject *Dtool_Notify_out_502(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ostream &Notify::out(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":out", key_word_list))
        {
            ostream *return_value = &(Notify::out());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "out()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_out_502_comment =
    "C++ Interface:\n"
    "out()\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_out_502_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static ostream &Notify::null(void)
 *******************************************************************/
static PyObject *Dtool_Notify_null_503(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static ostream &Notify::null(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":null", key_word_list))
        {
            ostream *return_value = &(Notify::null());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "null()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_null_503_comment =
    "C++ Interface:\n"
    "null()\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_null_503_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void Notify::write_string(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_Notify_write_string_504(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void Notify::write_string(basic_string< char > const &str)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:writeString", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:writeString", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Notify::write_string(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeString(string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_write_string_504_comment =
    "C++ Interface:\n"
    "writeString(string str)\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_write_string_504_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Notify *Notify::ptr(void)
 *******************************************************************/
static PyObject *Dtool_Notify_ptr_505(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Notify *Notify::ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ptr", key_word_list))
        {
            Notify *return_value = Notify::ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Notify,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ptr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Notify_ptr_505_comment =
    "C++ Interface:\n"
    "ptr()\n"
    "\n"
    "";
#else
static const char * Dtool_Notify_ptr_505_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Notify::Notify(void)
 *******************************************************************/
int  Dtool_Init_Notify(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Notify::Notify(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Notify", key_word_list))
        {
            Notify *return_value = new Notify();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Notify,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Notify()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Notify(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Notify)
    {
        printf("Notify ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Notify * local_this = (Notify *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Notify)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Notify(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Notify)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NotifyCategory 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > NotifyCategory::get_fullname(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_get_fullname_511(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > NotifyCategory::get_fullname(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFullname", key_word_list));
        else
            (PyArg_Parse(args, ":getFullname"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const NotifyCategory*)local_this)->get_fullname();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFullname(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_get_fullname_511_comment =
    "C++ Interface:\n"
    "getFullname(const NotifyCategory this)\n"
    "\n"
    "// Filename: notifyCategory.I\n"
    "// Created by:  drose (29Feb00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::get_fullname\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_get_fullname_511_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > NotifyCategory::get_basename(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_get_basename_512(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > NotifyCategory::get_basename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBasename", key_word_list));
        else
            (PyArg_Parse(args, ":getBasename"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const NotifyCategory*)local_this)->get_basename();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasename(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_get_basename_512_comment =
    "C++ Interface:\n"
    "getBasename(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::get_basename\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_get_basename_512_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NotifySeverity NotifyCategory::get_severity(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_get_severity_513(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NotifySeverity NotifyCategory::get_severity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSeverity", key_word_list));
        else
            (PyArg_Parse(args, ":getSeverity"));
        if(!PyErr_Occurred())
        {
            NotifySeverity return_value = ((const NotifyCategory*)local_this)->get_severity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSeverity(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_get_severity_513_comment =
    "C++ Interface:\n"
    "getSeverity(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::get_severity\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_get_severity_513_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NotifyCategory::set_severity(NotifySeverity severity)
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_set_severity_514(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NotifyCategory::set_severity(NotifySeverity severity)
        int param1;
        static char * key_word_list[] = {(char *)"severity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSeverity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSeverity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_severity((NotifySeverity)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NotifyCategory.setSeverity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSeverity(non-const NotifyCategory this, int severity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_set_severity_514_comment =
    "C++ Interface:\n"
    "setSeverity(non-const NotifyCategory this, int severity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::set_severity\n"
    "//       Access: Public\n"
    "//  Description: Sets the severity level of messages that will be\n"
    "//               reported from this Category.  This allows any message\n"
    "//               of this severity level or higher.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_set_severity_514_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_on(NotifySeverity severity) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_on_515(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_on(NotifySeverity severity) const
        int param1;
        static char * key_word_list[] = {(char *)"severity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isOn", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isOn", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_on((NotifySeverity)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOn(const NotifyCategory this, int severity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_on_515_comment =
    "C++ Interface:\n"
    "isOn(const NotifyCategory this, int severity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_on\n"
    "//       Access: Public\n"
    "//  Description: Returns true if messages of the indicated severity\n"
    "//               level ought to be reported for this Category.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_on_515_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_spam(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_spam_516(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_spam(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSpam", key_word_list));
        else
            (PyArg_Parse(args, ":isSpam"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_spam();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSpam(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_spam_516_comment =
    "C++ Interface:\n"
    "isSpam(const NotifyCategory this)\n"
    "\n"
    "// When NOTIFY_DEBUG is not defined, the categories will never be\n"
    "// set to \"spam\" or \"debug\" severities, and these methods are\n"
    "// redefined to be static to make it more obvious to the compiler.\n"
    "// However, we still want to present a consistent interface to our\n"
    "// scripting language, so during the interrogate pass (that is, when\n"
    "// CPPPARSER is defined), we still pretend they're nonstatic.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_spam\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_spam).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_spam_516_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_debug(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_debug_517(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_debug(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDebug", key_word_list));
        else
            (PyArg_Parse(args, ":isDebug"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_debug();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDebug(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_debug_517_comment =
    "C++ Interface:\n"
    "isDebug(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_debug\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_debug).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_debug_517_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_info(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_info_518(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_info(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isInfo", key_word_list));
        else
            (PyArg_Parse(args, ":isInfo"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_info();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isInfo(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_info_518_comment =
    "C++ Interface:\n"
    "isInfo(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_info\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_info).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_info_518_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_warning(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_warning_519(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_warning(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWarning", key_word_list));
        else
            (PyArg_Parse(args, ":isWarning"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_warning();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWarning(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_warning_519_comment =
    "C++ Interface:\n"
    "isWarning(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_warning\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_warning).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_warning_519_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_error(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_error_520(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_error_520_comment =
    "C++ Interface:\n"
    "isError(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_error\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_error).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_error_520_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NotifyCategory::is_fatal(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_is_fatal_521(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NotifyCategory::is_fatal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isFatal", key_word_list));
        else
            (PyArg_Parse(args, ":isFatal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NotifyCategory*)local_this)->is_fatal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFatal(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_is_fatal_521_comment =
    "C++ Interface:\n"
    "isFatal(const NotifyCategory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::is_fatal\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write is_on(NS_fatal).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_is_fatal_521_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ostream &NotifyCategory::out(NotifySeverity severity, bool prefix) const
 * ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_out_522(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = (1)) const
            int param1;
            static char * key_word_list[] = {(char *)"severity", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:out", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:out", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->out((NotifySeverity)param1));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-ostream &NotifyCategory::out(NotifySeverity severity, bool prefix) const
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"severity", (char *)"prefix", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:out", key_word_list, &param1, &param2))
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->out((NotifySeverity)param1, (PyObject_IsTrue(param2)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "out() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "out(const NotifyCategory this, int severity)\n"
          "out(const NotifyCategory this, int severity, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_out_522_comment =
    "C++ Interface:\n"
    "out(const NotifyCategory this, int severity)\n"
    "out(const NotifyCategory this, int severity, bool prefix)\n"
    "\n"
    "";
#else
static const char * Dtool_NotifyCategory_out_522_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::spam(bool prefix) const
 * inline ostream &NotifyCategory::spam(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_spam_523(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::spam(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":spam", key_word_list));
            else
                (PyArg_Parse(args, ":spam"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->spam());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::spam(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:spam", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:spam", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->spam((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "spam() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "spam(const NotifyCategory this)\n"
          "spam(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_spam_523_comment =
    "C++ Interface:\n"
    "spam(const NotifyCategory this)\n"
    "spam(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::spam\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_spam).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_spam_523_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::debug(bool prefix) const
 * inline ostream &NotifyCategory::debug(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_debug_524(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::debug(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":debug", key_word_list));
            else
                (PyArg_Parse(args, ":debug"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->debug());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::debug(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:debug", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:debug", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->debug((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "debug() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "debug(const NotifyCategory this)\n"
          "debug(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_debug_524_comment =
    "C++ Interface:\n"
    "debug(const NotifyCategory this)\n"
    "debug(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::debug\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_debug).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_debug_524_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::info(bool prefix) const
 * inline ostream &NotifyCategory::info(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_info_525(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::info(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":info", key_word_list));
            else
                (PyArg_Parse(args, ":info"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->info());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::info(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:info", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:info", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->info((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "info() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "info(const NotifyCategory this)\n"
          "info(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_info_525_comment =
    "C++ Interface:\n"
    "info(const NotifyCategory this)\n"
    "info(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::info\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_info).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_info_525_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::warning(bool prefix) const
 * inline ostream &NotifyCategory::warning(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_warning_526(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::warning(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":warning", key_word_list));
            else
                (PyArg_Parse(args, ":warning"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->warning());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::warning(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:warning", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:warning", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->warning((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "warning() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "warning(const NotifyCategory this)\n"
          "warning(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_warning_526_comment =
    "C++ Interface:\n"
    "warning(const NotifyCategory this)\n"
    "warning(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::warning\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_warning).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_warning_526_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::error(bool prefix) const
 * inline ostream &NotifyCategory::error(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_error_527(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::error(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":error", key_word_list));
            else
                (PyArg_Parse(args, ":error"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->error());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::error(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:error", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:error", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->error((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "error() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "error(const NotifyCategory this)\n"
          "error(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_error_527_comment =
    "C++ Interface:\n"
    "error(const NotifyCategory this)\n"
    "error(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::error\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_error).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_error_527_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream &NotifyCategory::fatal(bool prefix) const
 * inline ostream &NotifyCategory::fatal(bool prefix = (1)) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_fatal_528(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ostream &NotifyCategory::fatal(bool prefix = (1)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":fatal", key_word_list));
            else
                (PyArg_Parse(args, ":fatal"));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->fatal());
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ostream &NotifyCategory::fatal(bool prefix) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"prefix", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:fatal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:fatal", &param1));
            if(!PyErr_Occurred())
            {
                ostream *return_value = &(((const NotifyCategory*)local_this)->fatal((PyObject_IsTrue(param1)!=0)));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "fatal() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "fatal(const NotifyCategory this)\n"
          "fatal(const NotifyCategory this, bool prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_fatal_528_comment =
    "C++ Interface:\n"
    "fatal(const NotifyCategory this)\n"
    "fatal(const NotifyCategory this, bool prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NotifyCategory::fatal\n"
    "//       Access: Public\n"
    "//  Description: A shorthand way to write out(NS_fatal).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NotifyCategory_fatal_528_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NotifyCategory::get_num_children(void) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_get_num_children_529(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int NotifyCategory::get_num_children(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChildren", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChildren"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NotifyCategory*)local_this)->get_num_children();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChildren(const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_get_num_children_529_comment =
    "C++ Interface:\n"
    "getNumChildren(const NotifyCategory this)\n"
    "\n"
    "";
#else
static const char * Dtool_NotifyCategory_get_num_children_529_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NotifyCategory *NotifyCategory::get_child(int i) const
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_get_child_530(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NotifyCategory *NotifyCategory::get_child(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getChild", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getChild", &param1));
        if(!PyErr_Occurred())
        {
            NotifyCategory *return_value = ((const NotifyCategory*)local_this)->get_child((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NotifyCategory,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChild(const NotifyCategory this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_get_child_530_comment =
    "C++ Interface:\n"
    "getChild(const NotifyCategory this, int i)\n"
    "\n"
    "";
#else
static const char * Dtool_NotifyCategory_get_child_530_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void NotifyCategory::set_server_delta(long int delta)
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_set_server_delta_531(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void NotifyCategory::set_server_delta(long int delta)
        int param0;
        static char * key_word_list[] = {(char *)"delta", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setServerDelta", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:setServerDelta", &param0));
        if(!PyErr_Occurred())
        {
            NotifyCategory::set_server_delta((long int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setServerDelta(int delta)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_set_server_delta_531_comment =
    "C++ Interface:\n"
    "setServerDelta(int delta)\n"
    "\n"
    "";
#else
static const char * Dtool_NotifyCategory_set_server_delta_531_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
 *******************************************************************/
static PyObject *Dtool_NotifyCategory_upcast_to_ConfigFlags_509(PyObject *self, PyObject *args,PyObject *kwds) {
    NotifyCategory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NotifyCategory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConfigFlags", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConfigFlags"));
        if(!PyErr_Occurred())
        {
            ConfigFlags *return_value = (ConfigFlags *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigFlags,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NotifyCategory.upcastToConfigFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConfigFlags(non-const NotifyCategory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NotifyCategory_upcast_to_ConfigFlags_509_comment =
    "C++ Interface:\n"
    "upcastToConfigFlags(non-const NotifyCategory this)\n"
    "\n"
    "upcast from NotifyCategory to ConfigFlags\n"
    "";
#else
static const char * Dtool_NotifyCategory_upcast_to_ConfigFlags_509_comment = NULL;
#endif

int  Dtool_Init_NotifyCategory(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NotifyCategory)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NotifyCategory(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NotifyCategory)
    {
        printf("NotifyCategory ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NotifyCategory * local_this = (NotifyCategory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NotifyCategory)
        return local_this;
    if(requested_type == &Dtool_ConfigFlags)
        return ( ConfigFlags *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NotifyCategory(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NotifyCategory)
        return from_this;
    if(from_type == &Dtool_ConfigFlags)
    {
          ConfigFlags* other_this = (ConfigFlags*)from_this;
          return (NotifyCategory*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OEncryptStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline OEncryptStream &OEncryptStream::open(ostream *dest, bool owns_dest, basic_string< char > const &password)
 *******************************************************************/
static PyObject *Dtool_OEncryptStream_open_536(PyObject *self, PyObject *args,PyObject *kwds) {
    OEncryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OEncryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline OEncryptStream &OEncryptStream::open(ostream *dest, bool owns_dest, basic_string< char > const &password)
            PyObject *param1;
            PyObject *param2;
            char *param3_str; int param3_len;
            static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", (char *)"password", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:open", key_word_list, &param1, &param2, &param3_str, &param3_len))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OEncryptStream.open", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    OEncryptStream *return_value = &((local_this)->open(param1_this, (PyObject_IsTrue(param2)!=0), basic_string<char>(param3_str, param3_len)));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_OEncryptStream,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OEncryptStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const OEncryptStream this, non-const Ostream dest, bool owns_dest, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OEncryptStream_open_536_comment =
    "C++ Interface:\n"
    "open(non-const OEncryptStream this, non-const Ostream dest, bool owns_dest, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OEncryptStream::open\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OEncryptStream_open_536_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OEncryptStream &OEncryptStream::close(void)
 *******************************************************************/
static PyObject *Dtool_OEncryptStream_close_537(PyObject *self, PyObject *args,PyObject *kwds) {
    OEncryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OEncryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline OEncryptStream &OEncryptStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            OEncryptStream *return_value = &((local_this)->close());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_OEncryptStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OEncryptStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const OEncryptStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OEncryptStream_close_537_comment =
    "C++ Interface:\n"
    "close(non-const OEncryptStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OEncryptStream::close\n"
    "//       Access: Published\n"
    "//  Description: Resets the EncryptStream to empty, but does not actually\n"
    "//               close the dest ostream unless owns_dest was true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OEncryptStream_close_537_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OEncryptStream::set_algorithm(basic_string< char > const &algorithm)
 *******************************************************************/
static PyObject *Dtool_OEncryptStream_set_algorithm_538(PyObject *self, PyObject *args,PyObject *kwds) {
    OEncryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OEncryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OEncryptStream::set_algorithm(basic_string< char > const &algorithm)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"algorithm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setAlgorithm", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setAlgorithm", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_algorithm(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OEncryptStream.setAlgorithm() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlgorithm(non-const OEncryptStream this, string algorithm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OEncryptStream_set_algorithm_538_comment =
    "C++ Interface:\n"
    "setAlgorithm(non-const OEncryptStream this, string algorithm)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OEncryptStream::set_algorithm\n"
    "//       Access: Published\n"
    "//  Description: Specifies the encryption algorithm that should be\n"
    "//               used for future calls to open().  The default\n"
    "//               is whatever is specified by the encryption-algorithm\n"
    "//               config variable.  The complete set of available\n"
    "//               algorithms is defined by the current version of\n"
    "//               OpenSSL.\n"
    "//\n"
    "//               If an invalid algorithm is specified, there is no\n"
    "//               immediate error return code, but open() will\n"
    "//               fail.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OEncryptStream_set_algorithm_538_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OEncryptStream::set_key_length(int key_length)
 *******************************************************************/
static PyObject *Dtool_OEncryptStream_set_key_length_539(PyObject *self, PyObject *args,PyObject *kwds) {
    OEncryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OEncryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OEncryptStream::set_key_length(int key_length)
        int param1;
        static char * key_word_list[] = {(char *)"key_length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setKeyLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setKeyLength", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_key_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OEncryptStream.setKeyLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKeyLength(non-const OEncryptStream this, int key_length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OEncryptStream_set_key_length_539_comment =
    "C++ Interface:\n"
    "setKeyLength(non-const OEncryptStream this, int key_length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OEncryptStream::set_key_length\n"
    "//       Access: Published\n"
    "//  Description: Specifies the length of the key, in bits, that should\n"
    "//               be used to encrypt the stream in future calls to\n"
    "//               open().  The default is whatever is specified\n"
    "//               by the encryption-key-length config variable.  \n"
    "//\n"
    "//               If an invalid key_length for the chosen algorithm is\n"
    "//               specified, there is no immediate error return code,\n"
    "//               but open() will fail.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OEncryptStream_set_key_length_539_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OEncryptStream::set_iteration_count(int iteration_count)
 *******************************************************************/
static PyObject *Dtool_OEncryptStream_set_iteration_count_540(PyObject *self, PyObject *args,PyObject *kwds) {
    OEncryptStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OEncryptStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OEncryptStream::set_iteration_count(int iteration_count)
        int param1;
        static char * key_word_list[] = {(char *)"iteration_count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setIterationCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setIterationCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_iteration_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OEncryptStream.setIterationCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIterationCount(non-const OEncryptStream this, int iteration_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OEncryptStream_set_iteration_count_540_comment =
    "C++ Interface:\n"
    "setIterationCount(non-const OEncryptStream this, int iteration_count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OEncryptStream::set_iteration_count\n"
    "//       Access: Published\n"
    "//  Description: Specifies the number of times to repeatedly hash the\n"
    "//               key before writing it to the stream in future calls\n"
    "//               to open().  Its purpose is to make it\n"
    "//               computationally more expensive for an attacker to\n"
    "//               search the key space exhaustively.  This should be a\n"
    "//               multiple of 1,000 and should not exceed about 65\n"
    "//               million; the value 0 indicates just one application\n"
    "//               of the hashing algorithm.\n"
    "//\n"
    "//               The default is whatever is specified by the\n"
    "//               encryption-iteration-count config variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OEncryptStream_set_iteration_count_540_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OEncryptStream::OEncryptStream(void)
 * inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, basic_string< char > const &password)
 *******************************************************************/
int  Dtool_Init_OEncryptStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline OEncryptStream::OEncryptStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OEncryptStream", key_word_list))
            {
                OEncryptStream *return_value = new OEncryptStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OEncryptStream,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, basic_string< char > const &password)
                PyObject *param0;
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:OEncryptStream", key_word_list, &param0, &param1, &param2_str, &param2_len))
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "OEncryptStream.OEncryptStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OEncryptStream *return_value = new OEncryptStream(param0_this, (PyObject_IsTrue(param1)!=0), basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OEncryptStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OEncryptStream() takes 0 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OEncryptStream()\n"
          "OEncryptStream(non-const Ostream dest, bool owns_dest, string password)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OEncryptStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OEncryptStream)
    {
        printf("OEncryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OEncryptStream * local_this = (OEncryptStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OEncryptStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OEncryptStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OEncryptStream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (OEncryptStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OFileStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OFileStream::open(char const *filename, ios_base::openmode mode)
 * inline void OFileStream::open(char const *filename, ios_base::openmode mode = (ios::out))
 *******************************************************************/
static PyObject *Dtool_OFileStream_open_545(PyObject *self, PyObject *args,PyObject *kwds) {
    OFileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OFileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OFileStream::open(char const *filename, ios_base::openmode mode = (ios::out))
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:open", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:open", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->open((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OFileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OFileStream::open(char const *filename, ios_base::openmode mode)
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:open", key_word_list, &param1, &param2))
            {
                (local_this)->open((char const *)param1, (ios_base::openmode)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OFileStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "open() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "open(non-const OFileStream this, string filename)\n"
          "open(non-const OFileStream this, string filename, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OFileStream_open_545_comment =
    "C++ Interface:\n"
    "open(non-const OFileStream this, string filename)\n"
    "open(non-const OFileStream this, string filename, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OFileStream::open\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OFileStream_open_545_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OFileStream::close(void)
 *******************************************************************/
static PyObject *Dtool_OFileStream_close_546(PyObject *self, PyObject *args,PyObject *kwds) {
    OFileStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OFileStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OFileStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OFileStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const OFileStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OFileStream_close_546_comment =
    "C++ Interface:\n"
    "close(non-const OFileStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OFileStream::close\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OFileStream_close_546_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OFileStream::OFileStream(void)
 * inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
 * inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode = (ios::out))
 *******************************************************************/
int  Dtool_Init_OFileStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline OFileStream::OFileStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OFileStream", key_word_list))
            {
                OFileStream *return_value = new OFileStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OFileStream,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode = (ios::out))
            char *param0;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:OFileStream", key_word_list, &param0));
            else
                (PyArg_Parse(args, "s:OFileStream", &param0));
            if(!PyErr_Occurred())
            {
                OFileStream *return_value = new OFileStream((char const *)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OFileStream,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
            char *param0;
            int param1;
            static char * key_word_list[] = {(char *)"filename", (char *)"mode", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:OFileStream", key_word_list, &param0, &param1))
            {
                OFileStream *return_value = new OFileStream((char const *)param0, (ios_base::openmode)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OFileStream,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OFileStream() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OFileStream()\n"
          "OFileStream(string filename)\n"
          "OFileStream(string filename, int mode)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OFileStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OFileStream)
    {
        printf("OFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OFileStream * local_this = (OFileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OFileStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OFileStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OFileStream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (OFileStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OStreamWrapper 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline ostream *OStreamWrapper::get_ostream(void) const
 *******************************************************************/
static PyObject *Dtool_OStreamWrapper_get_ostream_551(PyObject *self, PyObject *args,PyObject *kwds) {
    OStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ostream *OStreamWrapper::get_ostream(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOstream", key_word_list));
        else
            (PyArg_Parse(args, ":getOstream"));
        if(!PyErr_Occurred())
        {
            ostream *return_value = ((const OStreamWrapper*)local_this)->get_ostream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOstream(const OStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OStreamWrapper_get_ostream_551_comment =
    "C++ Interface:\n"
    "getOstream(const OStreamWrapper this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OStreamWrapper::get_ostream\n"
    "//       Access: Published\n"
    "//  Description: Returns the ostream this object is wrapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OStreamWrapper_get_ostream_551_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
 *******************************************************************/
static PyObject *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_548(PyObject *self, PyObject *args,PyObject *kwds) {
    OStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToStreamWrapperBase", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToStreamWrapperBase"));
        if(!PyErr_Occurred())
        {
            StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_StreamWrapperBase,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OStreamWrapper.upcastToStreamWrapperBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToStreamWrapperBase(non-const OStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_548_comment =
    "C++ Interface:\n"
    "upcastToStreamWrapperBase(non-const OStreamWrapper this)\n"
    "\n"
    "upcast from OStreamWrapper to StreamWrapperBase\n"
    "";
#else
static const char * Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_548_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StreamWrapper *OStreamWrapper::downcast_to_StreamWrapper(void)
 *******************************************************************/
static PyObject *Dtool_OStreamWrapper_downcast_to_StreamWrapper_662(PyObject *self, PyObject *args,PyObject *kwds) {
    OStreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OStreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-StreamWrapper *OStreamWrapper::downcast_to_StreamWrapper(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToStreamWrapper", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToStreamWrapper"));
        if(!PyErr_Occurred())
        {
            StreamWrapper *return_value = (StreamWrapper *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_StreamWrapper,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OStreamWrapper.downcastToStreamWrapper() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToStreamWrapper(non-const OStreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OStreamWrapper_downcast_to_StreamWrapper_662_comment =
    "C++ Interface:\n"
    "downcastToStreamWrapper(non-const OStreamWrapper this)\n"
    "\n"
    "downcast from OStreamWrapper to StreamWrapper\n"
    "";
#else
static const char * Dtool_OStreamWrapper_downcast_to_StreamWrapper_662_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OStreamWrapper::OStreamWrapper(ostream &stream)
 *******************************************************************/
int  Dtool_Init_OStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline OStreamWrapper::OStreamWrapper(ostream &stream)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:OStreamWrapper", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:OStreamWrapper", &param0));
            if(!PyErr_Occurred())
            {
                ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "OStreamWrapper.OStreamWrapper", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    OStreamWrapper *return_value = new OStreamWrapper(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_OStreamWrapper,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OStreamWrapper(non-const Ostream stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OStreamWrapper)
    {
        printf("OStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OStreamWrapper * local_this = (OStreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OStreamWrapper)
        return local_this;
    if(requested_type == &Dtool_StreamWrapperBase)
        return ( StreamWrapperBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OStreamWrapper)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PandaSystem 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_version_string(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_version_string_553(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_version_string(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getVersionString", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_version_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVersionString()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_version_string_553_comment =
    "C++ Interface:\n"
    "getVersionString()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_version_string_553_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_package_version_string(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_package_version_string_554(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_package_version_string(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPackageVersionString", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_package_version_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPackageVersionString()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_package_version_string_554_comment =
    "C++ Interface:\n"
    "getPackageVersionString()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_package_version_string_554_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_package_host_url(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_package_host_url_555(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_package_host_url(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPackageHostUrl", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_package_host_url();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPackageHostUrl()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_package_host_url_555_comment =
    "C++ Interface:\n"
    "getPackageHostUrl()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_package_host_url_555_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_p3d_coreapi_version_string(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_p3d_coreapi_version_string_556(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_p3d_coreapi_version_string(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getP3dCoreapiVersionString", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_p3d_coreapi_version_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getP3dCoreapiVersionString()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_p3d_coreapi_version_string_556_comment =
    "C++ Interface:\n"
    "getP3dCoreapiVersionString()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_p3d_coreapi_version_string_556_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int PandaSystem::get_major_version(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_major_version_557(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int PandaSystem::get_major_version(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMajorVersion", key_word_list))
        {
            int return_value = PandaSystem::get_major_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMajorVersion()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_major_version_557_comment =
    "C++ Interface:\n"
    "getMajorVersion()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_major_version_557_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int PandaSystem::get_minor_version(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_minor_version_558(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int PandaSystem::get_minor_version(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinorVersion", key_word_list))
        {
            int return_value = PandaSystem::get_minor_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinorVersion()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_minor_version_558_comment =
    "C++ Interface:\n"
    "getMinorVersion()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_minor_version_558_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int PandaSystem::get_sequence_version(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_sequence_version_559(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int PandaSystem::get_sequence_version(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getSequenceVersion", key_word_list))
        {
            int return_value = PandaSystem::get_sequence_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSequenceVersion()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_sequence_version_559_comment =
    "C++ Interface:\n"
    "getSequenceVersion()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_sequence_version_559_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool PandaSystem::is_official_version(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_is_official_version_560(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static bool PandaSystem::is_official_version(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":isOfficialVersion", key_word_list))
        {
            bool return_value = PandaSystem::is_official_version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOfficialVersion()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_is_official_version_560_comment =
    "C++ Interface:\n"
    "isOfficialVersion()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_is_official_version_560_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_distributor(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_distributor_561(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_distributor(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDistributor", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_distributor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDistributor()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_distributor_561_comment =
    "C++ Interface:\n"
    "getDistributor()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_distributor_561_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_compiler(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_compiler_562(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_compiler(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCompiler", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_compiler();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCompiler()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_compiler_562_comment =
    "C++ Interface:\n"
    "getCompiler()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_compiler_562_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_build_date(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_build_date_563(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_build_date(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getBuildDate", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_build_date();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBuildDate()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_build_date_563_comment =
    "C++ Interface:\n"
    "getBuildDate()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_build_date_563_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > PandaSystem::get_platform(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_platform_564(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > PandaSystem::get_platform(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlatform", key_word_list))
        {
            basic_string< char > return_value = PandaSystem::get_platform();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlatform()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_platform_564_comment =
    "C++ Interface:\n"
    "getPlatform()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_platform_564_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PandaSystem::has_system(basic_string< char > const &system) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_has_system_565(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PandaSystem::has_system(basic_string< char > const &system) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"system", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasSystem", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasSystem", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PandaSystem*)local_this)->has_system(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSystem(const PandaSystem this, string system)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_has_system_565_comment =
    "C++ Interface:\n"
    "hasSystem(const PandaSystem this, string system)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_has_system_565_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PandaSystem::get_num_systems(void) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_num_systems_566(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PandaSystem::get_num_systems(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSystems", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSystems"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PandaSystem*)local_this)->get_num_systems();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSystems(const PandaSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_num_systems_566_comment =
    "C++ Interface:\n"
    "getNumSystems(const PandaSystem this)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_num_systems_566_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > PandaSystem::get_system(int n) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_system_567(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > PandaSystem::get_system(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSystem", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PandaSystem*)local_this)->get_system((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSystem(const PandaSystem this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_system_567_comment =
    "C++ Interface:\n"
    "getSystem(const PandaSystem this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_system_567_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > PandaSystem::get_system_tag(basic_string< char > const &system, basic_string< char > const &tag) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_system_tag_568(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > PandaSystem::get_system_tag(basic_string< char > const &system, basic_string< char > const &tag) const
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"system", (char *)"tag", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:getSystemTag", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            basic_string< char > return_value = ((const PandaSystem*)local_this)->get_system_tag(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSystemTag(const PandaSystem this, string system, string tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_system_tag_568_comment =
    "C++ Interface:\n"
    "getSystemTag(const PandaSystem this, string system, string tag)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_system_tag_568_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PandaSystem::add_system(basic_string< char > const &system)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_add_system_569(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PandaSystem::add_system(basic_string< char > const &system)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"system", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addSystem", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addSystem", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_system(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PandaSystem.addSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSystem(non-const PandaSystem this, string system)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_add_system_569_comment =
    "C++ Interface:\n"
    "addSystem(non-const PandaSystem this, string system)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_add_system_569_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PandaSystem::set_system_tag(basic_string< char > const &system, basic_string< char > const &tag, basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_set_system_tag_570(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PandaSystem::set_system_tag(basic_string< char > const &system, basic_string< char > const &tag, basic_string< char > const &value)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"system", (char *)"tag", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:setSystemTag", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len))
        {
            (local_this)->set_system_tag(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PandaSystem.setSystemTag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSystemTag(non-const PandaSystem this, string system, string tag, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_set_system_tag_570_comment =
    "C++ Interface:\n"
    "setSystemTag(non-const PandaSystem this, string system, string tag, string value)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_set_system_tag_570_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PandaSystem::heap_trim(unsigned int pad)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_heap_trim_571(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool PandaSystem::heap_trim(unsigned int pad)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"pad", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:heapTrim", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:heapTrim", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                bool return_value = (local_this)->heap_trim(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PandaSystem.heapTrim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "heapTrim(non-const PandaSystem this, unsigned int pad)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_heap_trim_571_comment =
    "C++ Interface:\n"
    "heapTrim(non-const PandaSystem this, unsigned int pad)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_heap_trim_571_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PandaSystem::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_output_572(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PandaSystem::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PandaSystem.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PandaSystem*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PandaSystem this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_output_572_comment =
    "C++ Interface:\n"
    "output(const PandaSystem this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_output_572_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PandaSystem::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PandaSystem_write_573(PyObject *self, PyObject *args,PyObject *kwds) {
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PandaSystem::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PandaSystem.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PandaSystem*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const PandaSystem this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_write_573_comment =
    "C++ Interface:\n"
    "write(const PandaSystem this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_write_573_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PandaSystem *PandaSystem::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_global_ptr_574(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PandaSystem *PandaSystem::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            PandaSystem *return_value = PandaSystem::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PandaSystem,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_global_ptr_574_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_global_ptr_574_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PandaSystem::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PandaSystem_get_class_type_575(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PandaSystem::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PandaSystem::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PandaSystem_get_class_type_575_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PandaSystem_get_class_type_575_comment = NULL;
#endif

int  Dtool_Init_PandaSystem(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PandaSystem)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PandaSystem(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PandaSystem)
    {
        printf("PandaSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PandaSystem * local_this = (PandaSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PandaSystem)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PandaSystem(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PandaSystem)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< float > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< float > ::PointerToArray< float >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< float > ::PointerToArray< float >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((float const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_empty_array_578(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< float > ::PointerToArray< float >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((float const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< float > result = ::PointerToArray< float >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< float > *return_value = new PointerToArray< float >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_float,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< float > ::PointerToArray< float >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< float > result = ::PointerToArray< float >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< float > *return_value = new PointerToArray< float >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_float,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_empty_array_578_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_empty_array_578_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< float >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_size_579(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< float >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< float >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_size_579_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_size_579_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::push_back(float const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_push_back_580(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::push_back(float const &x)
        double param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:pushBack", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:pushBack", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->push_back((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.pushBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, float x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_push_back_580_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, float x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_push_back_580_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_pop_back_581(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_pop_back_581_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_pop_back_581_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::PointerToArray< float >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_get_element_582(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::PointerToArray< float >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                float return_value = ((const PointerToArray< float >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_get_element_582_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_get_element_582_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::set_element(unsigned int n, float const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_set_element_583(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::set_element(unsigned int n, float const &value)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setElement", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), (float)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setElement() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_set_element_583_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_set_element_583_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::PointerToArray< float >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_getitem_584(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::PointerToArray< float >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< float >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                float return_value = ((const PointerToArray< float >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_getitem_584_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_getitem_584_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::__setitem__(unsigned int n, float const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_setitem_585(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::__setitem__(unsigned int n, float const &value)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), (float)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_setitem_585_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_setitem_585_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< float >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_get_data_586(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< float >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< float >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_get_data_586_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_get_data_586_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_set_data_587(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_set_data_587_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_set_data_587_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< float >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_get_subdata_588(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< float >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< float >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_get_subdata_588_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_get_subdata_588_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< float >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_set_subdata_589(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< float >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_set_subdata_589_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_set_subdata_589_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< float >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_get_ref_count_590(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< float >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< float >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_get_ref_count_590_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_get_ref_count_590_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< float >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_float_get_node_ref_count_591(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< float >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< float >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_float_get_node_ref_count_591_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_float_get_node_ref_count_591_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
 * ::PointerToArray< float >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< float >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< float >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((float const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< float >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((float const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< float > *return_value = new PointerToArray< float >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_float,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< float > *param0_this = (PointerToArray< float > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_float, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_float,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< float >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_float,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< float >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_float, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< float > *return_value = new PointerToArray< float >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_float,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_float)
    {
        printf("PointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< float > * local_this = (PointerToArray< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_float)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_float)
        return ( PointerToArrayBase< float > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
        return ( PointerToBase< ReferenceCountedVector< float > > *)( PointerToArrayBase< float > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< float > > *)( PointerToArrayBase< float > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_float)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_float)
    {
          PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
          return (PointerToArray< float >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_float)
    {
          PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
          return (PointerToArray< float >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< float >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< int > ::PointerToArray< int >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< int > ::PointerToArray< int >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((int const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_empty_array_595(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< int > ::PointerToArray< int >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((int const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< int > result = ::PointerToArray< int >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< int > *return_value = new PointerToArray< int >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_int,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< int > ::PointerToArray< int >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< int > result = ::PointerToArray< int >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< int > *return_value = new PointerToArray< int >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_int,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_empty_array_595_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_empty_array_595_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< int >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_size_596(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< int >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< int >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_size_596_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_size_596_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::push_back(int const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_push_back_597(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::push_back(int const &x)
        int param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:pushBack", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:pushBack", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->push_back((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.pushBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, int x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_push_back_597_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, int x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_push_back_597_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_pop_back_598(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_pop_back_598_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_pop_back_598_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::PointerToArray< int >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_get_element_599(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::PointerToArray< int >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const PointerToArray< int >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_get_element_599_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_get_element_599_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::set_element(unsigned int n, int const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_set_element_600(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::set_element(unsigned int n, int const &value)
        PyObject *param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setElement", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), (int)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setElement() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_set_element_600_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_set_element_600_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::PointerToArray< int >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_getitem_601(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::PointerToArray< int >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< int >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                int return_value = ((const PointerToArray< int >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_getitem_601_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_getitem_601_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::__setitem__(unsigned int n, int const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_setitem_602(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::__setitem__(unsigned int n, int const &value)
        PyObject *param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), (int)param2);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_setitem_602_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_setitem_602_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< int >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_get_data_603(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< int >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< int >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_get_data_603_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_get_data_603_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_set_data_604(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_set_data_604_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_set_data_604_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< int >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_get_subdata_605(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< int >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< int >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_get_subdata_605_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_get_subdata_605_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< int >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_set_subdata_606(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< int >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_set_subdata_606_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_set_subdata_606_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< int >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_get_ref_count_607(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< int >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< int >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_get_ref_count_607_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_get_ref_count_607_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< int >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_int_get_node_ref_count_608(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< int >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< int >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_int_get_node_ref_count_608_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_int_get_node_ref_count_608_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
 * ::PointerToArray< int >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< int >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< int >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((int const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< int >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((int const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< int > *return_value = new PointerToArray< int >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_int,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< int > *param0_this = (PointerToArray< int > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_int, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_int,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< int >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_int,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< int >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_int, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< int > *return_value = new PointerToArray< int >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_int,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_int)
    {
        printf("PointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< int > * local_this = (PointerToArray< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_int)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_int)
        return ( PointerToArrayBase< int > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
        return ( PointerToBase< ReferenceCountedVector< int > > *)( PointerToArrayBase< int > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< int > > *)( PointerToArrayBase< int > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_int)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_int)
    {
          PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
          return (PointerToArray< int >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_int)
    {
          PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
          return (PointerToArray< int >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< unsigned char > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< unsigned char > ::PointerToArray< unsigned char >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< unsigned char > ::PointerToArray< unsigned char >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((unsigned char const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_empty_array_612(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< unsigned char > ::PointerToArray< unsigned char >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((unsigned char const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< unsigned char > result = ::PointerToArray< unsigned char >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_unsigned_char,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< unsigned char > ::PointerToArray< unsigned char >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< unsigned char > result = ::PointerToArray< unsigned char >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_unsigned_char,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_empty_array_612_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_empty_array_612_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< unsigned char >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_size_613(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< unsigned char >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< unsigned char >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_size_613_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_size_613_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::push_back(unsigned char const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_push_back_614(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::push_back(unsigned char const &x)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:pushBack", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->push_back(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.pushBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, unsigned int x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_push_back_614_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, unsigned int x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_push_back_614_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_pop_back_615(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_pop_back_615_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_pop_back_615_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char const &::PointerToArray< unsigned char >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_get_element_616(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned char const &::PointerToArray< unsigned char >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                unsigned char return_value = ((const PointerToArray< unsigned char >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_get_element_616_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_get_element_616_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::set_element(unsigned int n, unsigned char const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_set_element_617(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::set_element(unsigned int n, unsigned char const &value)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setElement() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_set_element_617_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_set_element_617_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char const &::PointerToArray< unsigned char >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_getitem_618(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned char const &::PointerToArray< unsigned char >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< unsigned char >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                unsigned char return_value = ((const PointerToArray< unsigned char >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLongOrInt_FromUnsignedLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_getitem_618_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_getitem_618_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::__setitem__(unsigned int n, unsigned char const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_setitem_619(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::__setitem__(unsigned int n, unsigned char const &value)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_setitem_619_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, unsigned int value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_setitem_619_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< unsigned char >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_get_data_620(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< unsigned char >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< unsigned char >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_get_data_620_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_get_data_620_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_set_data_621(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_set_data_621_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_set_data_621_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< unsigned char >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_get_subdata_622(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< unsigned char >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< unsigned char >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_get_subdata_622_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_get_subdata_622_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< unsigned char >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_set_subdata_623(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< unsigned char >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_set_subdata_623_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_set_subdata_623_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< unsigned char >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_get_ref_count_624(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< unsigned char >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< unsigned char >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_get_ref_count_624_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_get_ref_count_624_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< unsigned char >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_unsigned_char_get_node_ref_count_625(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< unsigned char > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_unsigned_char,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< unsigned char >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< unsigned char >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_unsigned_char_get_node_ref_count_625_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_unsigned_char_get_node_ref_count_625_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
 * ::PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((unsigned char const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((unsigned char const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_char,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< unsigned char > *param0_this = (PointerToArray< unsigned char > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_unsigned_char, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_char,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_char,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_unsigned_char, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_unsigned_char,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_unsigned_char)
    {
        printf("PointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< unsigned char > * local_this = (PointerToArray< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_unsigned_char)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_unsigned_char)
        return ( PointerToArrayBase< unsigned char > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
        return ( PointerToBase< ReferenceCountedVector< unsigned char > > *)( PointerToArrayBase< unsigned char > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< unsigned char > > *)( PointerToArrayBase< unsigned char > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_unsigned_char)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_unsigned_char)
    {
          PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
          return (PointerToArray< unsigned char >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)
    {
          PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
          return (PointerToArray< unsigned char >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< unsigned char >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StreamReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void StreamReader::operator =(StreamReader const &copy)
 *******************************************************************/
static PyObject *Dtool_StreamReader_operator_629(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void StreamReader::operator =(StreamReader const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                StreamReader *param1_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StreamReader, 1, "StreamReader.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    StreamReader *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_StreamReader,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StreamReader.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const StreamReader this, const StreamReader copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_operator_629_comment =
    "C++ Interface:\n"
    "assign(non-const StreamReader this, const StreamReader copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: The copy constructor does not copy ownership of the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_operator_629_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline istream *StreamReader::get_istream(void) const
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_istream_631(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline istream *StreamReader::get_istream(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIstream", key_word_list));
        else
            (PyArg_Parse(args, ":getIstream"));
        if(!PyErr_Occurred())
        {
            istream *return_value = ((const StreamReader*)local_this)->get_istream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIstream(const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_istream_631_comment =
    "C++ Interface:\n"
    "getIstream(const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_istream\n"
    "//       Access: Published\n"
    "//  Description: Returns the stream in use.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_istream_631_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool StreamReader::get_bool(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_bool_632(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool StreamReader::get_bool(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBool", key_word_list));
        else
            (PyArg_Parse(args, ":getBool"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->get_bool();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBool() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBool(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_bool_632_comment =
    "C++ Interface:\n"
    "getBool(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_bool\n"
    "//       Access: Published\n"
    "//  Description: Extracts a boolean value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_bool_632_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline signed char StreamReader::get_int8(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_int8_633(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline signed char StreamReader::get_int8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt8", key_word_list));
        else
            (PyArg_Parse(args, ":getInt8"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            signed char return_value = (local_this)->get_int8();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt8(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_int8_633_comment =
    "C++ Interface:\n"
    "getInt8(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_int8\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed 8-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_int8_633_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char StreamReader::get_uint8(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_uint8_634(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned char StreamReader::get_uint8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint8", key_word_list));
        else
            (PyArg_Parse(args, ":getUint8"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned char return_value = (local_this)->get_uint8();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint8(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_uint8_634_comment =
    "C++ Interface:\n"
    "getUint8(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_uint8\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned 8-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_uint8_634_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int StreamReader::get_int16(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_int16_635(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline short int StreamReader::get_int16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt16", key_word_list));
        else
            (PyArg_Parse(args, ":getInt16"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            short int return_value = (local_this)->get_int16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt16(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_int16_635_comment =
    "C++ Interface:\n"
    "getInt16(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_int16\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_int16_635_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int StreamReader::get_int32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_int32_636(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int StreamReader::get_int32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt32", key_word_list));
        else
            (PyArg_Parse(args, ":getInt32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            int return_value = (local_this)->get_int32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_int32_636_comment =
    "C++ Interface:\n"
    "getInt32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_int32\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_int32_636_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 StreamReader::get_int64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_int64_637(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 StreamReader::get_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt64", key_word_list));
        else
            (PyArg_Parse(args, ":getInt64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            __int64 return_value = (local_this)->get_int64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_int64_637_comment =
    "C++ Interface:\n"
    "getInt64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_int64\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_int64_637_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int StreamReader::get_uint16(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_uint16_638(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int StreamReader::get_uint16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint16", key_word_list));
        else
            (PyArg_Parse(args, ":getUint16"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned short int return_value = (local_this)->get_uint16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint16(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_uint16_638_comment =
    "C++ Interface:\n"
    "getUint16(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_uint16\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_uint16_638_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int StreamReader::get_uint32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_uint32_639(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int StreamReader::get_uint32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint32", key_word_list));
        else
            (PyArg_Parse(args, ":getUint32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned int return_value = (local_this)->get_uint32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_uint32_639_comment =
    "C++ Interface:\n"
    "getUint32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_uint32\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_uint32_639_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 StreamReader::get_uint64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_uint64_640(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 StreamReader::get_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint64", key_word_list));
        else
            (PyArg_Parse(args, ":getUint64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned __int64 return_value = (local_this)->get_uint64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_uint64_640_comment =
    "C++ Interface:\n"
    "getUint64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_uint64\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_uint64_640_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float StreamReader::get_float32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_float32_641(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float StreamReader::get_float32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFloat32", key_word_list));
        else
            (PyArg_Parse(args, ":getFloat32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            float return_value = (local_this)->get_float32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFloat32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_float32_641_comment =
    "C++ Interface:\n"
    "getFloat32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_float32\n"
    "//       Access: Published\n"
    "//  Description: Extracts a 32-bit single-precision floating-point\n"
    "//               number.  Since this kind of float is not necessarily\n"
    "//               portable across different architectures, special care\n"
    "//               is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_float32_641_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double StreamReader::get_float64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_float64_642(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double StreamReader::get_float64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFloat64", key_word_list));
        else
            (PyArg_Parse(args, ":getFloat64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            double return_value = (local_this)->get_float64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFloat64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_float64_642_comment =
    "C++ Interface:\n"
    "getFloat64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_float64\n"
    "//       Access: Published\n"
    "//  Description: Extracts a 64-bit floating-point number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_float64_642_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int StreamReader::get_be_int16(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_int16_643(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline short int StreamReader::get_be_int16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt16", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt16"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            short int return_value = (local_this)->get_be_int16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt16(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_int16_643_comment =
    "C++ Interface:\n"
    "getBeInt16(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_int16\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed big-endian 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_int16_643_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int StreamReader::get_be_int32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_int32_644(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int StreamReader::get_be_int32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            int return_value = (local_this)->get_be_int32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_int32_644_comment =
    "C++ Interface:\n"
    "getBeInt32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_int32\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed big-endian 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_int32_644_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 StreamReader::get_be_int64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_int64_645(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 StreamReader::get_be_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            __int64 return_value = (local_this)->get_be_int64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_int64_645_comment =
    "C++ Interface:\n"
    "getBeInt64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_int64\n"
    "//       Access: Published\n"
    "//  Description: Extracts a signed big-endian 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_int64_645_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int StreamReader::get_be_uint16(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_uint16_646(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int StreamReader::get_be_uint16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint16", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint16"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned short int return_value = (local_this)->get_be_uint16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint16(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_uint16_646_comment =
    "C++ Interface:\n"
    "getBeUint16(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_uint16\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned big-endian 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_uint16_646_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int StreamReader::get_be_uint32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_uint32_647(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int StreamReader::get_be_uint32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned int return_value = (local_this)->get_be_uint32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_uint32_647_comment =
    "C++ Interface:\n"
    "getBeUint32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_uint32\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned big-endian 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_uint32_647_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 StreamReader::get_be_uint64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_uint64_648(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 StreamReader::get_be_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned __int64 return_value = (local_this)->get_be_uint64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_uint64_648_comment =
    "C++ Interface:\n"
    "getBeUint64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_uint64\n"
    "//       Access: Published\n"
    "//  Description: Extracts an unsigned big-endian 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_uint64_648_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float StreamReader::get_be_float32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_float32_649(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float StreamReader::get_be_float32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeFloat32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeFloat32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            float return_value = (local_this)->get_be_float32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeFloat32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_float32_649_comment =
    "C++ Interface:\n"
    "getBeFloat32(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_float32\n"
    "//       Access: Published\n"
    "//  Description: Extracts a 32-bit single-precision big-endian\n"
    "//               floating-point number.  Since this kind of float is\n"
    "//               not necessarily portable across different\n"
    "//               architectures, special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_float32_649_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double StreamReader::get_be_float64(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_be_float64_650(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double StreamReader::get_be_float64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeFloat64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeFloat64"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            double return_value = (local_this)->get_be_float64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getBeFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeFloat64(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_be_float64_650_comment =
    "C++ Interface:\n"
    "getBeFloat64(non-const StreamReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamReader::get_be_float64\n"
    "//       Access: Published\n"
    "//  Description: Extracts a 64-bit big-endian floating-point number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamReader_get_be_float64_650_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::get_string(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_string_651(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::get_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = (local_this)->get_string();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_string_651_comment =
    "C++ Interface:\n"
    "getString(non-const StreamReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_get_string_651_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::get_string32(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_string32_652(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::get_string32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString32", key_word_list));
        else
            (PyArg_Parse(args, ":getString32"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = (local_this)->get_string32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getString32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString32(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_string32_652_comment =
    "C++ Interface:\n"
    "getString32(non-const StreamReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_get_string32_652_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::get_z_string(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_z_string_653(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::get_z_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZString", key_word_list));
        else
            (PyArg_Parse(args, ":getZString"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = (local_this)->get_z_string();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getZString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZString(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_z_string_653_comment =
    "C++ Interface:\n"
    "getZString(non-const StreamReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_get_z_string_653_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::get_fixed_string(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_StreamReader_get_fixed_string_654(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::get_fixed_string(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFixedString", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getFixedString", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                basic_string< char > return_value = (local_this)->get_fixed_string(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.getFixedString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFixedString(non-const StreamReader this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_get_fixed_string_654_comment =
    "C++ Interface:\n"
    "getFixedString(non-const StreamReader this, unsigned int size)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_get_fixed_string_654_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StreamReader::skip_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_StreamReader_skip_bytes_655(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void StreamReader::skip_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:skipBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:skipBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->skip_bytes(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.skipBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "skipBytes(non-const StreamReader this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_skip_bytes_655_comment =
    "C++ Interface:\n"
    "skipBytes(non-const StreamReader this, unsigned int size)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_skip_bytes_655_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::extract_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_StreamReader_extract_bytes_656(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::extract_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:extractBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:extractBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                basic_string< char > return_value = (local_this)->extract_bytes(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.extractBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extractBytes(non-const StreamReader this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_extract_bytes_656_comment =
    "C++ Interface:\n"
    "extractBytes(non-const StreamReader this, unsigned int size)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_extract_bytes_656_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > StreamReader::readline(void)
 *******************************************************************/
static PyObject *Dtool_StreamReader_readline_657(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > StreamReader::readline(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":readline", key_word_list));
        else
            (PyArg_Parse(args, ":readline"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = (local_this)->readline();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamReader.readline() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readline(non-const StreamReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamReader_readline_657_comment =
    "C++ Interface:\n"
    "readline(non-const StreamReader this)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamReader_readline_657_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StreamReader::StreamReader(StreamReader const &copy)
 * inline StreamReader::StreamReader(istream *in, bool owns_stream)
 *******************************************************************/
int  Dtool_Init_StreamReader(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline StreamReader::StreamReader(StreamReader const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:StreamReader", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:StreamReader", &param0));
                if(!PyErr_Occurred())
                {
                    StreamReader *param0_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_StreamReader, 0, "StreamReader.StreamReader", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        StreamReader *return_value = new StreamReader(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StreamReader,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline StreamReader::StreamReader(istream *in, bool owns_stream)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"in", (char *)"owns_stream", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:StreamReader", key_word_list, &param0, &param1))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "StreamReader.StreamReader", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        StreamReader *return_value = new StreamReader(param0_this, (PyObject_IsTrue(param1)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StreamReader,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "StreamReader() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "StreamReader(const StreamReader copy)\n"
          "StreamReader(non-const Istream in, bool owns_stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StreamReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StreamReader)
    {
        printf("StreamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StreamReader * local_this = (StreamReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StreamReader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StreamReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StreamReader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StreamWrapper 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline iostream *StreamWrapper::get_iostream(void) const
 *******************************************************************/
static PyObject *Dtool_StreamWrapper_get_iostream_665(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline iostream *StreamWrapper::get_iostream(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIostream", key_word_list));
        else
            (PyArg_Parse(args, ":getIostream"));
        if(!PyErr_Occurred())
        {
            iostream *return_value = ((const StreamWrapper*)local_this)->get_iostream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_iostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIostream(const StreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWrapper_get_iostream_665_comment =
    "C++ Interface:\n"
    "getIostream(const StreamWrapper this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWrapper::get_iostream\n"
    "//       Access: Published\n"
    "//  Description: Returns the iostream this object is wrapping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWrapper_get_iostream_665_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
 *******************************************************************/
static PyObject *Dtool_StreamWrapper_upcast_to_IStreamWrapper_659(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToIStreamWrapper", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToIStreamWrapper"));
        if(!PyErr_Occurred())
        {
            IStreamWrapper *return_value = (IStreamWrapper *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_IStreamWrapper,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWrapper.upcastToIStreamWrapper() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToIStreamWrapper(non-const StreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWrapper_upcast_to_IStreamWrapper_659_comment =
    "C++ Interface:\n"
    "upcastToIStreamWrapper(non-const StreamWrapper this)\n"
    "\n"
    "upcast from StreamWrapper to IStreamWrapper\n"
    "";
#else
static const char * Dtool_StreamWrapper_upcast_to_IStreamWrapper_659_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
 *******************************************************************/
static PyObject *Dtool_StreamWrapper_upcast_to_OStreamWrapper_661(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWrapper * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWrapper,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToOStreamWrapper", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToOStreamWrapper"));
        if(!PyErr_Occurred())
        {
            OStreamWrapper *return_value = (OStreamWrapper *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_OStreamWrapper,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWrapper.upcastToOStreamWrapper() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToOStreamWrapper(non-const StreamWrapper this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWrapper_upcast_to_OStreamWrapper_661_comment =
    "C++ Interface:\n"
    "upcastToOStreamWrapper(non-const StreamWrapper this)\n"
    "\n"
    "upcast from StreamWrapper to OStreamWrapper\n"
    "";
#else
static const char * Dtool_StreamWrapper_upcast_to_OStreamWrapper_661_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StreamWrapper::StreamWrapper(iostream &stream)
 *******************************************************************/
int  Dtool_Init_StreamWrapper(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline StreamWrapper::StreamWrapper(iostream &stream)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:StreamWrapper", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:StreamWrapper", &param0));
            if(!PyErr_Occurred())
            {
                iostream *param0_this = (iostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_iostream, 0, "StreamWrapper.StreamWrapper", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    StreamWrapper *return_value = new StreamWrapper(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_StreamWrapper,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "StreamWrapper(non-const Iostream stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StreamWrapper)
    {
        printf("StreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StreamWrapper * local_this = (StreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StreamWrapper)
        return local_this;
    if(requested_type == &Dtool_IStreamWrapper)
        return ( IStreamWrapper *) local_this;
    if(requested_type == &Dtool_OStreamWrapper)
        return ( OStreamWrapper *) local_this;
    if(requested_type == &Dtool_StreamWrapperBase)
        return ( StreamWrapperBase *)( IStreamWrapper *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StreamWrapper(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StreamWrapper)
        return from_this;
    if(from_type == &Dtool_IStreamWrapper)
    {
          IStreamWrapper* other_this = (IStreamWrapper*)from_this;
          return (StreamWrapper*)other_this;
    }
    if(from_type == &Dtool_OStreamWrapper)
    {
          OStreamWrapper* other_this = (OStreamWrapper*)from_this;
          return (StreamWrapper*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StreamWriter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::operator =(StreamWriter const &copy)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_operator_668(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void StreamWriter::operator =(StreamWriter const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                StreamWriter *param1_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StreamWriter, 1, "StreamWriter.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    StreamWriter *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_StreamWriter,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StreamWriter.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const StreamWriter this, const StreamWriter copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_operator_668_comment =
    "C++ Interface:\n"
    "assign(non-const StreamWriter this, const StreamWriter copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: The copy constructor does not copy ownership of the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_operator_668_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ostream *StreamWriter::get_ostream(void) const
 *******************************************************************/
static PyObject *Dtool_StreamWriter_get_ostream_670(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ostream *StreamWriter::get_ostream(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOstream", key_word_list));
        else
            (PyArg_Parse(args, ":getOstream"));
        if(!PyErr_Occurred())
        {
            ostream *return_value = ((const StreamWriter*)local_this)->get_ostream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ostream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOstream(const StreamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_get_ostream_670_comment =
    "C++ Interface:\n"
    "getOstream(const StreamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::get_ostream\n"
    "//       Access: Published\n"
    "//  Description: Returns the stream in use.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_get_ostream_670_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_bool(bool value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_bool_671(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_bool(bool value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBool", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBool", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_bool((PyObject_IsTrue(param1)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBool() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBool(non-const StreamWriter this, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_bool_671_comment =
    "C++ Interface:\n"
    "addBool(non-const StreamWriter this, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_bool\n"
    "//       Access: Published\n"
    "//  Description: Adds a boolean value to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_bool_671_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_int8(signed char value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_int8_672(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_int8(signed char value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt8", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_int8((signed char)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt8(non-const StreamWriter this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_int8_672_comment =
    "C++ Interface:\n"
    "addInt8(non-const StreamWriter this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_int8\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 8-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_int8_672_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_uint8(unsigned char value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_uint8_673(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_uint8(unsigned char value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint8", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_uint8(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint8(non-const StreamWriter this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_uint8_673_comment =
    "C++ Interface:\n"
    "addUint8(non-const StreamWriter this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_uint8\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 8-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_uint8_673_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_int16(short int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_int16_674(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_int16(short int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt16", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_int16((short int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt16(non-const StreamWriter this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_int16_674_comment =
    "C++ Interface:\n"
    "addInt16(non-const StreamWriter this, int value)\n"
    "\n"
    "// The default numeric packing is little-endian.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_int16\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 16-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_int16_674_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_int32(int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_int32_675(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_int32(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt32", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_int32((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt32(non-const StreamWriter this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_int32_675_comment =
    "C++ Interface:\n"
    "addInt32(non-const StreamWriter this, int value)\n"
    "\n"
    "// The default numeric packing is little-endian.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_int32\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 32-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_int32_675_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_int64_676(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_int64(PyLong_AsLongLong(param1_long));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt64(non-const StreamWriter this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_int64_676_comment =
    "C++ Interface:\n"
    "addInt64(non-const StreamWriter this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_int64\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 64-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_int64_676_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_uint16(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_uint16_677(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_uint16(unsigned short int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint16", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_uint16(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint16(non-const StreamWriter this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_uint16_677_comment =
    "C++ Interface:\n"
    "addUint16(non-const StreamWriter this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_uint16\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 16-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_uint16_677_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_uint32(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_uint32_678(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_uint32(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint32", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_uint32(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint32(non-const StreamWriter this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_uint32_678_comment =
    "C++ Interface:\n"
    "addUint32(non-const StreamWriter this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_uint32\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 32-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_uint32_678_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_uint64_679(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_uint64(PyLong_AsUnsignedLongLong(param1_long));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint64(non-const StreamWriter this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_uint64_679_comment =
    "C++ Interface:\n"
    "addUint64(non-const StreamWriter this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_uint64\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 64-bit integer to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_uint64_679_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_float32(float value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_float32_680(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_float32(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addFloat32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addFloat32", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_float32((float)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFloat32(non-const StreamWriter this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_float32_680_comment =
    "C++ Interface:\n"
    "addFloat32(non-const StreamWriter this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_float32\n"
    "//       Access: Published\n"
    "//  Description: Adds a 32-bit single-precision floating-point number\n"
    "//               to the stream.  Since this kind of float is not\n"
    "//               necessarily portable across different architectures,\n"
    "//               special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_float32_680_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_float64(double value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_float64_681(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_float64(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addFloat64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addFloat64", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_float64((double)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFloat64(non-const StreamWriter this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_float64_681_comment =
    "C++ Interface:\n"
    "addFloat64(non-const StreamWriter this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_float64\n"
    "//       Access: Published\n"
    "//  Description: Adds a 64-bit floating-point number to the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_float64_681_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_int16(short int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_int16_682(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_int16(short int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addBeInt16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addBeInt16", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_be_int16((short int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt16(non-const StreamWriter this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_int16_682_comment =
    "C++ Interface:\n"
    "addBeInt16(non-const StreamWriter this, int value)\n"
    "\n"
    "// These functions pack numbers big-endian, in case that's desired.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_int16\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 16-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_int16_682_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_int32(int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_int32_683(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_int32(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addBeInt32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addBeInt32", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_be_int32((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt32(non-const StreamWriter this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_int32_683_comment =
    "C++ Interface:\n"
    "addBeInt32(non-const StreamWriter this, int value)\n"
    "\n"
    "// These functions pack numbers big-endian, in case that's desired.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_int32\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 32-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_int32_683_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_int64_684(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_be_int64(PyLong_AsLongLong(param1_long));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt64(non-const StreamWriter this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_int64_684_comment =
    "C++ Interface:\n"
    "addBeInt64(non-const StreamWriter this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_int64\n"
    "//       Access: Published\n"
    "//  Description: Adds a signed 64-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_int64_684_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_uint16(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_uint16_685(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_uint16(unsigned short int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint16", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_be_uint16(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint16(non-const StreamWriter this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_uint16_685_comment =
    "C++ Interface:\n"
    "addBeUint16(non-const StreamWriter this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_uint16\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 16-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_uint16_685_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_uint32(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_uint32_686(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_uint32(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint32", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_be_uint32(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint32(non-const StreamWriter this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_uint32_686_comment =
    "C++ Interface:\n"
    "addBeUint32(non-const StreamWriter this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_uint32\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 32-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_uint32_686_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_uint64_687(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_be_uint64(PyLong_AsUnsignedLongLong(param1_long));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint64(non-const StreamWriter this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_uint64_687_comment =
    "C++ Interface:\n"
    "addBeUint64(non-const StreamWriter this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_uint64\n"
    "//       Access: Published\n"
    "//  Description: Adds an unsigned 64-bit big-endian integer to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_uint64_687_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_float32(float value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_float32_688(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_float32(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addBeFloat32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addBeFloat32", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_be_float32((float)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeFloat32(non-const StreamWriter this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_float32_688_comment =
    "C++ Interface:\n"
    "addBeFloat32(non-const StreamWriter this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_float32\n"
    "//       Access: Published\n"
    "//  Description: Adds a 32-bit single-precision big-endian\n"
    "//               floating-point number to the stream.  Since this\n"
    "//               kind of float is not necessarily portable across\n"
    "//               different architectures, special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_float32_688_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_be_float64(double value)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_be_float64_689(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_be_float64(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addBeFloat64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addBeFloat64", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_be_float64((double)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addBeFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeFloat64(non-const StreamWriter this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_be_float64_689_comment =
    "C++ Interface:\n"
    "addBeFloat64(non-const StreamWriter this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_be_float64\n"
    "//       Access: Published\n"
    "//  Description: Adds a 64-bit big-endian floating-point number to the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_be_float64_689_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_string(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_string_690(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_string(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_string(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addString(non-const StreamWriter this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_string_690_comment =
    "C++ Interface:\n"
    "addString(non-const StreamWriter this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_string\n"
    "//       Access: Published\n"
    "//  Description: Adds a variable-length string to the stream.  This\n"
    "//               actually adds a count followed by n bytes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_string_690_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_string32(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_string32_691(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_string32(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addString32", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addString32", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_string32(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addString32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addString32(non-const StreamWriter this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_string32_691_comment =
    "C++ Interface:\n"
    "addString32(non-const StreamWriter this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_string32\n"
    "//       Access: Published\n"
    "//  Description: Adds a variable-length string to the stream, using a\n"
    "//               32-bit length field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_string32_691_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_z_string(basic_string< char > str)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_z_string_692(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_z_string(basic_string< char > str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addZString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addZString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->add_z_string(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addZString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addZString(non-const StreamWriter this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_z_string_692_comment =
    "C++ Interface:\n"
    "addZString(non-const StreamWriter this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_z_string\n"
    "//       Access: Published\n"
    "//  Description: Adds a variable-length string to the stream, as a\n"
    "//               NULL-terminated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_z_string_692_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::add_fixed_string(basic_string< char > const &str, unsigned int size)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_add_fixed_string_693(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::add_fixed_string(basic_string< char > const &str, unsigned int size)
        char *param1_str; int param1_len;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"str", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addFixedString", key_word_list, &param1_str, &param1_len, &param2))
        {
             PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param2_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->add_fixed_string(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.addFixedString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFixedString(non-const StreamWriter this, string str, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_add_fixed_string_693_comment =
    "C++ Interface:\n"
    "addFixedString(non-const StreamWriter this, string str, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::add_fixed_string\n"
    "//       Access: Published\n"
    "//  Description: Adds a fixed-length string to the stream.  If the\n"
    "//               string given is less than the requested size, this\n"
    "//               will pad the string out with zeroes; if it is greater\n"
    "//               than the requested size, this will silently truncate\n"
    "//               the string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_add_fixed_string_693_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StreamWriter::pad_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_pad_bytes_694(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void StreamWriter::pad_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:padBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:padBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->pad_bytes(PyLong_AsUnsignedLong(param1_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.padBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "padBytes(non-const StreamWriter this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_pad_bytes_694_comment =
    "C++ Interface:\n"
    "padBytes(non-const StreamWriter this, unsigned int size)\n"
    "\n"
    "";
#else
static const char * Dtool_StreamWriter_pad_bytes_694_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::append_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_append_data_695(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::append_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:appendData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->append_data(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.appendData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendData(non-const StreamWriter this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_append_data_695_comment =
    "C++ Interface:\n"
    "appendData(non-const StreamWriter this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::append_data\n"
    "//       Access: Published\n"
    "//  Description: Appends some more raw data to the end of the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::append_data\n"
    "//       Access: Published\n"
    "//  Description: Appends some more raw data to the end of the\n"
    "//               streamWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_append_data_695_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::flush(void)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_flush_696(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const StreamWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_flush_696_comment =
    "C++ Interface:\n"
    "flush(non-const StreamWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::flush\n"
    "//       Access: Published\n"
    "//  Description: Calls flush() on the underlying stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_flush_696_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void StreamWriter::write(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_StreamWriter_write_697(PyObject *self, PyObject *args,PyObject *kwds) {
    StreamWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StreamWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void StreamWriter::write(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:write", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:write", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->write(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StreamWriter.write() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(non-const StreamWriter this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StreamWriter_write_697_comment =
    "C++ Interface:\n"
    "write(non-const StreamWriter this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StreamWriter::write\n"
    "//       Access: Published\n"
    "//  Description: A synonym of append_data().  This is useful when\n"
    "//               assigning the StreamWriter to sys.stderr and/or\n"
    "//               sys.stdout in Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StreamWriter_write_697_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StreamWriter::StreamWriter(StreamWriter const &copy)
 * inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
 *******************************************************************/
int  Dtool_Init_StreamWriter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline StreamWriter::StreamWriter(StreamWriter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:StreamWriter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:StreamWriter", &param0));
                if(!PyErr_Occurred())
                {
                    StreamWriter *param0_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_StreamWriter, 0, "StreamWriter.StreamWriter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        StreamWriter *return_value = new StreamWriter(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StreamWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", (char *)"owns_stream", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:StreamWriter", key_word_list, &param0, &param1))
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "StreamWriter.StreamWriter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        StreamWriter *return_value = new StreamWriter(param0_this, (PyObject_IsTrue(param1)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StreamWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "StreamWriter() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "StreamWriter(const StreamWriter copy)\n"
          "StreamWriter(non-const Ostream out, bool owns_stream)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StreamWriter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StreamWriter)
    {
        printf("StreamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StreamWriter * local_this = (StreamWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StreamWriter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StreamWriter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StreamWriter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypeHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PyObject *TypeHandle::make(PyObject *classobj)
 *******************************************************************/
static PyObject *Dtool_TypeHandle_make_701(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PyObject *TypeHandle::make(PyObject *classobj)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"classobj", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:make", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:make", &param0));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = TypeHandle::make(param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "make(any classobj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_make_701_comment =
    "C++ Interface:\n"
    "make(any classobj)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeHandle_make_701_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator ==(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_702(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator ==(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_702_comment =
    "C++ Interface:\n"
    "eq(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "// HAVE_PYTHON\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Equality Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_702_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator !=(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_703(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator !=(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_703_comment =
    "C++ Interface:\n"
    "ne(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Inequality Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_703_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator <(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_704(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator <(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_704_comment =
    "C++ Interface:\n"
    "lessThan(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Ordering Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_704_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator <=(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_705(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator <=(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThanOrEqual", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThanOrEqual", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.lessThanOrEqual", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator <=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThanOrEqual(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_705_comment =
    "C++ Interface:\n"
    "lessThanOrEqual(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Ordering Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_705_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator >(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_706(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator >(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThan", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.greaterThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator >(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThan(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_706_comment =
    "C++ Interface:\n"
    "greaterThan(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Ordering Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_706_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::operator >=(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_operator_707(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypeHandle::operator >=(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThanOrEqual", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThanOrEqual", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.greaterThanOrEqual", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypeHandle*)local_this)->operator >=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThanOrEqual(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_operator_707_comment =
    "C++ Interface:\n"
    "greaterThanOrEqual(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::Ordering Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_operator_707_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypeHandle::compare_to(TypeHandle const &other) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_compare_to_708(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int TypeHandle::compare_to(TypeHandle const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const TypeHandle*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const TypeHandle this, const TypeHandle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_compare_to_708_comment =
    "C++ Interface:\n"
    "compareTo(const TypeHandle this, const TypeHandle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::compare_to\n"
    "//       Access: Published\n"
    "//  Description: Sorts TypeHandles arbitrarily (according to <, >,\n"
    "//               etc.).  Returns a number less than 0 if this type\n"
    "//               sorts before the other one, greater than zero if it\n"
    "//               sorts after, 0 if they are equivalent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_compare_to_708_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int TypeHandle::get_hash(void) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_hash_709(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int TypeHandle::get_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHash", key_word_list));
        else
            (PyArg_Parse(args, ":getHash"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const TypeHandle*)local_this)->get_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHash(const TypeHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_hash_709_comment =
    "C++ Interface:\n"
    "getHash(const TypeHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns a hash code suitable for phash_map.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_hash_709_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TypeHandle::get_name(TypedObject *object) const
 * inline basic_string< char > TypeHandle::get_name(TypedObject *object = ((TypedObject *)((void *)(0)))) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_name_710(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline basic_string< char > TypeHandle::get_name(TypedObject *object = ((TypedObject *)((void *)(0)))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
            else
                (PyArg_Parse(args, ":getName"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const TypeHandle*)local_this)->get_name();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline basic_string< char > TypeHandle::get_name(TypedObject *object) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"object", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getName", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getName", &param1));
                if(!PyErr_Occurred())
                {
                    TypedObject *param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedObject, 1, "TypeHandle.getName", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        basic_string< char > return_value = ((const TypeHandle*)local_this)->get_name(param1_this);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getName() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getName(const TypeHandle this)\n"
          "getName(const TypeHandle this, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_name_710_comment =
    "C++ Interface:\n"
    "getName(const TypeHandle this)\n"
    "getName(const TypeHandle this, non-const TypedObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the type.\n"
    "//\n"
    "//               The \"object\" pointer is an optional pointer to the\n"
    "//               TypedObject class that owns this TypeHandle.  It is\n"
    "//               only used in case the TypeHandle is inadvertantly\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_name_710_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object) const
 * inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = ((TypedObject *)((void *)(0)))) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_is_derived_from_711(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = ((TypedObject *)((void *)(0)))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"parent", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:isDerivedFrom", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:isDerivedFrom", &param1));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.isDerivedFrom", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const TypeHandle*)local_this)->is_derived_from(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"parent", (char *)"object", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:isDerivedFrom", key_word_list, &param1, &param2))
                {
                    TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.isDerivedFrom", 1, coerced_ptr, report_errors);
TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedObject, 2, "TypeHandle.isDerivedFrom", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = ((const TypeHandle*)local_this)->is_derived_from(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isDerivedFrom() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isDerivedFrom(const TypeHandle this, const TypeHandle parent)\n"
          "isDerivedFrom(const TypeHandle this, const TypeHandle parent, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_is_derived_from_711_comment =
    "C++ Interface:\n"
    "isDerivedFrom(const TypeHandle this, const TypeHandle parent)\n"
    "isDerivedFrom(const TypeHandle this, const TypeHandle parent, non-const TypedObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::is_derived_from\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this type is derived from the\n"
    "//               indicated type, false otherwise.\n"
    "//\n"
    "//               The \"object\" pointer is an optional pointer to the\n"
    "//               TypedObject class that owns this TypeHandle.  It is\n"
    "//               only used in case the TypeHandle is inadvertantly\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_is_derived_from_711_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypeHandle::get_num_parent_classes(TypedObject *object) const
 * inline int TypeHandle::get_num_parent_classes(TypedObject *object = ((TypedObject *)((void *)(0)))) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_num_parent_classes_712(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline int TypeHandle::get_num_parent_classes(TypedObject *object = ((TypedObject *)((void *)(0)))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumParentClasses", key_word_list));
            else
                (PyArg_Parse(args, ":getNumParentClasses"));
            if(!PyErr_Occurred())
            {
                int return_value = ((const TypeHandle*)local_this)->get_num_parent_classes();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline int TypeHandle::get_num_parent_classes(TypedObject *object) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"object", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNumParentClasses", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getNumParentClasses", &param1));
                if(!PyErr_Occurred())
                {
                    TypedObject *param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedObject, 1, "TypeHandle.getNumParentClasses", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const TypeHandle*)local_this)->get_num_parent_classes(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNumParentClasses() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNumParentClasses(const TypeHandle this)\n"
          "getNumParentClasses(const TypeHandle this, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_num_parent_classes_712_comment =
    "C++ Interface:\n"
    "getNumParentClasses(const TypeHandle this)\n"
    "getNumParentClasses(const TypeHandle this, non-const TypedObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_num_parent_classes\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of parent classes that this\n"
    "//               type is known to have.  This may then be used to\n"
    "//               index into get_parent_class().  The result will be 0\n"
    "//               if this class does not inherit from any other\n"
    "//               classes, 1 if normal, single inheritance is in\n"
    "//               effect, or greater than one if multiple inheritance\n"
    "//               is in effect.\n"
    "//\n"
    "//               The \"object\" pointer is an optional pointer to the\n"
    "//               TypedObject class that owns this TypeHandle.  It is\n"
    "//               only used in case the TypeHandle is inadvertantly\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_num_parent_classes_712_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypeHandle TypeHandle::get_parent_class(int index) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_parent_class_713(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypeHandle TypeHandle::get_parent_class(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParentClass", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParentClass", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const TypeHandle*)local_this)->get_parent_class((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParentClass(const TypeHandle this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_parent_class_713_comment =
    "C++ Interface:\n"
    "getParentClass(const TypeHandle this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_num_parent_classes\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth parent class of this type.  The index\n"
    "//               should be in the range 0 <= index <\n"
    "//               get_num_parent_classes().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_parent_class_713_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypeHandle::get_num_child_classes(TypedObject *object) const
 * inline int TypeHandle::get_num_child_classes(TypedObject *object = ((TypedObject *)((void *)(0)))) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_num_child_classes_714(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline int TypeHandle::get_num_child_classes(TypedObject *object = ((TypedObject *)((void *)(0)))) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChildClasses", key_word_list));
            else
                (PyArg_Parse(args, ":getNumChildClasses"));
            if(!PyErr_Occurred())
            {
                int return_value = ((const TypeHandle*)local_this)->get_num_child_classes();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline int TypeHandle::get_num_child_classes(TypedObject *object) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"object", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNumChildClasses", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getNumChildClasses", &param1));
                if(!PyErr_Occurred())
                {
                    TypedObject *param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedObject, 1, "TypeHandle.getNumChildClasses", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const TypeHandle*)local_this)->get_num_child_classes(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNumChildClasses() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNumChildClasses(const TypeHandle this)\n"
          "getNumChildClasses(const TypeHandle this, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_num_child_classes_714_comment =
    "C++ Interface:\n"
    "getNumChildClasses(const TypeHandle this)\n"
    "getNumChildClasses(const TypeHandle this, non-const TypedObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_num_child_classes\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of child classes that this\n"
    "//               type is known to have.  This may then be used to\n"
    "//               index into get_child_class().\n"
    "//\n"
    "//               The \"object\" pointer is an optional pointer to the\n"
    "//               TypedObject class that owns this TypeHandle.  It is\n"
    "//               only used in case the TypeHandle is inadvertantly\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_num_child_classes_714_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypeHandle TypeHandle::get_child_class(int index) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_child_class_715(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypeHandle TypeHandle::get_child_class(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getChildClass", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getChildClass", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const TypeHandle*)local_this)->get_child_class((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChildClass(const TypeHandle this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_child_class_715_comment =
    "C++ Interface:\n"
    "getChildClass(const TypeHandle this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_num_child_classes\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth child class of this type.  The index\n"
    "//               should be in the range 0 <= index <\n"
    "//               get_num_child_classes().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_child_class_715_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object) const
 * inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = ((TypedObject *)((void *)(0)))) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_parent_towards_716(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = ((TypedObject *)((void *)(0)))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"ancestor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getParentTowards", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getParentTowards", &param1));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.getParentTowards", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        TypeHandle result = ((const TypeHandle*)local_this)->get_parent_towards(*param1_this);
                        TypeHandle *return_value = new TypeHandle(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"ancestor", (char *)"object", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getParentTowards", key_word_list, &param1, &param2))
                {
                    TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeHandle.getParentTowards", 1, coerced_ptr, report_errors);
TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedObject, 2, "TypeHandle.getParentTowards", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        TypeHandle result = ((const TypeHandle*)local_this)->get_parent_towards(*param1_this, param2_this);
                        TypeHandle *return_value = new TypeHandle(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getParentTowards() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getParentTowards(const TypeHandle this, const TypeHandle ancestor)\n"
          "getParentTowards(const TypeHandle this, const TypeHandle ancestor, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_parent_towards_716_comment =
    "C++ Interface:\n"
    "getParentTowards(const TypeHandle this, const TypeHandle ancestor)\n"
    "getParentTowards(const TypeHandle this, const TypeHandle ancestor, non-const TypedObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_parent_towards\n"
    "//       Access: Published\n"
    "//  Description: Returns the parent class that is in a direct line of\n"
    "//               inheritance to the indicated ancestor class.  This is\n"
    "//               useful in the presence of multiple inheritance to try\n"
    "//               to determine what properties an unknown type may\n"
    "//               have.\n"
    "//\n"
    "//               The return value is TypeHandle::none() if the type\n"
    "//               does not inherit from the ancestor.  If ancestor is\n"
    "//               the same as this type, the return value is this type.\n"
    "//\n"
    "//               The \"object\" pointer is an optional pointer to the\n"
    "//               TypedObject class that owns this TypeHandle.  It is\n"
    "//               only used in case the TypeHandle is inadvertantly\n"
    "//               undefined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_parent_towards_716_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypeHandle::get_memory_usage(TypeHandle::MemoryClass ) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_memory_usage_718(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TypeHandle::get_memory_usage(TypeHandle::MemoryClass ) const
        int param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getMemoryUsage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getMemoryUsage", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TypeHandle*)local_this)->get_memory_usage((TypeHandle::MemoryClass)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMemoryUsage(const TypeHandle this, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_memory_usage_718_comment =
    "C++ Interface:\n"
    "getMemoryUsage(const TypeHandle this, int)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeHandle_get_memory_usage_718_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass , int )
 *******************************************************************/
static PyObject *Dtool_TypeHandle_inc_memory_usage_719(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass , int )
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:incMemoryUsage", key_word_list, &param1, &param2))
        {
            (local_this)->inc_memory_usage((TypeHandle::MemoryClass)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeHandle.incMemoryUsage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "incMemoryUsage(non-const TypeHandle this, int, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_inc_memory_usage_719_comment =
    "C++ Interface:\n"
    "incMemoryUsage(non-const TypeHandle this, int, int)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeHandle_inc_memory_usage_719_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass , int )
 *******************************************************************/
static PyObject *Dtool_TypeHandle_dec_memory_usage_720(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass , int )
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:decMemoryUsage", key_word_list, &param1, &param2))
        {
            (local_this)->dec_memory_usage((TypeHandle::MemoryClass)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeHandle.decMemoryUsage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "decMemoryUsage(non-const TypeHandle this, int, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_dec_memory_usage_720_comment =
    "C++ Interface:\n"
    "decMemoryUsage(non-const TypeHandle this, int, int)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeHandle_dec_memory_usage_720_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypeHandle::get_index(void) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_get_index_721(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TypeHandle::get_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TypeHandle*)local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndex(const TypeHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_get_index_721_comment =
    "C++ Interface:\n"
    "getIndex(const TypeHandle this)\n"
    "\n"
    "// DO_MEMORY_USAGE\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::get_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the integer index associated with this\n"
    "//               TypeHandle. Each different TypeHandle will have a\n"
    "//               different index.  However, you probably shouldn't be\n"
    "//               using this method; you should just treat the\n"
    "//               TypeHandles as opaque classes.  This is provided for\n"
    "//               the convenience of non-C++ scripting languages to\n"
    "//               build a hashtable of TypeHandles.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_get_index_721_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TypeHandle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_TypeHandle_output_722(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void TypeHandle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TypeHandle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const TypeHandle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const TypeHandle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_output_722_comment =
    "C++ Interface:\n"
    "output(const TypeHandle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_output_722_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TypeHandle TypeHandle::none(void)
 *******************************************************************/
static PyObject *Dtool_TypeHandle_none_723(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TypeHandle TypeHandle::none(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":none", key_word_list))
        {
            TypeHandle result = TypeHandle::none();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "none()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeHandle_none_723_comment =
    "C++ Interface:\n"
    "none()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypeHandle::none\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a special zero-valued TypeHandle that is used\n"
    "//               to indicate no type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypeHandle_none_723_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypeHandle::TypeHandle(void)
 * inline TypeHandle::TypeHandle(TypeHandle const &copy)
 *******************************************************************/
int  Dtool_Init_TypeHandle(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline TypeHandle::TypeHandle(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TypeHandle", key_word_list))
            {
                TypeHandle *return_value = new TypeHandle();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TypeHandle,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TypeHandle::TypeHandle(TypeHandle const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TypeHandle", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TypeHandle", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "TypeHandle.TypeHandle", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TypeHandle *return_value = new TypeHandle(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TypeHandle,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TypeHandle() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TypeHandle()\n"
          "TypeHandle(const TypeHandle copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TypeHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypeHandle)
    {
        printf("TypeHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypeHandle * local_this = (TypeHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypeHandle)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypeHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypeHandle)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypeRegistry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::find_type(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_find_type_726(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TypeHandle TypeRegistry::find_type(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findType", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findType", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const TypeRegistry*)local_this)->find_type(basic_string<char>(param1_str, param1_len));
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findType(const TypeRegistry this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_find_type_726_comment =
    "C++ Interface:\n"
    "findType(const TypeRegistry this, string name)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_find_type_726_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::find_type_by_id(int id) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_find_type_by_id_727(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TypeHandle TypeRegistry::find_type_by_id(int id) const
        int param1;
        static char * key_word_list[] = {(char *)"id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:findTypeById", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:findTypeById", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const TypeRegistry*)local_this)->find_type_by_id((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTypeById(const TypeRegistry this, int id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_find_type_by_id_727_comment =
    "C++ Interface:\n"
    "findTypeById(const TypeRegistry this, int id)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_find_type_by_id_727_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_name_728(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-basic_string< char > TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"type", (char *)"object", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getName", key_word_list, &param1, &param2))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getName", 1, coerced_ptr, report_errors);
TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedObject, 2, "TypeRegistry.getName", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    basic_string< char > return_value = ((const TypeRegistry*)local_this)->get_name(*param1_this, param2_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const TypeRegistry this, const TypeHandle type, non-const TypedObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_name_728_comment =
    "C++ Interface:\n"
    "getName(const TypeRegistry this, const TypeHandle type, non-const TypedObject object)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_name_728_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_is_derived_from_729(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"child", (char *)"base", (char *)"child_object", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:isDerivedFrom", key_word_list, &param1, &param2, &param3))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.isDerivedFrom", 1, coerced_ptr, report_errors);
TypeHandle *param2_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypeHandle, 2, "TypeRegistry.isDerivedFrom", 1, coerced_ptr, report_errors);
TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_TypedObject, 3, "TypeRegistry.isDerivedFrom", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = (local_this)->is_derived_from(*param1_this, *param2_this, param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TypeRegistry.isDerivedFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDerivedFrom(non-const TypeRegistry this, const TypeHandle child, const TypeHandle base, non-const TypedObject child_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_is_derived_from_729_comment =
    "C++ Interface:\n"
    "isDerivedFrom(non-const TypeRegistry this, const TypeHandle child, const TypeHandle base, non-const TypedObject child_object)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_is_derived_from_729_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TypeRegistry::get_num_typehandles(void)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_num_typehandles_730(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TypeRegistry::get_num_typehandles(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTypehandles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTypehandles"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_typehandles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeRegistry.getNumTypehandles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTypehandles(non-const TypeRegistry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_num_typehandles_730_comment =
    "C++ Interface:\n"
    "getNumTypehandles(non-const TypeRegistry this)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_num_typehandles_730_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::get_typehandle(int n)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_typehandle_731(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypeHandle TypeRegistry::get_typehandle(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTypehandle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTypehandle", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = (local_this)->get_typehandle((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeRegistry.getTypehandle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypehandle(non-const TypeRegistry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_typehandle_731_comment =
    "C++ Interface:\n"
    "getTypehandle(non-const TypeRegistry this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_typehandle_731_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TypeRegistry::get_num_root_classes(void)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_num_root_classes_732(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TypeRegistry::get_num_root_classes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRootClasses", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRootClasses"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_root_classes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeRegistry.getNumRootClasses() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRootClasses(non-const TypeRegistry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_num_root_classes_732_comment =
    "C++ Interface:\n"
    "getNumRootClasses(non-const TypeRegistry this)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_num_root_classes_732_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::get_root_class(int n)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_root_class_733(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypeHandle TypeRegistry::get_root_class(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRootClass", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getRootClass", &param1));
        if(!PyErr_Occurred())
        {
            TypeHandle result = (local_this)->get_root_class((int)param1);
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypeRegistry.getRootClass() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRootClass(non-const TypeRegistry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_root_class_733_comment =
    "C++ Interface:\n"
    "getRootClass(non-const TypeRegistry this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_root_class_733_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_num_parent_classes_734(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"child", (char *)"child_object", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getNumParentClasses", key_word_list, &param1, &param2))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getNumParentClasses", 1, coerced_ptr, report_errors);
TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedObject, 2, "TypeRegistry.getNumParentClasses", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    int return_value = ((const TypeRegistry*)local_this)->get_num_parent_classes(*param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumParentClasses(const TypeRegistry this, const TypeHandle child, non-const TypedObject child_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_num_parent_classes_734_comment =
    "C++ Interface:\n"
    "getNumParentClasses(const TypeRegistry this, const TypeHandle child, non-const TypedObject child_object)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_num_parent_classes_734_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_parent_class_735(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"child", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:getParentClass", key_word_list, &param1, &param2))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getParentClass", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    TypeHandle result = ((const TypeRegistry*)local_this)->get_parent_class(*param1_this, (int)param2);
                    TypeHandle *return_value = new TypeHandle(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParentClass(const TypeRegistry this, const TypeHandle child, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_parent_class_735_comment =
    "C++ Interface:\n"
    "getParentClass(const TypeRegistry this, const TypeHandle child, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_parent_class_735_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_num_child_classes_736(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"child", (char *)"child_object", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getNumChildClasses", key_word_list, &param1, &param2))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getNumChildClasses", 1, coerced_ptr, report_errors);
TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypedObject, 2, "TypeRegistry.getNumChildClasses", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    int return_value = ((const TypeRegistry*)local_this)->get_num_child_classes(*param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChildClasses(const TypeRegistry this, const TypeHandle child, non-const TypedObject child_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_num_child_classes_736_comment =
    "C++ Interface:\n"
    "getNumChildClasses(const TypeRegistry this, const TypeHandle child, non-const TypedObject child_object)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_num_child_classes_736_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_child_class_737(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"child", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:getChildClass", key_word_list, &param1, &param2))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getChildClass", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    TypeHandle result = ((const TypeRegistry*)local_this)->get_child_class(*param1_this, (int)param2);
                    TypeHandle *return_value = new TypeHandle(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChildClass(const TypeRegistry this, const TypeHandle child, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_child_class_737_comment =
    "C++ Interface:\n"
    "getChildClass(const TypeRegistry this, const TypeHandle child, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_child_class_737_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_get_parent_towards_738(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"child", (char *)"base", (char *)"child_object", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:getParentTowards", key_word_list, &param1, &param2, &param3))
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypeRegistry.getParentTowards", 1, coerced_ptr, report_errors);
TypeHandle *param2_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TypeHandle, 2, "TypeRegistry.getParentTowards", 1, coerced_ptr, report_errors);
TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_TypedObject, 3, "TypeRegistry.getParentTowards", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    TypeHandle result = (local_this)->get_parent_towards(*param1_this, *param2_this, param3_this);
                    TypeHandle *return_value = new TypeHandle(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TypeRegistry.getParentTowards() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParentTowards(non-const TypeRegistry this, const TypeHandle child, const TypeHandle base, non-const TypedObject child_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_get_parent_towards_738_comment =
    "C++ Interface:\n"
    "getParentTowards(non-const TypeRegistry this, const TypeHandle child, const TypeHandle base, non-const TypedObject child_object)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_get_parent_towards_738_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void TypeRegistry::reregister_types(void)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_reregister_types_739(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void TypeRegistry::reregister_types(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":reregisterTypes", key_word_list))
        {
            TypeRegistry::reregister_types();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reregisterTypes()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_reregister_types_739_comment =
    "C++ Interface:\n"
    "reregisterTypes()\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_reregister_types_739_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TypeRegistry::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_write_740(PyObject *self, PyObject *args,PyObject *kwds) {
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void TypeRegistry::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "TypeRegistry.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const TypeRegistry*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const TypeRegistry this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_write_740_comment =
    "C++ Interface:\n"
    "write(const TypeRegistry this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_TypeRegistry_write_740_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeRegistry *TypeRegistry::ptr(void)
 *******************************************************************/
static PyObject *Dtool_TypeRegistry_ptr_741(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeRegistry *TypeRegistry::ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ptr", key_word_list))
        {
            TypeRegistry *return_value = TypeRegistry::ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeRegistry,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ptr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypeRegistry_ptr_741_comment =
    "C++ Interface:\n"
    "ptr()\n"
    "\n"
    "// ptr() returns the pointer to the global TypeRegistry object.\n"
    "";
#else
static const char * Dtool_TypeRegistry_ptr_741_comment = NULL;
#endif

int  Dtool_Init_TypeRegistry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TypeRegistry)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypeRegistry)
    {
        printf("TypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypeRegistry * local_this = (TypeRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypeRegistry)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypeRegistry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypeRegistry)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypedObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle TypedObject::get_type(void) const = 0
 *******************************************************************/
static PyObject *Dtool_TypedObject_get_type_747(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle TypedObject::get_type(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const TypedObject*)local_this)->get_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const TypedObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_get_type_747_comment =
    "C++ Interface:\n"
    "getType(const TypedObject this)\n"
    "\n"
    "// Derived classes should override this function to return\n"
    "// get_class_type().\n"
    "";
#else
static const char * Dtool_TypedObject_get_type_747_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypedObject::get_type_index(void) const
 *******************************************************************/
static PyObject *Dtool_TypedObject_get_type_index_748(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TypedObject::get_type_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTypeIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getTypeIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TypedObject*)local_this)->get_type_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeIndex(const TypedObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_get_type_index_748_comment =
    "C++ Interface:\n"
    "getTypeIndex(const TypedObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedObject::get_type_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the internal index number associated with\n"
    "//               this object's TypeHandle, a unique number for each\n"
    "//               different type.  This is equivalent to\n"
    "//               get_type().get_index().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedObject_get_type_index_748_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypedObject::is_of_type(TypeHandle handle) const
 *******************************************************************/
static PyObject *Dtool_TypedObject_is_of_type_749(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypedObject::is_of_type(TypeHandle handle) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"handle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isOfType", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isOfType", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypedObject.isOfType", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypedObject*)local_this)->is_of_type(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOfType(const TypedObject this, const TypeHandle handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_is_of_type_749_comment =
    "C++ Interface:\n"
    "isOfType(const TypedObject this, const TypeHandle handle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedObject::is_of_type\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current object is or derives from\n"
    "//               the indicated type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedObject_is_of_type_749_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TypedObject::is_exact_type(TypeHandle handle) const
 *******************************************************************/
static PyObject *Dtool_TypedObject_is_exact_type_750(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool TypedObject::is_exact_type(TypeHandle handle) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"handle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isExactType", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isExactType", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "TypedObject.isExactType", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TypedObject*)local_this)->is_exact_type(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isExactType(const TypedObject this, const TypeHandle handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_is_exact_type_750_comment =
    "C++ Interface:\n"
    "isExactType(const TypedObject this, const TypeHandle handle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedObject::is_exact_type\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current object is the indicated\n"
    "//               type exactly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedObject_is_exact_type_750_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TypedObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TypedObject_get_class_type_751(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TypedObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TypedObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_get_class_type_751_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TypedObject_get_class_type_751_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *TypedObject::downcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_TypedObject_downcast_to_TypedReferenceCount_940(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *TypedObject::downcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedObject.downcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToTypedReferenceCount(non-const TypedObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedObject_downcast_to_TypedReferenceCount_940_comment =
    "C++ Interface:\n"
    "downcastToTypedReferenceCount(non-const TypedObject this)\n"
    "\n"
    "downcast from TypedObject to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_TypedObject_downcast_to_TypedReferenceCount_940_comment = NULL;
#endif

int  Dtool_Init_TypedObject(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TypedObject)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TypedObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypedObject)
    {
        printf("TypedObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypedObject * local_this = (TypedObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypedObject)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypedObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypedObject)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. fstream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void fstream::close(void)
 *******************************************************************/
static PyObject *Dtool_fstream_close_754(PyObject *self, PyObject *args,PyObject *kwds) {
    fstream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_fstream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void fstream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Fstream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const Fstream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_fstream_close_754_comment =
    "C++ Interface:\n"
    "close(non-const Fstream this)\n"
    "\n"
    "";
#else
static const char * Dtool_fstream_close_754_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * fstream::fstream(void)
 *******************************************************************/
int  Dtool_Init_fstream(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-fstream::fstream(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":fstream", key_word_list))
        {
            fstream *return_value = new fstream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_fstream,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fstream()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_fstream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_fstream)
    {
        printf("fstream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    fstream * local_this = (fstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_fstream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_iostream)
        return ( iostream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *)( iostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *)( iostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_fstream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_fstream)
        return from_this;
    if(from_type == &Dtool_iostream)
    {
          iostream* other_this = (iostream*)from_this;
          return (fstream*)other_this;
    }
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (fstream*)other_this;
    }
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (fstream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ifstream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ifstream::close(void)
 *******************************************************************/
static PyObject *Dtool_ifstream_close_758(PyObject *self, PyObject *args,PyObject *kwds) {
    ifstream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ifstream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ifstream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ifstream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const Ifstream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ifstream_close_758_comment =
    "C++ Interface:\n"
    "close(non-const Ifstream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ifstream_close_758_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ifstream::ifstream(void)
 *******************************************************************/
int  Dtool_Init_ifstream(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ifstream::ifstream(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ifstream", key_word_list))
        {
            ifstream *return_value = new ifstream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ifstream,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ifstream()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ifstream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ifstream)
    {
        printf("ifstream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ifstream * local_this = (ifstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ifstream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ifstream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ifstream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (ifstream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ofstream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ofstream::close(void)
 *******************************************************************/
static PyObject *Dtool_ofstream_close_762(PyObject *self, PyObject *args,PyObject *kwds) {
    ofstream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ofstream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ofstream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            (local_this)->close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ofstream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const Ofstream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ofstream_close_762_comment =
    "C++ Interface:\n"
    "close(non-const Ofstream this)\n"
    "\n"
    "";
#else
static const char * Dtool_ofstream_close_762_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ofstream::ofstream(void)
 *******************************************************************/
int  Dtool_Init_ofstream(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ofstream::ofstream(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ofstream", key_word_list))
        {
            ofstream *return_value = new ofstream();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ofstream,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ofstream()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ofstream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ofstream)
    {
        printf("ofstream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ofstream * local_this = (ofstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ofstream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ofstream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ofstream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (ofstream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int ReferenceCount::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_get_ref_count_769(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ReferenceCount::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ReferenceCount*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_get_ref_count_769_comment =
    "C++ Interface:\n"
    "getRefCount(const ReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReferenceCount::get_ref_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the current reference count.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReferenceCount_get_ref_count_769_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ReferenceCount::ref(void) const
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_ref_770(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void ReferenceCount::ref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ref", key_word_list));
        else
            (PyArg_Parse(args, ":ref"));
        if(!PyErr_Occurred())
        {
            ((const ReferenceCount*)local_this)->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ref(const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_ref_770_comment =
    "C++ Interface:\n"
    "ref(const ReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReferenceCount::ref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly increments the reference count.  User code\n"
    "//               should avoid using ref() and unref() directly, which\n"
    "//               can result in missed reference counts.  Instead, let\n"
    "//               a PointerTo object manage the reference counting\n"
    "//               automatically.\n"
    "//\n"
    "//               This function is const, even though it changes the\n"
    "//               object, because generally fiddling with an object's\n"
    "//               reference count isn't considered part of fiddling\n"
    "//               with the object.  An object might be const in other\n"
    "//               ways, but we still need to accurately count the\n"
    "//               number of references to it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReferenceCount_ref_770_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual inline bool ReferenceCount::unref(void) const
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_unref_771(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual inline bool ReferenceCount::unref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unref", key_word_list));
        else
            (PyArg_Parse(args, ":unref"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ReferenceCount*)local_this)->unref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unref(const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_unref_771_comment =
    "C++ Interface:\n"
    "unref(const ReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReferenceCount::unref\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Explicitly decrements the reference count.  Note that\n"
    "//               the object will not be implicitly deleted by unref()\n"
    "//               simply because the reference count drops to zero.\n"
    "//               (Having a member function delete itself is\n"
    "//               problematic.) However, see the helper function\n"
    "//               unref_delete().\n"
    "//\n"
    "//               User code should avoid using ref() and unref()\n"
    "//               directly, which can result in missed reference\n"
    "//               counts.  Instead, let a PointerTo object manage the\n"
    "//               reference counting automatically.\n"
    "//\n"
    "//               This function is const, even though it changes the\n"
    "//               object, because generally fiddling with an object's\n"
    "//               reference count isn't considered part of fiddling\n"
    "//               with the object.  An object might be const in other\n"
    "//               ways, but we still need to accurately count the\n"
    "//               number of references to it.\n"
    "//\n"
    "//               The return value is true if the new reference count\n"
    "//               is nonzero, false if it is zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReferenceCount_unref_771_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ReferenceCount::test_ref_count_integrity(void) const
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_test_ref_count_integrity_772(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ReferenceCount::test_ref_count_integrity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":testRefCountIntegrity", key_word_list));
        else
            (PyArg_Parse(args, ":testRefCountIntegrity"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ReferenceCount*)local_this)->test_ref_count_integrity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "testRefCountIntegrity(const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_test_ref_count_integrity_772_comment =
    "C++ Interface:\n"
    "testRefCountIntegrity(const ReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReferenceCount::test_ref_count_integrity\n"
    "//       Access: Published\n"
    "//  Description: Does some easy checks to make sure that the reference\n"
    "//               count isn't completely bogus.  Returns true if ok,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReferenceCount_test_ref_count_integrity_772_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ReferenceCount::test_ref_count_nonzero(void) const
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_test_ref_count_nonzero_773(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ReferenceCount::test_ref_count_nonzero(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":testRefCountNonzero", key_word_list));
        else
            (PyArg_Parse(args, ":testRefCountNonzero"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ReferenceCount*)local_this)->test_ref_count_nonzero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "testRefCountNonzero(const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_test_ref_count_nonzero_773_comment =
    "C++ Interface:\n"
    "testRefCountNonzero(const ReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReferenceCount::test_ref_count_nonzero\n"
    "//       Access: Published\n"
    "//  Description: Does some easy checks to make sure that the reference\n"
    "//               count isn't zero, or completely bogus.  Returns true\n"
    "//               if ok, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReferenceCount_test_ref_count_nonzero_773_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_get_class_type_774(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_get_class_type_774_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ReferenceCount_get_class_type_774_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *ReferenceCount::downcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_ReferenceCount_downcast_to_TypedReferenceCount_942(PyObject *self, PyObject *args,PyObject *kwds) {
    ReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *ReferenceCount::downcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ReferenceCount.downcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToTypedReferenceCount(non-const ReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReferenceCount_downcast_to_TypedReferenceCount_942_comment =
    "C++ Interface:\n"
    "downcastToTypedReferenceCount(non-const ReferenceCount this)\n"
    "\n"
    "downcast from ReferenceCount to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_ReferenceCount_downcast_to_TypedReferenceCount_942_comment = NULL;
#endif

int  Dtool_Init_ReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ReferenceCount)
    {
        printf("ReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ReferenceCount * local_this = (ReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ReferenceCount)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ReferenceCount)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Buffer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int Buffer::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_Buffer_get_length_776(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Buffer::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Buffer*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const Buffer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffer_get_length_776_comment =
    "C++ Interface:\n"
    "getLength(const Buffer this)\n"
    "\n"
    "// Filename: buffer.I\n"
    "// Created by:  mike (09Jan97)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Buffer::get_length\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffer_get_length_776_comment = NULL;
#endif

int  Dtool_Init_Buffer(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Buffer)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Buffer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Buffer)
    {
        printf("Buffer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Buffer * local_this = (Buffer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Buffer)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Buffer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Buffer)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Buffer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PStatCollectorForwardBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollectorForwardBase::add_level(double level)
 *******************************************************************/
static PyObject *Dtool_PStatCollectorForwardBase_add_level_785(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollectorForwardBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollectorForwardBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PStatCollectorForwardBase::add_level(double level)
        double param1;
        static char * key_word_list[] = {(char *)"level", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addLevel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addLevel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_level((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatCollectorForwardBase.addLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLevel(non-const PStatCollectorForwardBase this, float level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollectorForwardBase_add_level_785_comment =
    "C++ Interface:\n"
    "addLevel(non-const PStatCollectorForwardBase this, float level)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollectorForwardBase_add_level_785_comment = NULL;
#endif

int  Dtool_Init_PStatCollectorForwardBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PStatCollectorForwardBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PStatCollectorForwardBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PStatCollectorForwardBase)
    {
        printf("PStatCollectorForwardBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PStatCollectorForwardBase * local_this = (PStatCollectorForwardBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PStatCollectorForwardBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PStatCollectorForwardBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PStatCollectorForwardBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PStatCollectorForwardBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NodeReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int NodeReferenceCount::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_NodeReferenceCount_get_node_ref_count_788(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NodeReferenceCount::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NodeReferenceCount*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const NodeReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeReferenceCount_get_node_ref_count_788_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const NodeReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeReferenceCount::get_node_ref_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the current reference count.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeReferenceCount_get_node_ref_count_788_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NodeReferenceCount::node_ref(void) const
 *******************************************************************/
static PyObject *Dtool_NodeReferenceCount_node_ref_789(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void NodeReferenceCount::node_ref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":nodeRef", key_word_list));
        else
            (PyArg_Parse(args, ":nodeRef"));
        if(!PyErr_Occurred())
        {
            ((const NodeReferenceCount*)local_this)->node_ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "nodeRef(const NodeReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeReferenceCount_node_ref_789_comment =
    "C++ Interface:\n"
    "nodeRef(const NodeReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeReferenceCount::node_ref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly increments the node reference count and\n"
    "//               the normal reference count simultaneously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeReferenceCount_node_ref_789_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NodeReferenceCount::node_unref(void) const
 *******************************************************************/
static PyObject *Dtool_NodeReferenceCount_node_unref_790(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NodeReferenceCount::node_unref(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":nodeUnref", key_word_list));
        else
            (PyArg_Parse(args, ":nodeUnref"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NodeReferenceCount*)local_this)->node_unref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "nodeUnref(const NodeReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeReferenceCount_node_unref_790_comment =
    "C++ Interface:\n"
    "nodeUnref(const NodeReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeReferenceCount::node_unref\n"
    "//       Access: Published\n"
    "//  Description: Explicitly decrements the node reference count and\n"
    "//               the normal reference count simultaneously.\n"
    "//\n"
    "//               The return value is true if the new reference count\n"
    "//               is nonzero, false if it is zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeReferenceCount_node_unref_790_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NodeReferenceCount::test_ref_count_integrity(void) const
 *******************************************************************/
static PyObject *Dtool_NodeReferenceCount_test_ref_count_integrity_791(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NodeReferenceCount::test_ref_count_integrity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":testRefCountIntegrity", key_word_list));
        else
            (PyArg_Parse(args, ":testRefCountIntegrity"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NodeReferenceCount*)local_this)->test_ref_count_integrity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "testRefCountIntegrity(const NodeReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeReferenceCount_test_ref_count_integrity_791_comment =
    "C++ Interface:\n"
    "testRefCountIntegrity(const NodeReferenceCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeReferenceCount::test_ref_count_integrity\n"
    "//       Access: Published\n"
    "//  Description: Does some easy checks to make sure that the reference\n"
    "//               count isn't completely bogus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeReferenceCount_test_ref_count_integrity_791_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NodeReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NodeReferenceCount_get_class_type_792(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NodeReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NodeReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeReferenceCount_get_class_type_792_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NodeReferenceCount_get_class_type_792_comment = NULL;
#endif

int  Dtool_Init_NodeReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NodeReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NodeReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NodeReferenceCount)
    {
        printf("NodeReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NodeReferenceCount * local_this = (NodeReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NodeReferenceCount)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NodeReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NodeReferenceCount)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NodeReferenceCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Datagram 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::operator =(Datagram const &copy)
 *******************************************************************/
static PyObject *Dtool_Datagram_operator_795(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Datagram::operator =(Datagram const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "Datagram.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Datagram *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,false, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Datagram.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Datagram this, const Datagram copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_operator_795_comment =
    "C++ Interface:\n"
    "assign(non-const Datagram this, const Datagram copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_operator_795_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Datagram::clear(void)
 *******************************************************************/
static PyObject *Dtool_Datagram_clear_796(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void Datagram::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const Datagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_clear_796_comment =
    "C++ Interface:\n"
    "clear(non-const Datagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::clear\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Resets the datagram to empty, in preparation for\n"
    "//               building up a new datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_clear_796_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Datagram::dump_hex(ostream &out, unsigned int indent) const
 * void Datagram::dump_hex(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Datagram_dump_hex_797(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Datagram::dump_hex(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:dumpHex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:dumpHex", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Datagram.dumpHex", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Datagram*)local_this)->dump_hex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Datagram::dump_hex(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:dumpHex", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Datagram.dumpHex", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Datagram*)local_this)->dump_hex(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "dumpHex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "dumpHex(const Datagram this, non-const Ostream out)\n"
          "dumpHex(const Datagram this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_dump_hex_797_comment =
    "C++ Interface:\n"
    "dumpHex(const Datagram this, non-const Ostream out)\n"
    "dumpHex(const Datagram this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::dump_hex\n"
    "//       Access: Public\n"
    "//  Description: Writes a representation of the entire datagram\n"
    "//               contents, as a sequence of hex (and ASCII) values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_dump_hex_797_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_bool(bool value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_bool_798(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_bool(bool value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBool", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBool", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_bool((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBool() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBool(non-const Datagram this, bool value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_bool_798_comment =
    "C++ Interface:\n"
    "addBool(non-const Datagram this, bool value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_bool\n"
    "//       Access: Public\n"
    "//  Description: Adds a boolean value to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_bool_798_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_int8(signed char value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_int8_799(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_int8(signed char value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt8", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_int8((signed char)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt8(non-const Datagram this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_int8_799_comment =
    "C++ Interface:\n"
    "addInt8(non-const Datagram this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_int8\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 8-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_int8_799_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_uint8(unsigned char value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_uint8_800(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_uint8(unsigned char value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint8", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->add_uint8(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint8(non-const Datagram this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_uint8_800_comment =
    "C++ Interface:\n"
    "addUint8(non-const Datagram this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_uint8\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 8-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_uint8_800_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_int16(short int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_int16_801(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_int16(short int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt16", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_int16((short int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt16(non-const Datagram this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_int16_801_comment =
    "C++ Interface:\n"
    "addInt16(non-const Datagram this, int value)\n"
    "\n"
    "// The default numeric packing is little-endian.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_int16\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 16-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_int16_801_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_int32(int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_int32_802(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_int32(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addInt32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addInt32", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_int32((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt32(non-const Datagram this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_int32_802_comment =
    "C++ Interface:\n"
    "addInt32(non-const Datagram this, int value)\n"
    "\n"
    "// The default numeric packing is little-endian.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_int32\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 32-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_int32_802_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_int64_803(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->add_int64(PyLong_AsLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInt64(non-const Datagram this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_int64_803_comment =
    "C++ Interface:\n"
    "addInt64(non-const Datagram this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_int64\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 64-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_int64_803_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_uint16(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_uint16_804(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_uint16(unsigned short int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint16", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->add_uint16(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint16(non-const Datagram this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_uint16_804_comment =
    "C++ Interface:\n"
    "addUint16(non-const Datagram this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_uint16\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 16-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_uint16_804_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_uint32(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_uint32_805(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_uint32(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint32", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->add_uint32(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint32(non-const Datagram this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_uint32_805_comment =
    "C++ Interface:\n"
    "addUint32(non-const Datagram this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_uint32\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 32-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_uint32_805_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_uint64_806(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->add_uint64(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addUint64(non-const Datagram this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_uint64_806_comment =
    "C++ Interface:\n"
    "addUint64(non-const Datagram this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_uint64\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 64-bit integer to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_uint64_806_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_float32(float value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_float32_807(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_float32(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addFloat32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addFloat32", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_float32((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFloat32(non-const Datagram this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_float32_807_comment =
    "C++ Interface:\n"
    "addFloat32(non-const Datagram this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_float32\n"
    "//       Access: Public\n"
    "//  Description: Adds a 32-bit single-precision floating-point number\n"
    "//               to the datagram.  Since this kind of float is not\n"
    "//               necessarily portable across different architectures,\n"
    "//               special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_float32_807_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_float64(double value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_float64_808(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_float64(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addFloat64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addFloat64", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_float64((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFloat64(non-const Datagram this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_float64_808_comment =
    "C++ Interface:\n"
    "addFloat64(non-const Datagram this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_float64\n"
    "//       Access: Public\n"
    "//  Description: Adds a 64-bit floating-point number to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_float64_808_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_int16(short int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_int16_809(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_int16(short int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addBeInt16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addBeInt16", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_be_int16((short int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt16(non-const Datagram this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_int16_809_comment =
    "C++ Interface:\n"
    "addBeInt16(non-const Datagram this, int value)\n"
    "\n"
    "// These functions pack numbers big-endian, in case that's desired.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_int16\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 16-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_int16_809_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_int32(int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_int32_810(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_int32(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addBeInt32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addBeInt32", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_be_int32((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt32(non-const Datagram this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_int32_810_comment =
    "C++ Interface:\n"
    "addBeInt32(non-const Datagram this, int value)\n"
    "\n"
    "// These functions pack numbers big-endian, in case that's desired.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_int32\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 32-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_int32_810_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_int64_811(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->add_be_int64(PyLong_AsLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeInt64(non-const Datagram this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_int64_811_comment =
    "C++ Interface:\n"
    "addBeInt64(non-const Datagram this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_int64\n"
    "//       Access: Public\n"
    "//  Description: Adds a signed 64-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_int64_811_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_uint16(unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_uint16_812(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_uint16(unsigned short int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint16", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->add_be_uint16(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint16(non-const Datagram this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_uint16_812_comment =
    "C++ Interface:\n"
    "addBeUint16(non-const Datagram this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_uint16\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 16-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_uint16_812_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_uint32(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_uint32_813(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_uint32(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint32", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->add_be_uint32(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint32(non-const Datagram this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_uint32_813_comment =
    "C++ Interface:\n"
    "addBeUint32(non-const Datagram this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_uint32\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 32-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_uint32_813_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_uint64_814(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBeUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:addBeUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->add_be_uint64(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeUint64(non-const Datagram this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_uint64_814_comment =
    "C++ Interface:\n"
    "addBeUint64(non-const Datagram this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_uint64\n"
    "//       Access: Public\n"
    "//  Description: Adds an unsigned 64-bit big-endian integer to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_uint64_814_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_float32(float value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_float32_815(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_float32(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addBeFloat32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addBeFloat32", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_be_float32((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeFloat32(non-const Datagram this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_float32_815_comment =
    "C++ Interface:\n"
    "addBeFloat32(non-const Datagram this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_float32\n"
    "//       Access: Public\n"
    "//  Description: Adds a 32-bit single-precision big-endian\n"
    "//               floating-point number to the datagram.  Since this\n"
    "//               kind of float is not necessarily portable across\n"
    "//               different architectures, special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_float32_815_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_be_float64(double value)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_be_float64_816(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_be_float64(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addBeFloat64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addBeFloat64", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_be_float64((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addBeFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBeFloat64(non-const Datagram this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_be_float64_816_comment =
    "C++ Interface:\n"
    "addBeFloat64(non-const Datagram this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_be_float64\n"
    "//       Access: Public\n"
    "//  Description: Adds a 64-bit big-endian floating-point number to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_be_float64_816_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_string(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_string_817(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_string(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addString(non-const Datagram this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_string_817_comment =
    "C++ Interface:\n"
    "addString(non-const Datagram this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_string\n"
    "//       Access: Public\n"
    "//  Description: Adds a variable-length string to the datagram.  This\n"
    "//               actually adds a count followed by n bytes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_string_817_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_string32(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_string32_818(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_string32(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addString32", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addString32", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_string32(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addString32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addString32(non-const Datagram this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_string32_818_comment =
    "C++ Interface:\n"
    "addString32(non-const Datagram this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_string32\n"
    "//       Access: Public\n"
    "//  Description: Adds a variable-length string to the datagram, using\n"
    "//               a 32-bit length field to allow very long strings.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_string32_818_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_z_string(basic_string< char > str)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_z_string_819(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_z_string(basic_string< char > str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addZString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addZString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_z_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addZString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addZString(non-const Datagram this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_z_string_819_comment =
    "C++ Interface:\n"
    "addZString(non-const Datagram this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_z_string\n"
    "//       Access: Public\n"
    "//  Description: Adds a variable-length string to the datagram, as a\n"
    "//               NULL-terminated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_z_string_819_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::add_fixed_string(basic_string< char > const &str, unsigned int size)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_fixed_string_820(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::add_fixed_string(basic_string< char > const &str, unsigned int size)
        char *param1_str; int param1_len;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"str", (char *)"size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addFixedString", key_word_list, &param1_str, &param1_len, &param2))
        {
             PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param2_uint == NULL)))
            {
                (local_this)->add_fixed_string(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addFixedString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFixedString(non-const Datagram this, string str, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_fixed_string_820_comment =
    "C++ Interface:\n"
    "addFixedString(non-const Datagram this, string str, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_fixed_string\n"
    "//       Access: Public\n"
    "//  Description: Adds a fixed-length string to the datagram.  If the\n"
    "//               string given is less than the requested size, this\n"
    "//               will pad the string out with zeroes; if it is greater\n"
    "//               than the requested size, this will silently truncate\n"
    "//               the string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_fixed_string_820_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Datagram::add_wstring(basic_string< wchar_t > const &str)
 *******************************************************************/
static PyObject *Dtool_Datagram_add_wstring_821(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Datagram::add_wstring(basic_string< wchar_t > const &str)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:addWstring", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:addWstring", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            (local_this)->add_wstring(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.addWstring() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addWstring(non-const Datagram this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_add_wstring_821_comment =
    "C++ Interface:\n"
    "addWstring(non-const Datagram this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::add_wstring\n"
    "//       Access: Public\n"
    "//  Description: Adds a variable-length wstring to the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_add_wstring_821_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Datagram::pad_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_Datagram_pad_bytes_822(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Datagram::pad_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:padBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:padBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->pad_bytes(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.padBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "padBytes(non-const Datagram this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_pad_bytes_822_comment =
    "C++ Interface:\n"
    "padBytes(non-const Datagram this, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::pad_bytes\n"
    "//       Access: Public\n"
    "//  Description: Adds the indicated number of zero bytes to the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_pad_bytes_822_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::append_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_Datagram_append_data_823(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Datagram::append_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:appendData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->append_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.appendData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendData(non-const Datagram this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_append_data_823_comment =
    "C++ Interface:\n"
    "appendData(non-const Datagram this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::append_data\n"
    "//       Access: Public\n"
    "//  Description: Appends some more raw data to the end of the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::append_data\n"
    "//       Access: Public\n"
    "//  Description: Appends some more raw data to the end of the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_append_data_823_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Datagram::get_message(void) const
 *******************************************************************/
static PyObject *Dtool_Datagram_get_message_825(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Datagram::get_message(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMessage", key_word_list));
        else
            (PyArg_Parse(args, ":getMessage"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Datagram*)local_this)->get_message();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMessage(const Datagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_get_message_825_comment =
    "C++ Interface:\n"
    "getMessage(const Datagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::get_message\n"
    "//       Access: Public\n"
    "//  Description: Returns the datagram's data as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_get_message_825_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Datagram::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_Datagram_get_length_827(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Datagram::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Datagram*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const Datagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_get_length_827_comment =
    "C++ Interface:\n"
    "getLength(const Datagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::get_length\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of bytes in the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_get_length_827_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::set_array(PointerToArray< unsigned char > data)
 *******************************************************************/
static PyObject *Dtool_Datagram_set_array_828(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Datagram::set_array(PointerToArray< unsigned char > data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setArray", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setArray", &param1));
            if(!PyErr_Occurred())
            {
                PointerToArray< unsigned char > *param1_this = (PointerToArray< unsigned char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PointerToArray_unsigned_char, 1, "Datagram.setArray", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_array(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Datagram.setArray() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setArray(non-const Datagram this, const PointerToArray data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_set_array_828_comment =
    "C++ Interface:\n"
    "setArray(non-const Datagram this, const PointerToArray data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::set_array\n"
    "//       Access: Public\n"
    "//  Description: Replaces the data in the Datagram with the data in\n"
    "//               the indicated PTA_uchar.  This is assignment by\n"
    "//               reference: subsequent changes to the Datagram will\n"
    "//               also change the source PTA_uchar.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_set_array_828_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Datagram::copy_array(ConstPointerToArray< unsigned char > data)
 *******************************************************************/
static PyObject *Dtool_Datagram_copy_array_829(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Datagram::copy_array(ConstPointerToArray< unsigned char > data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copyArray", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copyArray", &param1));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< unsigned char > *param1_this = (ConstPointerToArray< unsigned char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ConstPointerToArray_unsigned_char, 1, "Datagram.copyArray", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->copy_array(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Datagram.copyArray() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyArray(non-const Datagram this, const ConstPointerToArray data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_copy_array_829_comment =
    "C++ Interface:\n"
    "copyArray(non-const Datagram this, const ConstPointerToArray data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::copy_array\n"
    "//       Access: Public\n"
    "//  Description: Replaces the data in the Datagram with a copy of the\n"
    "//               data in the indicated CPTA_uchar.  Unlike\n"
    "//               set_array(), a complete copy is made of the data;\n"
    "//               subsequent changes to the Datagram will *not* change\n"
    "//               the source CPTA_uchar.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_copy_array_829_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerToArray< unsigned char > Datagram::get_array(void) const
 *******************************************************************/
static PyObject *Dtool_Datagram_get_array_830(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerToArray< unsigned char > Datagram::get_array(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getArray", key_word_list));
        else
            (PyArg_Parse(args, ":getArray"));
        if(!PyErr_Occurred())
        {
            ConstPointerToArray< unsigned char > result = ((const Datagram*)local_this)->get_array();
            ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConstPointerToArray_unsigned_char,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArray(const Datagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_get_array_830_comment =
    "C++ Interface:\n"
    "getArray(const Datagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::get_array\n"
    "//       Access: Public\n"
    "//  Description: Returns a const pointer to the actual data in\n"
    "//               the Datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_get_array_830_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerToArray< unsigned char > Datagram::modify_array(void)
 *******************************************************************/
static PyObject *Dtool_Datagram_modify_array_831(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerToArray< unsigned char > Datagram::modify_array(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":modifyArray", key_word_list));
        else
            (PyArg_Parse(args, ":modifyArray"));
        if(!PyErr_Occurred())
        {
            PointerToArray< unsigned char > result = (local_this)->modify_array();
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_unsigned_char,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Datagram.modifyArray() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "modifyArray(non-const Datagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_modify_array_831_comment =
    "C++ Interface:\n"
    "modifyArray(non-const Datagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::modify_array\n"
    "//       Access: Public\n"
    "//  Description: Returns a modifiable pointer to the actual data in\n"
    "//               the Datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_modify_array_831_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Datagram::operator ==(Datagram const &other) const
 *******************************************************************/
static PyObject *Dtool_Datagram_operator_832(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Datagram::operator ==(Datagram const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "Datagram.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Datagram*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const Datagram this, const Datagram other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_operator_832_comment =
    "C++ Interface:\n"
    "eq(const Datagram this, const Datagram other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::operator ==\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_operator_832_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Datagram::operator !=(Datagram const &other) const
 *******************************************************************/
static PyObject *Dtool_Datagram_operator_833(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Datagram::operator !=(Datagram const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "Datagram.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Datagram*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const Datagram this, const Datagram other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_operator_833_comment =
    "C++ Interface:\n"
    "ne(const Datagram this, const Datagram other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::operator !=\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_operator_833_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Datagram::operator <(Datagram const &other) const
 *******************************************************************/
static PyObject *Dtool_Datagram_operator_834(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Datagram::operator <(Datagram const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "Datagram.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Datagram*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const Datagram this, const Datagram other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_operator_834_comment =
    "C++ Interface:\n"
    "lessThan(const Datagram this, const Datagram other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Datagram::operator <\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_operator_834_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Datagram::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Datagram_output_835(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Datagram::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Datagram.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Datagram*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Datagram this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_output_835_comment =
    "C++ Interface:\n"
    "output(const Datagram this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_output_835_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Datagram::write(ostream &out, unsigned int indent) const
 * void Datagram::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Datagram_write_836(PyObject *self, PyObject *args,PyObject *kwds) {
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Datagram::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Datagram.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Datagram*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Datagram::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Datagram.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Datagram*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Datagram this, non-const Ostream out)\n"
          "write(const Datagram this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_write_836_comment =
    "C++ Interface:\n"
    "write(const Datagram this, non-const Ostream out)\n"
    "write(const Datagram this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Datagram_write_836_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Datagram::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Datagram_get_class_type_837(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Datagram::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Datagram::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Datagram_get_class_type_837_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Datagram_get_class_type_837_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Datagram::Datagram(void)
 * inline Datagram::Datagram(Datagram const &copy)
 * inline Datagram::Datagram(basic_string< char > const &data)
 *******************************************************************/
int  Dtool_Init_Datagram(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Datagram::Datagram(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Datagram", key_word_list))
            {
                Datagram *return_value = new Datagram();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Datagram,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline Datagram::Datagram(Datagram const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Datagram", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Datagram", &param0));
                if(!PyErr_Occurred())
                {
                    Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Datagram, 0, "Datagram.Datagram", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Datagram *return_value = new Datagram(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Datagram,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline Datagram::Datagram(basic_string< char > const &data)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Datagram", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:Datagram", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    Datagram *return_value = new Datagram(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Datagram,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Datagram() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Datagram()\n"
          "Datagram(const Datagram copy)\n"
          "Datagram(string data)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Datagram)
    {
        printf("Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Datagram * local_this = (Datagram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Datagram)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Datagram(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Datagram)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Datagram*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DatagramGenerator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramGenerator_get_datagram_840(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "DatagramGenerator.getDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramGenerator.getDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDatagram(non-const DatagramGenerator this, non-const Datagram data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGenerator_get_datagram_840_comment =
    "C++ Interface:\n"
    "getDatagram(non-const DatagramGenerator this, non-const Datagram data)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramGenerator_get_datagram_840_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGenerator::is_eof(void) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramGenerator_is_eof_841(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramGenerator::is_eof(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEof", key_word_list));
        else
            (PyArg_Parse(args, ":isEof"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_eof();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGenerator.isEof() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEof(non-const DatagramGenerator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGenerator_is_eof_841_comment =
    "C++ Interface:\n"
    "isEof(non-const DatagramGenerator this)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramGenerator_is_eof_841_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGenerator::is_error(void) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramGenerator_is_error_842(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramGenerator::is_error(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGenerator.isError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(non-const DatagramGenerator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGenerator_is_error_842_comment =
    "C++ Interface:\n"
    "isError(non-const DatagramGenerator this)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramGenerator_is_error_842_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual VirtualFile *DatagramGenerator::get_file(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGenerator_get_file_843(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual VirtualFile *DatagramGenerator::get_file(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFile", key_word_list));
        else
            (PyArg_Parse(args, ":getFile"));
        if(!PyErr_Occurred())
        {
            VirtualFile *return_value = (local_this)->get_file();
            if (return_value != (VirtualFile *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_VirtualFile,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGenerator.getFile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFile(non-const DatagramGenerator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGenerator_get_file_843_comment =
    "C++ Interface:\n"
    "getFile(non-const DatagramGenerator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramGenerator::get_file\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns the VirtualFile that provides the source for\n"
    "//               these datagrams, if any, or NULL if the datagrams do\n"
    "//               not originate from a VirtualFile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramGenerator_get_file_843_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int DatagramGenerator::get_file_pos(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGenerator_get_file_pos_844(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual int DatagramGenerator::get_file_pos(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilePos", key_word_list));
        else
            (PyArg_Parse(args, ":getFilePos"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_file_pos();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGenerator.getFilePos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilePos(non-const DatagramGenerator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGenerator_get_file_pos_844_comment =
    "C++ Interface:\n"
    "getFilePos(non-const DatagramGenerator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramGenerator::get_file_pos\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns the current file position within the data\n"
    "//               stream, if any, or 0 if the file position is not\n"
    "//               meaningful or cannot be determined.\n"
    "//\n"
    "//               For DatagramGenerators that return a meaningful file\n"
    "//               position, this will be pointing to the first byte\n"
    "//               following the datagram returned after a call to\n"
    "//               get_datagram().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramGenerator_get_file_pos_844_comment = NULL;
#endif

int  Dtool_Init_DatagramGenerator(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DatagramGenerator)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DatagramGenerator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DatagramGenerator)
    {
        printf("DatagramGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DatagramGenerator * local_this = (DatagramGenerator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DatagramGenerator)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DatagramGenerator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DatagramGenerator)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DatagramIterator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DatagramIterator::operator =(DatagramIterator const &copy)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_operator_847(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DatagramIterator::operator =(DatagramIterator const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramIterator, 1, "DatagramIterator.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DatagramIterator *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramIterator,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramIterator.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DatagramIterator this, const DatagramIterator copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_operator_847_comment =
    "C++ Interface:\n"
    "assign(non-const DatagramIterator this, const DatagramIterator copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_operator_847_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DatagramIterator::get_bool(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_bool_849(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool DatagramIterator::get_bool(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBool", key_word_list));
        else
            (PyArg_Parse(args, ":getBool"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_bool();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBool() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBool(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_bool_849_comment =
    "C++ Interface:\n"
    "getBool(non-const DatagramIterator this)\n"
    "\n"
    "// Various ways to get data and increment the iterator...\n"
    "// Cut-and-paste-orama\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_bool\n"
    "//       Access: Public\n"
    "//  Description: Extracts a boolean value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_bool_849_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline signed char DatagramIterator::get_int8(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_int8_850(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline signed char DatagramIterator::get_int8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt8", key_word_list));
        else
            (PyArg_Parse(args, ":getInt8"));
        if(!PyErr_Occurred())
        {
            signed char return_value = (local_this)->get_int8();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt8(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_int8_850_comment =
    "C++ Interface:\n"
    "getInt8(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_int8\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 8-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_int8_850_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned char DatagramIterator::get_uint8(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_uint8_851(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned char DatagramIterator::get_uint8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint8", key_word_list));
        else
            (PyArg_Parse(args, ":getUint8"));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = (local_this)->get_uint8();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint8(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_uint8_851_comment =
    "C++ Interface:\n"
    "getUint8(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_uint8\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 8-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_uint8_851_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int DatagramIterator::get_int16(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_int16_852(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline short int DatagramIterator::get_int16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt16", key_word_list));
        else
            (PyArg_Parse(args, ":getInt16"));
        if(!PyErr_Occurred())
        {
            short int return_value = (local_this)->get_int16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt16(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_int16_852_comment =
    "C++ Interface:\n"
    "getInt16(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_int16\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_int16_852_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DatagramIterator::get_int32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_int32_853(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DatagramIterator::get_int32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt32", key_word_list));
        else
            (PyArg_Parse(args, ":getInt32"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_int32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_int32_853_comment =
    "C++ Interface:\n"
    "getInt32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_int32\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_int32_853_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 DatagramIterator::get_int64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_int64_854(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 DatagramIterator::get_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInt64", key_word_list));
        else
            (PyArg_Parse(args, ":getInt64"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = (local_this)->get_int64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInt64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_int64_854_comment =
    "C++ Interface:\n"
    "getInt64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_int64\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_int64_854_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int DatagramIterator::get_uint16(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_uint16_855(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int DatagramIterator::get_uint16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint16", key_word_list));
        else
            (PyArg_Parse(args, ":getUint16"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_uint16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint16(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_uint16_855_comment =
    "C++ Interface:\n"
    "getUint16(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_uint16\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 16-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_uint16_855_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DatagramIterator::get_uint32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_uint32_856(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DatagramIterator::get_uint32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint32", key_word_list));
        else
            (PyArg_Parse(args, ":getUint32"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_uint32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_uint32_856_comment =
    "C++ Interface:\n"
    "getUint32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_uint32\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 32-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_uint32_856_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 DatagramIterator::get_uint64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_uint64_857(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 DatagramIterator::get_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint64", key_word_list));
        else
            (PyArg_Parse(args, ":getUint64"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_uint64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_uint64_857_comment =
    "C++ Interface:\n"
    "getUint64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_uint64\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 64-bit integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_uint64_857_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DatagramIterator::get_float32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_float32_858(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DatagramIterator::get_float32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFloat32", key_word_list));
        else
            (PyArg_Parse(args, ":getFloat32"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_float32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFloat32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_float32_858_comment =
    "C++ Interface:\n"
    "getFloat32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_float32\n"
    "//       Access: Public\n"
    "//  Description: Extracts a 32-bit single-precision floating-point\n"
    "//               number.  Since this kind of float is not necessarily\n"
    "//               portable across different architectures, special care\n"
    "//               is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_float32_858_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double DatagramIterator::get_float64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_float64_859(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double DatagramIterator::get_float64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFloat64", key_word_list));
        else
            (PyArg_Parse(args, ":getFloat64"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_float64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFloat64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_float64_859_comment =
    "C++ Interface:\n"
    "getFloat64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_float64\n"
    "//       Access: Public\n"
    "//  Description: Extracts a 64-bit floating-point number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_float64_859_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline short int DatagramIterator::get_be_int16(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_int16_860(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline short int DatagramIterator::get_be_int16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt16", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt16"));
        if(!PyErr_Occurred())
        {
            short int return_value = (local_this)->get_be_int16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt16(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_int16_860_comment =
    "C++ Interface:\n"
    "getBeInt16(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_int16\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 16-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_int16_860_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DatagramIterator::get_be_int32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_int32_861(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DatagramIterator::get_be_int32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt32"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_be_int32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_int32_861_comment =
    "C++ Interface:\n"
    "getBeInt32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_int32\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 32-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_int32_861_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 DatagramIterator::get_be_int64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_int64_862(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 DatagramIterator::get_be_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeInt64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeInt64"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = (local_this)->get_be_int64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeInt64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_int64_862_comment =
    "C++ Interface:\n"
    "getBeInt64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_int64\n"
    "//       Access: Public\n"
    "//  Description: Extracts a signed 64-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_int64_862_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int DatagramIterator::get_be_uint16(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_uint16_863(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned short int DatagramIterator::get_be_uint16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint16", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint16"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = (local_this)->get_be_uint16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint16(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_uint16_863_comment =
    "C++ Interface:\n"
    "getBeUint16(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_uint16\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 16-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_uint16_863_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DatagramIterator::get_be_uint32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_uint32_864(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DatagramIterator::get_be_uint32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint32"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->get_be_uint32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_uint32_864_comment =
    "C++ Interface:\n"
    "getBeUint32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_uint32\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 32-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_uint32_864_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 DatagramIterator::get_be_uint64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_uint64_865(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 DatagramIterator::get_be_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeUint64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeUint64"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->get_be_uint64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeUint64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_uint64_865_comment =
    "C++ Interface:\n"
    "getBeUint64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_uint64\n"
    "//       Access: Public\n"
    "//  Description: Extracts an unsigned 64-bit big-endian integer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_uint64_865_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DatagramIterator::get_be_float32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_float32_866(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DatagramIterator::get_be_float32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeFloat32", key_word_list));
        else
            (PyArg_Parse(args, ":getBeFloat32"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_be_float32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeFloat32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeFloat32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_float32_866_comment =
    "C++ Interface:\n"
    "getBeFloat32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_float32\n"
    "//       Access: Public\n"
    "//  Description: Extracts a 32-bit big-endian single-precision\n"
    "//               floating-point number.  Since this kind of float is\n"
    "//               not necessarily portable across different\n"
    "//               architectures, special care is required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_float32_866_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double DatagramIterator::get_be_float64(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_be_float64_867(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double DatagramIterator::get_be_float64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBeFloat64", key_word_list));
        else
            (PyArg_Parse(args, ":getBeFloat64"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_be_float64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getBeFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBeFloat64(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_be_float64_867_comment =
    "C++ Interface:\n"
    "getBeFloat64(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_be_float64\n"
    "//       Access: Public\n"
    "//  Description: Extracts a 64-bit big-endian floating-point number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_be_float64_867_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DatagramIterator::get_string(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_string_868(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DatagramIterator::get_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_string_868_comment =
    "C++ Interface:\n"
    "getString(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_string\n"
    "//       Access: Public\n"
    "//  Description: Extracts a variable-length string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_string_868_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DatagramIterator::get_string32(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_string32_869(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DatagramIterator::get_string32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString32", key_word_list));
        else
            (PyArg_Parse(args, ":getString32"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_string32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getString32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString32(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_string32_869_comment =
    "C++ Interface:\n"
    "getString32(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_string32\n"
    "//       Access: Public\n"
    "//  Description: Extracts a variable-length string with a 32-bit\n"
    "//               length field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_string32_869_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DatagramIterator::get_z_string(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_z_string_870(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DatagramIterator::get_z_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZString", key_word_list));
        else
            (PyArg_Parse(args, ":getZString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_z_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getZString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZString(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_z_string_870_comment =
    "C++ Interface:\n"
    "getZString(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_z_string\n"
    "//       Access: Public\n"
    "//  Description: Extracts a variable-length string, as a\n"
    "//               NULL-terminated string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_z_string_870_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DatagramIterator::get_fixed_string(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_fixed_string_871(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DatagramIterator::get_fixed_string(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFixedString", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getFixedString", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->get_fixed_string(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getFixedString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFixedString(non-const DatagramIterator this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_fixed_string_871_comment =
    "C++ Interface:\n"
    "getFixedString(non-const DatagramIterator this, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_fixed_string\n"
    "//       Access: Public\n"
    "//  Description: Extracts a fixed-length string.  However, if a zero\n"
    "//               byte occurs within the string, it marks the end of\n"
    "//               the string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_fixed_string_871_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > DatagramIterator::get_wstring(void)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_wstring_872(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< wchar_t > DatagramIterator::get_wstring(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWstring", key_word_list));
        else
            (PyArg_Parse(args, ":getWstring"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = (local_this)->get_wstring();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.getWstring() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWstring(non-const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_wstring_872_comment =
    "C++ Interface:\n"
    "getWstring(non-const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_wstring\n"
    "//       Access: Public\n"
    "//  Description: Extracts a variable-length wstring (with a 32-bit\n"
    "//               length field).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_wstring_872_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DatagramIterator::skip_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_skip_bytes_873(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DatagramIterator::skip_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:skipBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:skipBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->skip_bytes(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.skipBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "skipBytes(non-const DatagramIterator this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_skip_bytes_873_comment =
    "C++ Interface:\n"
    "skipBytes(non-const DatagramIterator this, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::skip_bytes\n"
    "//       Access: Public\n"
    "//  Description: Skips over the indicated number of bytes in the\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_skip_bytes_873_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DatagramIterator::extract_bytes(unsigned int size)
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_extract_bytes_874(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DatagramIterator::extract_bytes(unsigned int size)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:extractBytes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:extractBytes", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->extract_bytes(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramIterator.extractBytes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extractBytes(non-const DatagramIterator this, unsigned int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_extract_bytes_874_comment =
    "C++ Interface:\n"
    "extractBytes(non-const DatagramIterator this, unsigned int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::extract_bytes\n"
    "//       Access: Public\n"
    "//  Description: Extracts the indicated number of bytes in the\n"
    "//               datagram and returns them as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_extract_bytes_874_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DatagramIterator::get_remaining_bytes(void) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_remaining_bytes_875(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DatagramIterator::get_remaining_bytes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRemainingBytes", key_word_list));
        else
            (PyArg_Parse(args, ":getRemainingBytes"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DatagramIterator*)local_this)->get_remaining_bytes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRemainingBytes(const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_remaining_bytes_875_comment =
    "C++ Interface:\n"
    "getRemainingBytes(const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_remaining_bytes\n"
    "//       Access: Public\n"
    "//  Description: Returns the remaining bytes in the datagram as a\n"
    "//               string, but does not extract them from the iterator.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_remaining_bytes_875_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DatagramIterator::get_remaining_size(void) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_remaining_size_876(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DatagramIterator::get_remaining_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRemainingSize", key_word_list));
        else
            (PyArg_Parse(args, ":getRemainingSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DatagramIterator*)local_this)->get_remaining_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRemainingSize(const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_remaining_size_876_comment =
    "C++ Interface:\n"
    "getRemainingSize(const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_remaining_size\n"
    "//       Access: Public\n"
    "//  Description: Return the bytes left in the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_remaining_size_876_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Datagram const &DatagramIterator::get_datagram(void) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_datagram_877(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Datagram const &DatagramIterator::get_datagram(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDatagram", key_word_list));
        else
            (PyArg_Parse(args, ":getDatagram"));
        if(!PyErr_Occurred())
        {
            Datagram const *return_value = &(((const DatagramIterator*)local_this)->get_datagram());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,false, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDatagram(const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_datagram_877_comment =
    "C++ Interface:\n"
    "getDatagram(const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_datagram\n"
    "//       Access: Public\n"
    "//  Description: Return the datagram of this iterator.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_datagram_877_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DatagramIterator::get_current_index(void) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_get_current_index_878(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DatagramIterator::get_current_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentIndex"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DatagramIterator*)local_this)->get_current_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentIndex(const DatagramIterator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_get_current_index_878_comment =
    "C++ Interface:\n"
    "getCurrentIndex(const DatagramIterator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramIterator::get_current_index\n"
    "//       Access: Public\n"
    "//  Description: Returns the current position within the datagram of the\n"
    "//               next piece of data to extract.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_get_current_index_878_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DatagramIterator::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_output_879(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DatagramIterator::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DatagramIterator.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DatagramIterator*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DatagramIterator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_output_879_comment =
    "C++ Interface:\n"
    "output(const DatagramIterator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_output_879_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DatagramIterator::write(ostream &out, unsigned int indent) const
 * void DatagramIterator::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_DatagramIterator_write_880(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DatagramIterator::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DatagramIterator.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DatagramIterator*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void DatagramIterator::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DatagramIterator.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const DatagramIterator*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DatagramIterator this, non-const Ostream out)\n"
          "write(const DatagramIterator this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramIterator_write_880_comment =
    "C++ Interface:\n"
    "write(const DatagramIterator this, non-const Ostream out)\n"
    "write(const DatagramIterator this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramIterator_write_880_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DatagramIterator::DatagramIterator(void)
 * inline DatagramIterator::DatagramIterator(Datagram const &datagram, unsigned int offset)
 * inline DatagramIterator::DatagramIterator(Datagram const &datagram, unsigned int offset = (0))
 * inline DatagramIterator::DatagramIterator(DatagramIterator const &copy)
 *******************************************************************/
int  Dtool_Init_DatagramIterator(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline DatagramIterator::DatagramIterator(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DatagramIterator", key_word_list))
            {
                DatagramIterator *return_value = new DatagramIterator();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramIterator,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline DatagramIterator::DatagramIterator(Datagram const &datagram, unsigned int offset = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"datagram", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DatagramIterator", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DatagramIterator", &param0));
                if(!PyErr_Occurred())
                {
                    Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Datagram, 0, "DatagramIterator.DatagramIterator", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        DatagramIterator *return_value = new DatagramIterator(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramIterator,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline DatagramIterator::DatagramIterator(DatagramIterator const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DatagramIterator", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DatagramIterator", &param0));
                if(!PyErr_Occurred())
                {
                    DatagramIterator *param0_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DatagramIterator, 0, "DatagramIterator.DatagramIterator", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DatagramIterator *return_value = new DatagramIterator(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramIterator,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline DatagramIterator::DatagramIterator(Datagram const &datagram, unsigned int offset)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"datagram", (char *)"offset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:DatagramIterator", key_word_list, &param0, &param1))
                {
                    Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Datagram, 0, "DatagramIterator.DatagramIterator", 1, coerced_ptr, report_errors);
 PyObject *param1_uint = PyNumber_Long(param1);
                    if (!((param0_this == NULL)|| (param1_uint == NULL)))
                    {
                        DatagramIterator *return_value = new DatagramIterator(*param0_this, PyLong_AsUnsignedLong(param1_uint));
                         Py_XDECREF(param1_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramIterator,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DatagramIterator() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DatagramIterator()\n"
          "DatagramIterator(const Datagram datagram)\n"
          "DatagramIterator(const DatagramIterator copy)\n"
          "DatagramIterator(const Datagram datagram, unsigned int offset)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DatagramIterator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DatagramIterator)
    {
        printf("DatagramIterator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DatagramIterator * local_this = (DatagramIterator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DatagramIterator)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DatagramIterator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DatagramIterator)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DatagramSink 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramSink_put_datagram_883(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSink * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSink,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:putDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:putDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "DatagramSink.putDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->put_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramSink.putDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "putDatagram(non-const DatagramSink this, const Datagram data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSink_put_datagram_883_comment =
    "C++ Interface:\n"
    "putDatagram(non-const DatagramSink this, const Datagram data)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramSink_put_datagram_883_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramSink::is_error(void) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramSink_is_error_884(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSink * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSink,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramSink::is_error(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSink.isError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(non-const DatagramSink this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSink_is_error_884_comment =
    "C++ Interface:\n"
    "isError(non-const DatagramSink this)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramSink_is_error_884_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DatagramSink::flush(void) = 0
 *******************************************************************/
static PyObject *Dtool_DatagramSink_flush_885(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSink * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSink,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DatagramSink::flush(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSink.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const DatagramSink this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSink_flush_885_comment =
    "C++ Interface:\n"
    "flush(non-const DatagramSink this)\n"
    "\n"
    "";
#else
static const char * Dtool_DatagramSink_flush_885_comment = NULL;
#endif

int  Dtool_Init_DatagramSink(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DatagramSink)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DatagramSink(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DatagramSink)
    {
        printf("DatagramSink ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DatagramSink * local_this = (DatagramSink *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DatagramSink)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DatagramSink(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DatagramSink)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TextEncoder 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_set_encoding_900(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
        int param1;
        static char * key_word_list[] = {(char *)"encoding", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setEncoding", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setEncoding", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encoding((TextEncoder::Encoding)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.setEncoding() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncoding(non-const TextEncoder this, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_set_encoding_900_comment =
    "C++ Interface:\n"
    "setEncoding(non-const TextEncoder this, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_encoding\n"
    "//       Access: Published\n"
    "//  Description: Specifies how the string set via set_text() is to be\n"
    "//               interpreted.  The default, E_iso8859, means a\n"
    "//               standard string with one-byte characters\n"
    "//               (i.e. ASCII).  Other encodings are possible to take\n"
    "//               advantage of character sets with more than 256\n"
    "//               characters.\n"
    "//\n"
    "//               This affects only future calls to set_text(); it does\n"
    "//               not change text that was set previously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_set_encoding_900_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_encoding_901(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncoding", key_word_list));
        else
            (PyArg_Parse(args, ":getEncoding"));
        if(!PyErr_Occurred())
        {
            TextEncoder::Encoding return_value = ((const TextEncoder*)local_this)->get_encoding();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncoding(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_encoding_901_comment =
    "C++ Interface:\n"
    "getEncoding(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_encoding\n"
    "//       Access: Published\n"
    "//  Description: Returns the encoding by which the string set via\n"
    "//               set_text() is to be interpreted.  See set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_encoding_901_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_set_default_encoding_902(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
        int param0;
        static char * key_word_list[] = {(char *)"encoding", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDefaultEncoding", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:setDefaultEncoding", &param0));
        if(!PyErr_Occurred())
        {
            TextEncoder::set_default_encoding((TextEncoder::Encoding)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultEncoding(int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_set_default_encoding_902_comment =
    "C++ Interface:\n"
    "setDefaultEncoding(int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_default_encoding\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies the default encoding to be used for all\n"
    "//               subsequently created TextEncoder objects.  See\n"
    "//               set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_set_default_encoding_902_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_default_encoding_903(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultEncoding", key_word_list))
        {
            TextEncoder::Encoding return_value = TextEncoder::get_default_encoding();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultEncoding()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_default_encoding_903_comment =
    "C++ Interface:\n"
    "getDefaultEncoding()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_default_encoding\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies the default encoding to be used for all\n"
    "//               subsequently created TextEncoder objects.  See\n"
    "//               set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_default_encoding_903_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::set_text(basic_string< char > const &text)
 * inline void TextEncoder::set_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_set_text_904(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextEncoder::set_text(basic_string< char > const &text)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"text", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setText", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setText", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->set_text(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextEncoder.setText() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void TextEncoder::set_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"text", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setText", key_word_list, &param1_str, &param1_len, &param2))
            {
                (local_this)->set_text(basic_string<char>(param1_str, param1_len), (TextEncoder::Encoding)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TextEncoder.setText() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setText() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setText(non-const TextEncoder this, string text)\n"
          "setText(non-const TextEncoder this, string text, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_set_text_904_comment =
    "C++ Interface:\n"
    "setText(non-const TextEncoder this, string text)\n"
    "setText(non-const TextEncoder this, string text, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_text\n"
    "//       Access: Published\n"
    "//  Description: Changes the text that is stored in the encoder.  The\n"
    "//               text should be encoded according to the method\n"
    "//               indicated by set_encoding().  Subsequent calls to\n"
    "//               get_text() will return this same string, while\n"
    "//               get_wtext() will return the decoded version of the\n"
    "//               string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_text\n"
    "//       Access: Published\n"
    "//  Description: The two-parameter version of set_text() accepts an\n"
    "//               explicit encoding; the text is immediately decoded\n"
    "//               and stored as a wide-character string.  Subsequent\n"
    "//               calls to get_text() will return the same text\n"
    "//               re-encoded using whichever encoding is specified by\n"
    "//               set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_set_text_904_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::clear_text(void)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_clear_text_905(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::clear_text(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearText", key_word_list));
        else
            (PyArg_Parse(args, ":clearText"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.clearText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearText(non-const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_clear_text_905_comment =
    "C++ Interface:\n"
    "clearText(non-const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::clear_text\n"
    "//       Access: Published\n"
    "//  Description: Removes the text from the TextEncoder.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_clear_text_905_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TextEncoder::has_text(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_has_text_906(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TextEncoder::has_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasText", key_word_list));
        else
            (PyArg_Parse(args, ":hasText"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextEncoder*)local_this)->has_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasText(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_has_text_906_comment =
    "C++ Interface:\n"
    "hasText(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::has_text\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_has_text_906_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextEncoder::make_upper(void)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_make_upper_907(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextEncoder::make_upper(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeUpper", key_word_list));
        else
            (PyArg_Parse(args, ":makeUpper"));
        if(!PyErr_Occurred())
        {
            (local_this)->make_upper();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.makeUpper() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeUpper(non-const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_make_upper_907_comment =
    "C++ Interface:\n"
    "makeUpper(non-const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::make_upper\n"
    "//       Access: Published\n"
    "//  Description: Adjusts the text stored within the encoder to all\n"
    "//               uppercase letters (preserving accent marks\n"
    "//               correctly).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_make_upper_907_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TextEncoder::make_lower(void)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_make_lower_908(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TextEncoder::make_lower(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeLower", key_word_list));
        else
            (PyArg_Parse(args, ":makeLower"));
        if(!PyErr_Occurred())
        {
            (local_this)->make_lower();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.makeLower() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeLower(non-const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_make_lower_908_comment =
    "C++ Interface:\n"
    "makeLower(non-const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::make_lower\n"
    "//       Access: Published\n"
    "//  Description: Adjusts the text stored within the encoder to all\n"
    "//               lowercase letters (preserving accent marks\n"
    "//               correctly).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_make_lower_908_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TextEncoder::get_text(void) const
 * inline basic_string< char > TextEncoder::get_text(TextEncoder::Encoding encoding) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_text_909(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline basic_string< char > TextEncoder::get_text(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getText", key_word_list));
            else
                (PyArg_Parse(args, ":getText"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const TextEncoder*)local_this)->get_text();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline basic_string< char > TextEncoder::get_text(TextEncoder::Encoding encoding) const
            int param1;
            static char * key_word_list[] = {(char *)"encoding", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getText", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getText", &param1));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const TextEncoder*)local_this)->get_text((TextEncoder::Encoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getText() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getText(const TextEncoder this)\n"
          "getText(const TextEncoder this, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_text_909_comment =
    "C++ Interface:\n"
    "getText(const TextEncoder this)\n"
    "getText(const TextEncoder this, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the current text, as encoded via the current\n"
    "//               encoding system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the current text, as encoded via the indicated\n"
    "//               encoding system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_text_909_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::append_text(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_append_text_910(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::append_text(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:appendText", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:appendText", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->append_text(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.appendText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendText(non-const TextEncoder this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_append_text_910_comment =
    "C++ Interface:\n"
    "appendText(non-const TextEncoder this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::append_text\n"
    "//       Access: Published\n"
    "//  Description: Appends the indicates string to the end of the stored\n"
    "//               text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_append_text_910_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::append_unicode_char(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_append_unicode_char_911(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::append_unicode_char(int character)
        int param1;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:appendUnicodeChar", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:appendUnicodeChar", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->append_unicode_char((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.appendUnicodeChar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendUnicodeChar(non-const TextEncoder this, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_append_unicode_char_911_comment =
    "C++ Interface:\n"
    "appendUnicodeChar(non-const TextEncoder this, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::append_unicode_char\n"
    "//       Access: Published\n"
    "//  Description: Appends a single character to the end of the stored\n"
    "//               text.  This may be a wide character, up to 16 bits in\n"
    "//               Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_append_unicode_char_911_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextEncoder::get_num_chars(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_num_chars_912(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextEncoder::get_num_chars(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChars", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChars"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextEncoder*)local_this)->get_num_chars();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChars(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_num_chars_912_comment =
    "C++ Interface:\n"
    "getNumChars(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_num_chars\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of characters in the stored text.\n"
    "//               This is a count of wide characters, after the string\n"
    "//               has been decoded according to set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_num_chars_912_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TextEncoder::get_unicode_char(int index) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_unicode_char_913(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TextEncoder::get_unicode_char(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getUnicodeChar", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getUnicodeChar", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TextEncoder*)local_this)->get_unicode_char((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUnicodeChar(const TextEncoder this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_unicode_char_913_comment =
    "C++ Interface:\n"
    "getUnicodeChar(const TextEncoder this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_unicode_char\n"
    "//       Access: Published\n"
    "//  Description: Returns the Unicode value of the nth character in the\n"
    "//               stored text.  This may be a wide character (greater\n"
    "//               than 255), after the string has been decoded\n"
    "//               according to set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_unicode_char_913_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::set_unicode_char(int index, int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_set_unicode_char_914(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::set_unicode_char(int index, int character)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"index", (char *)"character", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setUnicodeChar", key_word_list, &param1, &param2))
        {
            (local_this)->set_unicode_char((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.setUnicodeChar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUnicodeChar(non-const TextEncoder this, int index, int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_set_unicode_char_914_comment =
    "C++ Interface:\n"
    "setUnicodeChar(non-const TextEncoder this, int index, int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_unicode_char\n"
    "//       Access: Published\n"
    "//  Description: Sets the Unicode value of the nth character in the\n"
    "//               stored text.  This may be a wide character (greater\n"
    "//               than 255), after the string has been decoded\n"
    "//               according to set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_set_unicode_char_914_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TextEncoder::get_encoded_char(int index) const
 * inline basic_string< char > TextEncoder::get_encoded_char(int index, TextEncoder::Encoding encoding) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_encoded_char_915(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline basic_string< char > TextEncoder::get_encoded_char(int index) const
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getEncodedChar", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getEncodedChar", &param1));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const TextEncoder*)local_this)->get_encoded_char((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline basic_string< char > TextEncoder::get_encoded_char(int index, TextEncoder::Encoding encoding) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"index", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getEncodedChar", key_word_list, &param1, &param2))
            {
                basic_string< char > return_value = ((const TextEncoder*)local_this)->get_encoded_char((int)param1, (TextEncoder::Encoding)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getEncodedChar() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getEncodedChar(const TextEncoder this, int index)\n"
          "getEncodedChar(const TextEncoder this, int index, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_encoded_char_915_comment =
    "C++ Interface:\n"
    "getEncodedChar(const TextEncoder this, int index)\n"
    "getEncodedChar(const TextEncoder this, int index, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_encoded_char\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth char of the stored text, as a one-,\n"
    "//               two-, or three-byte encoded string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_encoded_char\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth char of the stored text, as a one-,\n"
    "//               two-, or three-byte encoded string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_encoded_char_915_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TextEncoder::get_text_as_ascii(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_text_as_ascii_916(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > TextEncoder::get_text_as_ascii(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextAsAscii", key_word_list));
        else
            (PyArg_Parse(args, ":getTextAsAscii"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const TextEncoder*)local_this)->get_text_as_ascii();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextAsAscii(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_text_as_ascii_916_comment =
    "C++ Interface:\n"
    "getTextAsAscii(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_text_as_ascii\n"
    "//       Access: Published\n"
    "//  Description: Returns the text associated with the node, converted\n"
    "//               as nearly as possible to a fully-ASCII\n"
    "//               representation.  This means replacing accented\n"
    "//               letters with their unaccented ASCII equivalents.\n"
    "//\n"
    "//               It is possible that some characters in the string\n"
    "//               cannot be converted to ASCII.  (The string may\n"
    "//               involve symbols like the copyright symbol, for\n"
    "//               instance, or it might involve letters in some other\n"
    "//               alphabet such as Greek or Cyrillic, or even Latin\n"
    "//               letters like thorn or eth that are not part of the\n"
    "//               ASCII character set.)  In this case, as much of the\n"
    "//               string as possible will be converted to ASCII, and\n"
    "//               the nonconvertible characters will remain encoded in\n"
    "//               the encoding specified by set_encoding().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_text_as_ascii_916_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > TextEncoder::reencode_text(basic_string< char > const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_reencode_text_917(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > TextEncoder::reencode_text(basic_string< char > const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
        char *param0_str; int param0_len;
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"text", (char *)"from", (char *)"to", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:reencodeText", key_word_list, &param0_str, &param0_len, &param1, &param2))
        {
            basic_string< char > return_value = TextEncoder::reencode_text(basic_string<char>(param0_str, param0_len), (TextEncoder::Encoding)param1, (TextEncoder::Encoding)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reencodeText(string text, int from, int to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_reencode_text_917_comment =
    "C++ Interface:\n"
    "reencodeText(string text, int from, int to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::reencode_text\n"
    "//       Access: Published, Static\n"
    "//  Description: Given the indicated text string, which is assumed to\n"
    "//               be encoded via the encoding \"from\", decodes it and\n"
    "//               then reencodes it into the encoding \"to\", and returns\n"
    "//               the newly encoded string.  This does not change or\n"
    "//               affect any properties on the TextEncoder itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_reencode_text_917_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_isalpha(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_isalpha_918(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_isalpha(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIsalpha", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIsalpha", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_isalpha((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIsalpha(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_isalpha_918_comment =
    "C++ Interface:\n"
    "unicodeIsalpha(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_isalpha\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is an\n"
    "//               alphabetic letter, false otherwise.  This is akin to\n"
    "//               ctype's isalpha(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_isalpha_918_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_isdigit(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_isdigit_919(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_isdigit(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIsdigit", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIsdigit", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_isdigit((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIsdigit(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_isdigit_919_comment =
    "C++ Interface:\n"
    "unicodeIsdigit(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_isdigit\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is a\n"
    "//               numeric digit, false otherwise.  This is akin to\n"
    "//               ctype's isdigit(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_isdigit_919_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_ispunct(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_ispunct_920(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_ispunct(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIspunct", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIspunct", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_ispunct((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIspunct(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_ispunct_920_comment =
    "C++ Interface:\n"
    "unicodeIspunct(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_ispunct\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is a\n"
    "//               punctuation mark, false otherwise.  This is akin to\n"
    "//               ctype's ispunct(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_ispunct_920_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_islower(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_islower_921(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_islower(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIslower", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIslower", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_islower((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIslower(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_islower_921_comment =
    "C++ Interface:\n"
    "unicodeIslower(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_islower\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is a\n"
    "//               lowercase letter, false otherwise.  This is akin to\n"
    "//               ctype's islower(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_islower_921_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_isupper(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_isupper_922(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_isupper(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIsupper", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIsupper", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_isupper((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIsupper(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_isupper_922_comment =
    "C++ Interface:\n"
    "unicodeIsupper(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_isupper\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is an\n"
    "//               uppercase letter, false otherwise.  This is akin to\n"
    "//               ctype's isupper(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_isupper_922_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool TextEncoder::unicode_isspace(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_isspace_923(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool TextEncoder::unicode_isspace(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeIsspace", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeIsspace", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = TextEncoder::unicode_isspace((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeIsspace(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_isspace_923_comment =
    "C++ Interface:\n"
    "unicodeIsspace(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_isspace\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if the indicated character is a\n"
    "//               whitespace letter, false otherwise.  This is akin to\n"
    "//               ctype's isspace(), extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_isspace_923_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int TextEncoder::unicode_toupper(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_toupper_924(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int TextEncoder::unicode_toupper(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeToupper", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeToupper", &param0));
        if(!PyErr_Occurred())
        {
            int return_value = TextEncoder::unicode_toupper((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeToupper(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_toupper_924_comment =
    "C++ Interface:\n"
    "unicodeToupper(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_toupper\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the uppercase equivalent of the given Unicode\n"
    "//               character.  This is akin to ctype's toupper(),\n"
    "//               extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_toupper_924_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int TextEncoder::unicode_tolower(int character)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_unicode_tolower_925(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int TextEncoder::unicode_tolower(int character)
        int param0;
        static char * key_word_list[] = {(char *)"character", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:unicodeTolower", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:unicodeTolower", &param0));
        if(!PyErr_Occurred())
        {
            int return_value = TextEncoder::unicode_tolower((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unicodeTolower(int character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_unicode_tolower_925_comment =
    "C++ Interface:\n"
    "unicodeTolower(int character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::unicode_tolower\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the uppercase equivalent of the given Unicode\n"
    "//               character.  This is akin to ctype's tolower(),\n"
    "//               extended to Unicode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_unicode_tolower_925_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > TextEncoder::upper(basic_string< char > const &source)
 * static inline basic_string< char > TextEncoder::upper(basic_string< char > const &source, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_upper_926(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline basic_string< char > TextEncoder::upper(basic_string< char > const &source)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:upper", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:upper", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = TextEncoder::upper(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline basic_string< char > TextEncoder::upper(basic_string< char > const &source, TextEncoder::Encoding encoding)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"source", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:upper", key_word_list, &param0_str, &param0_len, &param1))
            {
                basic_string< char > return_value = TextEncoder::upper(basic_string<char>(param0_str, param0_len), (TextEncoder::Encoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "upper() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "upper(string source)\n"
          "upper(string source, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_upper_926_comment =
    "C++ Interface:\n"
    "upper(string source)\n"
    "upper(string source, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::upper\n"
    "//       Access: Published, Static\n"
    "//  Description: Converts the string to uppercase, assuming the string\n"
    "//               is encoded in the default encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::upper\n"
    "//       Access: Published, Static\n"
    "//  Description: Converts the string to uppercase, assuming the string\n"
    "//               is encoded in the indicated encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_upper_926_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > TextEncoder::lower(basic_string< char > const &source)
 * static inline basic_string< char > TextEncoder::lower(basic_string< char > const &source, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_lower_927(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline basic_string< char > TextEncoder::lower(basic_string< char > const &source)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:lower", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:lower", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = TextEncoder::lower(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline basic_string< char > TextEncoder::lower(basic_string< char > const &source, TextEncoder::Encoding encoding)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"source", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:lower", key_word_list, &param0_str, &param0_len, &param1))
            {
                basic_string< char > return_value = TextEncoder::lower(basic_string<char>(param0_str, param0_len), (TextEncoder::Encoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "lower() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "lower(string source)\n"
          "lower(string source, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_lower_927_comment =
    "C++ Interface:\n"
    "lower(string source)\n"
    "lower(string source, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::lower\n"
    "//       Access: Published, Static\n"
    "//  Description: Converts the string to lowercase, assuming the string\n"
    "//               is encoded in the default encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::lower\n"
    "//       Access: Published, Static\n"
    "//  Description: Converts the string to lowercase, assuming the string\n"
    "//               is encoded in the indicated encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_lower_927_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::set_wtext(basic_string< wchar_t > const &wtext)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_set_wtext_928(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::set_wtext(basic_string< wchar_t > const &wtext)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"wtext", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:setWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:setWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            (local_this)->set_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.setWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWtext(non-const TextEncoder this, string wtext)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_set_wtext_928_comment =
    "C++ Interface:\n"
    "setWtext(non-const TextEncoder this, string wtext)\n"
    "\n"
    "// Direct support for wide-character strings.  Now publishable with\n"
    "// the new wstring support in interrogate.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::set_wtext\n"
    "//       Access: Published\n"
    "//  Description: Changes the text that is stored in the encoder.\n"
    "//               Subsequent calls to get_wtext() will return this same\n"
    "//               string, while get_text() will return the encoded\n"
    "//               version of the string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_set_wtext_928_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > const &TextEncoder::get_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_wtext_929(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< wchar_t > const &TextEncoder::get_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > const &return_value = ((const TextEncoder*)local_this)->get_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWtext(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_wtext_929_comment =
    "C++ Interface:\n"
    "getWtext(const TextEncoder this)\n"
    "\n"
    "// Direct support for wide-character strings.  Now publishable with\n"
    "// the new wstring support in interrogate.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns the text associated with the TextEncoder, as\n"
    "//               a wide-character string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_wtext_929_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TextEncoder::append_wtext(basic_string< wchar_t > const &text)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_append_wtext_930(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TextEncoder::append_wtext(basic_string< wchar_t > const &text)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:appendWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:appendWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            (local_this)->append_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TextEncoder.appendWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "appendWtext(non-const TextEncoder this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_append_wtext_930_comment =
    "C++ Interface:\n"
    "appendWtext(non-const TextEncoder this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::append_wtext\n"
    "//       Access: Published\n"
    "//  Description: Appends the indicates string to the end of the stored\n"
    "//               wide-character text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_append_wtext_930_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< wchar_t > TextEncoder::get_wtext_as_ascii(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_wtext_as_ascii_931(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< wchar_t > TextEncoder::get_wtext_as_ascii(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWtextAsAscii", key_word_list));
        else
            (PyArg_Parse(args, ":getWtextAsAscii"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const TextEncoder*)local_this)->get_wtext_as_ascii();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWtextAsAscii(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_wtext_as_ascii_931_comment =
    "C++ Interface:\n"
    "getWtextAsAscii(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::get_wtext_as_ascii\n"
    "//       Access: Published\n"
    "//  Description: Returns the text associated with the node, converted\n"
    "//               as nearly as possible to a fully-ASCII\n"
    "//               representation.  This means replacing accented\n"
    "//               letters with their unaccented ASCII equivalents.\n"
    "//\n"
    "//               It is possible that some characters in the string\n"
    "//               cannot be converted to ASCII.  (The string may\n"
    "//               involve symbols like the copyright symbol, for\n"
    "//               instance, or it might involve letters in some other\n"
    "//               alphabet such as Greek or Cyrillic, or even Latin\n"
    "//               letters like thorn or eth that are not part of the\n"
    "//               ASCII character set.)  In this case, as much of the\n"
    "//               string as possible will be converted to ASCII, and\n"
    "//               the nonconvertible characters will remain in their\n"
    "//               original form.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_get_wtext_as_ascii_931_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TextEncoder::is_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_TextEncoder_is_wtext_932(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TextEncoder::is_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWtext", key_word_list));
        else
            (PyArg_Parse(args, ":isWtext"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TextEncoder*)local_this)->is_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWtext(const TextEncoder this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_is_wtext_932_comment =
    "C++ Interface:\n"
    "isWtext(const TextEncoder this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::is_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any of the characters in the string\n"
    "//               returned by get_wtext() are out of the range of an\n"
    "//               ASCII character (and, therefore, get_wtext() should\n"
    "//               be called in preference to get_text()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_is_wtext_932_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > TextEncoder::encode_wchar(wchar_t ch, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_encode_wchar_933(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > TextEncoder::encode_wchar(wchar_t ch, TextEncoder::Encoding encoding)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"ch", (char *)"encoding", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:encodeWchar", key_word_list, &param0, &param1))
        {
            basic_string< char > return_value = TextEncoder::encode_wchar((wchar_t)param0, (TextEncoder::Encoding)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "encodeWchar(int ch, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_encode_wchar_933_comment =
    "C++ Interface:\n"
    "encodeWchar(int ch, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::encode_wchar\n"
    "//       Access: Published, Static\n"
    "//  Description: Encodes a single wide char into a one-, two-, or\n"
    "//               three-byte string, according to the given encoding\n"
    "//               system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_encode_wchar_933_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > TextEncoder::encode_wtext(basic_string< wchar_t > const &wtext) const
 * static basic_string< char > TextEncoder::encode_wtext(basic_string< wchar_t > const &wtext, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_encode_wtext_934(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline basic_string< char > TextEncoder::encode_wtext(basic_string< wchar_t > const &wtext) const
            PyUnicodeObject *param1
;
            static char * key_word_list[] = {(char *)"wtext", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "U:encodeWtext", key_word_list, &param1));
            else
                (PyArg_Parse(args, "U:encodeWtext", &param1));
            if(!PyErr_Occurred())
            {
                 int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
                basic_string< char > return_value = ((const TextEncoder*)local_this)->encode_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
                 delete[] param1_str;
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static basic_string< char > TextEncoder::encode_wtext(basic_string< wchar_t > const &wtext, TextEncoder::Encoding encoding)
            PyUnicodeObject *param0
;
            int param1;
            static char * key_word_list[] = {(char *)"wtext", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Ui:encodeWtext", key_word_list, &param0, &param1))
            {
                 int param0_len = PyUnicode_GetSize((PyObject *)param0); wchar_t *param0_str = new wchar_t[param0_len]; PyUnicode_AsWideChar(param0, param0_str, param0_len);
                basic_string< char > return_value = TextEncoder::encode_wtext(basic_string<wchar_t>((wchar_t *)param0_str, param0_len), (TextEncoder::Encoding)param1);
                 delete[] param0_str;
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "encodeWtext() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "encodeWtext(const TextEncoder this, string wtext)\n"
          "encodeWtext(string wtext, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_encode_wtext_934_comment =
    "C++ Interface:\n"
    "encodeWtext(const TextEncoder this, string wtext)\n"
    "encodeWtext(string wtext, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::encode_wtext\n"
    "//       Access: Published\n"
    "//  Description: Encodes a wide-text string into a single-char string,\n"
    "//               according to the current encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::encode_wtext\n"
    "//       Access: Published, Static\n"
    "//  Description: Encodes a wide-text string into a single-char string,\n"
    "//               according to the given encoding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_encode_wtext_934_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > TextEncoder::decode_text(basic_string< char > const &text) const
 * static basic_string< wchar_t > TextEncoder::decode_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_decode_text_935(PyObject *self, PyObject *args,PyObject *kwds) {
    TextEncoder * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TextEncoder,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline basic_string< wchar_t > TextEncoder::decode_text(basic_string< char > const &text) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"text", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:decodeText", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:decodeText", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                basic_string< wchar_t > return_value = ((const TextEncoder*)local_this)->decode_text(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static basic_string< wchar_t > TextEncoder::decode_text(basic_string< char > const &text, TextEncoder::Encoding encoding)
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"text", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:decodeText", key_word_list, &param0_str, &param0_len, &param1))
            {
                basic_string< wchar_t > return_value = TextEncoder::decode_text(basic_string<char>(param0_str, param0_len), (TextEncoder::Encoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "decodeText() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "decodeText(const TextEncoder this, string text)\n"
          "decodeText(string text, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_decode_text_935_comment =
    "C++ Interface:\n"
    "decodeText(const TextEncoder this, string text)\n"
    "decodeText(string text, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::decode_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the given wstring decoded to a single-byte\n"
    "//               string, via the current encoding system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TextEncoder::decode_text\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the given wstring decoded to a single-byte\n"
    "//               string, via the given encoding system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TextEncoder_decode_text_935_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TextEncoder::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TextEncoder_get_class_type_936(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TextEncoder::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TextEncoder::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TextEncoder_get_class_type_936_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TextEncoder_get_class_type_936_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextEncoder::TextEncoder(void)
 * inline TextEncoder::TextEncoder(TextEncoder const &copy)
 *******************************************************************/
int  Dtool_Init_TextEncoder(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline TextEncoder::TextEncoder(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TextEncoder", key_word_list))
            {
                TextEncoder *return_value = new TextEncoder();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TextEncoder,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline TextEncoder::TextEncoder(TextEncoder const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TextEncoder", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TextEncoder", &param0));
                if(!PyErr_Occurred())
                {
                    TextEncoder *param0_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextEncoder, 0, "TextEncoder.TextEncoder", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TextEncoder *return_value = new TextEncoder(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TextEncoder,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TextEncoder() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TextEncoder()\n"
          "TextEncoder(const TextEncoder copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TextEncoder(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TextEncoder)
    {
        printf("TextEncoder ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TextEncoder * local_this = (TextEncoder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TextEncoder)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TextEncoder(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TextEncoder)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypedReferenceCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TypedReferenceCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TypedReferenceCount_get_class_type_943(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TypedReferenceCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TypedReferenceCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedReferenceCount_get_class_type_943_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TypedReferenceCount_get_class_type_943_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
 *******************************************************************/
static PyObject *Dtool_TypedReferenceCount_upcast_to_TypedObject_939(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedObject", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedObject"));
        if(!PyErr_Occurred())
        {
            TypedObject *return_value = (TypedObject *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedObject,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedReferenceCount.upcastToTypedObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedObject(non-const TypedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedReferenceCount_upcast_to_TypedObject_939_comment =
    "C++ Interface:\n"
    "upcastToTypedObject(non-const TypedReferenceCount this)\n"
    "\n"
    "upcast from TypedReferenceCount to TypedObject\n"
    "";
#else
static const char * Dtool_TypedReferenceCount_upcast_to_TypedObject_939_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_941(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedReferenceCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedReferenceCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToReferenceCount"));
        if(!PyErr_Occurred())
        {
            ReferenceCount *return_value = (ReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ReferenceCount,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedReferenceCount.upcastToReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToReferenceCount(non-const TypedReferenceCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedReferenceCount_upcast_to_ReferenceCount_941_comment =
    "C++ Interface:\n"
    "upcastToReferenceCount(non-const TypedReferenceCount this)\n"
    "\n"
    "upcast from TypedReferenceCount to ReferenceCount\n"
    "";
#else
static const char * Dtool_TypedReferenceCount_upcast_to_ReferenceCount_941_comment = NULL;
#endif

int  Dtool_Init_TypedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TypedReferenceCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TypedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypedReferenceCount)
    {
        printf("TypedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypedReferenceCount * local_this = (TypedReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypedReferenceCount)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypedReferenceCount)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (TypedReferenceCount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TypedReferenceCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_file_system_946(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getFileSystem"));
        if(!PyErr_Occurred())
        {
            VirtualFileSystem *return_value = ((const VirtualFile*)local_this)->get_file_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_VirtualFileSystem,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileSystem(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_file_system_946_comment =
    "C++ Interface:\n"
    "getFileSystem(const VirtualFile this)\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFile_get_file_system_946_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual Filename VirtualFile::get_filename(void) const = 0
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_filename_947(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual Filename VirtualFile::get_filename(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename result = ((const VirtualFile*)local_this)->get_filename();
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_filename_947_comment =
    "C++ Interface:\n"
    "getFilename(const VirtualFile this)\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFile_get_filename_947_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &VirtualFile::get_original_filename(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_original_filename_948(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &VirtualFile::get_original_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOriginalFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getOriginalFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const VirtualFile*)local_this)->get_original_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOriginalFilename(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_original_filename_948_comment =
    "C++ Interface:\n"
    "getOriginalFilename(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::get_original_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the original filename as it was used to\n"
    "//               locate this VirtualFile.  This is usually, but not\n"
    "//               always, the same string returned by get_filename().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_get_original_filename_948_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool VirtualFile::has_file(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_has_file_949(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool VirtualFile::has_file(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFile", key_word_list));
        else
            (PyArg_Parse(args, ":hasFile"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VirtualFile*)local_this)->has_file();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFile(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_has_file_949_comment =
    "C++ Interface:\n"
    "hasFile(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::has_file\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if this file exists, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_has_file_949_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool VirtualFile::is_directory(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_is_directory_950(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool VirtualFile::is_directory(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDirectory", key_word_list));
        else
            (PyArg_Parse(args, ":isDirectory"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VirtualFile*)local_this)->is_directory();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDirectory(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_is_directory_950_comment =
    "C++ Interface:\n"
    "isDirectory(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::is_directory\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if this file represents a directory (and\n"
    "//               scan_directory() may be called), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_is_directory_950_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool VirtualFile::is_regular_file(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_is_regular_file_951(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool VirtualFile::is_regular_file(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRegularFile", key_word_list));
        else
            (PyArg_Parse(args, ":isRegularFile"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VirtualFile*)local_this)->is_regular_file();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRegularFile(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_is_regular_file_951_comment =
    "C++ Interface:\n"
    "isRegularFile(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::is_regular_file\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if this file represents a regular file\n"
    "//               (and read_file() may be called), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_is_regular_file_951_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_scan_directory_952(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":scanDirectory", key_word_list));
        else
            (PyArg_Parse(args, ":scanDirectory"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PointerTo< VirtualFileList > return_value = ((const VirtualFile*)local_this)->scan_directory();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (return_value != (VirtualFileList *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value.p(),Dtool_VirtualFileList,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "scanDirectory(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_scan_directory_952_comment =
    "C++ Interface:\n"
    "scanDirectory(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::scan_directory\n"
    "//       Access: Published\n"
    "//  Description: If the file represents a directory (that is,\n"
    "//               is_directory() returns true), this returns the list\n"
    "//               of files within the directory at the current time.\n"
    "//               Returns NULL if the file is not a directory or if the\n"
    "//               directory cannot be read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_scan_directory_952_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualFile::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_output_953(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void VirtualFile::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFile.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFile*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const VirtualFile this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_output_953_comment =
    "C++ Interface:\n"
    "output(const VirtualFile this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_output_953_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualFile::ls(ostream &out) const
 * void VirtualFile::ls(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_ls_954(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-void VirtualFile::ls(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":ls", key_word_list));
            else
                (PyArg_Parse(args, ":ls"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                ((const VirtualFile*)local_this)->ls();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void VirtualFile::ls(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ls", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:ls", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFile.ls", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        ((const VirtualFile*)local_this)->ls(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ls() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ls(const VirtualFile this)\n"
          "ls(const VirtualFile this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_ls_954_comment =
    "C++ Interface:\n"
    "ls(const VirtualFile this)\n"
    "ls(const VirtualFile this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::ls\n"
    "//       Access: Published\n"
    "//  Description: If the file represents a directory, lists its\n"
    "//               contents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_ls_954_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualFile::ls_all(ostream &out) const
 * void VirtualFile::ls_all(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_ls_all_955(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-void VirtualFile::ls_all(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":lsAll", key_word_list));
            else
                (PyArg_Parse(args, ":lsAll"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                ((const VirtualFile*)local_this)->ls_all();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void VirtualFile::ls_all(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:lsAll", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:lsAll", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFile.lsAll", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        ((const VirtualFile*)local_this)->ls_all(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "lsAll() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "lsAll(const VirtualFile this)\n"
          "lsAll(const VirtualFile this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_ls_all_955_comment =
    "C++ Interface:\n"
    "lsAll(const VirtualFile this)\n"
    "lsAll(const VirtualFile this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::ls_all\n"
    "//       Access: Published\n"
    "//  Description: If the file represents a directory, recursively lists\n"
    "//               its contents and those of all subdirectories.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_ls_all_955_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > VirtualFile::read_file(bool auto_unwrap) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_read_file_956(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > VirtualFile::read_file(bool auto_unwrap) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_unwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:readFile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:readFile", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = ((const VirtualFile*)local_this)->read_file((PyObject_IsTrue(param1)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readFile(const VirtualFile this, bool auto_unwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_read_file_956_comment =
    "C++ Interface:\n"
    "readFile(const VirtualFile this, bool auto_unwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::read_file\n"
    "//       Access: Public\n"
    "//  Description: Returns the entire contents of the file as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::read_file\n"
    "//       Access: Public\n"
    "//  Description: Fills up the indicated string with the contents of\n"
    "//               the file, if it is a regular file.  Returns true on\n"
    "//               success, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::read_file\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Fills up the indicated pvector with the contents of\n"
    "//               the file, if it is a regular file.  Returns true on\n"
    "//               success, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_read_file_956_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual istream *VirtualFile::open_read_file(bool auto_unwrap) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_open_read_file_957(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual istream *VirtualFile::open_read_file(bool auto_unwrap) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_unwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadFile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:openReadFile", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            istream *return_value = ((const VirtualFile*)local_this)->open_read_file((PyObject_IsTrue(param1)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openReadFile(const VirtualFile this, bool auto_unwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_open_read_file_957_comment =
    "C++ Interface:\n"
    "openReadFile(const VirtualFile this, bool auto_unwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::open_read_file\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Opens the file for reading.  Returns a newly\n"
    "//               allocated istream on success (which you should\n"
    "//               eventually delete when you are done reading).\n"
    "//               Returns NULL on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_open_read_file_957_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualFile::close_read_file(istream *stream) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_close_read_file_958(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void VirtualFile::close_read_file(istream *stream) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:closeReadFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:closeReadFile", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "VirtualFile.closeReadFile", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    ((const VirtualFile*)local_this)->close_read_file(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeReadFile(const VirtualFile this, non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_close_read_file_958_comment =
    "C++ Interface:\n"
    "closeReadFile(const VirtualFile this, non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::close_read_file\n"
    "//       Access: Public\n"
    "//  Description: Closes a file opened by a previous call to\n"
    "//               open_read_file().  This really just deletes the\n"
    "//               istream pointer, but it is recommended to use this\n"
    "//               interface instead of deleting it explicitly, to help\n"
    "//               work around compiler issues.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_close_read_file_958_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool VirtualFile::was_read_successful(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_was_read_successful_959(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool VirtualFile::was_read_successful(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":wasReadSuccessful", key_word_list));
        else
            (PyArg_Parse(args, ":wasReadSuccessful"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VirtualFile*)local_this)->was_read_successful();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wasReadSuccessful(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_was_read_successful_959_comment =
    "C++ Interface:\n"
    "wasReadSuccessful(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::was_read_successful\n"
    "//       Access: Public\n"
    "//  Description: Call this method after a reading the istream returned\n"
    "//               by open_read_file() to completion.  If it returns\n"
    "//               true, the file was read completely and without error;\n"
    "//               if it returns false, there may have been some errors\n"
    "//               or a truncated file read.  This is particularly\n"
    "//               likely if the stream is a VirtualFileHTTP.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_was_read_successful_959_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int VirtualFile::get_file_size(void) const
 * virtual int VirtualFile::get_file_size(istream *stream) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_file_size_960(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual int VirtualFile::get_file_size(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileSize", key_word_list));
            else
                (PyArg_Parse(args, ":getFileSize"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                int return_value = ((const VirtualFile*)local_this)->get_file_size();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual int VirtualFile::get_file_size(istream *stream) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFileSize", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getFileSize", &param1));
                if(!PyErr_Occurred())
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "VirtualFile.getFileSize", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        int return_value = ((const VirtualFile*)local_this)->get_file_size(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getFileSize() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getFileSize(const VirtualFile this)\n"
          "getFileSize(const VirtualFile this, non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_file_size_960_comment =
    "C++ Interface:\n"
    "getFileSize(const VirtualFile this)\n"
    "getFileSize(const VirtualFile this, non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::get_file_size\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the current size on disk (or wherever it is)\n"
    "//               of the already-open file.  Pass in the stream that\n"
    "//               was returned by open_read_file(); some\n"
    "//               implementations may require this stream to determine\n"
    "//               the size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::get_file_size\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the current size on disk (or wherever it is)\n"
    "//               of the file before it has been opened.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_get_file_size_960_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual unsigned int VirtualFile::get_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_timestamp_961(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual unsigned int VirtualFile::get_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getTimestamp"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned int return_value = ((const VirtualFile*)local_this)->get_timestamp();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimestamp(const VirtualFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_timestamp_961_comment =
    "C++ Interface:\n"
    "getTimestamp(const VirtualFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFile::get_timestamp\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns a time_t value that represents the time the\n"
    "//               file was last modified, to within whatever precision\n"
    "//               the operating system records this information (on a\n"
    "//               Windows95 system, for instance, this may only be\n"
    "//               accurate to within 2 seconds).\n"
    "//\n"
    "//               If the timestamp cannot be determined, either because\n"
    "//               it is not supported by the operating system or\n"
    "//               because there is some error (such as file not found),\n"
    "//               returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFile_get_timestamp_961_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFile::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFile_get_class_type_962(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFile::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFile::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFile_get_class_type_962_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFile_get_class_type_962_comment = NULL;
#endif

int  Dtool_Init_VirtualFile(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFile)");
       return -1;
}
inline void  * Dtool_UpcastInterface_VirtualFile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFile)
    {
        printf("VirtualFile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFile * local_this = (VirtualFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFile)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFile)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFile*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFile*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFile*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileComposite 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileComposite::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileComposite_get_class_type_965(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileComposite::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileComposite::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileComposite_get_class_type_965_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileComposite_get_class_type_965_comment = NULL;
#endif

int  Dtool_Init_VirtualFileComposite(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFileComposite)");
       return -1;
}
inline void  * Dtool_UpcastInterface_VirtualFileComposite(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileComposite)
    {
        printf("VirtualFileComposite ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileComposite * local_this = (VirtualFileComposite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileComposite)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_VirtualFile)
        return ( VirtualFile *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileComposite(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileComposite)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileComposite*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileComposite*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileComposite*)other_this;
    }
    if(from_type == &Dtool_VirtualFile)
    {
          VirtualFile* other_this = (VirtualFile*)from_this;
          return (VirtualFileComposite*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileMount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_get_file_system_968(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFileSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getFileSystem"));
        if(!PyErr_Occurred())
        {
            VirtualFileSystem *return_value = ((const VirtualFileMount*)local_this)->get_file_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_VirtualFileSystem,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFileSystem(const VirtualFileMount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_get_file_system_968_comment =
    "C++ Interface:\n"
    "getFileSystem(const VirtualFileMount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMount::get_file_system\n"
    "//       Access: Public\n"
    "//  Description: Returns the file system this mount object is attached\n"
    "//               to.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMount_get_file_system_968_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &VirtualFileMount::get_mount_point(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_get_mount_point_969(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &VirtualFileMount::get_mount_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMountPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getMountPoint"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const VirtualFileMount*)local_this)->get_mount_point());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMountPoint(const VirtualFileMount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_get_mount_point_969_comment =
    "C++ Interface:\n"
    "getMountPoint(const VirtualFileMount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMount::get_mount_point\n"
    "//       Access: Public\n"
    "//  Description: Returns the name of the directory within the virtual\n"
    "//               file system that this mount object is attached to.\n"
    "//               This directory name will end with a slash.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMount_get_mount_point_969_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int VirtualFileMount::get_mount_flags(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_get_mount_flags_970(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int VirtualFileMount::get_mount_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMountFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getMountFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const VirtualFileMount*)local_this)->get_mount_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMountFlags(const VirtualFileMount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_get_mount_flags_970_comment =
    "C++ Interface:\n"
    "getMountFlags(const VirtualFileMount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMount::get_mount_flags\n"
    "//       Access: Public\n"
    "//  Description: Returns the set of flags passed by the user to the\n"
    "//               VirtualFileSystem::mount() command.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMount_get_mount_flags_970_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void VirtualFileMount::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_output_971(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void VirtualFileMount::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFileMount.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFileMount*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const VirtualFileMount this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_output_971_comment =
    "C++ Interface:\n"
    "output(const VirtualFileMount this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMount::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMount_output_971_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void VirtualFileMount::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_write_972(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void VirtualFileMount::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFileMount.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFileMount*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const VirtualFileMount this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_write_972_comment =
    "C++ Interface:\n"
    "write(const VirtualFileMount this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMount::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMount_write_972_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileMount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileMount_get_class_type_973(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileMount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileMount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMount_get_class_type_973_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileMount_get_class_type_973_comment = NULL;
#endif

int  Dtool_Init_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFileMount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileMount)
    {
        printf("VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileMount * local_this = (VirtualFileMount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileMount)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileMount)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileMount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileMount*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileMount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ISubStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline ISubStream &ISubStream::open(IStreamWrapper *source, unsigned long int start, unsigned long int end)
 *******************************************************************/
static PyObject *Dtool_ISubStream_open_976(PyObject *self, PyObject *args,PyObject *kwds) {
    ISubStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISubStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline ISubStream &ISubStream::open(IStreamWrapper *source, unsigned long int start, unsigned long int end)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"source", (char *)"start", (char *)"end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:open", key_word_list, &param1, &param2, &param3))
            {
                IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_IStreamWrapper, 1, "ISubStream.open", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param1_this == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
                {
                    ISubStream *return_value = &((local_this)->open(param1_this, PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint)));
                     Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_ISubStream,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ISubStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const ISubStream this, non-const IStreamWrapper source, unsigned int start, unsigned int end)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISubStream_open_976_comment =
    "C++ Interface:\n"
    "open(non-const ISubStream this, non-const IStreamWrapper source, unsigned int start, unsigned int end)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ISubStream::open\n"
    "//       Access: Public\n"
    "//  Description: Starts the SubStream reading from the indicated\n"
    "//               source, with the first character being the character\n"
    "//               at position \"start\" within the source, for end -\n"
    "//               start total characters.  The character at \"end\"\n"
    "//               within the source will never be read; this will\n"
    "//               appear to be EOF.\n"
    "//\n"
    "//               If end is zero, it indicates that the ISubStream will\n"
    "//               continue until the end of the source stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ISubStream_open_976_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ISubStream &ISubStream::close(void)
 *******************************************************************/
static PyObject *Dtool_ISubStream_close_977(PyObject *self, PyObject *args,PyObject *kwds) {
    ISubStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ISubStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline ISubStream &ISubStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            ISubStream *return_value = &((local_this)->close());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ISubStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ISubStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const ISubStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ISubStream_close_977_comment =
    "C++ Interface:\n"
    "close(non-const ISubStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ISubStream::close\n"
    "//       Access: Public\n"
    "//  Description: Resets the SubStream to empty, but does not actually\n"
    "//               close the source istream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ISubStream_close_977_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ISubStream::ISubStream(void)
 * inline ISubStream::ISubStream(IStreamWrapper *source, unsigned long int start, unsigned long int end)
 *******************************************************************/
int  Dtool_Init_ISubStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ISubStream::ISubStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ISubStream", key_word_list))
            {
                ISubStream *return_value = new ISubStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ISubStream,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline ISubStream::ISubStream(IStreamWrapper *source, unsigned long int start, unsigned long int end)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"source", (char *)"start", (char *)"end", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:ISubStream", key_word_list, &param0, &param1, &param2))
                {
                    IStreamWrapper *param0_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_IStreamWrapper, 0, "ISubStream.ISubStream", 0, coerced_ptr, report_errors);
 PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param0_this == NULL)|| (param1_uint == NULL)|| (param2_uint == NULL)))
                    {
                        ISubStream *return_value = new ISubStream(param0_this, PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ISubStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ISubStream() takes 0 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ISubStream()\n"
          "ISubStream(non-const IStreamWrapper source, unsigned int start, unsigned int end)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ISubStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ISubStream)
    {
        printf("ISubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ISubStream * local_this = (ISubStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ISubStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ISubStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ISubStream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (ISubStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Multifile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool Multifile::open_read(Filename const &multifile_name, int const &offset)
 * bool Multifile::open_read(Filename const &multifile_name, int const &offset = (0))
 * bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer, int const &offset)
 * bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer, int const &offset = (0))
 * bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = (0), int const &offset = (0))
 *******************************************************************/
static PyObject *Dtool_Multifile_open_read_981(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = (0), int const &offset = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openRead", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openRead", &param1));
                if(!PyErr_Occurred())
                {
                    IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_IStreamWrapper, 1, "Multifile.openRead", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read(Filename const &multifile_name, int const &offset = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openRead", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openRead", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.openRead", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer, int const &offset = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"multifile_stream", (char *)"owns_pointer", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openRead", key_word_list, &param1, &param2))
                {
                    IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_IStreamWrapper, 1, "Multifile.openRead", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read(param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read(Filename const &multifile_name, int const &offset)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"multifile_name", (char *)"offset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:openRead", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.openRead", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer, int const &offset)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"multifile_stream", (char *)"owns_pointer", (char *)"offset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:openRead", key_word_list, &param1, &param2, &param3))
                {
                    IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_IStreamWrapper, 1, "Multifile.openRead", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read(param1_this, (PyObject_IsTrue(param2)!=0), (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.openRead() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openRead() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream)\n"
          "openRead(non-const Multifile this, const Filename multifile_name)\n"
          "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream, bool owns_pointer)\n"
          "openRead(non-const Multifile this, const Filename multifile_name, int offset)\n"
          "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream, bool owns_pointer, int offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_open_read_981_comment =
    "C++ Interface:\n"
    "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream)\n"
    "openRead(non-const Multifile this, const Filename multifile_name)\n"
    "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream, bool owns_pointer)\n"
    "openRead(non-const Multifile this, const Filename multifile_name, int offset)\n"
    "openRead(non-const Multifile this, non-const IStreamWrapper multifile_stream, bool owns_pointer, int offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read\n"
    "//       Access: Published\n"
    "//  Description: Opens the named Multifile on disk for reading.  The\n"
    "//               Multifile index is read in, and the list of subfiles\n"
    "//               becomes available; individual subfiles may then be\n"
    "//               extracted or read, but the list of subfiles may not\n"
    "//               be modified.\n"
    "//\n"
    "//               Also see the version of open_read() which accepts an\n"
    "//               istream.  Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read\n"
    "//       Access: Public\n"
    "//  Description: Opens an anonymous Multifile for reading using an\n"
    "//               istream.  There must be seek functionality via\n"
    "//               seekg() and tellg() on the istream.\n"
    "//\n"
    "//               If owns_pointer is true, then the Multifile assumes\n"
    "//               ownership of the stream pointer and will delete it\n"
    "//               when the multifile is closed, including if this\n"
    "//               function returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_open_read_981_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::open_write(Filename const &multifile_name)
 * bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer)
 * bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer = (0))
 *******************************************************************/
static PyObject *Dtool_Multifile_open_write_982(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openWrite", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Multifile.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_write(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_write(Filename const &multifile_name)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openWrite", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.openWrite", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"multifile_stream", (char *)"owns_pointer", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openWrite", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Multifile.openWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_write(param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.openWrite() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openWrite() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openWrite(non-const Multifile this, non-const Ostream multifile_stream)\n"
          "openWrite(non-const Multifile this, const Filename multifile_name)\n"
          "openWrite(non-const Multifile this, non-const Ostream multifile_stream, bool owns_pointer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_open_write_982_comment =
    "C++ Interface:\n"
    "openWrite(non-const Multifile this, non-const Ostream multifile_stream)\n"
    "openWrite(non-const Multifile this, const Filename multifile_name)\n"
    "openWrite(non-const Multifile this, non-const Ostream multifile_stream, bool owns_pointer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_write\n"
    "//       Access: Published\n"
    "//  Description: Opens the named Multifile on disk for writing.  If\n"
    "//               there already exists a file by that name, it is\n"
    "//               truncated.  The Multifile is then prepared for\n"
    "//               accepting a brand new set of subfiles, which will be\n"
    "//               written to the indicated filename.  Individual\n"
    "//               subfiles may not be extracted or read.\n"
    "//\n"
    "//               Also see the version of open_write() which accepts an\n"
    "//               ostream.  Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_write\n"
    "//       Access: Public\n"
    "//  Description: Opens an anonymous Multifile for writing using an\n"
    "//               ostream.  There must be seek functionality via\n"
    "//               seekp() and tellp() on the pstream.\n"
    "//\n"
    "//               If owns_pointer is true, then the Multifile assumes\n"
    "//               ownership of the stream pointer and will delete it\n"
    "//               when the multifile is closed, including if this\n"
    "//               function returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_open_write_982_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::open_read_write(Filename const &multifile_name)
 * bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer)
 * bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer = (0))
 *******************************************************************/
static PyObject *Dtool_Multifile_open_read_write_983(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_stream", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openReadWrite", &param1));
                if(!PyErr_Occurred())
                {
                    iostream *param1_this = (iostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_iostream, 1, "Multifile.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read_write(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool Multifile::open_read_write(Filename const &multifile_name)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"multifile_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:openReadWrite", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:openReadWrite", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.openReadWrite", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read_write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"multifile_stream", (char *)"owns_pointer", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openReadWrite", key_word_list, &param1, &param2))
                {
                    iostream *param1_this = (iostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_iostream, 1, "Multifile.openReadWrite", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->open_read_write(param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.openReadWrite() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openReadWrite() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openReadWrite(non-const Multifile this, non-const Iostream multifile_stream)\n"
          "openReadWrite(non-const Multifile this, const Filename multifile_name)\n"
          "openReadWrite(non-const Multifile this, non-const Iostream multifile_stream, bool owns_pointer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_open_read_write_983_comment =
    "C++ Interface:\n"
    "openReadWrite(non-const Multifile this, non-const Iostream multifile_stream)\n"
    "openReadWrite(non-const Multifile this, const Filename multifile_name)\n"
    "openReadWrite(non-const Multifile this, non-const Iostream multifile_stream, bool owns_pointer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read_write\n"
    "//       Access: Published\n"
    "//  Description: Opens the named Multifile on disk for reading and\n"
    "//               writing.  If there already exists a file by that\n"
    "//               name, its index is read.  Subfiles may be added or\n"
    "//               removed, and the resulting changes will be written to\n"
    "//               the named file.\n"
    "//\n"
    "//               Also see the version of open_read_write() which\n"
    "//               accepts an iostream.  Returns true on success, false\n"
    "//               on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read_write\n"
    "//       Access: Public\n"
    "//  Description: Opens an anonymous Multifile for reading and writing\n"
    "//               using an iostream.  There must be seek functionality\n"
    "//               via seekg()/seekp() and tellg()/tellp() on the\n"
    "//               iostream.\n"
    "//\n"
    "//               If owns_pointer is true, then the Multifile assumes\n"
    "//               ownership of the stream pointer and will delete it\n"
    "//               when the multifile is closed, including if this\n"
    "//               function returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_open_read_write_983_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::close(void)
 *******************************************************************/
static PyObject *Dtool_Multifile_close_984(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Multifile::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->close();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_close_984_comment =
    "C++ Interface:\n"
    "close(non-const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::close\n"
    "//       Access: Published\n"
    "//  Description: Closes the Multifile if it is open.  All changes are\n"
    "//               flushed to disk, and the file becomes invalid for\n"
    "//               further operations until the next call to open().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_close_984_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &Multifile::get_multifile_name(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_multifile_name_985(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &Multifile::get_multifile_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMultifileName", key_word_list));
        else
            (PyArg_Parse(args, ":getMultifileName"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const Multifile*)local_this)->get_multifile_name());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMultifileName(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_multifile_name_985_comment =
    "C++ Interface:\n"
    "getMultifileName(const Multifile this)\n"
    "\n"
    "// Filename: multifile.I\n"
    "// Created by:  mike (09Jan97)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_multifile_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the filename of the Multifile, if it is\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_multifile_name_985_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_multifile_name(Filename const &multifile_name)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_multifile_name_986(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Multifile::set_multifile_name(Filename const &multifile_name)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"multifile_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMultifileName", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMultifileName", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.setMultifileName", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_multifile_name(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Multifile.setMultifileName() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMultifileName(non-const Multifile this, const Filename multifile_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_multifile_name_986_comment =
    "C++ Interface:\n"
    "setMultifileName(non-const Multifile this, const Filename multifile_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_multifile_name\n"
    "//       Access: Published\n"
    "//  Description: Replaces the filename of the Multifile.  This is\n"
    "//               primarily used for documentation purposes only;\n"
    "//               changing this name does not open the indicated file.\n"
    "//               See open_read() or open_write() for that.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_multifile_name_986_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::is_read_valid(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_is_read_valid_987(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Multifile::is_read_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isReadValid", key_word_list));
        else
            (PyArg_Parse(args, ":isReadValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->is_read_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isReadValid(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_is_read_valid_987_comment =
    "C++ Interface:\n"
    "isReadValid(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::is_read_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Multifile has been opened for\n"
    "//               read mode and there have been no errors, and\n"
    "//               individual Subfile contents may be extracted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_is_read_valid_987_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::is_write_valid(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_is_write_valid_988(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Multifile::is_write_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWriteValid", key_word_list));
        else
            (PyArg_Parse(args, ":isWriteValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->is_write_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWriteValid(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_is_write_valid_988_comment =
    "C++ Interface:\n"
    "isWriteValid(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::is_write_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Multifile has been opened for\n"
    "//               write mode and there have been no errors, and\n"
    "//               Subfiles may be added or removed from the Multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_is_write_valid_988_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::needs_repack(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_needs_repack_989(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Multifile::needs_repack(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":needsRepack", key_word_list));
        else
            (PyArg_Parse(args, ":needsRepack"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->needs_repack();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "needsRepack(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_needs_repack_989_comment =
    "C++ Interface:\n"
    "needsRepack(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::needs_repack\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Multifile index is suboptimal and\n"
    "//               should be repacked.  Call repack() to achieve this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_needs_repack_989_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Multifile::get_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_timestamp_990(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Multifile::get_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getTimestamp"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Multifile*)local_this)->get_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimestamp(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_timestamp_990_comment =
    "C++ Interface:\n"
    "getTimestamp(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Returns the modification timestamp of the overall\n"
    "//               Multifile.  This indicates the most recent date at\n"
    "//               which subfiles were added or removed from the\n"
    "//               Multifile.  Note that it is logically possible for an\n"
    "//               individual subfile to have a more recent timestamp\n"
    "//               than the overall timestamp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_timestamp_990_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_record_timestamp(bool record_timestamp)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_record_timestamp_991(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_record_timestamp(bool record_timestamp)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"record_timestamp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRecordTimestamp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRecordTimestamp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_record_timestamp((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setRecordTimestamp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRecordTimestamp(non-const Multifile this, bool record_timestamp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_record_timestamp_991_comment =
    "C++ Interface:\n"
    "setRecordTimestamp(non-const Multifile this, bool record_timestamp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_record_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating whether timestamps should be\n"
    "//               recorded within the Multifile or not.  The default is\n"
    "//               true, indicating the Multifile will record timestamps\n"
    "//               for the overall file and also for each subfile.  \n"
    "//\n"
    "//               If this is false, the Multifile will not record\n"
    "//               timestamps internally.  In this case, the return\n"
    "//               value from get_timestamp() or get_subfile_timestamp()\n"
    "//               will be estimations.\n"
    "//\n"
    "//               You may want to set this false to minimize the\n"
    "//               bitwise difference between independently-generated\n"
    "//               Multifiles.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_record_timestamp_991_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::get_record_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_record_timestamp_992(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Multifile::get_record_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRecordTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getRecordTimestamp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->get_record_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRecordTimestamp(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_record_timestamp_992_comment =
    "C++ Interface:\n"
    "getRecordTimestamp(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_record_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag indicating whether timestamps\n"
    "//               should be recorded within the Multifile or not.  See\n"
    "//               set_record_timestamp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_record_timestamp_992_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::set_scale_factor(unsigned int scale_factor)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_scale_factor_993(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Multifile::set_scale_factor(unsigned int scale_factor)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"scale_factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScaleFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setScaleFactor", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_scale_factor(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setScaleFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScaleFactor(non-const Multifile this, unsigned int scale_factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_scale_factor_993_comment =
    "C++ Interface:\n"
    "setScaleFactor(non-const Multifile this, unsigned int scale_factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_scale_factor\n"
    "//       Access: Published\n"
    "//  Description: Changes the internal scale factor for this Multifile.\n"
    "//\n"
    "//               This is normally 1, but it may be set to any\n"
    "//               arbitrary value (greater than zero) to support\n"
    "//               Multifile archives that exceed 4GB, if necessary.\n"
    "//               (Individual subfiles may still not exceed 4GB.)\n"
    "//\n"
    "//               All addresses within the file are rounded up to the\n"
    "//               next multiple of _scale_factor, and zeros are written\n"
    "//               to the file to fill the resulting gaps.  Then the\n"
    "//               address is divided by _scale_factor and written out\n"
    "//               as a 32-bit integer.  Thus, setting a scale factor of\n"
    "//               2 supports up to 8GB files, 3 supports 12GB files,\n"
    "//               etc.\n"
    "//\n"
    "//               Calling this function on an already-existing\n"
    "//               Multifile will have no immediate effect until a\n"
    "//               future call to repack() or close() (or until the\n"
    "//               Multifile is destructed).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_scale_factor_993_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Multifile::get_scale_factor(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_scale_factor_994(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Multifile::get_scale_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScaleFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getScaleFactor"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Multifile*)local_this)->get_scale_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScaleFactor(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_scale_factor_994_comment =
    "C++ Interface:\n"
    "getScaleFactor(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_scale_factor\n"
    "//       Access: Published\n"
    "//  Description: Returns the internal scale factor for this Multifile.\n"
    "//               See set_scale_factor().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_scale_factor_994_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_encryption_flag(bool flag)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_encryption_flag_995(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_encryption_flag(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEncryptionFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setEncryptionFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encryption_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setEncryptionFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncryptionFlag(non-const Multifile this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_encryption_flag_995_comment =
    "C++ Interface:\n"
    "setEncryptionFlag(non-const Multifile this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_encryption_flag\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating whether subsequently-added\n"
    "//               subfiles should be encrypted before writing them to\n"
    "//               the multifile.  If true, subfiles will be encrypted;\n"
    "//               if false (the default), they will be written without\n"
    "//               encryption.\n"
    "//\n"
    "//               When true, subfiles will be encrypted with the\n"
    "//               password specified by set_encryption_password().  It\n"
    "//               is possible to apply a different password to\n"
    "//               different files, but the resulting file can't be\n"
    "//               mounted via VFS.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_encryption_flag_995_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::get_encryption_flag(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_encryption_flag_996(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Multifile::get_encryption_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncryptionFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getEncryptionFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->get_encryption_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncryptionFlag(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_encryption_flag_996_comment =
    "C++ Interface:\n"
    "getEncryptionFlag(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_encryption_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag indicating whether\n"
    "//               subsequently-added subfiles should be encrypted\n"
    "//               before writing them to the multifile.  See\n"
    "//               set_encryption_flag().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_encryption_flag_996_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_encryption_password(basic_string< char > const &encryption_password)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_encryption_password_997(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_encryption_password(basic_string< char > const &encryption_password)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"encryption_password", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setEncryptionPassword", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setEncryptionPassword", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encryption_password(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setEncryptionPassword() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncryptionPassword(non-const Multifile this, string encryption_password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_encryption_password_997_comment =
    "C++ Interface:\n"
    "setEncryptionPassword(non-const Multifile this, string encryption_password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_encryption_password\n"
    "//       Access: Published\n"
    "//  Description: Specifies the password that will be used to encrypt\n"
    "//               subfiles subsequently added to the multifile, if the\n"
    "//               encryption flag is also set true (see\n"
    "//               set_encryption_flag()).\n"
    "//\n"
    "//               It is possible to apply a different password to\n"
    "//               different files, but the resulting file can't be\n"
    "//               mounted via VFS.  Changing this value may cause an\n"
    "//               implicit call to flush().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_encryption_password_997_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Multifile::get_encryption_password(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_encryption_password_998(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Multifile::get_encryption_password(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncryptionPassword", key_word_list));
        else
            (PyArg_Parse(args, ":getEncryptionPassword"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Multifile*)local_this)->get_encryption_password();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncryptionPassword(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_encryption_password_998_comment =
    "C++ Interface:\n"
    "getEncryptionPassword(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_encryption_password\n"
    "//       Access: Published\n"
    "//  Description: Returns the password that will be used to encrypt\n"
    "//               subfiles subsequently added to the multifile.  See\n"
    "//               set_encryption_password().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_encryption_password_998_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_encryption_algorithm(basic_string< char > const &encryption_algorithm)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_encryption_algorithm_999(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_encryption_algorithm(basic_string< char > const &encryption_algorithm)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"encryption_algorithm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setEncryptionAlgorithm", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setEncryptionAlgorithm", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encryption_algorithm(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setEncryptionAlgorithm() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncryptionAlgorithm(non-const Multifile this, string encryption_algorithm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_encryption_algorithm_999_comment =
    "C++ Interface:\n"
    "setEncryptionAlgorithm(non-const Multifile this, string encryption_algorithm)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_encryption_algorithm\n"
    "//       Access: Public\n"
    "//  Description: Specifies the encryption algorithm that should be\n"
    "//               used for future calls to add_subfile().  The default\n"
    "//               is whatever is specified by the encryption-algorithm\n"
    "//               config variable.  The complete set of available\n"
    "//               algorithms is defined by the current version of\n"
    "//               OpenSSL.\n"
    "//\n"
    "//               If an invalid algorithm is specified, there is no\n"
    "//               immediate error return code, but flush() will fail\n"
    "//               and the file will be invalid.\n"
    "//\n"
    "//               It is possible to apply a different encryption\n"
    "//               algorithm to different files, and unlike the\n"
    "//               password, this does not interfere with mounting the\n"
    "//               multifile via VFS.  Changing this value may cause an\n"
    "//               implicit call to flush().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_encryption_algorithm_999_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Multifile::get_encryption_algorithm(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_encryption_algorithm_1000(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Multifile::get_encryption_algorithm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncryptionAlgorithm", key_word_list));
        else
            (PyArg_Parse(args, ":getEncryptionAlgorithm"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Multifile*)local_this)->get_encryption_algorithm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncryptionAlgorithm(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_encryption_algorithm_1000_comment =
    "C++ Interface:\n"
    "getEncryptionAlgorithm(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_encryption_algorithm\n"
    "//       Access: Public\n"
    "//  Description: Returns the encryption algorithm that was specified\n"
    "//               by set_encryption_algorithm().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_encryption_algorithm_1000_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_encryption_key_length(int encryption_key_length)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_encryption_key_length_1001(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_encryption_key_length(int encryption_key_length)
        int param1;
        static char * key_word_list[] = {(char *)"encryption_key_length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setEncryptionKeyLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setEncryptionKeyLength", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encryption_key_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setEncryptionKeyLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncryptionKeyLength(non-const Multifile this, int encryption_key_length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_encryption_key_length_1001_comment =
    "C++ Interface:\n"
    "setEncryptionKeyLength(non-const Multifile this, int encryption_key_length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_encryption_key_length\n"
    "//       Access: Public\n"
    "//  Description: Specifies the length of the key, in bits, that should\n"
    "//               be used to encrypt the stream in future calls to\n"
    "//               add_subfile().  The default is whatever is specified\n"
    "//               by the encryption-key-length config variable.  \n"
    "//\n"
    "//               If an invalid key_length for the chosen algorithm is\n"
    "//               specified, there is no immediate error return code,\n"
    "//               but flush() will fail and the file will be invalid.\n"
    "//\n"
    "//               It is possible to apply a different key length to\n"
    "//               different files, and unlike the password, this does\n"
    "//               not interfere with mounting the multifile via VFS.\n"
    "//               Changing this value may cause an implicit call to\n"
    "//               flush().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_encryption_key_length_1001_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Multifile::get_encryption_key_length(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_encryption_key_length_1002(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Multifile::get_encryption_key_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncryptionKeyLength", key_word_list));
        else
            (PyArg_Parse(args, ":getEncryptionKeyLength"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_encryption_key_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncryptionKeyLength(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_encryption_key_length_1002_comment =
    "C++ Interface:\n"
    "getEncryptionKeyLength(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_encryption_key_length\n"
    "//       Access: Public\n"
    "//  Description: Returns the encryption key length, in bits, that was\n"
    "//               specified by set_encryption_key_length().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_encryption_key_length_1002_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_encryption_iteration_count_1003(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
        int param1;
        static char * key_word_list[] = {(char *)"encryption_iteration_count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setEncryptionIterationCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setEncryptionIterationCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_encryption_iteration_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setEncryptionIterationCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEncryptionIterationCount(non-const Multifile this, int encryption_iteration_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_encryption_iteration_count_1003_comment =
    "C++ Interface:\n"
    "setEncryptionIterationCount(non-const Multifile this, int encryption_iteration_count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_encryption_iteration_count\n"
    "//       Access: Public\n"
    "//  Description: Specifies the number of times to repeatedly hash the\n"
    "//               key before writing it to the stream in future calls\n"
    "//               to add_subfile().  Its purpose is to make it\n"
    "//               computationally more expensive for an attacker to\n"
    "//               search the key space exhaustively.  This should be a\n"
    "//               multiple of 1,000 and should not exceed about 65\n"
    "//               million; the value 0 indicates just one application\n"
    "//               of the hashing algorithm.\n"
    "//\n"
    "//               The default is whatever is specified by the\n"
    "//               multifile-encryption-iteration-count config variable.\n"
    "//\n"
    "//               It is possible to apply a different iteration count\n"
    "//               to different files, and unlike the password, this\n"
    "//               does not interfere with mounting the multifile via\n"
    "//               VFS.  Changing this value causes an implicit call to\n"
    "//               flush().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_encryption_iteration_count_1003_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Multifile::get_encryption_iteration_count(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_encryption_iteration_count_1004(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Multifile::get_encryption_iteration_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEncryptionIterationCount", key_word_list));
        else
            (PyArg_Parse(args, ":getEncryptionIterationCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_encryption_iteration_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEncryptionIterationCount(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_encryption_iteration_count_1004_comment =
    "C++ Interface:\n"
    "getEncryptionIterationCount(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_encryption_iteration_count\n"
    "//       Access: Public\n"
    "//  Description: Returns the value that was specified by\n"
    "//               set_encryption_iteration_count().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_encryption_iteration_count_1004_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Multifile::add_subfile(basic_string< char > const &subfile_name, Filename const &filename, int compression_level)
 * basic_string< char > Multifile::add_subfile(basic_string< char > const &subfile_name, istream *subfile_data, int compression_level)
 *******************************************************************/
static PyObject *Dtool_Multifile_add_subfile_1005(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 basic_string< char > Multifile::add_subfile(basic_string< char > const &subfile_name, istream *subfile_data, int compression_level)
            char *param1_str; int param1_len;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"subfile_name", (char *)"subfile_data", (char *)"compression_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oi:addSubfile", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                istream *param2_this = (istream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_istream, 2, "Multifile.addSubfile", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    basic_string< char > return_value = (local_this)->add_subfile(basic_string<char>(param1_str, param1_len), param2_this, (int)param3);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 basic_string< char > Multifile::add_subfile(basic_string< char > const &subfile_name, Filename const &filename, int compression_level)
            char *param1_str; int param1_len;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"subfile_name", (char *)"filename", (char *)"compression_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oi:addSubfile", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.addSubfile", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    basic_string< char > return_value = (local_this)->add_subfile(basic_string<char>(param1_str, param1_len), *param2_this, (int)param3);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSubfile(non-const Multifile this, string subfile_name, non-const Istream subfile_data, int compression_level)\n"
          "addSubfile(non-const Multifile this, string subfile_name, const Filename filename, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_add_subfile_1005_comment =
    "C++ Interface:\n"
    "addSubfile(non-const Multifile this, string subfile_name, non-const Istream subfile_data, int compression_level)\n"
    "addSubfile(non-const Multifile this, string subfile_name, const Filename filename, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_subfile\n"
    "//       Access: Published\n"
    "//  Description: Adds a file on disk as a subfile to the Multifile.\n"
    "//               The file named by filename will be read and added to\n"
    "//               the Multifile at the next call to flush().  If there\n"
    "//               already exists a subfile with the indicated name, it\n"
    "//               is replaced without examining its contents (but see\n"
    "//               also update_subfile).\n"
    "//\n"
    "//               Returns the subfile name on success (it might have\n"
    "//               been modified slightly), or empty string on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_subfile\n"
    "//       Access: Public\n"
    "//  Description: Adds a file from a stream as a subfile to the Multifile.\n"
    "//               The indicated istream will be read and its contents\n"
    "//               added to the Multifile at the next call to flush().\n"
    "//\n"
    "//               Note that the istream must remain untouched and\n"
    "//               unused by any other code until flush() is called.  At\n"
    "//               that time, the Multifile will read the entire\n"
    "//               contents of the istream from the current file\n"
    "//               position to the end of the file.  Subsequently, the\n"
    "//               Multifile will *not* close or delete the istream.  It\n"
    "//               is the caller's responsibility to ensure that the\n"
    "//               istream pointer does not destruct during the lifetime\n"
    "//               of the Multifile.\n"
    "//\n"
    "//               Returns the subfile name on success (it might have\n"
    "//               been modified slightly), or empty string on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_add_subfile_1005_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Multifile::update_subfile(basic_string< char > const &subfile_name, Filename const &filename, int compression_level)
 *******************************************************************/
static PyObject *Dtool_Multifile_update_subfile_1006(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > Multifile::update_subfile(basic_string< char > const &subfile_name, Filename const &filename, int compression_level)
            char *param1_str; int param1_len;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"subfile_name", (char *)"filename", (char *)"compression_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oi:updateSubfile", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.updateSubfile", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    basic_string< char > return_value = (local_this)->update_subfile(basic_string<char>(param1_str, param1_len), *param2_this, (int)param3);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Multifile.updateSubfile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateSubfile(non-const Multifile this, string subfile_name, const Filename filename, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_update_subfile_1006_comment =
    "C++ Interface:\n"
    "updateSubfile(non-const Multifile this, string subfile_name, const Filename filename, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::update_subfile\n"
    "//       Access: Published\n"
    "//  Description: Adds a file on disk to the subfile.  If a subfile\n"
    "//               already exists with the same name, its contents are\n"
    "//               compared byte-for-byte to the disk file, and it is\n"
    "//               replaced only if it is different; otherwise, the\n"
    "//               multifile is left unchanged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_update_subfile_1006_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, basic_string< char > const &password)
 * bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, basic_string< char > const &password = (""))
 * bool Multifile::add_signature(Filename const &composite, basic_string< char > const &password)
 * bool Multifile::add_signature(Filename const &composite, basic_string< char > const &password = (""))
 * Rejected Remap [bool Multifile::add_signature(vector< Multifile::CertRecord > const &chain, EVP_PKEY *pkey)]
 *******************************************************************/
static PyObject *Dtool_Multifile_add_signature_1009(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::add_signature(Filename const &composite, basic_string< char > const &password = (""))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"composite", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addSignature", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addSignature", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.addSignature", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->add_signature(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.addSignature() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::add_signature(Filename const &composite, basic_string< char > const &password)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"composite", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:addSignature", key_word_list, &param1, &param2_str, &param2_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.addSignature", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->add_signature(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.addSignature() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, basic_string< char > const &password = (""))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"certificate", (char *)"chain", (char *)"pkey", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:addSignature", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.addSignature", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.addSignature", 1, coerced_ptr, report_errors);
Filename *param3_this = (Filename *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Filename, 3, "Multifile.addSignature", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = (local_this)->add_signature(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.addSignature() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, basic_string< char > const &password)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                char *param4_str; int param4_len;
                static char * key_word_list[] = {(char *)"certificate", (char *)"chain", (char *)"pkey", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOs#:addSignature", key_word_list, &param1, &param2, &param3, &param4_str, &param4_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Multifile.addSignature", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.addSignature", 1, coerced_ptr, report_errors);
Filename *param3_this = (Filename *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Filename, 3, "Multifile.addSignature", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = (local_this)->add_signature(*param1_this, *param2_this, *param3_this, basic_string<char>(param4_str, param4_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Multifile.addSignature() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addSignature() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addSignature(non-const Multifile this, const Filename composite)\n"
          "addSignature(non-const Multifile this, const Filename composite, string password)\n"
          "addSignature(non-const Multifile this, const Filename certificate, const Filename chain, const Filename pkey)\n"
          "addSignature(non-const Multifile this, const Filename certificate, const Filename chain, const Filename pkey, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_add_signature_1009_comment =
    "C++ Interface:\n"
    "addSignature(non-const Multifile this, const Filename composite)\n"
    "addSignature(non-const Multifile this, const Filename composite, string password)\n"
    "addSignature(non-const Multifile this, const Filename certificate, const Filename chain, const Filename pkey)\n"
    "addSignature(non-const Multifile this, const Filename certificate, const Filename chain, const Filename pkey, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_signature\n"
    "//       Access: Published\n"
    "//  Description: Adds a new signature to the Multifile.  This\n"
    "//               signature associates the indicated certificate with\n"
    "//               the current contents of the Multifile.  When the\n"
    "//               Multifile is read later, the signature will still be\n"
    "//               present only if the Multifile is unchanged; any\n"
    "//               subsequent changes to the Multifile will\n"
    "//               automatically invalidate and remove the signature.\n"
    "//\n"
    "//               The chain filename may be empty if the certificate\n"
    "//               does not require an authenticating certificate chain\n"
    "//               (e.g. because it is self-signed).\n"
    "//\n"
    "//               The specified private key must match the certificate,\n"
    "//               and the Multifile must be open in read-write mode.\n"
    "//               The private key is only used for generating the\n"
    "//               signature; it is not written to the Multifile and\n"
    "//               cannot be retrieved from the Multifile later.\n"
    "//               (However, the certificate *can* be retrieved from the\n"
    "//               Multifile later, to identify the entity that created\n"
    "//               the signature.)\n"
    "//\n"
    "//               This implicitly causes a repack() operation if one is\n"
    "//               needed.  Returns true on success, false on failure.\n"
    "//\n"
    "//               This flavor of add_signature() reads the certificate\n"
    "//               and private key from a PEM-formatted file, for\n"
    "//               instance as generated by the openssl command.  If the\n"
    "//               private key file is password-encrypted, the third\n"
    "//               parameter will be used as the password to decrypt it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_signature\n"
    "//       Access: Published\n"
    "//  Description: Adds a new signature to the Multifile.  This\n"
    "//               signature associates the indicated certificate with\n"
    "//               the current contents of the Multifile.  When the\n"
    "//               Multifile is read later, the signature will still be\n"
    "//               present only if the Multifile is unchanged; any\n"
    "//               subsequent changes to the Multifile will\n"
    "//               automatically invalidate and remove the signature.\n"
    "//\n"
    "//               This flavor of add_signature() reads the certificate,\n"
    "//               private key, and certificate chain from the same\n"
    "//               PEM-formatted file.  It takes the first private key\n"
    "//               found as the intended key, and then uses the first\n"
    "//               certificate found that matches that key as the\n"
    "//               signing certificate.  Any other certificates in the\n"
    "//               file are taken to be part of the chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_signature\n"
    "//       Access: Published\n"
    "//  Description: Adds a new signature to the Multifile.  This\n"
    "//               signature associates the indicated certificate with\n"
    "//               the current contents of the Multifile.  When the\n"
    "//               Multifile is read later, the signature will still be\n"
    "//               present only if the Multifile is unchanged; any\n"
    "//               subsequent changes to the Multifile will\n"
    "//               automatically invalidate and remove the signature.\n"
    "//\n"
    "//               If chain is non-NULL, it represents the certificate\n"
    "//               chain that validates the certificate.\n"
    "//\n"
    "//               The specified private key must match the certificate,\n"
    "//               and the Multifile must be open in read-write mode.\n"
    "//               The private key is only used for generating the\n"
    "//               signature; it is not written to the Multifile and\n"
    "//               cannot be retrieved from the Multifile later.\n"
    "//               (However, the certificate *can* be retrieved from the\n"
    "//               Multifile later, to identify the entity that created\n"
    "//               the signature.)\n"
    "//\n"
    "//               This implicitly causes a repack() operation if one is\n"
    "//               needed.  Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::add_signature\n"
    "//       Access: Published\n"
    "//  Description: Adds a new signature to the Multifile.  This\n"
    "//               signature associates the indicated certificate with\n"
    "//               the current contents of the Multifile.  When the\n"
    "//               Multifile is read later, the signature will still be\n"
    "//               present only if the Multifile is unchanged; any\n"
    "//               subsequent changes to the Multifile will\n"
    "//               automatically invalidate and remove the signature.\n"
    "//\n"
    "//               The signature certificate is the first certificate on\n"
    "//               the CertChain object.  Any remaining certificates are\n"
    "//               support certificates to authenticate the first one.\n"
    "//\n"
    "//               The specified private key must match the certificate,\n"
    "//               and the Multifile must be open in read-write mode.\n"
    "//               The private key is only used for generating the\n"
    "//               signature; it is not written to the Multifile and\n"
    "//               cannot be retrieved from the Multifile later.\n"
    "//               (However, the certificate *can* be retrieved from the\n"
    "//               Multifile later, to identify the entity that created\n"
    "//               the signature.)\n"
    "//\n"
    "//               This implicitly causes a repack() operation if one is\n"
    "//               needed.  Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_add_signature_1009_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::get_num_signatures(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_num_signatures_1010(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::get_num_signatures(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSignatures", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSignatures"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_num_signatures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSignatures(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_num_signatures_1010_comment =
    "C++ Interface:\n"
    "getNumSignatures(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_num_signatures\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of matching signatures found on\n"
    "//               the Multifile.  These signatures may be iterated via\n"
    "//               get_signature() and related methods.\n"
    "//\n"
    "//               A signature on this list is guaranteed to match the\n"
    "//               Multifile contents, proving that the Multifile has\n"
    "//               been unmodified since the signature was applied.\n"
    "//               However, this does not guarantee that the certificate\n"
    "//               itself is actually from who it says it is from; only\n"
    "//               that it matches the Multifile contents.  See\n"
    "//               validate_signature_certificate() to authenticate a\n"
    "//               particular certificate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_num_signatures_1010_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Multifile::get_signature_subject_name(int n) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_signature_subject_name_1012(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Multifile::get_signature_subject_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSignatureSubjectName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSignatureSubjectName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Multifile*)local_this)->get_signature_subject_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignatureSubjectName(const Multifile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_signature_subject_name_1012_comment =
    "C++ Interface:\n"
    "getSignatureSubjectName(const Multifile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_signature_subject_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"subject name\" for the nth signature found\n"
    "//               on the Multifile.  This is a string formatted\n"
    "//               according to RFC2253 that should more-or-less\n"
    "//               identify a particular certificate; when paired with\n"
    "//               the public key (see get_signature_public_key()), it\n"
    "//               can uniquely identify a certificate.  See the\n"
    "//               comments in get_num_signatures().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_signature_subject_name_1012_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Multifile::get_signature_friendly_name(int n) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_signature_friendly_name_1013(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Multifile::get_signature_friendly_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSignatureFriendlyName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSignatureFriendlyName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Multifile*)local_this)->get_signature_friendly_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignatureFriendlyName(const Multifile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_signature_friendly_name_1013_comment =
    "C++ Interface:\n"
    "getSignatureFriendlyName(const Multifile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_signature_friendly_name\n"
    "//       Access: Published\n"
    "//  Description: Returns a \"friendly name\" for the nth signature found\n"
    "//               on the Multifile.  This attempts to extract out the\n"
    "//               most meaningful part of the subject name.  It returns\n"
    "//               the emailAddress, if it is defined; otherwise, it\n"
    "//               returns the commonName.\n"
    "//               See the comments in get_num_signatures().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_signature_friendly_name_1013_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Multifile::get_signature_public_key(int n) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_signature_public_key_1014(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Multifile::get_signature_public_key(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSignaturePublicKey", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSignaturePublicKey", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Multifile*)local_this)->get_signature_public_key((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignaturePublicKey(const Multifile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_signature_public_key_1014_comment =
    "C++ Interface:\n"
    "getSignaturePublicKey(const Multifile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_signature_public_key\n"
    "//       Access: Published\n"
    "//  Description: Returns the public key used for the nth signature\n"
    "//               found on the Multifile.  This is encoded in DER form\n"
    "//               and returned as a string of hex digits.\n"
    "//\n"
    "//               This can be used, in conjunction with the subject\n"
    "//               name (see get_signature_subject_name()), to uniquely\n"
    "//               identify a particular certificate and its subsequent\n"
    "//               reissues.  See the comments in get_num_signatures().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_signature_public_key_1014_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::write_signature_certificate(int n, ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Multifile_write_signature_certificate_1015(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Multifile::write_signature_certificate(int n, ostream &out) const
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"out", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:writeSignatureCertificate", key_word_list, &param1, &param2))
            {
                ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "Multifile.writeSignatureCertificate", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const Multifile*)local_this)->write_signature_certificate((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeSignatureCertificate(const Multifile this, int n, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_write_signature_certificate_1015_comment =
    "C++ Interface:\n"
    "writeSignatureCertificate(const Multifile this, int n, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::write_signature_certificate\n"
    "//       Access: Published\n"
    "//  Description: Writes the certificate for the nth signature, in\n"
    "//               verbose form, to the indicated stream.  See the\n"
    "//               comments in get_num_signatures().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_write_signature_certificate_1015_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::validate_signature_certificate(int n) const
 *******************************************************************/
static PyObject *Dtool_Multifile_validate_signature_certificate_1016(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::validate_signature_certificate(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:validateSignatureCertificate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:validateSignatureCertificate", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->validate_signature_certificate((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "validateSignatureCertificate(const Multifile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_validate_signature_certificate_1016_comment =
    "C++ Interface:\n"
    "validateSignatureCertificate(const Multifile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::validate_signature_certificate\n"
    "//       Access: Published\n"
    "//  Description: Checks that the certificate used for the nth\n"
    "//               signature is a valid, authorized certificate with\n"
    "//               some known certificate authority.  Returns 0 if it\n"
    "//               is valid, -1 if there is some error, or the\n"
    "//               corresponding OpenSSL error code if it is invalid,\n"
    "//               out-of-date, or self-signed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_validate_signature_certificate_1016_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::flush(void)
 *******************************************************************/
static PyObject *Dtool_Multifile_flush_1017(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Multifile::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_flush_1017_comment =
    "C++ Interface:\n"
    "flush(non-const Multifile this)\n"
    "\n"
    "// HAVE_OPENSSL\n"
    "\n"
    "// HAVE_OPENSSL\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::flush\n"
    "//       Access: Published\n"
    "//  Description: Writes all contents of the Multifile to disk.  Until\n"
    "//               flush() is called, add_subfile() and remove_subfile()\n"
    "//               do not actually do anything to disk.  At this point,\n"
    "//               all of the recently-added subfiles are read and their\n"
    "//               contents are added to the end of the Multifile, and\n"
    "//               the recently-removed subfiles are marked gone from\n"
    "//               the Multifile.\n"
    "//\n"
    "//               This may result in a suboptimal index.  To guarantee\n"
    "//               that the index is written at the beginning of the\n"
    "//               file, call repack() instead of flush().\n"
    "//\n"
    "//               It is not necessary to call flush() explicitly unless\n"
    "//               you are concerned about reading the recently-added\n"
    "//               subfiles immediately.\n"
    "//\n"
    "//               Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_flush_1017_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::repack(void)
 *******************************************************************/
static PyObject *Dtool_Multifile_repack_1018(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Multifile::repack(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":repack", key_word_list));
        else
            (PyArg_Parse(args, ":repack"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->repack();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.repack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "repack(non-const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_repack_1018_comment =
    "C++ Interface:\n"
    "repack(non-const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::repack\n"
    "//       Access: Published\n"
    "//  Description: Forces a complete rewrite of the Multifile and all of\n"
    "//               its contents, so that its index will appear at the\n"
    "//               beginning of the file with all of the subfiles listed\n"
    "//               in alphabetical order.  This is considered optimal\n"
    "//               for reading, and is the standard configuration; but\n"
    "//               it is not essential to do this.\n"
    "//\n"
    "//               It is only valid to call this if the Multifile was\n"
    "//               opened using open_read_write() and an explicit\n"
    "//               filename, rather than an iostream.  Also, we must\n"
    "//               have write permission to the directory containing the\n"
    "//               Multifile.\n"
    "//\n"
    "//               Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_repack_1018_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::get_num_subfiles(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_num_subfiles_1019(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::get_num_subfiles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSubfiles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSubfiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_num_subfiles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSubfiles(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_num_subfiles_1019_comment =
    "C++ Interface:\n"
    "getNumSubfiles(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_num_subfiles\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of subfiles within the Multifile.\n"
    "//               The subfiles may be accessed in alphabetical order by\n"
    "//               iterating through [0 .. get_num_subfiles()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_num_subfiles_1019_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::find_subfile(basic_string< char > const &subfile_name) const
 *******************************************************************/
static PyObject *Dtool_Multifile_find_subfile_1020(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::find_subfile(basic_string< char > const &subfile_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"subfile_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findSubfile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findSubfile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->find_subfile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findSubfile(const Multifile this, string subfile_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_find_subfile_1020_comment =
    "C++ Interface:\n"
    "findSubfile(const Multifile this, string subfile_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::find_subfile\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the subfile with the indicated\n"
    "//               name, or -1 if the named subfile is not within the\n"
    "//               Multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_find_subfile_1020_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::has_directory(basic_string< char > const &subfile_name) const
 *******************************************************************/
static PyObject *Dtool_Multifile_has_directory_1021(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Multifile::has_directory(basic_string< char > const &subfile_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"subfile_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasDirectory", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasDirectory", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->has_directory(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDirectory(const Multifile this, string subfile_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_has_directory_1021_comment =
    "C++ Interface:\n"
    "hasDirectory(const Multifile this, string subfile_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::has_directory\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated subfile name is the\n"
    "//               directory prefix to one or more files within the\n"
    "//               Multifile.  That is, the Multifile contains at least\n"
    "//               one file named \"subfile_name/...\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_has_directory_1021_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Multifile::remove_subfile(basic_string< char > const &subfile_name)
 * void Multifile::remove_subfile(int index)
 *******************************************************************/
static PyObject *Dtool_Multifile_remove_subfile_1023(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline bool Multifile::remove_subfile(basic_string< char > const &subfile_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"subfile_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeSubfile", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeSubfile", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_subfile(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void Multifile::remove_subfile(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeSubfile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeSubfile", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_subfile((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSubfile(non-const Multifile this, string subfile_name)\n"
          "removeSubfile(non-const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_remove_subfile_1023_comment =
    "C++ Interface:\n"
    "removeSubfile(non-const Multifile this, string subfile_name)\n"
    "removeSubfile(non-const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::remove_subfile\n"
    "//       Access: Published\n"
    "//  Description: Removes the named subfile from the Multifile, if it\n"
    "//               exists; returns true if successfully removed, or\n"
    "//               false if it did not exist in the first place.  The\n"
    "//               file will not actually be removed from the disk until\n"
    "//               the next call to flush().\n"
    "//\n"
    "//               Note that this does not actually remove the data from\n"
    "//               the indicated subfile; it simply removes it from the\n"
    "//               index.  The Multifile will not be reduced in size\n"
    "//               after this operation, until the next call to\n"
    "//               repack().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::remove_subfile\n"
    "//       Access: Published\n"
    "//  Description: Removes the nth subfile from the Multifile.  This\n"
    "//               will cause all subsequent index numbers to decrease\n"
    "//               by one.  The file will not actually be removed from\n"
    "//               the disk until the next call to flush().\n"
    "//\n"
    "//               Note that this does not actually remove the data from\n"
    "//               the indicated subfile; it simply removes it from the\n"
    "//               index.  The Multifile will not be reduced in size\n"
    "//               after this operation, until the next call to\n"
    "//               repack().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_remove_subfile_1023_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &Multifile::get_subfile_name(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_subfile_name_1024(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &Multifile::get_subfile_name(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubfileName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubfileName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Multifile*)local_this)->get_subfile_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubfileName(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_subfile_name_1024_comment =
    "C++ Interface:\n"
    "getSubfileName(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_subfile_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the nth subfile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_subfile_name_1024_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int Multifile::get_subfile_length(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_subfile_length_1025(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int Multifile::get_subfile_length(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubfileLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubfileLength", &param1));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Multifile*)local_this)->get_subfile_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubfileLength(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_subfile_length_1025_comment =
    "C++ Interface:\n"
    "getSubfileLength(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_subfile_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the uncompressed data length of the nth\n"
    "//               subfile.  This might return 0 if the subfile has\n"
    "//               recently been added and flush() has not yet been\n"
    "//               called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_subfile_length_1025_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int Multifile::get_subfile_timestamp(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_subfile_timestamp_1026(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int Multifile::get_subfile_timestamp(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubfileTimestamp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubfileTimestamp", &param1));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Multifile*)local_this)->get_subfile_timestamp((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubfileTimestamp(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_subfile_timestamp_1026_comment =
    "C++ Interface:\n"
    "getSubfileTimestamp(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_subfile_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Returns the modification time of the nth\n"
    "//               subfile.  If this is called on an older .mf file,\n"
    "//               which did not store individual timestamps in the file\n"
    "//               (or if get_record_timestamp() is false), this will\n"
    "//               return the modification time of the overall\n"
    "//               multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_subfile_timestamp_1026_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::is_subfile_compressed(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_is_subfile_compressed_1027(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Multifile::is_subfile_compressed(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isSubfileCompressed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isSubfileCompressed", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->is_subfile_compressed((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSubfileCompressed(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_is_subfile_compressed_1027_comment =
    "C++ Interface:\n"
    "isSubfileCompressed(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::is_subfile_compressed\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated subfile has been\n"
    "//               compressed when stored within the archive, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_is_subfile_compressed_1027_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::is_subfile_encrypted(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_is_subfile_encrypted_1028(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Multifile::is_subfile_encrypted(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isSubfileEncrypted", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isSubfileEncrypted", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Multifile*)local_this)->is_subfile_encrypted((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSubfileEncrypted(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_is_subfile_encrypted_1028_comment =
    "C++ Interface:\n"
    "isSubfileEncrypted(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::is_subfile_encrypted\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated subfile has been\n"
    "//               encrypted when stored within the archive, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_is_subfile_encrypted_1028_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::get_index_end(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_index_end_1029(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::get_index_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndexEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getIndexEnd"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_index_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndexEnd(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_index_end_1029_comment =
    "C++ Interface:\n"
    "getIndexEnd(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_index_end\n"
    "//       Access: Published\n"
    "//  Description: Returns the first byte that is guaranteed to follow\n"
    "//               any index byte already written to disk in the\n"
    "//               Multifile.\n"
    "//\n"
    "//               This number is largely meaningless in many cases, but\n"
    "//               if needs_repack() is false, and the file is flushed,\n"
    "//               this will indicate the number of bytes in the header\n"
    "//               + index.  Everything at this byte position and later\n"
    "//               will be actual data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_index_end_1029_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Multifile::get_subfile_internal_start(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_subfile_internal_start_1030(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Multifile::get_subfile_internal_start(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubfileInternalStart", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubfileInternalStart", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Multifile*)local_this)->get_subfile_internal_start((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubfileInternalStart(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_subfile_internal_start_1030_comment =
    "C++ Interface:\n"
    "getSubfileInternalStart(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_subfile_internal_start\n"
    "//       Access: Published\n"
    "//  Description: Returns the starting byte position within the\n"
    "//               Multifile at which the indicated subfile begins.\n"
    "//               This may be used, with get_subfile_internal_length(),\n"
    "//               for low-level access to the subfile, but usually it\n"
    "//               is better to use open_read_subfile() instead (which\n"
    "//               automatically decrypts and/or uncompresses the\n"
    "//               subfile data).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_subfile_internal_start_1030_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int Multifile::get_subfile_internal_length(int index) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_subfile_internal_length_1031(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int Multifile::get_subfile_internal_length(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSubfileInternalLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSubfileInternalLength", &param1));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Multifile*)local_this)->get_subfile_internal_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubfileInternalLength(const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_subfile_internal_length_1031_comment =
    "C++ Interface:\n"
    "getSubfileInternalLength(const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_subfile_internal_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bytes the indicated subfile\n"
    "//               consumes within the archive.  For compressed\n"
    "//               subfiles, this will generally be smaller than\n"
    "//               get_subfile_length(); for encrypted (but\n"
    "//               noncompressed) subfiles, it may be slightly\n"
    "//               different, for noncompressed and nonencrypted\n"
    "//               subfiles, it will be equal.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_subfile_internal_length_1031_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Multifile::read_subfile(int index)
 *******************************************************************/
static PyObject *Dtool_Multifile_read_subfile_1032(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > Multifile::read_subfile(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:readSubfile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:readSubfile", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            basic_string< char > return_value = (local_this)->read_subfile((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.readSubfile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readSubfile(non-const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_read_subfile_1032_comment =
    "C++ Interface:\n"
    "readSubfile(non-const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::read_subfile\n"
    "//       Access: Published\n"
    "//  Description: Returns a string that contains the entire contents of\n"
    "//               the indicated subfile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::read_subfile\n"
    "//       Access: Public\n"
    "//  Description: Fills a string with the entire contents of\n"
    "//               the indicated subfile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::read_subfile\n"
    "//       Access: Public\n"
    "//  Description: Fills a pvector with the entire contents of\n"
    "//               the indicated subfile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_read_subfile_1032_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * istream *Multifile::open_read_subfile(int index)
 *******************************************************************/
static PyObject *Dtool_Multifile_open_read_subfile_1033(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-istream *Multifile::open_read_subfile(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:openReadSubfile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:openReadSubfile", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            istream *return_value = (local_this)->open_read_subfile((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.openReadSubfile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openReadSubfile(non-const Multifile this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_open_read_subfile_1033_comment =
    "C++ Interface:\n"
    "openReadSubfile(non-const Multifile this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read_subfile\n"
    "//       Access: Published\n"
    "//  Description: Returns an istream that may be used to read the\n"
    "//               indicated subfile.  You may seek() within this\n"
    "//               istream to your heart's content; even though it will\n"
    "//               be a reference to the already-opened pfstream of the\n"
    "//               Multifile itself, byte 0 appears to be the beginning\n"
    "//               of the subfile and EOF appears to be the end of the\n"
    "//               subfile.\n"
    "//\n"
    "//               The returned istream will have been allocated via\n"
    "//               new; you should pass the pointer to\n"
    "//               close_read_subfile() when you are finished with it to\n"
    "//               delete it and release its resources.\n"
    "//\n"
    "//               Any future calls to repack() or close() (or the\n"
    "//               Multifile destructor) will invalidate all currently\n"
    "//               open subfile pointers.\n"
    "//\n"
    "//               The return value will be NULL if the stream cannot be\n"
    "//               opened for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::open_read_subfile\n"
    "//       Access: Private\n"
    "//  Description: This variant of open_read_subfile() is used\n"
    "//               internally only, and accepts a pointer to the\n"
    "//               internal Subfile object, which is assumed to be valid\n"
    "//               and written to the multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_open_read_subfile_1033_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void Multifile::close_read_subfile(istream *stream)
 *******************************************************************/
static PyObject *Dtool_Multifile_close_read_subfile_1034(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void Multifile::close_read_subfile(istream *stream)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:closeReadSubfile", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:closeReadSubfile", &param0));
            if(!PyErr_Occurred())
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "Multifile.closeReadSubfile", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Multifile::close_read_subfile(param0_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeReadSubfile(non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_close_read_subfile_1034_comment =
    "C++ Interface:\n"
    "closeReadSubfile(non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::close_read_subfile\n"
    "//       Access: Published, Static\n"
    "//  Description: Closes a file opened by a previous call to\n"
    "//               open_read_subfile().  This really just deletes the\n"
    "//               istream pointer, but it is recommended to use this\n"
    "//               interface instead of deleting it explicitly, to help\n"
    "//               work around compiler issues.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_close_read_subfile_1034_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::extract_subfile(int index, Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_Multifile_extract_subfile_1035(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Multifile::extract_subfile(int index, Filename const &filename)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"filename", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:extractSubfile", key_word_list, &param1, &param2))
            {
                Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.extractSubfile", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->extract_subfile((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Multifile.extractSubfile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extractSubfile(non-const Multifile this, int index, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_extract_subfile_1035_comment =
    "C++ Interface:\n"
    "extractSubfile(non-const Multifile this, int index, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::extract_subfile\n"
    "//       Access: Published\n"
    "//  Description: Extracts the nth subfile into a file with the given\n"
    "//               name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_extract_subfile_1035_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::extract_subfile_to(int index, ostream &out)
 *******************************************************************/
static PyObject *Dtool_Multifile_extract_subfile_to_1036(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Multifile::extract_subfile_to(int index, ostream &out)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"out", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:extractSubfileTo", key_word_list, &param1, &param2))
            {
                ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "Multifile.extractSubfileTo", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->extract_subfile_to((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Multifile.extractSubfileTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extractSubfileTo(non-const Multifile this, int index, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_extract_subfile_to_1036_comment =
    "C++ Interface:\n"
    "extractSubfileTo(non-const Multifile this, int index, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::extract_subfile_to\n"
    "//       Access: Public\n"
    "//  Description: Extracts the nth subfile to the indicated ostream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_extract_subfile_to_1036_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Multifile::compare_subfile(int index, Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_Multifile_compare_subfile_1037(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Multifile::compare_subfile(int index, Filename const &filename)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"filename", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:compareSubfile", key_word_list, &param1, &param2))
            {
                Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Multifile.compareSubfile", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->compare_subfile((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Multifile.compareSubfile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareSubfile(non-const Multifile this, int index, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_compare_subfile_1037_comment =
    "C++ Interface:\n"
    "compareSubfile(non-const Multifile this, int index, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::compare_subfile\n"
    "//       Access: Published\n"
    "//  Description: Performs a byte-for-byte comparison of the indicated\n"
    "//               file on disk with the nth subfile.  Returns true if\n"
    "//               the files are equivalent, or false if they are\n"
    "//               different (or the file is missing).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_compare_subfile_1037_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Multifile_output_1038(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Multifile::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Multifile.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Multifile*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Multifile this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_output_1038_comment =
    "C++ Interface:\n"
    "output(const Multifile this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_output_1038_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::ls(ostream &out) const
 * void Multifile::ls(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_Multifile_ls_1039(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-void Multifile::ls(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":ls", key_word_list));
            else
                (PyArg_Parse(args, ":ls"));
            if(!PyErr_Occurred())
            {
                ((const Multifile*)local_this)->ls();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Multifile::ls(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ls", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:ls", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Multifile.ls", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Multifile*)local_this)->ls(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ls() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ls(const Multifile this)\n"
          "ls(const Multifile this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_ls_1039_comment =
    "C++ Interface:\n"
    "ls(const Multifile this)\n"
    "ls(const Multifile this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::ls\n"
    "//       Access: Published\n"
    "//  Description: Shows a list of all subfiles within the Multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_ls_1039_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > Multifile::get_magic_number(void)
 *******************************************************************/
static PyObject *Dtool_Multifile_get_magic_number_1040(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > Multifile::get_magic_number(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMagicNumber", key_word_list))
        {
            basic_string< char > return_value = Multifile::get_magic_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMagicNumber()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_magic_number_1040_comment =
    "C++ Interface:\n"
    "getMagicNumber()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_magic_number\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a string with the first n bytes written to a\n"
    "//               Multifile, to identify it as a Multifile.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_magic_number_1040_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Multifile::set_header_prefix(basic_string< char > const &header_prefix)
 *******************************************************************/
static PyObject *Dtool_Multifile_set_header_prefix_1041(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Multifile::set_header_prefix(basic_string< char > const &header_prefix)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"header_prefix", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setHeaderPrefix", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setHeaderPrefix", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_header_prefix(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Multifile.setHeaderPrefix() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeaderPrefix(non-const Multifile this, string header_prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_set_header_prefix_1041_comment =
    "C++ Interface:\n"
    "setHeaderPrefix(non-const Multifile this, string header_prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::set_header_prefix\n"
    "//       Access: Published\n"
    "//  Description: Sets the string which is written to the Multifile\n"
    "//               before the Multifile header.  This string must begin\n"
    "//               with a hash mark and end with a newline character;\n"
    "//               and if it includes embedded newline characters, each\n"
    "//               one must be followed by a hash mark.  If these\n"
    "//               conditions are not initially true, the string will be\n"
    "//               modified as necessary to make it so.\n"
    "//\n"
    "//               This is primarily useful as a simple hack to allow\n"
    "//               p3d applications to be run directly from the command\n"
    "//               line on Unix-like systems.\n"
    "//\n"
    "//               The return value is true if successful, or false on\n"
    "//               failure (for instance, because the header prefix\n"
    "//               violates the above rules).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_set_header_prefix_1041_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Multifile::get_header_prefix(void) const
 *******************************************************************/
static PyObject *Dtool_Multifile_get_header_prefix_1042(PyObject *self, PyObject *args,PyObject *kwds) {
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Multifile::get_header_prefix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeaderPrefix", key_word_list));
        else
            (PyArg_Parse(args, ":getHeaderPrefix"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Multifile*)local_this)->get_header_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeaderPrefix(const Multifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Multifile_get_header_prefix_1042_comment =
    "C++ Interface:\n"
    "getHeaderPrefix(const Multifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Multifile::get_header_prefix\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that preceded the Multifile header\n"
    "//               on the file, if any.  See set_header_prefix().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Multifile_get_header_prefix_1042_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Multifile::Multifile(void)
 *******************************************************************/
int  Dtool_Init_Multifile(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Multifile::Multifile(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Multifile", key_word_list))
        {
            Multifile *return_value = new Multifile();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Multifile,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Multifile()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_Multifile_get_subfile_names(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSubfiles", "getSubfileName");
}
inline void  * Dtool_UpcastInterface_Multifile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Multifile)
    {
        printf("Multifile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Multifile * local_this = (Multifile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Multifile)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Multifile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Multifile)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Multifile*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Multifile::CertRecord 
//********************************************************************
int  Dtool_Init_Multifile_CertRecord(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Multifile::CertRecord)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Multifile_CertRecord(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Multifile_CertRecord)
    {
        printf("Multifile_CertRecord ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Multifile::CertRecord * local_this = (Multifile::CertRecord *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Multifile_CertRecord)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Multifile_CertRecord(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Multifile_CertRecord)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileMountMultifile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountMultifile_get_multifile_1045(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMountMultifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMountMultifile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMultifile", key_word_list));
        else
            (PyArg_Parse(args, ":getMultifile"));
        if(!PyErr_Occurred())
        {
            Multifile *return_value = ((const VirtualFileMountMultifile*)local_this)->get_multifile();
            if (return_value != (Multifile *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Multifile,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMultifile(const VirtualFileMountMultifile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountMultifile_get_multifile_1045_comment =
    "C++ Interface:\n"
    "getMultifile(const VirtualFileMountMultifile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMountMultifile::get_multifile\n"
    "//       Access: Public\n"
    "//  Description: Returns the Multifile pointer that this mount object\n"
    "//               is based on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMountMultifile_get_multifile_1045_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileMountMultifile::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountMultifile_get_class_type_1046(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileMountMultifile::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileMountMultifile::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountMultifile_get_class_type_1046_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileMountMultifile_get_class_type_1046_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
 *******************************************************************/
int  Dtool_Init_VirtualFileMountMultifile(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"multifile", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:VirtualFileMountMultifile", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:VirtualFileMountMultifile", &param0));
            if(!PyErr_Occurred())
            {
                Multifile *param0_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualFileMountMultifile,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VirtualFileMountMultifile(non-const Multifile multifile)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_VirtualFileMountMultifile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileMountMultifile)
    {
        printf("VirtualFileMountMultifile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileMountMultifile * local_this = (VirtualFileMountMultifile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileMountMultifile)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_VirtualFileMount)
        return ( VirtualFileMount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileMountMultifile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileMountMultifile)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileMountMultifile*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileMountMultifile*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileMountMultifile*)other_this;
    }
    if(from_type == &Dtool_VirtualFileMount)
    {
          VirtualFileMount* other_this = (VirtualFileMount*)from_this;
          return (VirtualFileMountMultifile*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileMountSystem 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountSystem_get_physical_filename_1049(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileMountSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMountSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicalFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicalFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const VirtualFileMountSystem*)local_this)->get_physical_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicalFilename(const VirtualFileMountSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountSystem_get_physical_filename_1049_comment =
    "C++ Interface:\n"
    "getPhysicalFilename(const VirtualFileMountSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileMountSystem::get_physical_filename\n"
    "//       Access: Public\n"
    "//  Description: Returns the name of the source file on the OS\n"
    "//               filesystem of the directory or file that is mounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileMountSystem_get_physical_filename_1049_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileMountSystem::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileMountSystem_get_class_type_1050(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileMountSystem::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileMountSystem::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileMountSystem_get_class_type_1050_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileMountSystem_get_class_type_1050_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
 *******************************************************************/
int  Dtool_Init_VirtualFileMountSystem(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"physical_filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:VirtualFileMountSystem", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:VirtualFileMountSystem", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "VirtualFileMountSystem.VirtualFileMountSystem", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualFileMountSystem,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VirtualFileMountSystem(const Filename physical_filename)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_VirtualFileMountSystem(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileMountSystem)
    {
        printf("VirtualFileMountSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileMountSystem * local_this = (VirtualFileMountSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileMountSystem)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFileMount *) local_this;
    if(requested_type == &Dtool_VirtualFileMount)
        return ( VirtualFileMount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileMountSystem(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileMountSystem)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileMountSystem*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileMountSystem*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileMountSystem*)other_this;
    }
    if(from_type == &Dtool_VirtualFileMount)
    {
          VirtualFileMount* other_this = (VirtualFileMount*)from_this;
          return (VirtualFileMountSystem*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileSimple 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSimple_get_mount_1053(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSimple * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSimple,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMount", key_word_list));
        else
            (PyArg_Parse(args, ":getMount"));
        if(!PyErr_Occurred())
        {
            VirtualFileMount *return_value = ((const VirtualFileSimple*)local_this)->get_mount();
            if (return_value != (VirtualFileMount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_VirtualFileMount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMount(const VirtualFileSimple this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSimple_get_mount_1053_comment =
    "C++ Interface:\n"
    "getMount(const VirtualFileSimple this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSimple::get_mount\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the VirtualFileMount this file is associated\n"
    "//               with.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSimple_get_mount_1053_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VirtualFileSimple::is_implicit_pz_file(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSimple_is_implicit_pz_file_1054(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSimple * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSimple,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool VirtualFileSimple::is_implicit_pz_file(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isImplicitPzFile", key_word_list));
        else
            (PyArg_Parse(args, ":isImplicitPzFile"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VirtualFileSimple*)local_this)->is_implicit_pz_file();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isImplicitPzFile(const VirtualFileSimple this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSimple_is_implicit_pz_file_1054_comment =
    "C++ Interface:\n"
    "isImplicitPzFile(const VirtualFileSimple this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSimple::is_implicit_pz_file\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this file is a .pz file that should\n"
    "//               be implicitly decompressed on load, or false if it is\n"
    "//               not a .pz file or if it should not be decompressed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSimple_is_implicit_pz_file_1054_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualFileSimple::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSimple_get_class_type_1055(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualFileSimple::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualFileSimple::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSimple_get_class_type_1055_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualFileSimple_get_class_type_1055_comment = NULL;
#endif

int  Dtool_Init_VirtualFileSimple(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFileSimple)");
       return -1;
}
inline void  * Dtool_UpcastInterface_VirtualFileSimple(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileSimple)
    {
        printf("VirtualFileSimple ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileSimple * local_this = (VirtualFileSimple *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileSimple)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( VirtualFile *) local_this;
    if(requested_type == &Dtool_VirtualFile)
        return ( VirtualFile *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileSimple(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileSimple)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileSimple*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualFileSimple*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VirtualFileSimple*)other_this;
    }
    if(from_type == &Dtool_VirtualFile)
    {
          VirtualFile* other_this = (VirtualFile*)from_this;
          return (VirtualFileSimple*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Namable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Namable &Namable::operator =(Namable const &other)
 *******************************************************************/
static PyObject *Dtool_Namable_operator_1059(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline Namable &Namable::operator =(Namable const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Namable *param1_this = (Namable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Namable, 1, "Namable.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Namable *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Namable.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Namable this, const Namable other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_operator_1059_comment =
    "C++ Interface:\n"
    "assign(non-const Namable this, const Namable other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_operator_1059_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Namable::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_Namable_set_name_1060(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Namable::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Namable.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const Namable this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_set_name_1060_comment =
    "C++ Interface:\n"
    "setName(non-const Namable this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::set_name\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_set_name_1060_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Namable::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_Namable_clear_name_1061(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Namable::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Namable.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const Namable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_clear_name_1061_comment =
    "C++ Interface:\n"
    "clearName(non-const Namable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::clear_name\n"
    "//       Access: Public\n"
    "//  Description: Resets the Namable's name to empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_clear_name_1061_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Namable::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_Namable_has_name_1062(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Namable::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Namable*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const Namable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_has_name_1062_comment =
    "C++ Interface:\n"
    "hasName(const Namable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::has_name\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the Namable has a nonempty name set,\n"
    "//               false if the name is empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_has_name_1062_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Namable::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_Namable_get_name_1063(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Namable::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Namable*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const Namable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_get_name_1063_comment =
    "C++ Interface:\n"
    "getName(const Namable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::get_name\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_get_name_1063_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Namable::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Namable_output_1064(PyObject *self, PyObject *args,PyObject *kwds) {
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void Namable::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Namable.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Namable*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Namable this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_output_1064_comment =
    "C++ Interface:\n"
    "output(const Namable this, non-const Ostream out)\n"
    "\n"
    "// In the absence of any definition to the contrary, outputting a\n"
    "// Namable will write out its name.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Namable::output\n"
    "//       Access: Public\n"
    "//  Description: Outputs the Namable.  This function simply writes the\n"
    "//               name to the output stream; most Namable derivatives\n"
    "//               will probably redefine this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Namable_output_1064_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Namable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Namable_get_class_type_1065(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Namable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Namable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Namable_get_class_type_1065_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Namable_get_class_type_1065_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Namable::Namable(Namable const &copy)
 * inline Namable::Namable(basic_string< char > const &initial_name)
 * inline Namable::Namable(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_Namable(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Namable::Namable(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Namable", key_word_list))
            {
                Namable *return_value = new Namable();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Namable,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline Namable::Namable(Namable const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Namable", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Namable", &param0));
                if(!PyErr_Occurred())
                {
                    Namable *param0_this = (Namable *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Namable, 0, "Namable.Namable", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Namable *return_value = new Namable(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Namable,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline Namable::Namable(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Namable", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:Namable", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    Namable *return_value = new Namable(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Namable,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Namable() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Namable()\n"
          "Namable(const Namable copy)\n"
          "Namable(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Namable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Namable)
    {
        printf("Namable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Namable * local_this = (Namable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Namable)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Namable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Namable)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. IDecompressStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline IDecompressStream &IDecompressStream::open(istream *source, bool owns_source)
 *******************************************************************/
static PyObject *Dtool_IDecompressStream_open_1069(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecompressStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecompressStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline IDecompressStream &IDecompressStream::open(istream *source, bool owns_source)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"source", (char *)"owns_source", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:open", key_word_list, &param1, &param2))
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "IDecompressStream.open", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    IDecompressStream *return_value = &((local_this)->open(param1_this, (PyObject_IsTrue(param2)!=0)));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_IDecompressStream,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call IDecompressStream.open() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const IDecompressStream this, non-const Istream source, bool owns_source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecompressStream_open_1069_comment =
    "C++ Interface:\n"
    "open(non-const IDecompressStream this, non-const Istream source, bool owns_source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecompressStream::open\n"
    "//       Access: Public\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecompressStream_open_1069_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IDecompressStream &IDecompressStream::close(void)
 *******************************************************************/
static PyObject *Dtool_IDecompressStream_close_1070(PyObject *self, PyObject *args,PyObject *kwds) {
    IDecompressStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_IDecompressStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline IDecompressStream &IDecompressStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            IDecompressStream *return_value = &((local_this)->close());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_IDecompressStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call IDecompressStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const IDecompressStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_IDecompressStream_close_1070_comment =
    "C++ Interface:\n"
    "close(non-const IDecompressStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: IDecompressStream::close\n"
    "//       Access: Public\n"
    "//  Description: Resets the ZStream to empty, but does not actually\n"
    "//               close the source istream unless owns_source was true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_IDecompressStream_close_1070_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline IDecompressStream::IDecompressStream(void)
 * inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
 *******************************************************************/
int  Dtool_Init_IDecompressStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline IDecompressStream::IDecompressStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":IDecompressStream", key_word_list))
            {
                IDecompressStream *return_value = new IDecompressStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_IDecompressStream,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"source", (char *)"owns_source", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:IDecompressStream", key_word_list, &param0, &param1))
                {
                    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "IDecompressStream.IDecompressStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        IDecompressStream *return_value = new IDecompressStream(param0_this, (PyObject_IsTrue(param1)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_IDecompressStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "IDecompressStream() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "IDecompressStream()\n"
          "IDecompressStream(non-const Istream source, bool owns_source)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_IDecompressStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_IDecompressStream)
    {
        printf("IDecompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    IDecompressStream * local_this = (IDecompressStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_IDecompressStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( istream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( istream *) local_this;
    if(requested_type == &Dtool_istream)
        return ( istream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_IDecompressStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_IDecompressStream)
        return from_this;
    if(from_type == &Dtool_istream)
    {
          istream* other_this = (istream*)from_this;
          return (IDecompressStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OCompressStream 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level)
 * inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level = (6))
 *******************************************************************/
static PyObject *Dtool_OCompressStream_open_1074(PyObject *self, PyObject *args,PyObject *kwds) {
    OCompressStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OCompressStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level = (6))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:open", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OCompressStream.open", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        OCompressStream *return_value = &((local_this)->open(param1_this, (PyObject_IsTrue(param2)!=0)));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_OCompressStream,false, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OCompressStream.open() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", (char *)"compression_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:open", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OCompressStream.open", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        OCompressStream *return_value = &((local_this)->open(param1_this, (PyObject_IsTrue(param2)!=0), (int)param3));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_OCompressStream,false, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OCompressStream.open() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "open() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "open(non-const OCompressStream this, non-const Ostream dest, bool owns_dest)\n"
          "open(non-const OCompressStream this, non-const Ostream dest, bool owns_dest, int compression_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OCompressStream_open_1074_comment =
    "C++ Interface:\n"
    "open(non-const OCompressStream this, non-const Ostream dest, bool owns_dest)\n"
    "open(non-const OCompressStream this, non-const Ostream dest, bool owns_dest, int compression_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OCompressStream::open\n"
    "//       Access: Public\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OCompressStream_open_1074_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OCompressStream &OCompressStream::close(void)
 *******************************************************************/
static PyObject *Dtool_OCompressStream_close_1075(PyObject *self, PyObject *args,PyObject *kwds) {
    OCompressStream * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OCompressStream,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline OCompressStream &OCompressStream::close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":close", key_word_list));
        else
            (PyArg_Parse(args, ":close"));
        if(!PyErr_Occurred())
        {
            OCompressStream *return_value = &((local_this)->close());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_OCompressStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OCompressStream.close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "close(non-const OCompressStream this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OCompressStream_close_1075_comment =
    "C++ Interface:\n"
    "close(non-const OCompressStream this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OCompressStream::close\n"
    "//       Access: Public\n"
    "//  Description: Resets the ZStream to empty, but does not actually\n"
    "//               close the dest ostream unless owns_dest was true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OCompressStream_close_1075_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OCompressStream::OCompressStream(void)
 * inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level)
 * inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = (6))
 *******************************************************************/
int  Dtool_Init_OCompressStream(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline OCompressStream::OCompressStream(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OCompressStream", key_word_list))
            {
                OCompressStream *return_value = new OCompressStream();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OCompressStream,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = (6))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OCompressStream", key_word_list, &param0, &param1))
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "OCompressStream.OCompressStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OCompressStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"dest", (char *)"owns_dest", (char *)"compression_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:OCompressStream", key_word_list, &param0, &param1, &param2))
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "OCompressStream.OCompressStream", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1)!=0), (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OCompressStream,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OCompressStream() takes 0, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OCompressStream()\n"
          "OCompressStream(non-const Ostream dest, bool owns_dest)\n"
          "OCompressStream(non-const Ostream dest, bool owns_dest, int compression_level)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OCompressStream(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OCompressStream)
    {
        printf("OCompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OCompressStream * local_this = (OCompressStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OCompressStream)
        return local_this;
    if(requested_type == &Dtool_ios)
        return ( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ios_base)
        return ( ios_base *)( ios *)( ostream *) local_this;
    if(requested_type == &Dtool_ostream)
        return ( ostream *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OCompressStream(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OCompressStream)
        return from_this;
    if(from_type == &Dtool_ostream)
    {
          ostream* other_this = (ostream*)from_this;
          return (OCompressStream*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileList 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int VirtualFileList::get_num_files(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_get_num_files_1078(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int VirtualFileList::get_num_files(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFiles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFiles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const VirtualFileList*)local_this)->get_num_files();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFiles(const VirtualFileList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_get_num_files_1078_comment =
    "C++ Interface:\n"
    "getNumFiles(const VirtualFileList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::get_num_files\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of files in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_get_num_files_1078_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VirtualFile *VirtualFileList::get_file(int n) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_get_file_1079(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline VirtualFile *VirtualFileList::get_file(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFile", &param1));
        if(!PyErr_Occurred())
        {
            VirtualFile *return_value = ((const VirtualFileList*)local_this)->get_file((int)param1);
            if (return_value != (VirtualFile *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_VirtualFile,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFile(const VirtualFileList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_get_file_1079_comment =
    "C++ Interface:\n"
    "getFile(const VirtualFileList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::get_file\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth file in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_get_file_1079_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VirtualFile *VirtualFileList::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_operator_1080(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline VirtualFile *VirtualFileList::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const VirtualFileList*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            VirtualFile *return_value = ((const VirtualFileList*)local_this)->operator []((int)param1);
            if (return_value != (VirtualFile *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_VirtualFile,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const VirtualFileList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_operator_1080_comment =
    "C++ Interface:\n"
    "__getitem__(const VirtualFileList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth file in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_operator_1080_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int VirtualFileList::size(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_size_1081(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int VirtualFileList::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const VirtualFileList*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const VirtualFileList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_size_1081_comment =
    "C++ Interface:\n"
    "size(const VirtualFileList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of files in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_size_1081_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void VirtualFileList::operator +=(VirtualFileList const &other)
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_operator_1082(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void VirtualFileList::operator +=(VirtualFileList const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                VirtualFileList *param1_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_VirtualFileList, 1, "VirtualFileList.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call VirtualFileList.__iadd__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const VirtualFileList this, const VirtualFileList other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_operator_1082_comment =
    "C++ Interface:\n"
    "__iadd__(non-const VirtualFileList this, const VirtualFileList other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Appends the other list onto the end of this one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_operator_1082_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline VirtualFileList VirtualFileList::operator +(VirtualFileList const &other) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileList_operator_1083(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileList,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline VirtualFileList VirtualFileList::operator +(VirtualFileList const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                VirtualFileList *param1_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_VirtualFileList, 1, "VirtualFileList.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    VirtualFileList result = ((const VirtualFileList*)local_this)->operator +(*param1_this);
                    VirtualFileList *return_value = new VirtualFileList(result);
                    if (return_value != (VirtualFileList *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_VirtualFileList,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const VirtualFileList this, const VirtualFileList other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileList_operator_1083_comment =
    "C++ Interface:\n"
    "__add__(const VirtualFileList this, const VirtualFileList other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileList::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a VirtualFileList representing the\n"
    "//               concatenation of the two lists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileList_operator_1083_comment = NULL;
#endif

int  Dtool_Init_VirtualFileList(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (VirtualFileList)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_VirtualFileList_get_files(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumFiles", "getFile");
}
inline void  * Dtool_UpcastInterface_VirtualFileList(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileList)
    {
        printf("VirtualFileList ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileList * local_this = (VirtualFileList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileList)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileList(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileList)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VirtualFileList*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualFileSystem 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, basic_string< char > const &password)
 * bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, basic_string< char > const &password = (""))
 * bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
 * bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_mount_1088(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mount", (char *)"mount_point", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:mount", key_word_list, &param1, &param2, &param3))
                {
                    VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_VirtualFileMount, 1, "VirtualFileSystem.mount", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->mount(param1_this, *param2_this, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"multifile", (char *)"mount_point", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:mount", key_word_list, &param1, &param2, &param3))
                {
                    Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Multifile, 1, "VirtualFileSystem.mount", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->mount(param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, basic_string< char > const &password = (""))
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"physical_filename", (char *)"mount_point", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:mount", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->mount(*param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, basic_string< char > const &password)
                PyObject *param1;
                PyObject *param2;
                int param3;
                char *param4_str; int param4_len;
                static char * key_word_list[] = {(char *)"physical_filename", (char *)"mount_point", (char *)"flags", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOis#:mount", key_word_list, &param1, &param2, &param3, &param4_str, &param4_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mount", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->mount(*param1_this, *param2_this, (int)param3, basic_string<char>(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call VirtualFileSystem.mount() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "mount() takes 4 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "mount(non-const VirtualFileSystem this, non-const VirtualFileMount mount, const Filename mount_point, int flags)\n"
          "mount(non-const VirtualFileSystem this, non-const Multifile multifile, const Filename mount_point, int flags)\n"
          "mount(non-const VirtualFileSystem this, const Filename physical_filename, const Filename mount_point, int flags)\n"
          "mount(non-const VirtualFileSystem this, const Filename physical_filename, const Filename mount_point, int flags, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_mount_1088_comment =
    "C++ Interface:\n"
    "mount(non-const VirtualFileSystem this, non-const VirtualFileMount mount, const Filename mount_point, int flags)\n"
    "mount(non-const VirtualFileSystem this, non-const Multifile multifile, const Filename mount_point, int flags)\n"
    "mount(non-const VirtualFileSystem this, const Filename physical_filename, const Filename mount_point, int flags)\n"
    "mount(non-const VirtualFileSystem this, const Filename physical_filename, const Filename mount_point, int flags, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::mount\n"
    "//       Access: Published\n"
    "//  Description: Mounts the indicated Multifile at the given mount\n"
    "//               point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::mount\n"
    "//       Access: Published\n"
    "//  Description: Mounts the indicated system file or directory at the\n"
    "//               given mount point.  If the named file is a directory,\n"
    "//               mounts the directory.  If the named file is a\n"
    "//               Multifile, mounts it as a Multifile.  Returns true on\n"
    "//               success, false on failure.\n"
    "//\n"
    "//               A given system directory may be mounted to multiple\n"
    "//               different mount point, and the same mount point may\n"
    "//               share multiple system directories.  In the case of\n"
    "//               ambiguities (that is, two different files with\n"
    "//               exactly the same full pathname), the most-recently\n"
    "//               mounted system wins.\n"
    "//\n"
    "//               The filename specified as the first parameter must\n"
    "//               refer to a real, physical filename on disk; it cannot\n"
    "//               be a virtual file already appearing within the vfs\n"
    "//               filespace.  However, it is possible to mount such a\n"
    "//               file; see mount_loop() for this.\n"
    "////\n"
    "//               Note that a mounted VirtualFileSystem directory is\n"
    "//               fully case-sensitive, unlike the native Windows file\n"
    "//               system, so you must refer to files within the virtual\n"
    "//               file system with exactly the right case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::mount\n"
    "//       Access: Published\n"
    "//  Description: Adds the given VirtualFileMount object to the mount\n"
    "//               list.  This is a lower-level function that the other\n"
    "//               flavors of mount(); it requires you to create a\n"
    "//               VirtualFileMount object specifically.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_mount_1088_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, basic_string< char > const &password)
 * bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, basic_string< char > const &password = (""))
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_mount_loop_1089(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, basic_string< char > const &password = (""))
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"virtual_filename", (char *)"mount_point", (char *)"flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:mountLoop", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.mountLoop", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mountLoop", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->mount_loop(*param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call VirtualFileSystem.mountLoop() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, basic_string< char > const &password)
                PyObject *param1;
                PyObject *param2;
                int param3;
                char *param4_str; int param4_len;
                static char * key_word_list[] = {(char *)"virtual_filename", (char *)"mount_point", (char *)"flags", (char *)"password", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOis#:mountLoop", key_word_list, &param1, &param2, &param3, &param4_str, &param4_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.mountLoop", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "VirtualFileSystem.mountLoop", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->mount_loop(*param1_this, *param2_this, (int)param3, basic_string<char>(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call VirtualFileSystem.mountLoop() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "mountLoop() takes 4 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "mountLoop(non-const VirtualFileSystem this, const Filename virtual_filename, const Filename mount_point, int flags)\n"
          "mountLoop(non-const VirtualFileSystem this, const Filename virtual_filename, const Filename mount_point, int flags, string password)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_mount_loop_1089_comment =
    "C++ Interface:\n"
    "mountLoop(non-const VirtualFileSystem this, const Filename virtual_filename, const Filename mount_point, int flags)\n"
    "mountLoop(non-const VirtualFileSystem this, const Filename virtual_filename, const Filename mount_point, int flags, string password)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::mount_loop\n"
    "//       Access: Published\n"
    "//  Description: This is similar to mount(), but it receives the name\n"
    "//               of a Multifile that already appears within the\n"
    "//               virtual file system.  It can be used to mount a\n"
    "//               Multifile that is itself hosted within a\n"
    "//               virtually-mounted Multifile.\n"
    "//\n"
    "//               This interface can also be used to mount physical\n"
    "//               files (that appear within the virtual filespace), but\n"
    "//               it cannot be used to mount directories.  Use mount()\n"
    "//               if you need to mount a directory.\n"
    "//\n"
    "//               Note that there is additional overhead, in the form\n"
    "//               of additional buffer copies of the data, for\n"
    "//               recursively mounting a multifile like this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_mount_loop_1089_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int VirtualFileSystem::unmount(Filename const &physical_filename)
 * int VirtualFileSystem::unmount(Multifile *multifile)
 * int VirtualFileSystem::unmount(VirtualFileMount *mount)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_unmount_1090(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int VirtualFileSystem::unmount(VirtualFileMount *mount)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mount", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmount", &param1));
            if(!PyErr_Occurred())
            {
                VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_VirtualFileMount, 1, "VirtualFileSystem.unmount", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->unmount(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int VirtualFileSystem::unmount(Multifile *multifile)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"multifile", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmount", &param1));
            if(!PyErr_Occurred())
            {
                Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Multifile, 1, "VirtualFileSystem.unmount", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    int return_value = (local_this)->unmount(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int VirtualFileSystem::unmount(Filename const &physical_filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physical_filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmount", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.unmount", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    int return_value = (local_this)->unmount(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unmount(non-const VirtualFileSystem this, non-const VirtualFileMount mount)\n"
          "unmount(non-const VirtualFileSystem this, non-const Multifile multifile)\n"
          "unmount(non-const VirtualFileSystem this, const Filename physical_filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_unmount_1090_comment =
    "C++ Interface:\n"
    "unmount(non-const VirtualFileSystem this, non-const VirtualFileMount mount)\n"
    "unmount(non-const VirtualFileSystem this, non-const Multifile multifile)\n"
    "unmount(non-const VirtualFileSystem this, const Filename physical_filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::unmount\n"
    "//       Access: Published\n"
    "//  Description: Unmounts all appearances of the indicated Multifile\n"
    "//               from the file system.  Returns the number of\n"
    "//               appearances unmounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::unmount\n"
    "//       Access: Published\n"
    "//  Description: Unmounts all appearances of the indicated directory\n"
    "//               name or multifile name from the file system.  Returns\n"
    "//               the number of appearances unmounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::unmount\n"
    "//       Access: Published\n"
    "//  Description: Unmounts the indicated VirtualFileMount object\n"
    "//               from the file system.  Returns the number of\n"
    "//               appearances unmounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_unmount_1090_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int VirtualFileSystem::unmount_point(Filename const &mount_point)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_unmount_point_1091(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int VirtualFileSystem::unmount_point(Filename const &mount_point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mount_point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmountPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmountPoint", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.unmountPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    int return_value = (local_this)->unmount_point(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call VirtualFileSystem.unmountPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unmountPoint(non-const VirtualFileSystem this, const Filename mount_point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_unmount_point_1091_comment =
    "C++ Interface:\n"
    "unmountPoint(non-const VirtualFileSystem this, const Filename mount_point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::unmount_point\n"
    "//       Access: Published\n"
    "//  Description: Unmounts all systems attached to the given mount\n"
    "//               point from the file system.  Returns the number of\n"
    "//               appearances unmounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_unmount_point_1091_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int VirtualFileSystem::unmount_all(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_unmount_all_1092(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int VirtualFileSystem::unmount_all(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unmountAll", key_word_list));
        else
            (PyArg_Parse(args, ":unmountAll"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            int return_value = (local_this)->unmount_all();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call VirtualFileSystem.unmountAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unmountAll(non-const VirtualFileSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_unmount_all_1092_comment =
    "C++ Interface:\n"
    "unmountAll(non-const VirtualFileSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::unmount_all\n"
    "//       Access: Published\n"
    "//  Description: Unmounts all files from the file system.  Returns the\n"
    "//               number of systems unmounted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_unmount_all_1092_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int VirtualFileSystem::get_num_mounts(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_get_num_mounts_1093(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int VirtualFileSystem::get_num_mounts(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumMounts", key_word_list));
        else
            (PyArg_Parse(args, ":getNumMounts"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const VirtualFileSystem*)local_this)->get_num_mounts();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumMounts(const VirtualFileSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_get_num_mounts_1093_comment =
    "C++ Interface:\n"
    "getNumMounts(const VirtualFileSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::get_num_mounts\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of individual mounts in the\n"
    "//               system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_get_num_mounts_1093_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_get_mount_1094(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getMount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getMount", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< VirtualFileMount > return_value = ((const VirtualFileSystem*)local_this)->get_mount((int)param1);
            if (return_value != (VirtualFileMount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_VirtualFileMount,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMount(const VirtualFileSystem this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_get_mount_1094_comment =
    "C++ Interface:\n"
    "getMount(const VirtualFileSystem this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::get_mount\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth mount in the system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_get_mount_1094_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool VirtualFileSystem::chdir(Filename const &new_directory)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_chdir_1095(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool VirtualFileSystem::chdir(Filename const &new_directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"new_directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:chdir", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:chdir", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.chdir", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->chdir(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call VirtualFileSystem.chdir() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "chdir(non-const VirtualFileSystem this, const Filename new_directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_chdir_1095_comment =
    "C++ Interface:\n"
    "chdir(non-const VirtualFileSystem this, const Filename new_directory)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::chdir\n"
    "//       Access: Published\n"
    "//  Description: Changes the current directory.  This is used to\n"
    "//               resolve relative pathnames in get_file() and/or\n"
    "//               find_file().  Returns true if successful, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_chdir_1095_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Filename VirtualFileSystem::get_cwd(void) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_get_cwd_1096(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Filename VirtualFileSystem::get_cwd(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCwd", key_word_list));
        else
            (PyArg_Parse(args, ":getCwd"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Filename result = ((const VirtualFileSystem*)local_this)->get_cwd();
            Filename *return_value = new Filename(result);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCwd(const VirtualFileSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_get_cwd_1096_comment =
    "C++ Interface:\n"
    "getCwd(const VirtualFileSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::get_cwd\n"
    "//       Access: Published\n"
    "//  Description: Returns the current directory name.  See chdir().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_get_cwd_1096_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only) const
 * PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = (0)) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_get_file_1097(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getFile", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getFile", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.getFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< VirtualFile > return_value = ((const VirtualFileSystem*)local_this)->get_file(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (VirtualFile *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_VirtualFile,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"status_only", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getFile", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.getFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< VirtualFile > return_value = ((const VirtualFileSystem*)local_this)->get_file(*param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (VirtualFile *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_VirtualFile,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getFile() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getFile(const VirtualFileSystem this, const Filename filename)\n"
          "getFile(const VirtualFileSystem this, const Filename filename, bool status_only)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_get_file_1097_comment =
    "C++ Interface:\n"
    "getFile(const VirtualFileSystem this, const Filename filename)\n"
    "getFile(const VirtualFileSystem this, const Filename filename, bool status_only)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::get_file\n"
    "//       Access: Published\n"
    "//  Description: Looks up the file by the indicated name in the file\n"
    "//               system.  Returns a VirtualFile pointer representing\n"
    "//               the file if it is found, or NULL if it is not.\n"
    "//\n"
    "//               If status_only is true, the file will be checked for\n"
    "//               existence and length and so on, but the returned\n"
    "//               file's contents cannot be read.  This is an\n"
    "//               optimization which is especially important for\n"
    "//               certain mount types, for instance HTTP, for which\n"
    "//               opening a file to determine its status is\n"
    "//               substantially less expensive than opening it to read\n"
    "//               its contents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_get_file_1097_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only) const
 * PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = (0)) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_find_file_1098(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = (0)) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"searchpath", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:findFile", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.findFile", 1, coerced_ptr, report_errors);
DSearchPath *param2_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath, 2, "VirtualFileSystem.findFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< VirtualFile > return_value = ((const VirtualFileSystem*)local_this)->find_file(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (VirtualFile *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_VirtualFile,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only) const
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"filename", (char *)"searchpath", (char *)"status_only", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:findFile", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.findFile", 1, coerced_ptr, report_errors);
DSearchPath *param2_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath, 2, "VirtualFileSystem.findFile", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< VirtualFile > return_value = ((const VirtualFileSystem*)local_this)->find_file(*param1_this, *param2_this, (PyObject_IsTrue(param3)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (VirtualFile *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_VirtualFile,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "findFile() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "findFile(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath)\n"
          "findFile(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath, bool status_only)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_find_file_1098_comment =
    "C++ Interface:\n"
    "findFile(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath)\n"
    "findFile(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath, bool status_only)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::find_file\n"
    "//       Access: Published\n"
    "//  Description: Uses the indicated search path to find the file\n"
    "//               within the file system.  Returns the first occurrence\n"
    "//               of the file found, or NULL if the file cannot be\n"
    "//               found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_find_file_1098_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, basic_string< char > const &default_extension) const
 * bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, basic_string< char > const &default_extension = ((string()))) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_resolve_filename_1099(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, basic_string< char > const &default_extension = ((string()))) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"searchpath", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:resolveFilename", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.resolveFilename", 0, coerced_ptr, report_errors);
DSearchPath *param2_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath, 2, "VirtualFileSystem.resolveFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const VirtualFileSystem*)local_this)->resolve_filename(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, basic_string< char > const &default_extension) const
                PyObject *param1;
                PyObject *param2;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"filename", (char *)"searchpath", (char *)"default_extension", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:resolveFilename", key_word_list, &param1, &param2, &param3_str, &param3_len))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.resolveFilename", 0, coerced_ptr, report_errors);
DSearchPath *param2_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath, 2, "VirtualFileSystem.resolveFilename", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const VirtualFileSystem*)local_this)->resolve_filename(*param1_this, *param2_this, basic_string<char>(param3_str, param3_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "resolveFilename() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "resolveFilename(const VirtualFileSystem this, non-const Filename filename, const DSearchPath searchpath)\n"
          "resolveFilename(const VirtualFileSystem this, non-const Filename filename, const DSearchPath searchpath, string default_extension)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_resolve_filename_1099_comment =
    "C++ Interface:\n"
    "resolveFilename(const VirtualFileSystem this, non-const Filename filename, const DSearchPath searchpath)\n"
    "resolveFilename(const VirtualFileSystem this, non-const Filename filename, const DSearchPath searchpath, string default_extension)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::resolve_filename\n"
    "//       Access: Public\n"
    "//  Description: Searches the given search path for the filename.  If\n"
    "//               it is found, updates the filename to the full\n"
    "//               pathname found and returns true; otherwise, returns\n"
    "//               false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_resolve_filename_1099_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_find_all_files_1100(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"filename", (char *)"searchpath", (char *)"results", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:findAllFiles", key_word_list, &param1, &param2, &param3))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.findAllFiles", 1, coerced_ptr, report_errors);
DSearchPath *param2_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DSearchPath, 2, "VirtualFileSystem.findAllFiles", 1, coerced_ptr, report_errors);
DSearchPath::Results *param3_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DSearchPath_Results, 3, "VirtualFileSystem.findAllFiles", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    int return_value = ((const VirtualFileSystem*)local_this)->find_all_files(*param1_this, *param2_this, *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findAllFiles(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath, non-const Results results)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_find_all_files_1100_comment =
    "C++ Interface:\n"
    "findAllFiles(const VirtualFileSystem this, const Filename filename, const DSearchPath searchpath, non-const Results results)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::find_all_files\n"
    "//       Access: Public\n"
    "//  Description: Searches all the directories in the search list for\n"
    "//               the indicated file, in order.  Fills up the results\n"
    "//               list with *all* of the matching filenames found, if\n"
    "//               any.  Returns the number of matches found.\n"
    "//\n"
    "//               It is the responsibility of the the caller to clear\n"
    "//               the results list first; otherwise, the newly-found\n"
    "//               files will be appended to the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_find_all_files_1100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VirtualFileSystem::exists(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_exists_1101(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool VirtualFileSystem::exists(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:exists", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:exists", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.exists", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = ((const VirtualFileSystem*)local_this)->exists(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "exists(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_exists_1101_comment =
    "C++ Interface:\n"
    "exists(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "// Filename: virtualFileSystem.I\n"
    "// Created by:  drose (03Aug02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::exists\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns true if the named file\n"
    "//               exists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_exists_1101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VirtualFileSystem::is_directory(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_is_directory_1102(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool VirtualFileSystem::is_directory(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.isDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = ((const VirtualFileSystem*)local_this)->is_directory(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDirectory(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_is_directory_1102_comment =
    "C++ Interface:\n"
    "isDirectory(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::is_directory\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns true if the named file\n"
    "//               exists and is a directory.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_is_directory_1102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_is_regular_file_1103(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isRegularFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isRegularFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.isRegularFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = ((const VirtualFileSystem*)local_this)->is_regular_file(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRegularFile(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_is_regular_file_1103_comment =
    "C++ Interface:\n"
    "isRegularFile(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::is_regular_file\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns true if the named file\n"
    "//               exists and is a regular file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_is_regular_file_1103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_scan_directory_1104(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:scanDirectory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:scanDirectory", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.scanDirectory", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PointerTo< VirtualFileList > return_value = ((const VirtualFileSystem*)local_this)->scan_directory(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (return_value != (VirtualFileList *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value.p(),Dtool_VirtualFileList,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "scanDirectory(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_scan_directory_1104_comment =
    "C++ Interface:\n"
    "scanDirectory(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::scan_directory\n"
    "//       Access: Published\n"
    "//  Description: If the file represents a directory (that is,\n"
    "//               is_directory() returns true), this returns the list\n"
    "//               of files within the directory at the current time.\n"
    "//               Returns NULL if the file is not a directory or if the\n"
    "//               directory cannot be read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_scan_directory_1104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void VirtualFileSystem::ls(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_ls_1105(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void VirtualFileSystem::ls(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ls", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ls", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.ls", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFileSystem*)local_this)->ls(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ls(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_ls_1105_comment =
    "C++ Interface:\n"
    "ls(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::ls\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; lists the files within the\n"
    "//               indicated directory.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_ls_1105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void VirtualFileSystem::ls_all(Filename const &filename) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_ls_all_1106(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void VirtualFileSystem::ls_all(Filename const &filename) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lsAll", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lsAll", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.lsAll", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFileSystem*)local_this)->ls_all(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lsAll(const VirtualFileSystem this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_ls_all_1106_comment =
    "C++ Interface:\n"
    "lsAll(const VirtualFileSystem this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::ls_all\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; lists the files within the\n"
    "//               indicated directory, and all files below,\n"
    "//               recursively.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_ls_all_1106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualFileSystem::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_write_1107(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void VirtualFileSystem::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VirtualFileSystem.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const VirtualFileSystem*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const VirtualFileSystem this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_write_1107_comment =
    "C++ Interface:\n"
    "write(const VirtualFileSystem this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::write\n"
    "//       Access: Published\n"
    "//  Description: Print debugging information.\n"
    "//               (e.g. from Python or gdb prompt).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_write_1107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_get_global_ptr_1108(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            VirtualFileSystem *return_value = VirtualFileSystem::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_VirtualFileSystem,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_get_global_ptr_1108_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the default global VirtualFileSystem.  You\n"
    "//               may create your own personal VirtualFileSystem\n"
    "//               objects and use them for whatever you like, but Panda\n"
    "//               will attempt to load models and stuff from this\n"
    "//               default object.\n"
    "//\n"
    "//               Initially, the global VirtualFileSystem is set up to\n"
    "//               mount the OS filesystem to root; i.e. it is\n"
    "//               equivalent to the OS filesystem.  This may be\n"
    "//               subsequently adjusted by the user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_get_global_ptr_1108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *VirtualFileSystem::__py__read_file(Filename const &filename, bool auto_unwrap) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_py_read_file_1109(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PyObject *VirtualFileSystem::__py__read_file(Filename const &filename, bool auto_unwrap) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"auto_unwrap", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:readFile", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.readFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PyObject *return_value = ((const VirtualFileSystem*)local_this)->__py__read_file(*param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return  return_value;
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_py_read_file_1109_comment =
    "C++ Interface:\n"
    "readFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::__py__read_file\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns the entire contents of\n"
    "//               the indicated file as a string.\n"
    "//\n"
    "//               This variant on read_file() is implemented directly\n"
    "//               for Python, as a small optimization, to avoid the\n"
    "//               double-construction of a string object that would be\n"
    "//               otherwise required for the return value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_py_read_file_1109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_read_file_1110(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"auto_unwrap", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:readFile", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.readFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    basic_string< char > return_value = ((const VirtualFileSystem*)local_this)->read_file(*param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_read_file_1110_comment =
    "C++ Interface:\n"
    "readFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
    "\n"
    "// HAVE_PYTHON\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::read_file\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns the entire contents of\n"
    "//               the indicated file as a string.\n"
    "//\n"
    "//               If auto_unwrap is true, an explicitly-named .pz file\n"
    "//               is automatically decompressed and the decompressed\n"
    "//               contents are returned.  This is different than\n"
    "//               vfs-implicit-pz, which will automatically decompress\n"
    "//               a file if the extension .pz is *not* given.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::read_file\n"
    "//       Access: Public\n"
    "//  Description: Convenience function; fills the string up with the\n"
    "//               data from the indicated file, if it exists and can be\n"
    "//               read.  Returns true on success, false otherwise.\n"
    "//\n"
    "//               If auto_unwrap is true, an explicitly-named .pz file\n"
    "//               is automatically decompressed and the decompressed\n"
    "//               contents are returned.  This is different than\n"
    "//               vfs-implicit-pz, which will automatically decompress\n"
    "//               a file if the extension .pz is *not* given.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::read_file\n"
    "//       Access: Public\n"
    "//  Description: Convenience function; fills the pvector up with the\n"
    "//               data from the indicated file, if it exists and can be\n"
    "//               read.  Returns true on success, false otherwise.\n"
    "//\n"
    "//               If auto_unwrap is true, an explicitly-named .pz file\n"
    "//               is automatically decompressed and the decompressed\n"
    "//               contents are returned.  This is different than\n"
    "//               vfs-implicit-pz, which will automatically decompress\n"
    "//               a file if the extension .pz is *not* given.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_read_file_1110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_open_read_file_1111(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"auto_unwrap", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:openReadFile", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "VirtualFileSystem.openReadFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    istream *return_value = ((const VirtualFileSystem*)local_this)->open_read_file(*param1_this, (PyObject_IsTrue(param2)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_istream,false, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "openReadFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_open_read_file_1111_comment =
    "C++ Interface:\n"
    "openReadFile(const VirtualFileSystem this, const Filename filename, bool auto_unwrap)\n"
    "\n"
    "// HAVE_PYTHON\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::open_read_file\n"
    "//       Access: Published\n"
    "//  Description: Convenience function; returns a newly allocated\n"
    "//               istream if the file exists and can be read, or NULL\n"
    "//               otherwise.  Does not return an invalid istream.\n"
    "//\n"
    "//               If auto_unwrap is true, an explicitly-named .pz file\n"
    "//               is automatically decompressed and the decompressed\n"
    "//               contents are returned.  This is different than\n"
    "//               vfs-implicit-pz, which will automatically decompress\n"
    "//               a file if the extension .pz is *not* given.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_open_read_file_1111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void VirtualFileSystem::close_read_file(istream *stream)
 *******************************************************************/
static PyObject *Dtool_VirtualFileSystem_close_read_file_1112(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void VirtualFileSystem::close_read_file(istream *stream)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:closeReadFile", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:closeReadFile", &param0));
            if(!PyErr_Occurred())
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "VirtualFileSystem.closeReadFile", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    VirtualFileSystem::close_read_file(param0_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeReadFile(non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualFileSystem_close_read_file_1112_comment =
    "C++ Interface:\n"
    "closeReadFile(non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualFileSystem::close_read_file\n"
    "//       Access: Published, Static\n"
    "//  Description: Closes a file opened by a previous call to\n"
    "//               open_read_file().  This really just deletes the\n"
    "//               istream pointer, but it is recommended to use this\n"
    "//               interface instead of deleting it explicitly, to help\n"
    "//               work around compiler issues.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualFileSystem_close_read_file_1112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * VirtualFileSystem::VirtualFileSystem(void)
 *******************************************************************/
int  Dtool_Init_VirtualFileSystem(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-VirtualFileSystem::VirtualFileSystem(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":VirtualFileSystem", key_word_list))
        {
            VirtualFileSystem *return_value = new VirtualFileSystem();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualFileSystem,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VirtualFileSystem()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_VirtualFileSystem_get_mounts(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumMounts", "getMount");
}
inline void  * Dtool_UpcastInterface_VirtualFileSystem(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualFileSystem)
    {
        printf("VirtualFileSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualFileSystem * local_this = (VirtualFileSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualFileSystem)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualFileSystem(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualFileSystem)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Ramfile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Ramfile::seek(unsigned int pos)
 *******************************************************************/
static PyObject *Dtool_Ramfile_seek_1115(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Ramfile::seek(unsigned int pos)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"pos", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:seek", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:seek", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->seek(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ramfile.seek() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "seek(non-const Ramfile this, unsigned int pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_seek_1115_comment =
    "C++ Interface:\n"
    "seek(non-const Ramfile this, unsigned int pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::seek\n"
    "//       Access: Published\n"
    "//  Description: Moves the data pointer to the indicated byte\n"
    "//               position.  It is not an error to move the pointer\n"
    "//               past the end of data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_seek_1115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Ramfile::tell(void) const
 *******************************************************************/
static PyObject *Dtool_Ramfile_tell_1116(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Ramfile::tell(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tell", key_word_list));
        else
            (PyArg_Parse(args, ":tell"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Ramfile*)local_this)->tell();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tell(const Ramfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_tell_1116_comment =
    "C++ Interface:\n"
    "tell(const Ramfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::tell\n"
    "//       Access: Published\n"
    "//  Description: Returns the current data pointer position as a byte\n"
    "//               offset from the beginning of the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_tell_1116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Ramfile::read(unsigned int length)
 *******************************************************************/
static PyObject *Dtool_Ramfile_read_1117(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Ramfile::read(unsigned int length)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:read", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = (local_this)->read(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ramfile.read() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "read(non-const Ramfile this, unsigned int length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_read_1117_comment =
    "C++ Interface:\n"
    "read(non-const Ramfile this, unsigned int length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::read\n"
    "//       Access: Published\n"
    "//  Description: Extracts and returns the indicated number of\n"
    "//               characters from the current data pointer, and\n"
    "//               advances the data pointer.  If the data pointer\n"
    "//               exceeds the end of the buffer, returns empty string.\n"
    "//\n"
    "//               The interface here is intentionally designed to be\n"
    "//               similar to that for Python's file.read() function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_read_1117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Ramfile::readline(void)
 *******************************************************************/
static PyObject *Dtool_Ramfile_readline_1118(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Ramfile::readline(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":readline", key_word_list));
        else
            (PyArg_Parse(args, ":readline"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->readline();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ramfile.readline() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readline(non-const Ramfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_readline_1118_comment =
    "C++ Interface:\n"
    "readline(non-const Ramfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::readline\n"
    "//       Access: Published\n"
    "//  Description: Assumes the stream represents a text file, and\n"
    "//               extracts one line up to and including the trailing\n"
    "//               newline character.  Returns empty string when the end\n"
    "//               of file is reached.\n"
    "//\n"
    "//               The interface here is intentionally designed to be\n"
    "//               similar to that for Python's file.readline()\n"
    "//               function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_readline_1118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Ramfile::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_Ramfile_get_data_1119(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Ramfile::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Ramfile*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const Ramfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_get_data_1119_comment =
    "C++ Interface:\n"
    "getData(const Ramfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::get_data\n"
    "//       Access: Published\n"
    "//  Description: Returns the entire buffer contents as a string,\n"
    "//               regardless of the current data pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_get_data_1119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Ramfile::get_data_size(void) const
 *******************************************************************/
static PyObject *Dtool_Ramfile_get_data_size_1120(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int Ramfile::get_data_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDataSize", key_word_list));
        else
            (PyArg_Parse(args, ":getDataSize"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const Ramfile*)local_this)->get_data_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDataSize(const Ramfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_get_data_size_1120_comment =
    "C++ Interface:\n"
    "getDataSize(const Ramfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::get_data_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the size of the entire buffer contents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_get_data_size_1120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Ramfile::clear(void)
 *******************************************************************/
static PyObject *Dtool_Ramfile_clear_1121(PyObject *self, PyObject *args,PyObject *kwds) {
    Ramfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Ramfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Ramfile::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Ramfile.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const Ramfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Ramfile_clear_1121_comment =
    "C++ Interface:\n"
    "clear(non-const Ramfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Ramfile::clear\n"
    "//       Access: Published\n"
    "//  Description: Empties the current buffer contents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Ramfile_clear_1121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Ramfile::Ramfile(void)
 *******************************************************************/
int  Dtool_Init_Ramfile(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Ramfile::Ramfile(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Ramfile", key_word_list))
        {
            Ramfile *return_value = new Ramfile();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Ramfile,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Ramfile()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Ramfile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Ramfile)
    {
        printf("Ramfile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Ramfile * local_this = (Ramfile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Ramfile)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Ramfile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Ramfile)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HashVal 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::operator =(HashVal const &copy)
 *******************************************************************/
static PyObject *Dtool_HashVal_operator_1125(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::operator =(HashVal const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    HashVal *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const HashVal this, const HashVal copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_operator_1125_comment =
    "C++ Interface:\n"
    "assign(non-const HashVal this, const HashVal copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_operator_1125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HashVal::operator ==(HashVal const &other) const
 *******************************************************************/
static PyObject *Dtool_HashVal_operator_1126(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HashVal::operator ==(HashVal const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HashVal*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const HashVal this, const HashVal other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_operator_1126_comment =
    "C++ Interface:\n"
    "eq(const HashVal this, const HashVal other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::operator ==\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_operator_1126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HashVal::operator !=(HashVal const &other) const
 *******************************************************************/
static PyObject *Dtool_HashVal_operator_1127(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HashVal::operator !=(HashVal const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HashVal*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const HashVal this, const HashVal other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_operator_1127_comment =
    "C++ Interface:\n"
    "ne(const HashVal this, const HashVal other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::operator !=\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_operator_1127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool HashVal::operator <(HashVal const &other) const
 *******************************************************************/
static PyObject *Dtool_HashVal_operator_1128(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool HashVal::operator <(HashVal const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const HashVal*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const HashVal this, const HashVal other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_operator_1128_comment =
    "C++ Interface:\n"
    "lessThan(const HashVal this, const HashVal other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::operator <\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_operator_1128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int HashVal::compare_to(HashVal const &other) const
 *******************************************************************/
static PyObject *Dtool_HashVal_compare_to_1129(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int HashVal::compare_to(HashVal const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const HashVal*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const HashVal this, const HashVal other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_compare_to_1129_comment =
    "C++ Interface:\n"
    "compareTo(const HashVal this, const HashVal other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::compare_to\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_compare_to_1129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::merge_with(HashVal const &other)
 *******************************************************************/
static PyObject *Dtool_HashVal_merge_with_1130(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::merge_with(HashVal const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:mergeWith", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:mergeWith", &param1));
            if(!PyErr_Occurred())
            {
                HashVal *param1_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HashVal, 1, "HashVal.mergeWith", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->merge_with(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.mergeWith() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mergeWith(non-const HashVal this, const HashVal other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_merge_with_1130_comment =
    "C++ Interface:\n"
    "mergeWith(non-const HashVal this, const HashVal other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::merge_with\n"
    "//       Access: Published\n"
    "//  Description: Generates a new HashVal representing the xor of this\n"
    "//               one and the other one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_merge_with_1130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::output_dec(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HashVal_output_dec_1131(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void HashVal::output_dec(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputDec", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputDec", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HashVal.outputDec", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->output_dec(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputDec(const HashVal this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_output_dec_1131_comment =
    "C++ Interface:\n"
    "outputDec(const HashVal this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::output_dec\n"
    "//       Access: Published\n"
    "//  Description: Outputs the HashVal as four unsigned decimal\n"
    "//               integers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_output_dec_1131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::input_dec(istream &in)
 *******************************************************************/
static PyObject *Dtool_HashVal_input_dec_1132(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::input_dec(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:inputDec", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:inputDec", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HashVal.inputDec", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->input_dec(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.inputDec() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "inputDec(non-const HashVal this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_input_dec_1132_comment =
    "C++ Interface:\n"
    "inputDec(non-const HashVal this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::input\n"
    "//       Access: Published\n"
    "//  Description: Inputs the HashVal as four unsigned decimal integers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_input_dec_1132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HashVal::output_hex(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HashVal_output_hex_1133(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HashVal::output_hex(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputHex", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputHex", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HashVal.outputHex", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->output_hex(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputHex(const HashVal this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_output_hex_1133_comment =
    "C++ Interface:\n"
    "outputHex(const HashVal this, non-const Ostream out)\n"
    "\n"
    "// HAVE_OPENSSL\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::output_hex\n"
    "//       Access: Published\n"
    "//  Description: Outputs the HashVal as a 32-digit hexadecimal number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_output_hex_1133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HashVal::input_hex(istream &in)
 *******************************************************************/
static PyObject *Dtool_HashVal_input_hex_1134(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HashVal::input_hex(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:inputHex", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:inputHex", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HashVal.inputHex", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->input_hex(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.inputHex() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "inputHex(non-const HashVal this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_input_hex_1134_comment =
    "C++ Interface:\n"
    "inputHex(non-const HashVal this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::input_hex\n"
    "//       Access: Published\n"
    "//  Description: Inputs the HashVal as a 32-digit hexadecimal number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_input_hex_1134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HashVal::output_binary(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HashVal_output_binary_1135(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void HashVal::output_binary(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBinary", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputBinary", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HashVal.outputBinary", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->output_binary(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputBinary(const HashVal this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_output_binary_1135_comment =
    "C++ Interface:\n"
    "outputBinary(const HashVal this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::output_binary\n"
    "//       Access: Published\n"
    "//  Description: Outputs the HashVal as a binary stream of bytes in\n"
    "//               order.  This is not the same order generated by\n"
    "//               write_stream().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_output_binary_1135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HashVal::input_binary(istream &in)
 *******************************************************************/
static PyObject *Dtool_HashVal_input_binary_1136(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void HashVal::input_binary(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:inputBinary", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:inputBinary", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HashVal.inputBinary", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->input_binary(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.inputBinary() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "inputBinary(non-const HashVal this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_input_binary_1136_comment =
    "C++ Interface:\n"
    "inputBinary(non-const HashVal this, non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::input_binary\n"
    "//       Access: Published\n"
    "//  Description: Inputs the HashVal as a binary stream of bytes in\n"
    "//               order.  This is not the same order expected by\n"
    "//               read_stream().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_input_binary_1136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_HashVal_output_1137(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void HashVal::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "HashVal.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const HashVal this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_output_1137_comment =
    "C++ Interface:\n"
    "output(const HashVal this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_output_1137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HashVal::as_dec(void) const
 *******************************************************************/
static PyObject *Dtool_HashVal_as_dec_1138(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HashVal::as_dec(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asDec", key_word_list));
        else
            (PyArg_Parse(args, ":asDec"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HashVal*)local_this)->as_dec();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asDec(const HashVal this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_as_dec_1138_comment =
    "C++ Interface:\n"
    "asDec(const HashVal this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::as_dec\n"
    "//       Access: Published\n"
    "//  Description: Returns the HashVal as a string with four decimal\n"
    "//               numbers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_as_dec_1138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HashVal::set_from_dec(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_HashVal_set_from_dec_1139(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HashVal::set_from_dec(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFromDec", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFromDec", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_from_dec(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HashVal.setFromDec() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFromDec(non-const HashVal this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_set_from_dec_1139_comment =
    "C++ Interface:\n"
    "setFromDec(non-const HashVal this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::set_from_dec\n"
    "//       Access: Published\n"
    "//  Description: Sets the HashVal from a string with four decimal\n"
    "//               numbers.  Returns true if valid, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_set_from_dec_1139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HashVal::as_hex(void) const
 *******************************************************************/
static PyObject *Dtool_HashVal_as_hex_1140(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HashVal::as_hex(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asHex", key_word_list));
        else
            (PyArg_Parse(args, ":asHex"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HashVal*)local_this)->as_hex();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asHex(const HashVal this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_as_hex_1140_comment =
    "C++ Interface:\n"
    "asHex(const HashVal this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::as_hex\n"
    "//       Access: Published\n"
    "//  Description: Returns the HashVal as a 32-byte hexadecimal string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_as_hex_1140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HashVal::set_from_hex(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_HashVal_set_from_hex_1141(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HashVal::set_from_hex(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFromHex", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFromHex", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_from_hex(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HashVal.setFromHex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFromHex(non-const HashVal this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_set_from_hex_1141_comment =
    "C++ Interface:\n"
    "setFromHex(non-const HashVal this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::set_from_hex\n"
    "//       Access: Published\n"
    "//  Description: Sets the HashVal from a 32-byte hexademical string.\n"
    "//               Returns true if successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_set_from_hex_1141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > HashVal::as_bin(void) const
 *******************************************************************/
static PyObject *Dtool_HashVal_as_bin_1142(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > HashVal::as_bin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asBin", key_word_list));
        else
            (PyArg_Parse(args, ":asBin"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const HashVal*)local_this)->as_bin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asBin(const HashVal this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_as_bin_1142_comment =
    "C++ Interface:\n"
    "asBin(const HashVal this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::as_bin\n"
    "//       Access: Published\n"
    "//  Description: Returns the HashVal as a 16-byte binary string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_as_bin_1142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HashVal::set_from_bin(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_HashVal_set_from_bin_1143(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool HashVal::set_from_bin(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFromBin", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFromBin", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_from_bin(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HashVal.setFromBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFromBin(non-const HashVal this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_set_from_bin_1143_comment =
    "C++ Interface:\n"
    "setFromBin(non-const HashVal this, string text)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::set_from_bin\n"
    "//       Access: Published\n"
    "//  Description: Sets the HashVal from a 16-byte binary string.\n"
    "//               Returns true if successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_set_from_bin_1143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::write_datagram(Datagram &destination) const
 *******************************************************************/
static PyObject *Dtool_HashVal_write_datagram_1144(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void HashVal::write_datagram(Datagram &destination) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"destination", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "HashVal.writeDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->write_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeDatagram(const HashVal this, non-const Datagram destination)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_write_datagram_1144_comment =
    "C++ Interface:\n"
    "writeDatagram(const HashVal this, non-const Datagram destination)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::write_datagram\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_write_datagram_1144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::read_datagram(DatagramIterator &source)
 *******************************************************************/
static PyObject *Dtool_HashVal_read_datagram_1145(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::read_datagram(DatagramIterator &source)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:readDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:readDatagram", &param1));
            if(!PyErr_Occurred())
            {
                DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramIterator, 1, "HashVal.readDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->read_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.readDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readDatagram(non-const HashVal this, non-const DatagramIterator source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_read_datagram_1145_comment =
    "C++ Interface:\n"
    "readDatagram(non-const HashVal this, non-const DatagramIterator source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::read_datagram\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_read_datagram_1145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::write_stream(StreamWriter &destination) const
 *******************************************************************/
static PyObject *Dtool_HashVal_write_stream_1146(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void HashVal::write_stream(StreamWriter &destination) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"destination", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeStream", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeStream", &param1));
            if(!PyErr_Occurred())
            {
                StreamWriter *param1_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StreamWriter, 1, "HashVal.writeStream", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const HashVal*)local_this)->write_stream(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeStream(const HashVal this, non-const StreamWriter destination)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_write_stream_1146_comment =
    "C++ Interface:\n"
    "writeStream(const HashVal this, non-const StreamWriter destination)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::write_stream\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_write_stream_1146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::read_stream(StreamReader &source)
 *******************************************************************/
static PyObject *Dtool_HashVal_read_stream_1147(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::read_stream(StreamReader &source)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"source", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:readStream", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:readStream", &param1));
            if(!PyErr_Occurred())
            {
                StreamReader *param1_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StreamReader, 1, "HashVal.readStream", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->read_stream(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.readStream() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readStream(non-const HashVal this, non-const StreamReader source)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_read_stream_1147_comment =
    "C++ Interface:\n"
    "readStream(non-const HashVal this, non-const StreamReader source)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::read_stream\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_read_stream_1147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HashVal::hash_file(Filename const &filename)
 *******************************************************************/
static PyObject *Dtool_HashVal_hash_file_1148(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HashVal::hash_file(Filename const &filename)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hashFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hashFile", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "HashVal.hashFile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->hash_file(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.hashFile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashFile(non-const HashVal this, const Filename filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_hash_file_1148_comment =
    "C++ Interface:\n"
    "hashFile(non-const HashVal this, const Filename filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::hash_file\n"
    "//       Access: Published\n"
    "//  Description: Generates the hash value from the indicated file.\n"
    "//               Returns true on success, false if the file cannot be\n"
    "//               read.  This method is only defined if we have the\n"
    "//               OpenSSL library (which provides md5 functionality)\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_hash_file_1148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool HashVal::hash_stream(istream &stream)
 *******************************************************************/
static PyObject *Dtool_HashVal_hash_stream_1149(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool HashVal::hash_stream(istream &stream)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stream", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hashStream", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hashStream", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "HashVal.hashStream", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->hash_stream(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.hashStream() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashStream(non-const HashVal this, non-const Istream stream)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_hash_stream_1149_comment =
    "C++ Interface:\n"
    "hashStream(non-const HashVal this, non-const Istream stream)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::hash_stream\n"
    "//       Access: Published\n"
    "//  Description: Generates the hash value from the indicated file.\n"
    "//               Returns true on success, false if the file cannot be\n"
    "//               read.  This method is only defined if we have the\n"
    "//               OpenSSL library (which provides md5 functionality)\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_hash_stream_1149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::hash_ramfile(Ramfile const &ramfile)
 *******************************************************************/
static PyObject *Dtool_HashVal_hash_ramfile_1150(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void HashVal::hash_ramfile(Ramfile const &ramfile)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ramfile", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hashRamfile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hashRamfile", &param1));
            if(!PyErr_Occurred())
            {
                Ramfile *param1_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Ramfile, 1, "HashVal.hashRamfile", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->hash_ramfile(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call HashVal.hashRamfile() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashRamfile(non-const HashVal this, const Ramfile ramfile)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_hash_ramfile_1150_comment =
    "C++ Interface:\n"
    "hashRamfile(non-const HashVal this, const Ramfile ramfile)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::hash_ramfile\n"
    "//       Access: Published\n"
    "//  Description: Generates the hash value by hashing the indicated\n"
    "//               data.  This method is only defined if we have the\n"
    "//               OpenSSL library (which provides md5 functionality)\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_hash_ramfile_1150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void HashVal::hash_string(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_HashVal_hash_string_1151(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void HashVal::hash_string(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hashString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hashString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->hash_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HashVal.hashString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashString(non-const HashVal this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_hash_string_1151_comment =
    "C++ Interface:\n"
    "hashString(non-const HashVal this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::hash_string\n"
    "//       Access: Published\n"
    "//  Description: Generates the hash value by hashing the indicated\n"
    "//               data.  This method is only defined if we have the\n"
    "//               OpenSSL library (which provides md5 functionality)\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_hash_string_1151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void HashVal::hash_buffer(char const *buffer, int length)
 *******************************************************************/
static PyObject *Dtool_HashVal_hash_buffer_1152(PyObject *self, PyObject *args,PyObject *kwds) {
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void HashVal::hash_buffer(char const *buffer, int length)
        char *param1;
        int param2;
        static char * key_word_list[] = {(char *)"buffer", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "si:hashBuffer", key_word_list, &param1, &param2))
        {
            (local_this)->hash_buffer((char const *)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HashVal.hashBuffer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hashBuffer(non-const HashVal this, string buffer, int length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HashVal_hash_buffer_1152_comment =
    "C++ Interface:\n"
    "hashBuffer(non-const HashVal this, string buffer, int length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: HashVal::hash_buffer\n"
    "//       Access: Published\n"
    "//  Description: Generates the hash value by hashing the indicated\n"
    "//               data.  This method is only defined if we have the\n"
    "//               OpenSSL library (which provides md5 functionality)\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_HashVal_hash_buffer_1152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HashVal::HashVal(void)
 * inline HashVal::HashVal(HashVal const &copy)
 *******************************************************************/
int  Dtool_Init_HashVal(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline HashVal::HashVal(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":HashVal", key_word_list))
            {
                HashVal *return_value = new HashVal();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_HashVal,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline HashVal::HashVal(HashVal const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HashVal", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HashVal", &param0));
                if(!PyErr_Occurred())
                {
                    HashVal *param0_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HashVal, 0, "HashVal.HashVal", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        HashVal *return_value = new HashVal(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HashVal,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HashVal() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HashVal()\n"
          "HashVal(const HashVal copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HashVal(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HashVal)
    {
        printf("HashVal ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HashVal * local_this = (HashVal *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HashVal)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HashVal(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HashVal)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Patchfile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
 *******************************************************************/
static PyObject *Dtool_Patchfile_build_1157(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"file_orig", (char *)"file_new", (char *)"patch_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:build", key_word_list, &param1, &param2, &param3))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.build", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patchfile.build", 1, coerced_ptr, report_errors);
Filename *param3_this = (Filename *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Filename, 3, "Patchfile.build", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = (local_this)->build(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Patchfile.build() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "build(non-const Patchfile this, const Filename file_orig, const Filename file_new, const Filename patch_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_build_1157_comment =
    "C++ Interface:\n"
    "build(non-const Patchfile this, const Filename file_orig, const Filename file_new, const Filename patch_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::build\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "//               This implementation uses the \"greedy differencing\n"
    "//               algorithm\" described in the masters thesis\n"
    "//               \"Differential Compression: A Generalized Solution\n"
    "//               for Binary Files\" by Randal C. Burns (p.13).\n"
    "//               For an original file of size M and a new file of\n"
    "//               size N, this algorithm is O(M) in space and\n"
    "//               O(M*N) (worst-case) in time.\n"
    "//               return false on error\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_build_1157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Patchfile::read_header(Filename const &patch_file)
 *******************************************************************/
static PyObject *Dtool_Patchfile_read_header_1158(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int Patchfile::read_header(Filename const &patch_file)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"patch_file", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:readHeader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:readHeader", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.readHeader", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->read_header(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Patchfile.readHeader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readHeader(non-const Patchfile this, const Filename patch_file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_read_header_1158_comment =
    "C++ Interface:\n"
    "readHeader(non-const Patchfile this, const Filename patch_file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::read_header\n"
    "//       Access: Published\n"
    "//  Description: Opens the patch file for reading, and gets the header\n"
    "//               information from the file but does not begin to do\n"
    "//               any real work.  This can be used to query the data\n"
    "//               stored in the patch.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_read_header_1158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Patchfile::initiate(Filename const &patch_file, Filename const &file)
 * int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
 *******************************************************************/
static PyObject *Dtool_Patchfile_initiate_1159(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &file)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"patch_file", (char *)"file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:initiate", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.initiate", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patchfile.initiate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        int return_value = (local_this)->initiate(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Patchfile.initiate() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"patch_file", (char *)"orig_file", (char *)"target_file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:initiate", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.initiate", 1, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patchfile.initiate", 1, coerced_ptr, report_errors);
Filename *param3_this = (Filename *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Filename, 3, "Patchfile.initiate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        int return_value = (local_this)->initiate(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Patchfile.initiate() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "initiate() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "initiate(non-const Patchfile this, const Filename patch_file, const Filename file)\n"
          "initiate(non-const Patchfile this, const Filename patch_file, const Filename orig_file, const Filename target_file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_initiate_1159_comment =
    "C++ Interface:\n"
    "initiate(non-const Patchfile this, const Filename patch_file, const Filename file)\n"
    "initiate(non-const Patchfile this, const Filename patch_file, const Filename orig_file, const Filename target_file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "///// PATCH FILE APPLY MEMBER FUNCTIONS\n"
    "/////\n"
    "////////////////////\n"
    "///// NOTE: this patch-application functionality unfortunately has to be\n"
    "/////       duplicated in the Installer. It is contained in the file\n"
    "/////       installerApplyPatch.cxx\n"
    "/////       PLEASE MAKE SURE THAT THAT FILE GETS UPDATED IF ANY OF THIS\n"
    "/////       LOGIC CHANGES! (i.e. if the patch file format changes)\n"
    "////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::initiate\n"
    "//       Access: Published\n"
    "//  Description: Set up to apply the patch to the file (original\n"
    "//               file and patch are destroyed in the process).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::initiate\n"
    "//       Access: Published\n"
    "//  Description: Set up to apply the patch to the file.  In this form,\n"
    "//               neither the original file nor the patch file are\n"
    "//               destroyed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_initiate_1159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Patchfile::run(void)
 *******************************************************************/
static PyObject *Dtool_Patchfile_run_1160(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int Patchfile::run(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":run", key_word_list));
        else
            (PyArg_Parse(args, ":run"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->run();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.run() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "run(non-const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_run_1160_comment =
    "C++ Interface:\n"
    "run(non-const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::run\n"
    "//       Access: Published\n"
    "//  Description: Perform one buffer's worth of patching\n"
    "//               Returns EU_ok while patching\n"
    "//               Returns EU_success when done\n"
    "//               If error happens will return one of:\n"
    "//               EU_error_abort : Patching has not been initiated\n"
    "//               EU_error_file_invalid : file is corrupted\n"
    "//               EU_error_invalid_checksum : incompatible patch file\n"
    "//               EU_error_write_file_rename : could not rename file\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_run_1160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Patchfile::apply(Filename &patch_file, Filename &file)
 * bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
 *******************************************************************/
static PyObject *Dtool_Patchfile_apply_1161(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Patchfile::apply(Filename &patch_file, Filename &file)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"patch_file", (char *)"file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:apply", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.apply", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patchfile.apply", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->apply(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Patchfile.apply() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"patch_file", (char *)"orig_file", (char *)"target_file", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:apply", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "Patchfile.apply", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "Patchfile.apply", 0, coerced_ptr, report_errors);
Filename *param3_this = (Filename *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Filename, 3, "Patchfile.apply", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = (local_this)->apply(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Patchfile.apply() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "apply() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "apply(non-const Patchfile this, non-const Filename patch_file, non-const Filename file)\n"
          "apply(non-const Patchfile this, non-const Filename patch_file, non-const Filename orig_file, const Filename target_file)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_apply_1161_comment =
    "C++ Interface:\n"
    "apply(non-const Patchfile this, non-const Filename patch_file, non-const Filename file)\n"
    "apply(non-const Patchfile this, non-const Filename patch_file, non-const Filename orig_file, const Filename target_file)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::apply\n"
    "//       Access: Public\n"
    "//  Description: Patches the entire file in one call\n"
    "//               returns true on success and false on error\n"
    "//\n"
    "//               This version will delete the patch file and overwrite\n"
    "//               the original file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::apply\n"
    "//       Access: Public\n"
    "//  Description: Patches the entire file in one call\n"
    "//               returns true on success and false on error\n"
    "//\n"
    "//               This version will not delete any files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_apply_1161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Patchfile::get_progress(void) const
 *******************************************************************/
static PyObject *Dtool_Patchfile_get_progress_1162(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Patchfile::get_progress(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProgress", key_word_list));
        else
            (PyArg_Parse(args, ":getProgress"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Patchfile*)local_this)->get_progress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProgress(const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_get_progress_1162_comment =
    "C++ Interface:\n"
    "getProgress(const Patchfile this)\n"
    "\n"
    "// Filename: patchfile.I\n"
    "// Created by:  darren, mike (09Jan97)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//#include \"config_downloader.h\"\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::get_progress\n"
    "//       Access: Published\n"
    "//  Description: Returns a value in the range 0..1, representing the\n"
    "//               amount of progress through the patchfile, during a\n"
    "//               session.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_get_progress_1162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Patchfile::set_allow_multifile(bool allow_multifile)
 *******************************************************************/
static PyObject *Dtool_Patchfile_set_allow_multifile_1163(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Patchfile::set_allow_multifile(bool allow_multifile)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"allow_multifile", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAllowMultifile", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAllowMultifile", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_allow_multifile((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.setAllowMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAllowMultifile(non-const Patchfile this, bool allow_multifile)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_set_allow_multifile_1163_comment =
    "C++ Interface:\n"
    "setAllowMultifile(non-const Patchfile this, bool allow_multifile)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::set_allow_multifile\n"
    "//       Access: Published\n"
    "//  Description: If this flag is set true, the Patchfile will make a\n"
    "//               special case for patching Panda Multifiles, if\n"
    "//               detected, and attempt to patch them on a\n"
    "//               subfile-by-subfile basis.  If this flag is false, the\n"
    "//               Patchfile will always patch the file on a full-file\n"
    "//               basis.\n"
    "//\n"
    "//               This has effect only when building patches; it is not\n"
    "//               used for applying patches.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_set_allow_multifile_1163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Patchfile::get_allow_multifile(void)
 *******************************************************************/
static PyObject *Dtool_Patchfile_get_allow_multifile_1164(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Patchfile::get_allow_multifile(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAllowMultifile", key_word_list));
        else
            (PyArg_Parse(args, ":getAllowMultifile"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_allow_multifile();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.getAllowMultifile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAllowMultifile(non-const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_get_allow_multifile_1164_comment =
    "C++ Interface:\n"
    "getAllowMultifile(non-const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::get_allow_multifile\n"
    "//       Access: Published\n"
    "//  Description: See set_allow_multifile().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_get_allow_multifile_1164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Patchfile::set_footprint_length(int length)
 *******************************************************************/
static PyObject *Dtool_Patchfile_set_footprint_length_1165(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Patchfile::set_footprint_length(int length)
        int param1;
        static char * key_word_list[] = {(char *)"length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFootprintLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFootprintLength", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_footprint_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.setFootprintLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFootprintLength(non-const Patchfile this, int length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_set_footprint_length_1165_comment =
    "C++ Interface:\n"
    "setFootprintLength(non-const Patchfile this, int length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::set_footprint_length\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_set_footprint_length_1165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Patchfile::get_footprint_length(void)
 *******************************************************************/
static PyObject *Dtool_Patchfile_get_footprint_length_1166(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Patchfile::get_footprint_length(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFootprintLength", key_word_list));
        else
            (PyArg_Parse(args, ":getFootprintLength"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_footprint_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.getFootprintLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFootprintLength(non-const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_get_footprint_length_1166_comment =
    "C++ Interface:\n"
    "getFootprintLength(non-const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::get_footprint_length\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_get_footprint_length_1166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Patchfile::reset_footprint_length(void)
 *******************************************************************/
static PyObject *Dtool_Patchfile_reset_footprint_length_1167(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Patchfile::reset_footprint_length(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetFootprintLength", key_word_list));
        else
            (PyArg_Parse(args, ":resetFootprintLength"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_footprint_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Patchfile.resetFootprintLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetFootprintLength(non-const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_reset_footprint_length_1167_comment =
    "C++ Interface:\n"
    "resetFootprintLength(non-const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::reset_footprint_length\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_reset_footprint_length_1167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Patchfile::has_source_hash(void) const
 *******************************************************************/
static PyObject *Dtool_Patchfile_has_source_hash_1168(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Patchfile::has_source_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSourceHash", key_word_list));
        else
            (PyArg_Parse(args, ":hasSourceHash"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Patchfile*)local_this)->has_source_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSourceHash(const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_has_source_hash_1168_comment =
    "C++ Interface:\n"
    "hasSourceHash(const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::has_source_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the MD5 hash for the source file is\n"
    "//               known.  (Some early versions of the patch file did\n"
    "//               not store this information.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_has_source_hash_1168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HashVal const &Patchfile::get_source_hash(void) const
 *******************************************************************/
static PyObject *Dtool_Patchfile_get_source_hash_1169(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HashVal const &Patchfile::get_source_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSourceHash", key_word_list));
        else
            (PyArg_Parse(args, ":getSourceHash"));
        if(!PyErr_Occurred())
        {
            HashVal const *return_value = &(((const Patchfile*)local_this)->get_source_hash());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSourceHash(const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_get_source_hash_1169_comment =
    "C++ Interface:\n"
    "getSourceHash(const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::get_source_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns the MD5 hash for the source file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_get_source_hash_1169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline HashVal const &Patchfile::get_result_hash(void) const
 *******************************************************************/
static PyObject *Dtool_Patchfile_get_result_hash_1170(PyObject *self, PyObject *args,PyObject *kwds) {
    Patchfile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Patchfile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline HashVal const &Patchfile::get_result_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getResultHash", key_word_list));
        else
            (PyArg_Parse(args, ":getResultHash"));
        if(!PyErr_Occurred())
        {
            HashVal const *return_value = &(((const Patchfile*)local_this)->get_result_hash());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_HashVal,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getResultHash(const Patchfile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Patchfile_get_result_hash_1170_comment =
    "C++ Interface:\n"
    "getResultHash(const Patchfile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Patchfile::get_result_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns the MD5 hash for the file after the patch has\n"
    "//               been applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Patchfile_get_result_hash_1170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Patchfile::Patchfile(void)
 * Patchfile::Patchfile(PointerTo< Buffer > buffer)
 *******************************************************************/
int  Dtool_Init_Patchfile(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-Patchfile::Patchfile(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Patchfile", key_word_list))
            {
                Patchfile *return_value = new Patchfile();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Patchfile,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Patchfile::Patchfile(PointerTo< Buffer > buffer)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"buffer", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Patchfile", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Patchfile", &param0));
                if(!PyErr_Occurred())
                {
                    Buffer *param0_this = (Buffer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Buffer, 0, "Patchfile.Patchfile", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Patchfile *return_value = new Patchfile(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Patchfile,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Patchfile() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Patchfile()\n"
          "Patchfile(const Buffer buffer)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Patchfile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Patchfile)
    {
        printf("Patchfile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Patchfile * local_this = (Patchfile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Patchfile)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Patchfile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Patchfile)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TrueClock 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * double TrueClock::get_long_time(void)
 *******************************************************************/
static PyObject *Dtool_TrueClock_get_long_time_1173(PyObject *self, PyObject *args,PyObject *kwds) {
    TrueClock * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrueClock,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double TrueClock::get_long_time(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLongTime", key_word_list));
        else
            (PyArg_Parse(args, ":getLongTime"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_long_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TrueClock.getLongTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLongTime(non-const TrueClock this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_get_long_time_1173_comment =
    "C++ Interface:\n"
    "getLongTime(non-const TrueClock this)\n"
    "\n"
    "// get_long_time() returns the most accurate timer we have over a\n"
    "// long interval.  It may not be very precise for measuring short\n"
    "// intervals, but it should not drift substantially over the long\n"
    "// haul.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrueClock::get_long_time, Win32 implementation\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrueClock_get_long_time_1173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double TrueClock::get_short_time(void)
 *******************************************************************/
static PyObject *Dtool_TrueClock_get_short_time_1174(PyObject *self, PyObject *args,PyObject *kwds) {
    TrueClock * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrueClock,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double TrueClock::get_short_time(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShortTime", key_word_list));
        else
            (PyArg_Parse(args, ":getShortTime"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_short_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TrueClock.getShortTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShortTime(non-const TrueClock this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_get_short_time_1174_comment =
    "C++ Interface:\n"
    "getShortTime(non-const TrueClock this)\n"
    "\n"
    "// get_short_time() returns the most precise timer we have over a\n"
    "// short interval.  It may tend to drift over the long haul, but it\n"
    "// should have lots of digits to measure short intervals very\n"
    "// precisely.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrueClock::get_short_time, Win32 implementation\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrueClock_get_short_time_1174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double TrueClock::get_short_raw_time(void)
 *******************************************************************/
static PyObject *Dtool_TrueClock_get_short_raw_time_1175(PyObject *self, PyObject *args,PyObject *kwds) {
    TrueClock * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrueClock,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double TrueClock::get_short_raw_time(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShortRawTime", key_word_list));
        else
            (PyArg_Parse(args, ":getShortRawTime"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_short_raw_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TrueClock.getShortRawTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShortRawTime(non-const TrueClock this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_get_short_raw_time_1175_comment =
    "C++ Interface:\n"
    "getShortRawTime(non-const TrueClock this)\n"
    "\n"
    "// get_short_raw_time() is like get_short_time(), but does not apply\n"
    "// any corrections (e.g. paranoid-clock) to the result returned by\n"
    "// the OS.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrueClock::get_short_raw_time, Win32 implementation\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrueClock_get_short_raw_time_1175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TrueClock::get_error_count(void) const
 *******************************************************************/
static PyObject *Dtool_TrueClock_get_error_count_1176(PyObject *self, PyObject *args,PyObject *kwds) {
    TrueClock * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrueClock,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int TrueClock::get_error_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getErrorCount", key_word_list));
        else
            (PyArg_Parse(args, ":getErrorCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TrueClock*)local_this)->get_error_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getErrorCount(const TrueClock this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_get_error_count_1176_comment =
    "C++ Interface:\n"
    "getErrorCount(const TrueClock this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrueClock::get_error_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of clock errors that have\n"
    "//               been detected.  Each time a clock error is detected,\n"
    "//               in which the value returned by either of the above\n"
    "//               methods is suspect, the value returned by this method\n"
    "//               will be incremented.  Applications can monitor this\n"
    "//               value and react, for instance, by resynchronizing\n"
    "//               their clocks each time this value changes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrueClock_get_error_count_1176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline TrueClock *TrueClock::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_TrueClock_get_global_ptr_1177(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline TrueClock *TrueClock::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            TrueClock *return_value = TrueClock::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TrueClock,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_get_global_ptr_1177_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrueClock::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the one TrueClock object in\n"
    "//               the world.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrueClock_get_global_ptr_1177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TrueClock::set_cpu_affinity(unsigned int mask) const
 *******************************************************************/
static PyObject *Dtool_TrueClock_set_cpu_affinity_1178(PyObject *self, PyObject *args,PyObject *kwds) {
    TrueClock * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrueClock,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TrueClock::set_cpu_affinity(unsigned int mask) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"mask", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCpuAffinity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCpuAffinity", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                bool return_value = ((const TrueClock*)local_this)->set_cpu_affinity(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCpuAffinity(const TrueClock this, unsigned int mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrueClock_set_cpu_affinity_1178_comment =
    "C++ Interface:\n"
    "setCpuAffinity(const TrueClock this, unsigned int mask)\n"
    "\n"
    "";
#else
static const char * Dtool_TrueClock_set_cpu_affinity_1178_comment = NULL;
#endif

int  Dtool_Init_TrueClock(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TrueClock)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TrueClock(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TrueClock)
    {
        printf("TrueClock ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TrueClock * local_this = (TrueClock *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TrueClock)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TrueClock(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TrueClock)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ProfileTimer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::init(char const *name, int maxEntries)
 * void ProfileTimer::init(char const *name, int maxEntries = (MaxEntriesDefault))
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_init_1182(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProfileTimer::init(char const *name, int maxEntries = (MaxEntriesDefault))
            char *param1;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:init", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:init", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->init((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProfileTimer.init() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProfileTimer::init(char const *name, int maxEntries)
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"name", (char *)"maxEntries", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:init", key_word_list, &param1, &param2))
            {
                (local_this)->init((char const *)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProfileTimer.init() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "init() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "init(non-const ProfileTimer this, string name)\n"
          "init(non-const ProfileTimer this, string name, int maxEntries)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_init_1182_comment =
    "C++ Interface:\n"
    "init(non-const ProfileTimer this, string name)\n"
    "init(non-const ProfileTimer this, string name, int maxEntries)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_init_1182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::on(void)
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_on_1183(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ProfileTimer::on(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":on", key_word_list));
        else
            (PyArg_Parse(args, ":on"));
        if(!PyErr_Occurred())
        {
            (local_this)->on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProfileTimer.on() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "on(non-const ProfileTimer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_on_1183_comment =
    "C++ Interface:\n"
    "on(non-const ProfileTimer this)\n"
    "\n"
    "// Filename: profileTimer.I\n"
    "// Created by:  \n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProfileTimer_on_1183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::mark(char const *tag)
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_mark_1184(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ProfileTimer::mark(char const *tag)
        char *param1;
        static char * key_word_list[] = {(char *)"tag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:mark", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:mark", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->mark((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProfileTimer.mark() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mark(non-const ProfileTimer this, string tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_mark_1184_comment =
    "C++ Interface:\n"
    "mark(non-const ProfileTimer this, string tag)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_mark_1184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::off(void)
 * void ProfileTimer::off(char const *tag)
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_off_1185(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProfileTimer::off(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":off", key_word_list));
            else
                (PyArg_Parse(args, ":off"));
            if(!PyErr_Occurred())
            {
                (local_this)->off();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProfileTimer.off() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProfileTimer::off(char const *tag)
            char *param1;
            static char * key_word_list[] = {(char *)"tag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:off", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:off", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->off((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProfileTimer.off() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "off() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "off(non-const ProfileTimer this)\n"
          "off(non-const ProfileTimer this, string tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_off_1185_comment =
    "C++ Interface:\n"
    "off(non-const ProfileTimer this)\n"
    "off(non-const ProfileTimer this, string tag)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_off_1185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double ProfileTimer::getTotalTime(void) const
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_getTotalTime_1186(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double ProfileTimer::getTotalTime(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalTime", key_word_list));
        else
            (PyArg_Parse(args, ":getTotalTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ProfileTimer*)local_this)->getTotalTime();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalTime(const ProfileTimer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_getTotalTime_1186_comment =
    "C++ Interface:\n"
    "getTotalTime(const ProfileTimer this)\n"
    "\n"
    "// Don't call any of the following during timing:\n"
    "// (Because they are slow, not because anything will break).\n"
    "";
#else
static const char * Dtool_ProfileTimer_getTotalTime_1186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void ProfileTimer::consolidateAllTo(ostream &out)
 * static void ProfileTimer::consolidateAllTo(ostream &out = (cout))
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_consolidateAllTo_1187(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static void ProfileTimer::consolidateAllTo(ostream &out = (cout))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":consolidateAllTo", key_word_list))
            {
                ProfileTimer::consolidateAllTo();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static void ProfileTimer::consolidateAllTo(ostream &out)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:consolidateAllTo", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:consolidateAllTo", &param0));
                if(!PyErr_Occurred())
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "ProfileTimer.consolidateAllTo", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ProfileTimer::consolidateAllTo(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "consolidateAllTo() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "consolidateAllTo()\n"
          "consolidateAllTo(non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_consolidateAllTo_1187_comment =
    "C++ Interface:\n"
    "consolidateAllTo()\n"
    "consolidateAllTo(non-const Ostream out)\n"
    "\n"
    "// Don't call any of the following during timing:\n"
    "// (Because they are slow, not because anything will break).\n"
    "";
#else
static const char * Dtool_ProfileTimer_consolidateAllTo_1187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::consolidateTo(ostream &out) const
 * void ProfileTimer::consolidateTo(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_consolidateTo_1188(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-void ProfileTimer::consolidateTo(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":consolidateTo", key_word_list));
            else
                (PyArg_Parse(args, ":consolidateTo"));
            if(!PyErr_Occurred())
            {
                ((const ProfileTimer*)local_this)->consolidateTo();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ProfileTimer::consolidateTo(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:consolidateTo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:consolidateTo", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ProfileTimer.consolidateTo", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ProfileTimer*)local_this)->consolidateTo(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "consolidateTo() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "consolidateTo(const ProfileTimer this)\n"
          "consolidateTo(const ProfileTimer this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_consolidateTo_1188_comment =
    "C++ Interface:\n"
    "consolidateTo(const ProfileTimer this)\n"
    "consolidateTo(const ProfileTimer this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_consolidateTo_1188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void ProfileTimer::printAllTo(ostream &out)
 * static void ProfileTimer::printAllTo(ostream &out = (cout))
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_printAllTo_1189(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static void ProfileTimer::printAllTo(ostream &out = (cout))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":printAllTo", key_word_list))
            {
                ProfileTimer::printAllTo();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static void ProfileTimer::printAllTo(ostream &out)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:printAllTo", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:printAllTo", &param0));
                if(!PyErr_Occurred())
                {
                    ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "ProfileTimer.printAllTo", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ProfileTimer::printAllTo(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "printAllTo() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "printAllTo()\n"
          "printAllTo(non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_printAllTo_1189_comment =
    "C++ Interface:\n"
    "printAllTo()\n"
    "printAllTo(non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_printAllTo_1189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProfileTimer::printTo(ostream &out) const
 * void ProfileTimer::printTo(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_ProfileTimer_printTo_1190(PyObject *self, PyObject *args,PyObject *kwds) {
    ProfileTimer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProfileTimer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-void ProfileTimer::printTo(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":printTo", key_word_list));
            else
                (PyArg_Parse(args, ":printTo"));
            if(!PyErr_Occurred())
            {
                ((const ProfileTimer*)local_this)->printTo();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void ProfileTimer::printTo(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:printTo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:printTo", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ProfileTimer.printTo", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ProfileTimer*)local_this)->printTo(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "printTo() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "printTo(const ProfileTimer this)\n"
          "printTo(const ProfileTimer this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProfileTimer_printTo_1190_comment =
    "C++ Interface:\n"
    "printTo(const ProfileTimer this)\n"
    "printTo(const ProfileTimer this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_ProfileTimer_printTo_1190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ProfileTimer::ProfileTimer(ProfileTimer const &other)
 * ProfileTimer::ProfileTimer(char const *name, int maxEntries)
 * ProfileTimer::ProfileTimer(char const *name, int maxEntries = (MaxEntriesDefault))
 * ProfileTimer::ProfileTimer(char const *name = (0), int maxEntries = (MaxEntriesDefault))
 *******************************************************************/
int  Dtool_Init_ProfileTimer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ProfileTimer::ProfileTimer(char const *name = (0), int maxEntries = (MaxEntriesDefault))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ProfileTimer", key_word_list))
            {
                ProfileTimer *return_value = new ProfileTimer();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ProfileTimer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 ProfileTimer::ProfileTimer(ProfileTimer const &other)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ProfileTimer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ProfileTimer", &param0));
                if(!PyErr_Occurred())
                {
                    ProfileTimer *param0_this = (ProfileTimer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ProfileTimer, 0, "ProfileTimer.ProfileTimer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ProfileTimer *return_value = new ProfileTimer(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ProfileTimer,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ProfileTimer::ProfileTimer(char const *name, int maxEntries = (MaxEntriesDefault))
                char *param0;
                static char * key_word_list[] = {(char *)"name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s:ProfileTimer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "s:ProfileTimer", &param0));
                if(!PyErr_Occurred())
                {
                    ProfileTimer *return_value = new ProfileTimer((char const *)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ProfileTimer,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
            char *param0;
            int param1;
            static char * key_word_list[] = {(char *)"name", (char *)"maxEntries", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:ProfileTimer", key_word_list, &param0, &param1))
            {
                ProfileTimer *return_value = new ProfileTimer((char const *)param0, (int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ProfileTimer,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ProfileTimer() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ProfileTimer()\n"
          "ProfileTimer(const ProfileTimer other)\n"
          "ProfileTimer(string name)\n"
          "ProfileTimer(string name, int maxEntries)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ProfileTimer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ProfileTimer)
    {
        printf("ProfileTimer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ProfileTimer * local_this = (ProfileTimer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ProfileTimer)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ProfileTimer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ProfileTimer)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WeakPointerToVoid 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool WeakPointerToVoid::was_deleted(void) const
 *******************************************************************/
static PyObject *Dtool_WeakPointerToVoid_was_deleted_1192(PyObject *self, PyObject *args,PyObject *kwds) {
    WeakPointerToVoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WeakPointerToVoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WeakPointerToVoid::was_deleted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":wasDeleted", key_word_list));
        else
            (PyArg_Parse(args, ":wasDeleted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WeakPointerToVoid*)local_this)->was_deleted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "wasDeleted(const WeakPointerToVoid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WeakPointerToVoid_was_deleted_1192_comment =
    "C++ Interface:\n"
    "wasDeleted(const WeakPointerToVoid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WeakPointerToVoid::was_deleted\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the object we are pointing to has\n"
    "//               been deleted, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WeakPointerToVoid_was_deleted_1192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool WeakPointerToVoid::is_valid_pointer(void) const
 *******************************************************************/
static PyObject *Dtool_WeakPointerToVoid_is_valid_pointer_1193(PyObject *self, PyObject *args,PyObject *kwds) {
    WeakPointerToVoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WeakPointerToVoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool WeakPointerToVoid::is_valid_pointer(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValidPointer", key_word_list));
        else
            (PyArg_Parse(args, ":isValidPointer"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const WeakPointerToVoid*)local_this)->is_valid_pointer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValidPointer(const WeakPointerToVoid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WeakPointerToVoid_is_valid_pointer_1193_comment =
    "C++ Interface:\n"
    "isValidPointer(const WeakPointerToVoid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WeakPointerToVoid::is_valid_pointer\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the pointer is not null and the\n"
    "//               object has not been deleted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WeakPointerToVoid_is_valid_pointer_1193_comment = NULL;
#endif

int  Dtool_Init_WeakPointerToVoid(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (WeakPointerToVoid)");
       return -1;
}
inline void  * Dtool_UpcastInterface_WeakPointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WeakPointerToVoid)
    {
        printf("WeakPointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WeakPointerToVoid * local_this = (WeakPointerToVoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WeakPointerToVoid)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WeakPointerToVoid(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WeakPointerToVoid)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (WeakPointerToVoid*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WindowsRegistry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static bool WindowsRegistry::set_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &value, WindowsRegistry::RegLevel rl)
 * static bool WindowsRegistry::set_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &value, WindowsRegistry::RegLevel rl = (rl_machine))
 *******************************************************************/
static PyObject *Dtool_WindowsRegistry_set_string_value_1196(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          // 1-static bool WindowsRegistry::set_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &value, WindowsRegistry::RegLevel rl = (rl_machine))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:setStringValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                bool return_value = WindowsRegistry::set_string_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-static bool WindowsRegistry::set_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &value, WindowsRegistry::RegLevel rl)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"value", (char *)"rl", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:setStringValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                bool return_value = WindowsRegistry::set_string_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (WindowsRegistry::RegLevel)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setStringValue() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setStringValue(string key, string name, string value)\n"
          "setStringValue(string key, string name, string value, int rl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowsRegistry_set_string_value_1196_comment =
    "C++ Interface:\n"
    "setStringValue(string key, string name, string value)\n"
    "setStringValue(string key, string name, string value, int rl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowsRegistry::set_string_value\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the registry key to the indicated value as a\n"
    "//               string.  The supplied string value is automatically\n"
    "//               converted from whatever encoding is set by\n"
    "//               TextEncoder::set_default_encoding() and written as a\n"
    "//               Unicode string.  The registry key must already exist\n"
    "//               prior to calling this function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowsRegistry_set_string_value_1196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool WindowsRegistry::set_int_value(basic_string< char > const &key, basic_string< char > const &name, int value, WindowsRegistry::RegLevel rl)
 * static bool WindowsRegistry::set_int_value(basic_string< char > const &key, basic_string< char > const &name, int value, WindowsRegistry::RegLevel rl = (rl_machine))
 *******************************************************************/
static PyObject *Dtool_WindowsRegistry_set_int_value_1197(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          // 1-static bool WindowsRegistry::set_int_value(basic_string< char > const &key, basic_string< char > const &name, int value, WindowsRegistry::RegLevel rl = (rl_machine))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#i:setIntValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2))
            {
                bool return_value = WindowsRegistry::set_int_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-static bool WindowsRegistry::set_int_value(basic_string< char > const &key, basic_string< char > const &name, int value, WindowsRegistry::RegLevel rl)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"value", (char *)"rl", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#ii:setIntValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3))
            {
                bool return_value = WindowsRegistry::set_int_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2, (WindowsRegistry::RegLevel)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setIntValue() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setIntValue(string key, string name, int value)\n"
          "setIntValue(string key, string name, int value, int rl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowsRegistry_set_int_value_1197_comment =
    "C++ Interface:\n"
    "setIntValue(string key, string name, int value)\n"
    "setIntValue(string key, string name, int value, int rl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowsRegistry::set_int_value\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the registry key to the indicated value as an\n"
    "//               integer.  The registry key must already exist prior\n"
    "//               to calling this function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowsRegistry_set_int_value_1197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static WindowsRegistry::Type WindowsRegistry::get_key_type(basic_string< char > const &key, basic_string< char > const &name, WindowsRegistry::RegLevel rl)
 * static WindowsRegistry::Type WindowsRegistry::get_key_type(basic_string< char > const &key, basic_string< char > const &name, WindowsRegistry::RegLevel rl = (rl_machine))
 *******************************************************************/
static PyObject *Dtool_WindowsRegistry_get_key_type_1199(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-static WindowsRegistry::Type WindowsRegistry::get_key_type(basic_string< char > const &key, basic_string< char > const &name, WindowsRegistry::RegLevel rl = (rl_machine))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"key", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:getKeyType", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                WindowsRegistry::Type return_value = WindowsRegistry::get_key_type(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-static WindowsRegistry::Type WindowsRegistry::get_key_type(basic_string< char > const &key, basic_string< char > const &name, WindowsRegistry::RegLevel rl)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"rl", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#i:getKeyType", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2))
            {
                WindowsRegistry::Type return_value = WindowsRegistry::get_key_type(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (WindowsRegistry::RegLevel)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getKeyType() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getKeyType(string key, string name)\n"
          "getKeyType(string key, string name, int rl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowsRegistry_get_key_type_1199_comment =
    "C++ Interface:\n"
    "getKeyType(string key, string name)\n"
    "getKeyType(string key, string name, int rl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowsRegistry::get_key_type\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the type of the indicated key, or T_none if\n"
    "//               the key is not known or is some unsupported type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowsRegistry_get_key_type_1199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > WindowsRegistry::get_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &default_value, WindowsRegistry::RegLevel rl)
 * static basic_string< char > WindowsRegistry::get_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &default_value, WindowsRegistry::RegLevel rl = (rl_machine))
 *******************************************************************/
static PyObject *Dtool_WindowsRegistry_get_string_value_1200(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          // 1-static basic_string< char > WindowsRegistry::get_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &default_value, WindowsRegistry::RegLevel rl = (rl_machine))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:getStringValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                basic_string< char > return_value = WindowsRegistry::get_string_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-static basic_string< char > WindowsRegistry::get_string_value(basic_string< char > const &key, basic_string< char > const &name, basic_string< char > const &default_value, WindowsRegistry::RegLevel rl)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            int param3;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"default_value", (char *)"rl", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#i:getStringValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3))
            {
                basic_string< char > return_value = WindowsRegistry::get_string_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), (WindowsRegistry::RegLevel)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getStringValue() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getStringValue(string key, string name, string default_value)\n"
          "getStringValue(string key, string name, string default_value, int rl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowsRegistry_get_string_value_1200_comment =
    "C++ Interface:\n"
    "getStringValue(string key, string name, string default_value)\n"
    "getStringValue(string key, string name, string default_value, int rl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowsRegistry::get_string_value\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the value associated with the indicated\n"
    "//               registry key, assuming it is a string value.  The\n"
    "//               string value is automatically encoded using\n"
    "//               TextEncoder::get_default_encoding().  If the key is\n"
    "//               not defined or is not a string type value,\n"
    "//               default_value is returned instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowsRegistry_get_string_value_1200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int WindowsRegistry::get_int_value(basic_string< char > const &key, basic_string< char > const &name, int default_value, WindowsRegistry::RegLevel rl)
 * static int WindowsRegistry::get_int_value(basic_string< char > const &key, basic_string< char > const &name, int default_value, WindowsRegistry::RegLevel rl = (rl_machine))
 *******************************************************************/
static PyObject *Dtool_WindowsRegistry_get_int_value_1201(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          // 1-static int WindowsRegistry::get_int_value(basic_string< char > const &key, basic_string< char > const &name, int default_value, WindowsRegistry::RegLevel rl = (rl_machine))
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#i:getIntValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2))
            {
                int return_value = WindowsRegistry::get_int_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-static int WindowsRegistry::get_int_value(basic_string< char > const &key, basic_string< char > const &name, int default_value, WindowsRegistry::RegLevel rl)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"key", (char *)"name", (char *)"default_value", (char *)"rl", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#ii:getIntValue", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3))
            {
                int return_value = WindowsRegistry::get_int_value(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), (int)param2, (WindowsRegistry::RegLevel)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getIntValue() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getIntValue(string key, string name, int default_value)\n"
          "getIntValue(string key, string name, int default_value, int rl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WindowsRegistry_get_int_value_1201_comment =
    "C++ Interface:\n"
    "getIntValue(string key, string name, int default_value)\n"
    "getIntValue(string key, string name, int default_value, int rl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WindowsRegistry::get_int_value\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the value associated with the indicated\n"
    "//               registry key, assuming it is an integer value.  If\n"
    "//               the key is not defined or is not an integer type\n"
    "//               value, default_value is returned instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WindowsRegistry_get_int_value_1201_comment = NULL;
#endif

int  Dtool_Init_WindowsRegistry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (WindowsRegistry)");
       return -1;
}
inline void  * Dtool_UpcastInterface_WindowsRegistry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WindowsRegistry)
    {
        printf("WindowsRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WindowsRegistry * local_this = (WindowsRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WindowsRegistry)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WindowsRegistry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WindowsRegistry)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ConfigFlags | ConfigFlags
//********************************************************************
PyMethodDef Dtool_Methods_ConfigFlags[]= {
  { "downcastToNotifyCategory",(PyCFunction ) &Dtool_ConfigFlags_downcast_to_NotifyCategory_510, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigFlags_downcast_to_NotifyCategory_510_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConfigFlags(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigFlags.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigFlags\n"
          "// Description : This class is the base class of both ConfigVariable\n"
          "//               and ConfigVariableCore.  It exists only to provide a\n"
          "//               convenient name scoping for some enumerated values\n"
          "//               common to both classes.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConfigFlags.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConfigFlags.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigFlags.As_PyTypeObject().tp_dict);
        // Enum  ConfigFlags::ValueType;
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTUndefined",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTList",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTString",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTFilename",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTBool",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTInt",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTDouble",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTEnum",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTSearchPath",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"VTInt64",PyInt_FromLong(9));
        // Enum  ConfigFlags::VariableFlags;
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"FTrustLevelMask",PyInt_FromLong(4095));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"FOpen",PyInt_FromLong(4096));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"FClosed",PyInt_FromLong(8192));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"FDynamic",PyInt_FromLong(16384));
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"FDconfig",PyInt_FromLong(32768));
        if(PyType_Ready(&Dtool_ConfigFlags.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigFlags)");
             printf(" Error In PyType_ReadyConfigFlags");
             return;
        }
        Py_INCREF(&Dtool_ConfigFlags.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigFlags.As_PyTypeObject().tp_dict,"ConfigFlags",&Dtool_ConfigFlags.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigFlags,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigFlags.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigFlags",(PyObject *)&Dtool_ConfigFlags.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigPage | ConfigPage
//********************************************************************
PyMethodDef Dtool_Methods_ConfigPage[]= {
  { "getDefaultPage",(PyCFunction ) &Dtool_ConfigPage_get_default_page_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_default_page_6_comment},
  { "getLocalPage",(PyCFunction ) &Dtool_ConfigPage_get_local_page_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_local_page_7_comment},
  { "getName",(PyCFunction ) &Dtool_ConfigPage_get_name_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_name_8_comment},
  { "isSpecial",(PyCFunction ) &Dtool_ConfigPage_is_special_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_is_special_9_comment},
  { "isImplicit",(PyCFunction ) &Dtool_ConfigPage_is_implicit_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_is_implicit_10_comment},
  { "getPageSeq",(PyCFunction ) &Dtool_ConfigPage_get_page_seq_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_page_seq_11_comment},
  { "getTrustLevel",(PyCFunction ) &Dtool_ConfigPage_get_trust_level_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_trust_level_12_comment},
  { "setTrustLevel",(PyCFunction ) &Dtool_ConfigPage_set_trust_level_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_set_trust_level_13_comment},
  { "getSignature",(PyCFunction ) &Dtool_ConfigPage_get_signature_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_signature_14_comment},
  { "clear",(PyCFunction ) &Dtool_ConfigPage_clear_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_clear_15_comment},
  { "readPrc",(PyCFunction ) &Dtool_ConfigPage_read_prc_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_read_prc_16_comment},
  { "readEncryptedPrc",(PyCFunction ) &Dtool_ConfigPage_read_encrypted_prc_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_read_encrypted_prc_17_comment},
  { "getNumDeclarations",(PyCFunction ) &Dtool_ConfigPage_get_num_declarations_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_num_declarations_20_comment},
  { "getVariableName",(PyCFunction ) &Dtool_ConfigPage_get_variable_name_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_variable_name_22_comment},
  { "getStringValue",(PyCFunction ) &Dtool_ConfigPage_get_string_value_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_get_string_value_23_comment},
  { "isVariableUsed",(PyCFunction ) &Dtool_ConfigPage_is_variable_used_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_is_variable_used_24_comment},
  { "output",(PyCFunction ) &Dtool_ConfigPage_output_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_output_25_comment},
  { "outputBriefSignature",(PyCFunction ) &Dtool_ConfigPage_output_brief_signature_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_output_brief_signature_26_comment},
  { "write",(PyCFunction ) &Dtool_ConfigPage_write_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPage_write_27_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConfigPage
//////////////////
static PyObject *  Dtool_Repr_ConfigPage(PyObject * self)
{
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigPage
//////////////////
static PyObject *  Dtool_Str_ConfigPage(PyObject * self)
{
    ConfigPage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPage,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigPage(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigPage.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigPage\n"
          "// Description : A page of ConfigDeclarations that may be loaded or\n"
          "//               unloaded.  Typically this represents a single .prc\n"
          "//               file that is read from disk at runtime, but it may\n"
          "//               also represent a list of declarations built up\n"
          "//               by application code and explicitly loaded.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConfigPage.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConfigPage.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigPage.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigPage.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConfigPage.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigPage;
        // __str__
        Dtool_ConfigPage.As_PyTypeObject().tp_str = & Dtool_Str_ConfigPage;
        if(PyType_Ready(&Dtool_ConfigPage.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigPage)");
             printf(" Error In PyType_ReadyConfigPage");
             return;
        }
        Py_INCREF(&Dtool_ConfigPage.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigPage.As_PyTypeObject().tp_dict,"ConfigPage",&Dtool_ConfigPage.As_PyObject());
        //  Static Method getDefaultPage
        PyDict_SetItemString(Dtool_ConfigPage.As_PyTypeObject().tp_dict,"getDefaultPage",PyCFunction_New(&Dtool_Methods_ConfigPage[0],&Dtool_ConfigPage.As_PyObject()));
        //  Static Method getLocalPage
        PyDict_SetItemString(Dtool_ConfigPage.As_PyTypeObject().tp_dict,"getLocalPage",PyCFunction_New(&Dtool_Methods_ConfigPage[1],&Dtool_ConfigPage.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ConfigPage,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigPage.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigPage",(PyObject *)&Dtool_ConfigPage.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigPageManager | ConfigPageManager
//********************************************************************
PyMethodDef Dtool_Methods_ConfigPageManager[]= {
  { "loadedImplicitPages",(PyCFunction ) &Dtool_ConfigPageManager_loaded_implicit_pages_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_loaded_implicit_pages_29_comment},
  { "loadImplicitPages",(PyCFunction ) &Dtool_ConfigPageManager_load_implicit_pages_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_load_implicit_pages_30_comment},
  { "reloadImplicitPages",(PyCFunction ) &Dtool_ConfigPageManager_reload_implicit_pages_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_reload_implicit_pages_31_comment},
  { "getSearchPath",(PyCFunction ) &Dtool_ConfigPageManager_get_search_path_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_search_path_32_comment},
  { "getNumPrcPatterns",(PyCFunction ) &Dtool_ConfigPageManager_get_num_prc_patterns_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_num_prc_patterns_33_comment},
  { "getPrcPattern",(PyCFunction ) &Dtool_ConfigPageManager_get_prc_pattern_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_prc_pattern_34_comment},
  { "getNumPrcEncryptedPatterns",(PyCFunction ) &Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_35_comment},
  { "getPrcEncryptedPattern",(PyCFunction ) &Dtool_ConfigPageManager_get_prc_encrypted_pattern_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_prc_encrypted_pattern_36_comment},
  { "getNumPrcExecutablePatterns",(PyCFunction ) &Dtool_ConfigPageManager_get_num_prc_executable_patterns_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_num_prc_executable_patterns_37_comment},
  { "getPrcExecutablePattern",(PyCFunction ) &Dtool_ConfigPageManager_get_prc_executable_pattern_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_prc_executable_pattern_38_comment},
  { "makeExplicitPage",(PyCFunction ) &Dtool_ConfigPageManager_make_explicit_page_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_make_explicit_page_39_comment},
  { "deleteExplicitPage",(PyCFunction ) &Dtool_ConfigPageManager_delete_explicit_page_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_delete_explicit_page_40_comment},
  { "getNumImplicitPages",(PyCFunction ) &Dtool_ConfigPageManager_get_num_implicit_pages_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_num_implicit_pages_41_comment},
  { "getImplicitPage",(PyCFunction ) &Dtool_ConfigPageManager_get_implicit_page_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_implicit_page_42_comment},
  { "getNumExplicitPages",(PyCFunction ) &Dtool_ConfigPageManager_get_num_explicit_pages_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_num_explicit_pages_43_comment},
  { "getExplicitPage",(PyCFunction ) &Dtool_ConfigPageManager_get_explicit_page_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_explicit_page_44_comment},
  { "output",(PyCFunction ) &Dtool_ConfigPageManager_output_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_output_45_comment},
  { "write",(PyCFunction ) &Dtool_ConfigPageManager_write_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_write_46_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_ConfigPageManager_get_global_ptr_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigPageManager_get_global_ptr_47_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConfigPageManager
//////////////////
static PyObject *  Dtool_Repr_ConfigPageManager(PyObject * self)
{
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigPageManager
//////////////////
static PyObject *  Dtool_Str_ConfigPageManager(PyObject * self)
{
    ConfigPageManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigPageManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigPageManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigPageManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigPageManager\n"
          "// Description : A global object that maintains the set of ConfigPages\n"
          "//               everywhere in the world, and keeps them in sorted\n"
          "//               order.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigFlags._Dtool_ClassInit(NULL);
        Dtool_ConfigPageManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigFlags.As_PyTypeObject());
        Dtool_ConfigPageManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigPageManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigPageManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConfigPageManager.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigPageManager;
        // __str__
        Dtool_ConfigPageManager.As_PyTypeObject().tp_str = & Dtool_Str_ConfigPageManager;
        if(PyType_Ready(&Dtool_ConfigPageManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigPageManager)");
             printf(" Error In PyType_ReadyConfigPageManager");
             return;
        }
        Py_INCREF(&Dtool_ConfigPageManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigPageManager.As_PyTypeObject().tp_dict,"ConfigPageManager",&Dtool_ConfigPageManager.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_ConfigPageManager.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_ConfigPageManager[18],&Dtool_ConfigPageManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ConfigPageManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigPageManager.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigPageManager",(PyObject *)&Dtool_ConfigPageManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariable | ConfigVariable
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariable[]= {
  { "getStringValue",(PyCFunction ) &Dtool_ConfigVariable_get_string_value_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_string_value_65_comment},
  { "setStringValue",(PyCFunction ) &Dtool_ConfigVariable_set_string_value_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_string_value_66_comment},
  { "clearValue",(PyCFunction ) &Dtool_ConfigVariable_clear_value_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_clear_value_67_comment},
  { "getNumWords",(PyCFunction ) &Dtool_ConfigVariable_get_num_words_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_num_words_68_comment},
  { "hasStringWord",(PyCFunction ) &Dtool_ConfigVariable_has_string_word_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_has_string_word_69_comment},
  { "hasBoolWord",(PyCFunction ) &Dtool_ConfigVariable_has_bool_word_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_has_bool_word_70_comment},
  { "hasIntWord",(PyCFunction ) &Dtool_ConfigVariable_has_int_word_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_has_int_word_71_comment},
  { "hasInt64Word",(PyCFunction ) &Dtool_ConfigVariable_has_int64_word_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_has_int64_word_72_comment},
  { "hasDoubleWord",(PyCFunction ) &Dtool_ConfigVariable_has_double_word_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_has_double_word_73_comment},
  { "getStringWord",(PyCFunction ) &Dtool_ConfigVariable_get_string_word_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_string_word_74_comment},
  { "getBoolWord",(PyCFunction ) &Dtool_ConfigVariable_get_bool_word_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_bool_word_75_comment},
  { "getIntWord",(PyCFunction ) &Dtool_ConfigVariable_get_int_word_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_int_word_76_comment},
  { "getInt64Word",(PyCFunction ) &Dtool_ConfigVariable_get_int64_word_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_int64_word_77_comment},
  { "getDoubleWord",(PyCFunction ) &Dtool_ConfigVariable_get_double_word_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_get_double_word_78_comment},
  { "setStringWord",(PyCFunction ) &Dtool_ConfigVariable_set_string_word_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_string_word_79_comment},
  { "setBoolWord",(PyCFunction ) &Dtool_ConfigVariable_set_bool_word_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_bool_word_80_comment},
  { "setIntWord",(PyCFunction ) &Dtool_ConfigVariable_set_int_word_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_int_word_81_comment},
  { "setInt64Word",(PyCFunction ) &Dtool_ConfigVariable_set_int64_word_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_int64_word_82_comment},
  { "setDoubleWord",(PyCFunction ) &Dtool_ConfigVariable_set_double_word_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariable_set_double_word_83_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConfigVariable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariable\n"
          "// Description : This is a generic, untyped ConfigVariable.  It is\n"
          "//               also the base class for the typed ConfigVariables,\n"
          "//               and contains all of the code common to\n"
          "//               ConfigVariables of all types (except\n"
          "//               ConfigVariableList, which is a bit of a special\n"
          "//               case).\n"
          "//\n"
          "//               Mostly, this class serves as a thin wrapper around\n"
          "//               ConfigVariableCore and/or ConfigDeclaration, more or\n"
          "//               less duplicating the interface presented there.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariableBase._Dtool_ClassInit(NULL);
        Dtool_ConfigVariable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariableBase.As_PyTypeObject());
        Dtool_ConfigVariable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConfigVariable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariable)");
             printf(" Error In PyType_ReadyConfigVariable");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariable.As_PyTypeObject().tp_dict,"ConfigVariable",&Dtool_ConfigVariable.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariable,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariable.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariable",(PyObject *)&Dtool_ConfigVariable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableBase | ConfigVariableBase
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableBase[]= {
  { "getName",(PyCFunction ) &Dtool_ConfigVariableBase_get_name_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_get_name_50_comment},
  { "getValueType",(PyCFunction ) &Dtool_ConfigVariableBase_get_value_type_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_get_value_type_51_comment},
  { "getDescription",(PyCFunction ) &Dtool_ConfigVariableBase_get_description_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_get_description_52_comment},
  { "getFlags",(PyCFunction ) &Dtool_ConfigVariableBase_get_flags_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_get_flags_53_comment},
  { "isClosed",(PyCFunction ) &Dtool_ConfigVariableBase_is_closed_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_is_closed_54_comment},
  { "getTrustLevel",(PyCFunction ) &Dtool_ConfigVariableBase_get_trust_level_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_get_trust_level_55_comment},
  { "isDynamic",(PyCFunction ) &Dtool_ConfigVariableBase_is_dynamic_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_is_dynamic_56_comment},
  { "clearLocalValue",(PyCFunction ) &Dtool_ConfigVariableBase_clear_local_value_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_clear_local_value_57_comment},
  { "hasLocalValue",(PyCFunction ) &Dtool_ConfigVariableBase_has_local_value_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_has_local_value_58_comment},
  { "hasValue",(PyCFunction ) &Dtool_ConfigVariableBase_has_value_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_has_value_59_comment},
  { "output",(PyCFunction ) &Dtool_ConfigVariableBase_output_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_output_60_comment},
  { "write",(PyCFunction ) &Dtool_ConfigVariableBase_write_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBase_write_61_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConfigVariableBase
//////////////////
static PyObject *  Dtool_Repr_ConfigVariableBase(PyObject * self)
{
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigVariableBase
//////////////////
static PyObject *  Dtool_Str_ConfigVariableBase(PyObject * self)
{
    ConfigVariableBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableBase,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigVariableBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableBase\n"
          "// Description : This class is the base class for both\n"
          "//               ConfigVariableList and ConfigVariable (and hence for\n"
          "//               all of the ConfigVariableBool, ConfigVaribleString,\n"
          "//               etc. classes).  It collects together the common\n"
          "//               interface for all generic ConfigVariables.\n"
          "//\n"
          "//               Mostly, this class serves as a thin wrapper around\n"
          "//               ConfigVariableCore and/or ConfigDeclaration, more or\n"
          "//               less duplicating the interface presented there.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigFlags._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigFlags.As_PyTypeObject());
        Dtool_ConfigVariableBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableBase.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConfigVariableBase.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigVariableBase;
        // __str__
        Dtool_ConfigVariableBase.As_PyTypeObject().tp_str = & Dtool_Str_ConfigVariableBase;
        if(PyType_Ready(&Dtool_ConfigVariableBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableBase)");
             printf(" Error In PyType_ReadyConfigVariableBase");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableBase.As_PyTypeObject().tp_dict,"ConfigVariableBase",&Dtool_ConfigVariableBase.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableBase,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableBase.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableBase",(PyObject *)&Dtool_ConfigVariableBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableBool | ConfigVariableBool
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableBool[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableBool_operator_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_operator_86_comment},
  { "size",(PyCFunction ) &Dtool_ConfigVariableBool_size_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_size_88_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableBool_operator_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_operator_89_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableBool_set_value_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_set_value_90_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableBool_get_value_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_get_value_91_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableBool_get_default_value_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_get_default_value_92_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableBool_get_word_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_get_word_93_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableBool_set_word_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_set_word_94_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_ConfigVariableBool_operator_typecast_bool_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableBool_operator_typecast_bool_87_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableBool ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_ConfigVariableBool_operator_typecast_bool_87__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableBool_operator_typecast_bool_87(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableBool ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConfigVariableBool_size_88size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableBool_size_88(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableBool ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_ConfigVariableBool_operator_89__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConfigVariableBool_operator_89(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConfigVariableBool(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableBool\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as a boolean type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableBool.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableBool.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_ConfigVariableBool_operator_typecast_bool_87__nonzero__;
        // tp_as_sequence->sq_length = size
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConfigVariableBool_size_88size;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_ConfigVariableBool.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConfigVariableBool_operator_89__getitem__;
        if(PyType_Ready(&Dtool_ConfigVariableBool.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableBool)");
             printf(" Error In PyType_ReadyConfigVariableBool");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableBool.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableBool.As_PyTypeObject().tp_dict,"ConfigVariableBool",&Dtool_ConfigVariableBool.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableBool,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableBool.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableBool",(PyObject *)&Dtool_ConfigVariableBool.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableDouble | ConfigVariableDouble
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableDouble[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableDouble_operator_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_operator_98_comment},
  { "size",(PyCFunction ) &Dtool_ConfigVariableDouble_size_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_size_100_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableDouble_operator_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_operator_101_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableDouble_set_value_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_set_value_102_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableDouble_get_value_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_get_value_103_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableDouble_get_default_value_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_get_default_value_104_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableDouble_get_word_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_get_word_105_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableDouble_set_word_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_set_word_106_comment},
  { "operatorTypecastDouble",(PyCFunction ) &Dtool_ConfigVariableDouble_operator_typecast_double_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableDouble_operator_typecast_double_99_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableDouble ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_ConfigVariableDouble_operator_101__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConfigVariableDouble_operator_101(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableDouble ...tp_as_number->nb_float = operatorTypecastDouble
//////////////////
static PyObject * Dtool_ConfigVariableDouble_operator_typecast_double_99operatorTypecastDouble( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableDouble_operator_typecast_double_99(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableDouble ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConfigVariableDouble_size_100size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableDouble_size_100(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_ConfigVariableDouble(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableDouble\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as a floating-point type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableDouble.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableDouble.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = __getitem__
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConfigVariableDouble_operator_101__getitem__;
        // tp_as_number->nb_float = operatorTypecastDouble
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_as_number->nb_float = &Dtool_ConfigVariableDouble_operator_typecast_double_99operatorTypecastDouble;
        // tp_as_sequence->sq_length = size
        Dtool_ConfigVariableDouble.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConfigVariableDouble_size_100size;
        if(PyType_Ready(&Dtool_ConfigVariableDouble.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableDouble)");
             printf(" Error In PyType_ReadyConfigVariableDouble");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableDouble.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableDouble.As_PyTypeObject().tp_dict,"ConfigVariableDouble",&Dtool_ConfigVariableDouble.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableDouble,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableDouble.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableDouble",(PyObject *)&Dtool_ConfigVariableDouble.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableFilename | ConfigVariableFilename
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableFilename[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_110_comment},
  { "cStr",(PyCFunction ) &Dtool_ConfigVariableFilename_c_str_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_c_str_112_comment},
  { "empty",(PyCFunction ) &Dtool_ConfigVariableFilename_empty_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_empty_113_comment},
  { "length",(PyCFunction ) &Dtool_ConfigVariableFilename_length_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_length_114_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_115_comment},
  { "getFullpath",(PyCFunction ) &Dtool_ConfigVariableFilename_get_fullpath_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_fullpath_116_comment},
  { "getDirname",(PyCFunction ) &Dtool_ConfigVariableFilename_get_dirname_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_dirname_117_comment},
  { "getBasename",(PyCFunction ) &Dtool_ConfigVariableFilename_get_basename_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_basename_118_comment},
  { "getFullpathWoExtension",(PyCFunction ) &Dtool_ConfigVariableFilename_get_fullpath_wo_extension_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_fullpath_wo_extension_119_comment},
  { "getBasenameWoExtension",(PyCFunction ) &Dtool_ConfigVariableFilename_get_basename_wo_extension_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_basename_wo_extension_120_comment},
  { "getExtension",(PyCFunction ) &Dtool_ConfigVariableFilename_get_extension_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_extension_121_comment},
  { "eq",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_122_comment},
  { "ne",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_123_comment},
  { "lessThan",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_124_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableFilename_set_value_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_set_value_125_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableFilename_get_value_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_value_126_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableFilename_get_default_value_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_default_value_127_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableFilename_get_word_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_get_word_128_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableFilename_set_word_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_set_word_129_comment},
  { "operatorTypecast",(PyCFunction ) &Dtool_ConfigVariableFilename_operator_typecast_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableFilename_operator_typecast_111_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableFilename ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_ConfigVariableFilename_operator_115__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_ConfigVariableFilename_operator_115(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConfigVariableFilename(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableFilename.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableFilename\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as a Filename type.  It is almost the\n"
          "//               same thing as ConfigVariableString, except it handles\n"
          "//               an implicit Filename::expand_from() operation so that\n"
          "//               the user may put OS-specific filenames, or filenames\n"
          "//               based on environment variables, in the prc file.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableFilename.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableFilename.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableFilename.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableFilename.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_ConfigVariableFilename.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_ConfigVariableFilename_operator_115__getitem__;
        if(PyType_Ready(&Dtool_ConfigVariableFilename.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableFilename)");
             printf(" Error In PyType_ReadyConfigVariableFilename");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableFilename.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableFilename.As_PyTypeObject().tp_dict,"ConfigVariableFilename",&Dtool_ConfigVariableFilename.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableFilename,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableFilename.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableFilename",(PyObject *)&Dtool_ConfigVariableFilename.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableInt | ConfigVariableInt
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableInt[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableInt_operator_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_operator_133_comment},
  { "size",(PyCFunction ) &Dtool_ConfigVariableInt_size_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_size_135_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableInt_operator_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_operator_136_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableInt_set_value_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_set_value_137_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableInt_get_value_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_get_value_138_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableInt_get_default_value_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_get_default_value_139_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableInt_get_word_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_get_word_140_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableInt_set_word_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_set_word_141_comment},
  { "operatorTypecastInt",(PyCFunction ) &Dtool_ConfigVariableInt_operator_typecast_int_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt_operator_typecast_int_134_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_ConfigVariableInt_operator_136__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConfigVariableInt_operator_136(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt_size_135size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableInt_size_135(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt ...tp_as_number->nb_int = operatorTypecastInt
//////////////////
static PyObject * Dtool_ConfigVariableInt_operator_typecast_int_134operatorTypecastInt( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableInt_operator_typecast_int_134(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConfigVariableInt(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableInt\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as an integer type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableInt.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableInt.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = __getitem__
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConfigVariableInt_operator_136__getitem__;
        // tp_as_sequence->sq_length = size
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConfigVariableInt_size_135size;
        // tp_as_number->nb_int = operatorTypecastInt
        Dtool_ConfigVariableInt.As_PyTypeObject().tp_as_number->nb_int = &Dtool_ConfigVariableInt_operator_typecast_int_134operatorTypecastInt;
        if(PyType_Ready(&Dtool_ConfigVariableInt.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableInt)");
             printf(" Error In PyType_ReadyConfigVariableInt");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableInt.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableInt.As_PyTypeObject().tp_dict,"ConfigVariableInt",&Dtool_ConfigVariableInt.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableInt,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableInt.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableInt",(PyObject *)&Dtool_ConfigVariableInt.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableInt64 | ConfigVariableInt64
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableInt64[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableInt64_operator_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_operator_145_comment},
  { "size",(PyCFunction ) &Dtool_ConfigVariableInt64_size_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_size_147_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableInt64_operator_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_operator_148_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableInt64_set_value_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_set_value_149_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableInt64_get_value_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_get_value_150_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableInt64_get_default_value_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_get_default_value_151_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableInt64_get_word_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_get_word_152_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableInt64_set_word_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_set_word_153_comment},
  { "operatorTypecastInt64",(PyCFunction ) &Dtool_ConfigVariableInt64_operator_typecast_int64_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableInt64_operator_typecast_int64_146_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt64 ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt64_size_147size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableInt64_size_147(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt64 ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_ConfigVariableInt64_operator_148__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConfigVariableInt64_operator_148(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableInt64 ...tp_as_number->nb_int = operatorTypecastInt64
//////////////////
static PyObject * Dtool_ConfigVariableInt64_operator_typecast_int64_146operatorTypecastInt64( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableInt64_operator_typecast_int64_146(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConfigVariableInt64(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableInt64\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as a 64-bit integer type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableInt64.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableInt64.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConfigVariableInt64_size_147size;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConfigVariableInt64_operator_148__getitem__;
        // tp_as_number->nb_int = operatorTypecastInt64
        Dtool_ConfigVariableInt64.As_PyTypeObject().tp_as_number->nb_int = &Dtool_ConfigVariableInt64_operator_typecast_int64_146operatorTypecastInt64;
        if(PyType_Ready(&Dtool_ConfigVariableInt64.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableInt64)");
             printf(" Error In PyType_ReadyConfigVariableInt64");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableInt64.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableInt64.As_PyTypeObject().tp_dict,"ConfigVariableInt64",&Dtool_ConfigVariableInt64.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableInt64,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableInt64.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableInt64",(PyObject *)&Dtool_ConfigVariableInt64.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableList | ConfigVariableList
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableList[]= {
  { "getNumValues",(PyCFunction ) &Dtool_ConfigVariableList_get_num_values_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_get_num_values_158_comment},
  { "getStringValue",(PyCFunction ) &Dtool_ConfigVariableList_get_string_value_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_get_string_value_159_comment},
  { "getNumUniqueValues",(PyCFunction ) &Dtool_ConfigVariableList_get_num_unique_values_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_get_num_unique_values_160_comment},
  { "getUniqueValue",(PyCFunction ) &Dtool_ConfigVariableList_get_unique_value_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_get_unique_value_161_comment},
  { "size",(PyCFunction ) &Dtool_ConfigVariableList_size_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_size_162_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableList_operator_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_operator_163_comment},
  { "output",(PyCFunction ) &Dtool_ConfigVariableList_output_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_output_164_comment},
  { "write",(PyCFunction ) &Dtool_ConfigVariableList_write_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableList_write_165_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableList ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConfigVariableList_size_162size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConfigVariableList_size_162(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableList ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_ConfigVariableList_operator_163__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConfigVariableList_operator_163(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     ConfigVariableList
//////////////////
static PyObject *  Dtool_Repr_ConfigVariableList(PyObject * self)
{
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigVariableList
//////////////////
static PyObject *  Dtool_Str_ConfigVariableList(PyObject * self)
{
    ConfigVariableList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableList,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigVariableList(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableList.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableList\n"
          "// Description : This class is similar to ConfigVariable, but it\n"
          "//               reports its value as a list of strings.  In this\n"
          "//               special case, all of the declarations of the variable\n"
          "//               are returned as the elements of this list, in order.\n"
          "//\n"
          "//               Note that this is different from a normal\n"
          "//               ConfigVariableString, which just returns its topmost\n"
          "//               value, which can optionally be treated as a number of\n"
          "//               discrete words by dividing it at the spaces.\n"
          "//\n"
          "//               A ConfigVariableList cannot be modified locally.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariableBase._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableList.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariableBase.As_PyTypeObject());
        Dtool_ConfigVariableList.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableList.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableList.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConfigVariableList.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConfigVariableList_size_162size;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_ConfigVariableList.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConfigVariableList_operator_163__getitem__;
        // __repr__
        Dtool_ConfigVariableList.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigVariableList;
        // __str__
        Dtool_ConfigVariableList.As_PyTypeObject().tp_str = & Dtool_Str_ConfigVariableList;
        if(PyType_Ready(&Dtool_ConfigVariableList.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableList)");
             printf(" Error In PyType_ReadyConfigVariableList");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableList.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableList.As_PyTypeObject().tp_dict,"ConfigVariableList",&Dtool_ConfigVariableList.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableList,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableList.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableList",(PyObject *)&Dtool_ConfigVariableList.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableManager | ConfigVariableManager
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableManager[]= {
  { "getNumVariables",(PyCFunction ) &Dtool_ConfigVariableManager_get_num_variables_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_get_num_variables_169_comment},
  { "getVariableName",(PyCFunction ) &Dtool_ConfigVariableManager_get_variable_name_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_get_variable_name_171_comment},
  { "isVariableUsed",(PyCFunction ) &Dtool_ConfigVariableManager_is_variable_used_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_is_variable_used_172_comment},
  { "output",(PyCFunction ) &Dtool_ConfigVariableManager_output_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_output_173_comment},
  { "write",(PyCFunction ) &Dtool_ConfigVariableManager_write_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_write_174_comment},
  { "writePrcVariables",(PyCFunction ) &Dtool_ConfigVariableManager_write_prc_variables_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_write_prc_variables_175_comment},
  { "listUnusedVariables",(PyCFunction ) &Dtool_ConfigVariableManager_list_unused_variables_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_list_unused_variables_176_comment},
  { "listVariables",(PyCFunction ) &Dtool_ConfigVariableManager_list_variables_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_list_variables_177_comment},
  { "listDynamicVariables",(PyCFunction ) &Dtool_ConfigVariableManager_list_dynamic_variables_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_list_dynamic_variables_178_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_ConfigVariableManager_get_global_ptr_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableManager_get_global_ptr_179_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConfigVariableManager
//////////////////
static PyObject *  Dtool_Repr_ConfigVariableManager(PyObject * self)
{
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigVariableManager
//////////////////
static PyObject *  Dtool_Str_ConfigVariableManager(PyObject * self)
{
    ConfigVariableManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigVariableManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableManager\n"
          "// Description : A global object that maintains the set of\n"
          "//               ConfigVariables (actually, ConfigVariableCores)\n"
          "//               everywhere in the world, and keeps them in sorted\n"
          "//               order.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConfigVariableManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConfigVariableManager.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigVariableManager;
        // __str__
        Dtool_ConfigVariableManager.As_PyTypeObject().tp_str = & Dtool_Str_ConfigVariableManager;
        if(PyType_Ready(&Dtool_ConfigVariableManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableManager)");
             printf(" Error In PyType_ReadyConfigVariableManager");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableManager.As_PyTypeObject().tp_dict,"ConfigVariableManager",&Dtool_ConfigVariableManager.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_ConfigVariableManager.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_ConfigVariableManager[9],&Dtool_ConfigVariableManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ConfigVariableManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableManager.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableManager",(PyObject *)&Dtool_ConfigVariableManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableSearchPath | ConfigVariableSearchPath
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableSearchPath[]= {
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableSearchPath_get_value_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_get_value_184_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableSearchPath_get_default_value_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_get_default_value_185_comment},
  { "clearLocalValue",(PyCFunction ) &Dtool_ConfigVariableSearchPath_clear_local_value_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_clear_local_value_186_comment},
  { "clear",(PyCFunction ) &Dtool_ConfigVariableSearchPath_clear_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_clear_187_comment},
  { "appendDirectory",(PyCFunction ) &Dtool_ConfigVariableSearchPath_append_directory_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_append_directory_188_comment},
  { "prependDirectory",(PyCFunction ) &Dtool_ConfigVariableSearchPath_prepend_directory_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_prepend_directory_189_comment},
  { "appendPath",(PyCFunction ) &Dtool_ConfigVariableSearchPath_append_path_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_append_path_190_comment},
  { "prependPath",(PyCFunction ) &Dtool_ConfigVariableSearchPath_prepend_path_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_prepend_path_191_comment},
  { "isEmpty",(PyCFunction ) &Dtool_ConfigVariableSearchPath_is_empty_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_is_empty_192_comment},
  { "getNumDirectories",(PyCFunction ) &Dtool_ConfigVariableSearchPath_get_num_directories_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_get_num_directories_193_comment},
  { "getDirectory",(PyCFunction ) &Dtool_ConfigVariableSearchPath_get_directory_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_get_directory_194_comment},
  { "findFile",(PyCFunction ) &Dtool_ConfigVariableSearchPath_find_file_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_find_file_195_comment},
  { "findAllFiles",(PyCFunction ) &Dtool_ConfigVariableSearchPath_find_all_files_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_find_all_files_196_comment},
  { "output",(PyCFunction ) &Dtool_ConfigVariableSearchPath_output_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_output_197_comment},
  { "write",(PyCFunction ) &Dtool_ConfigVariableSearchPath_write_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_write_198_comment},
  { "operatorTypecast",(PyCFunction ) &Dtool_ConfigVariableSearchPath_operator_typecast_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableSearchPath_operator_typecast_183_comment},
  { "getDirectories",(PyCFunction) &MakeSeq_ConfigVariableSearchPath_get_directories, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConfigVariableSearchPath
//////////////////
static PyObject *  Dtool_Repr_ConfigVariableSearchPath(PyObject * self)
{
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ConfigVariableSearchPath
//////////////////
static PyObject *  Dtool_Str_ConfigVariableSearchPath(PyObject * self)
{
    ConfigVariableSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConfigVariableSearchPath,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConfigVariableSearchPath(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableSearchPath\n"
          "// Description : This is similar to a ConfigVariableList, but it\n"
          "//               returns its list as a DSearchPath, as a list of\n"
          "//               directories.\n"
          "//\n"
          "//               You may locally append directories to the end of the\n"
          "//               search path with the methods here, or prepend them to\n"
          "//               the beginning.  Use these methods to make adjustments\n"
          "//               to the path; do not attempt to directly modify the\n"
          "//               const DSearchPath object returned by get_value().\n"
          "//\n"
          "//               Unlike other ConfigVariable types, local changes\n"
          "//               (made by calling append_directory() and\n"
          "//               prepend_directory()) are specific to this particular\n"
          "//               instance of the ConfigVariableSearchPath.  A separate\n"
          "//               instance of the same variable, created by using the\n"
          "//               same name to the constructor, will not reflect the\n"
          "//               local changes.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariableBase._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariableBase.As_PyTypeObject());
        Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_repr = & Dtool_Repr_ConfigVariableSearchPath;
        // __str__
        Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_str = & Dtool_Str_ConfigVariableSearchPath;
        if(PyType_Ready(&Dtool_ConfigVariableSearchPath.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableSearchPath)");
             printf(" Error In PyType_ReadyConfigVariableSearchPath");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableSearchPath.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableSearchPath.As_PyTypeObject().tp_dict,"ConfigVariableSearchPath",&Dtool_ConfigVariableSearchPath.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableSearchPath,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableSearchPath.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableSearchPath",(PyObject *)&Dtool_ConfigVariableSearchPath.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConfigVariableString | ConfigVariableString
//********************************************************************
PyMethodDef Dtool_Methods_ConfigVariableString[]= {
  { "assign",(PyCFunction ) &Dtool_ConfigVariableString_operator_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_201_comment},
  { "cStr",(PyCFunction ) &Dtool_ConfigVariableString_c_str_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_c_str_203_comment},
  { "empty",(PyCFunction ) &Dtool_ConfigVariableString_empty_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_empty_204_comment},
  { "length",(PyCFunction ) &Dtool_ConfigVariableString_length_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_length_205_comment},
  { "__getitem__",(PyCFunction ) &Dtool_ConfigVariableString_operator_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_206_comment},
  { "eq",(PyCFunction ) &Dtool_ConfigVariableString_operator_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_207_comment},
  { "ne",(PyCFunction ) &Dtool_ConfigVariableString_operator_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_208_comment},
  { "lessThan",(PyCFunction ) &Dtool_ConfigVariableString_operator_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_209_comment},
  { "setValue",(PyCFunction ) &Dtool_ConfigVariableString_set_value_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_set_value_210_comment},
  { "getValue",(PyCFunction ) &Dtool_ConfigVariableString_get_value_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_get_value_211_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_ConfigVariableString_get_default_value_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_get_default_value_212_comment},
  { "getWord",(PyCFunction ) &Dtool_ConfigVariableString_get_word_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_get_word_213_comment},
  { "setWord",(PyCFunction ) &Dtool_ConfigVariableString_set_word_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_set_word_214_comment},
  { "operatorTypecast",(PyCFunction ) &Dtool_ConfigVariableString_operator_typecast_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConfigVariableString_operator_typecast_202_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConfigVariableString ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_ConfigVariableString_operator_206__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_ConfigVariableString_operator_206(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConfigVariableString(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConfigVariableString.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConfigVariableString\n"
          "// Description : This is a convenience class to specialize\n"
          "//               ConfigVariable as a string type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigVariable._Dtool_ClassInit(NULL);
        Dtool_ConfigVariableString.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigVariable.As_PyTypeObject());
        Dtool_ConfigVariableString.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConfigVariableString.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConfigVariableString.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_ConfigVariableString.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_ConfigVariableString_operator_206__getitem__;
        if(PyType_Ready(&Dtool_ConfigVariableString.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConfigVariableString)");
             printf(" Error In PyType_ReadyConfigVariableString");
             return;
        }
        Py_INCREF(&Dtool_ConfigVariableString.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConfigVariableString.As_PyTypeObject().tp_dict,"ConfigVariableString",&Dtool_ConfigVariableString.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConfigVariableString,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConfigVariableString.As_PyTypeObject());
        PyModule_AddObject(module, "ConfigVariableString",(PyObject *)&Dtool_ConfigVariableString.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_float | CPTAFloat
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_float[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_float_size_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_size_227_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_float_get_element_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_get_element_228_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_float_getitem_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_getitem_229_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_float_get_data_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_get_data_230_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_float_get_subdata_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_get_subdata_231_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_float_get_ref_count_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_get_ref_count_232_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_float_get_node_ref_count_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_float_get_node_ref_count_233_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_float ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_float_getitem_229Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_float_getitem_229(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_float ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_float_size_227size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_float_size_227(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_float._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_float.As_PyTypeObject());
        Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_float_getitem_229Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_float_size_227size;
        if(PyType_Ready(&Dtool_ConstPointerToArray_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_float)");
             printf(" Error In PyType_ReadyConstPointerToArray_float");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_float.As_PyTypeObject().tp_dict,"CPTAFloat",&Dtool_ConstPointerToArray_float.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_float,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_float.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAFloat",(PyObject *)&Dtool_ConstPointerToArray_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_float | PointerToArrayBaseFloat
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_float[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_float._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject());
        Dtool_PointerToArrayBase_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_float.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_float)");
             printf(" Error In PyType_ReadyPointerToArrayBase_float");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_float.As_PyTypeObject().tp_dict,"PointerToArrayBaseFloat",&Dtool_PointerToArrayBase_float.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_float,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_float.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseFloat",(PyObject *)&Dtool_PointerToArrayBase_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_float | PointerToBaseReferenceCountedVectorFloat
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_float[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_float_clear_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_float_clear_223_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_float_output_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_float_output_224_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_float
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_float(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< float > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_float,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_float;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_float;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_float)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_float");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorFloat",&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_float,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorFloat",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToVoid | PointerToVoid
//********************************************************************
PyMethodDef Dtool_Methods_PointerToVoid[]= {
  { "isNull",(PyCFunction ) &Dtool_PointerToVoid_is_null_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToVoid_is_null_221_comment},
  { "getHash",(PyCFunction ) &Dtool_PointerToVoid_get_hash_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToVoid_get_hash_222_comment},
  { NULL, NULL }
};

//////////////////
//  A LocalHash(getKey) Function for this type
//     PointerToVoid
//////////////////
static long  DTool_HashKey_PointerToVoid(PyObject * self)
{
    PointerToVoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToVoid,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_hash();
}

void   Dtool_PyModuleClassInit_PointerToVoid(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointerToVoid.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointerToVoid\n"
          "// Description : This is the non-template part of the base class for\n"
          "//               PointerTo and ConstPointerTo.  It is necessary so we\n"
          "//               can keep a pointer to a non-template class within the\n"
          "//               ReferenceCount object, to implement weak reference\n"
          "//               pointers--we need to have something to clean up when\n"
          "//               the ReferenceCount object destructs.\n"
          "//\n"
          "//               This is the base class for PointerToBase<T>.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PointerToVoid.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PointerToVoid.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToVoid.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToVoid.As_PyTypeObject().tp_dict);
        // __hash__
        Dtool_PointerToVoid.As_PyTypeObject().tp_hash = &DTool_HashKey_PointerToVoid;
        Dtool_PointerToVoid.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        if(PyType_Ready(&Dtool_PointerToVoid.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToVoid)");
             printf(" Error In PyType_ReadyPointerToVoid");
             return;
        }
        Py_INCREF(&Dtool_PointerToVoid.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToVoid.As_PyTypeObject().tp_dict,"PointerToVoid",&Dtool_PointerToVoid.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToVoid,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToVoid.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToVoid",(PyObject *)&Dtool_PointerToVoid.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_int | CPTAInt
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_int[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_int_size_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_size_242_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_int_get_element_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_get_element_243_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_int_getitem_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_getitem_244_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_int_get_data_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_get_data_245_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_int_get_subdata_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_get_subdata_246_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_int_get_ref_count_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_get_ref_count_247_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_int_get_node_ref_count_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_int_get_node_ref_count_248_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_int ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_int_size_242size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_int_size_242(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_int ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_int_getitem_244Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_int_getitem_244(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_int._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_int.As_PyTypeObject());
        Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_int_size_242size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_int_getitem_244Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_int)");
             printf(" Error In PyType_ReadyConstPointerToArray_int");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_int.As_PyTypeObject().tp_dict,"CPTAInt",&Dtool_ConstPointerToArray_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_int.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAInt",(PyObject *)&Dtool_ConstPointerToArray_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_int | PointerToArrayBaseInt
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_int[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_int._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject());
        Dtool_PointerToArrayBase_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_int.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_int)");
             printf(" Error In PyType_ReadyPointerToArrayBase_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_int.As_PyTypeObject().tp_dict,"PointerToArrayBaseInt",&Dtool_PointerToArrayBase_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_int.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseInt",(PyObject *)&Dtool_PointerToArrayBase_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_int | PointerToBaseReferenceCountedVectorInt
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_int[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_int_clear_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_int_clear_238_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_int_output_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_int_output_239_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_int
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_int(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< int > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_int,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_int;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_int;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_int)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorInt",&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorInt",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_unsigned_char | CPTAUchar
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_unsigned_char[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_size_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_size_257_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_get_element_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_get_element_258_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_getitem_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_getitem_259_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_get_data_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_get_data_260_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_get_subdata_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_get_subdata_261_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_get_ref_count_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_get_ref_count_262_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_263_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_unsigned_char ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_unsigned_char_size_257size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_unsigned_char_size_257(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_unsigned_char ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_unsigned_char_getitem_259Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_unsigned_char_getitem_259(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_unsigned_char._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject());
        Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_unsigned_char_size_257size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_unsigned_char_getitem_259Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_unsigned_char)");
             printf(" Error In PyType_ReadyConstPointerToArray_unsigned_char");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject().tp_dict,"CPTAUchar",&Dtool_ConstPointerToArray_unsigned_char.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_unsigned_char,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAUchar",(PyObject *)&Dtool_ConstPointerToArray_unsigned_char.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_unsigned_char | PointerToArrayBaseUnsignedChar
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_unsigned_char[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject());
        Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_unsigned_char)");
             printf(" Error In PyType_ReadyPointerToArrayBase_unsigned_char");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject().tp_dict,"PointerToArrayBaseUnsignedChar",&Dtool_PointerToArrayBase_unsigned_char.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_unsigned_char,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseUnsignedChar",(PyObject *)&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_unsigned_char | PointerToBaseReferenceCountedVectorUnsignedChar
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_char[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_253_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_254_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_unsigned_char
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< unsigned char > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_unsigned_char)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_unsigned_char");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorUnsignedChar",&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnsignedChar",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DConfig | DConfig
//********************************************************************
PyMethodDef Dtool_Methods_DConfig[]= {
  { "GetBool",(PyCFunction ) &Dtool_DConfig_GetBool_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DConfig_GetBool_266_comment},
  { "GetInt",(PyCFunction ) &Dtool_DConfig_GetInt_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DConfig_GetInt_267_comment},
  { "GetFloat",(PyCFunction ) &Dtool_DConfig_GetFloat_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DConfig_GetFloat_268_comment},
  { "GetDouble",(PyCFunction ) &Dtool_DConfig_GetDouble_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DConfig_GetDouble_269_comment},
  { "GetString",(PyCFunction ) &Dtool_DConfig_GetString_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DConfig_GetString_270_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DConfig(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DConfig.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DConfig\n"
          "// Description : This class emulates the old dconfig-style interface\n"
          "//               to our Panda config system.  It exists only to\n"
          "//               provide backward-compatible support, and it is used\n"
          "//               primarily by Python code.  For modern code, use the\n"
          "//               new ConfigVariable* interface instead of this\n"
          "//               deprecated interface.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DConfig.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DConfig.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DConfig.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DConfig.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DConfig)");
             printf(" Error In PyType_ReadyDConfig");
             return;
        }
        Py_INCREF(&Dtool_DConfig.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"DConfig",&Dtool_DConfig.As_PyObject());
        //  Static Method GetBool
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"GetBool",PyCFunction_New(&Dtool_Methods_DConfig[0],&Dtool_DConfig.As_PyObject()));
        //  Static Method GetInt
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"GetInt",PyCFunction_New(&Dtool_Methods_DConfig[1],&Dtool_DConfig.As_PyObject()));
        //  Static Method GetFloat
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"GetFloat",PyCFunction_New(&Dtool_Methods_DConfig[2],&Dtool_DConfig.As_PyObject()));
        //  Static Method GetDouble
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"GetDouble",PyCFunction_New(&Dtool_Methods_DConfig[3],&Dtool_DConfig.As_PyObject()));
        //  Static Method GetString
        PyDict_SetItemString(Dtool_DConfig.As_PyTypeObject().tp_dict,"GetString",PyCFunction_New(&Dtool_Methods_DConfig[4],&Dtool_DConfig.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DConfig,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DConfig.As_PyTypeObject());
        PyModule_AddObject(module, "DConfig",(PyObject *)&Dtool_DConfig.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DSearchPath_Results | Results
//********************************************************************
PyMethodDef Dtool_Methods_DSearchPath_Results[]= {
  { "assign",(PyCFunction ) &Dtool_DSearchPath_Results_operator_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_operator_275_comment},
  { "clear",(PyCFunction ) &Dtool_DSearchPath_Results_clear_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_clear_277_comment},
  { "getNumFiles",(PyCFunction ) &Dtool_DSearchPath_Results_get_num_files_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_get_num_files_278_comment},
  { "getFile",(PyCFunction ) &Dtool_DSearchPath_Results_get_file_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_get_file_279_comment},
  { "__getitem__",(PyCFunction ) &Dtool_DSearchPath_Results_operator_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_operator_280_comment},
  { "size",(PyCFunction ) &Dtool_DSearchPath_Results_size_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_size_281_comment},
  { "output",(PyCFunction ) &Dtool_DSearchPath_Results_output_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_output_282_comment},
  { "write",(PyCFunction ) &Dtool_DSearchPath_Results_write_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_Results_write_283_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DSearchPath_Results ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_DSearchPath_Results_operator_280__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_DSearchPath_Results_operator_280(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     DSearchPath_Results ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_DSearchPath_Results_size_281size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_DSearchPath_Results_size_281(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A __repr__ Function
//     DSearchPath_Results
//////////////////
static PyObject *  Dtool_Repr_DSearchPath_Results(PyObject * self)
{
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DSearchPath_Results
//////////////////
static PyObject *  Dtool_Str_DSearchPath_Results(PyObject * self)
{
    DSearchPath::Results * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath_Results,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DSearchPath_Results(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DSearchPath_Results.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DSearchPath_Results.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = __getitem__
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_DSearchPath_Results_operator_280__getitem__;
        // tp_as_sequence->sq_length = size
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_DSearchPath_Results_size_281size;
        // __repr__
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_repr = & Dtool_Repr_DSearchPath_Results;
        // __str__
        Dtool_DSearchPath_Results.As_PyTypeObject().tp_str = & Dtool_Str_DSearchPath_Results;
        if(PyType_Ready(&Dtool_DSearchPath_Results.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DSearchPath_Results)");
             printf(" Error In PyType_ReadyDSearchPath_Results");
             return;
        }
        Py_INCREF(&Dtool_DSearchPath_Results.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DSearchPath_Results.As_PyTypeObject().tp_dict,"Results",&Dtool_DSearchPath_Results.As_PyObject());
        RegisterRuntimeClass(&Dtool_DSearchPath_Results,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DSearchPath_Results.As_PyTypeObject());
        PyModule_AddObject(module, "Results",(PyObject *)&Dtool_DSearchPath_Results.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DSearchPath | DSearchPath
//********************************************************************
PyMethodDef Dtool_Methods_DSearchPath[]= {
  { "assign",(PyCFunction ) &Dtool_DSearchPath_operator_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_operator_285_comment},
  { "clear",(PyCFunction ) &Dtool_DSearchPath_clear_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_clear_287_comment},
  { "appendDirectory",(PyCFunction ) &Dtool_DSearchPath_append_directory_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_append_directory_288_comment},
  { "prependDirectory",(PyCFunction ) &Dtool_DSearchPath_prepend_directory_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_prepend_directory_289_comment},
  { "appendPath",(PyCFunction ) &Dtool_DSearchPath_append_path_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_append_path_290_comment},
  { "prependPath",(PyCFunction ) &Dtool_DSearchPath_prepend_path_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_prepend_path_291_comment},
  { "isEmpty",(PyCFunction ) &Dtool_DSearchPath_is_empty_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_is_empty_292_comment},
  { "getNumDirectories",(PyCFunction ) &Dtool_DSearchPath_get_num_directories_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_get_num_directories_293_comment},
  { "getDirectory",(PyCFunction ) &Dtool_DSearchPath_get_directory_294, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_get_directory_294_comment},
  { "findFile",(PyCFunction ) &Dtool_DSearchPath_find_file_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_find_file_295_comment},
  { "findAllFiles",(PyCFunction ) &Dtool_DSearchPath_find_all_files_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_find_all_files_296_comment},
  { "searchPath",(PyCFunction ) &Dtool_DSearchPath_search_path_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_search_path_297_comment},
  { "output",(PyCFunction ) &Dtool_DSearchPath_output_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_output_298_comment},
  { "write",(PyCFunction ) &Dtool_DSearchPath_write_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DSearchPath_write_299_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getDirectories",(PyCFunction) &MakeSeq_DSearchPath_get_directories, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DSearchPath
//////////////////
static PyObject *  Dtool_Repr_DSearchPath(PyObject * self)
{
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DSearchPath
//////////////////
static PyObject *  Dtool_Str_DSearchPath(PyObject * self)
{
    DSearchPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DSearchPath,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DSearchPath(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DSearchPath.As_PyTypeObject().tp_doc =
          "///////////////////////////////////////////////////////////////////\n"
          "//       Class : DSearchPath\n"
          "// Description : This class stores a list of directories that can be\n"
          "//               searched, in order, to locate a particular file.  It\n"
          "//               is normally constructed by passing it a traditional\n"
          "//               searchpath-style string, e.g. a list of directory\n"
          "//               names delimited by spaces or colons, but it can also\n"
          "//               be built up explicitly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DSearchPath.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DSearchPath.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DSearchPath.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DSearchPath.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DSearchPath.As_PyTypeObject().tp_repr = & Dtool_Repr_DSearchPath;
        // __str__
        Dtool_DSearchPath.As_PyTypeObject().tp_str = & Dtool_Str_DSearchPath;
        // Nested Object   DSearchPath_Results;
        Dtool_DSearchPath_Results._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_DSearchPath.As_PyTypeObject().tp_dict,"Results",(PyObject *)&Dtool_DSearchPath_Results.As_PyTypeObject());
        if(PyType_Ready(&Dtool_DSearchPath.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DSearchPath)");
             printf(" Error In PyType_ReadyDSearchPath");
             return;
        }
        Py_INCREF(&Dtool_DSearchPath.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DSearchPath.As_PyTypeObject().tp_dict,"DSearchPath",&Dtool_DSearchPath.As_PyObject());
        //  Static Method searchPath
        PyDict_SetItemString(Dtool_DSearchPath.As_PyTypeObject().tp_dict,"searchPath",PyCFunction_New(&Dtool_Methods_DSearchPath[11],&Dtool_DSearchPath.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DSearchPath,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DSearchPath.As_PyTypeObject());
        PyModule_AddObject(module, "DSearchPath",(PyObject *)&Dtool_DSearchPath.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ExecutionEnvironment | ExecutionEnvironment
//********************************************************************
PyMethodDef Dtool_Methods_ExecutionEnvironment[]= {
  { "hasEnvironmentVariable",(PyCFunction ) &Dtool_ExecutionEnvironment_has_environment_variable_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_has_environment_variable_301_comment},
  { "getEnvironmentVariable",(PyCFunction ) &Dtool_ExecutionEnvironment_get_environment_variable_302, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_environment_variable_302_comment},
  { "setEnvironmentVariable",(PyCFunction ) &Dtool_ExecutionEnvironment_set_environment_variable_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_set_environment_variable_303_comment},
  { "shadowEnvironmentVariable",(PyCFunction ) &Dtool_ExecutionEnvironment_shadow_environment_variable_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_shadow_environment_variable_304_comment},
  { "clearShadow",(PyCFunction ) &Dtool_ExecutionEnvironment_clear_shadow_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_clear_shadow_305_comment},
  { "expandString",(PyCFunction ) &Dtool_ExecutionEnvironment_expand_string_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_expand_string_306_comment},
  { "getNumArgs",(PyCFunction ) &Dtool_ExecutionEnvironment_get_num_args_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_num_args_307_comment},
  { "getArg",(PyCFunction ) &Dtool_ExecutionEnvironment_get_arg_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_arg_308_comment},
  { "getBinaryName",(PyCFunction ) &Dtool_ExecutionEnvironment_get_binary_name_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_binary_name_309_comment},
  { "getDtoolName",(PyCFunction ) &Dtool_ExecutionEnvironment_get_dtool_name_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_dtool_name_310_comment},
  { "getCwd",(PyCFunction ) &Dtool_ExecutionEnvironment_get_cwd_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExecutionEnvironment_get_cwd_311_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ExecutionEnvironment(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ExecutionEnvironment.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ExecutionEnvironment\n"
          "// Description : Encapsulates access to the environment variables and\n"
          "//               command-line arguments at the time of execution.\n"
          "//               This is encapsulated to support accessing these\n"
          "//               things during static init time, which seems to be\n"
          "//               risky at best.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ExecutionEnvironment.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ExecutionEnvironment.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ExecutionEnvironment)");
             printf(" Error In PyType_ReadyExecutionEnvironment");
             return;
        }
        Py_INCREF(&Dtool_ExecutionEnvironment.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"ExecutionEnvironment",&Dtool_ExecutionEnvironment.As_PyObject());
        //  Static Method hasEnvironmentVariable
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"hasEnvironmentVariable",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[0],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getEnvironmentVariable
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getEnvironmentVariable",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[1],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method setEnvironmentVariable
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"setEnvironmentVariable",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[2],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method shadowEnvironmentVariable
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"shadowEnvironmentVariable",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[3],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method clearShadow
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"clearShadow",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[4],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method expandString
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"expandString",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[5],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getNumArgs
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getNumArgs",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[6],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getArg
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getArg",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[7],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getBinaryName
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getBinaryName",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[8],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getDtoolName
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getDtoolName",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[9],&Dtool_ExecutionEnvironment.As_PyObject()));
        //  Static Method getCwd
        PyDict_SetItemString(Dtool_ExecutionEnvironment.As_PyTypeObject().tp_dict,"getCwd",PyCFunction_New(&Dtool_Methods_ExecutionEnvironment[10],&Dtool_ExecutionEnvironment.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ExecutionEnvironment,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ExecutionEnvironment.As_PyTypeObject());
        PyModule_AddObject(module, "ExecutionEnvironment",(PyObject *)&Dtool_ExecutionEnvironment.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FileStream | FileStream
//********************************************************************
PyMethodDef Dtool_Methods_FileStream[]= {
  { "open",(PyCFunction ) &Dtool_FileStream_open_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FileStream_open_347_comment},
  { "close",(PyCFunction ) &Dtool_FileStream_close_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FileStream_close_348_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FileStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FileStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FileStream\n"
          "// Description : Implements a C++ stream object suitable for reading\n"
          "//               from and/or writing to files on disk.  This is\n"
          "//               similar to fstream, but it provides low-level support\n"
          "//               for Panda's simple-threading implementation (using\n"
          "//               this interface will block only the current thread,\n"
          "//               rather than the entire process, on I/O waits).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_iostream._Dtool_ClassInit(NULL);
        Dtool_FileStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_iostream.As_PyTypeObject());
        Dtool_FileStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FileStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FileStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FileStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FileStream)");
             printf(" Error In PyType_ReadyFileStream");
             return;
        }
        Py_INCREF(&Dtool_FileStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FileStream.As_PyTypeObject().tp_dict,"FileStream",&Dtool_FileStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_FileStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FileStream.As_PyTypeObject());
        PyModule_AddObject(module, "FileStream",(PyObject *)&Dtool_FileStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. iostream | Iostream
//********************************************************************
PyMethodDef Dtool_Methods_iostream[]= {
  { "flush",(PyCFunction ) &Dtool_iostream_flush_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_iostream_flush_343_comment},
  { "upcastToIstream",(PyCFunction ) &Dtool_iostream_upcast_to_istream_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_iostream_upcast_to_istream_332_comment},
  { "upcastToOstream",(PyCFunction ) &Dtool_iostream_upcast_to_ostream_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_iostream_upcast_to_ostream_341_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_iostream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_iostream.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_istream.As_PyTypeObject(),&Dtool_ostream.As_PyTypeObject());
        Dtool_iostream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_iostream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_iostream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_iostream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(iostream)");
             printf(" Error In PyType_Readyiostream");
             return;
        }
        Py_INCREF(&Dtool_iostream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_iostream.As_PyTypeObject().tp_dict,"Iostream",&Dtool_iostream.As_PyObject());
        RegisterRuntimeClass(&Dtool_iostream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_iostream.As_PyTypeObject());
        PyModule_AddObject(module, "Iostream",(PyObject *)&Dtool_iostream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. istream | Istream
//********************************************************************
PyMethodDef Dtool_Methods_istream[]= {
  { "get",(PyCFunction ) &Dtool_istream_get_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_istream_get_328_comment},
  { "tellg",(PyCFunction ) &Dtool_istream_tellg_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_istream_tellg_329_comment},
  { "seekg",(PyCFunction ) &Dtool_istream_seekg_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_istream_seekg_330_comment},
  { "upcastToIos",(PyCFunction ) &Dtool_istream_upcast_to_ios_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_istream_upcast_to_ios_327_comment},
  { "downcastToIostream",(PyCFunction ) &Dtool_istream_downcast_to_iostream_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_istream_downcast_to_iostream_333_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_istream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ios._Dtool_ClassInit(NULL);
        Dtool_istream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ios.As_PyTypeObject());
        Dtool_istream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_istream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_istream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_istream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(istream)");
             printf(" Error In PyType_Readyistream");
             return;
        }
        Py_INCREF(&Dtool_istream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_istream.As_PyTypeObject().tp_dict,"Istream",&Dtool_istream.As_PyObject());
        RegisterRuntimeClass(&Dtool_istream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_istream.As_PyTypeObject());
        PyModule_AddObject(module, "Istream",(PyObject *)&Dtool_istream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ios | Ios
//********************************************************************
PyMethodDef Dtool_Methods_ios[]= {
  { "good",(PyCFunction ) &Dtool_ios_good_321, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ios_good_321_comment},
  { "eof",(PyCFunction ) &Dtool_ios_eof_322, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ios_eof_322_comment},
  { "fail",(PyCFunction ) &Dtool_ios_fail_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ios_fail_323_comment},
  { "bad",(PyCFunction ) &Dtool_ios_bad_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ios_bad_324_comment},
  { "clear",(PyCFunction ) &Dtool_ios_clear_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ios_clear_325_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ios(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ios_base._Dtool_ClassInit(NULL);
        Dtool_ios.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ios_base.As_PyTypeObject());
        Dtool_ios.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ios.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ios.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ios.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ios)");
             printf(" Error In PyType_Readyios");
             return;
        }
        Py_INCREF(&Dtool_ios.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ios.As_PyTypeObject().tp_dict,"Ios",&Dtool_ios.As_PyObject());
        RegisterRuntimeClass(&Dtool_ios,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ios.As_PyTypeObject());
        PyModule_AddObject(module, "Ios",(PyObject *)&Dtool_ios.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ios_base | IosBase
//********************************************************************
PyMethodDef Dtool_Methods_ios_base[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ios_base(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ios_base.As_PyTypeObject().tp_doc =
          "// We don't care (much) about the actual definition of the various\n"
          "// iostream classes, but we do need to know the classnames that are\n"
          "// available.\n"
          "// We need to expose one method in each class to force it to publish.\n"
          "// But we'd like to expose some of these methods anyway, so no\n"
          "// problem.";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ios_base.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ios_base.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ios_base.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ios_base.As_PyTypeObject().tp_dict);
        // Enum  ios_base::seekdir;
        PyDict_SetItemString(Dtool_ios_base.As_PyTypeObject().tp_dict,"Beg",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_ios_base.As_PyTypeObject().tp_dict,"Cur",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_ios_base.As_PyTypeObject().tp_dict,"End",PyInt_FromLong(2));
        // Enum  ios_base::openmode;
        if(PyType_Ready(&Dtool_ios_base.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ios_base)");
             printf(" Error In PyType_Readyios_base");
             return;
        }
        Py_INCREF(&Dtool_ios_base.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ios_base.As_PyTypeObject().tp_dict,"IosBase",&Dtool_ios_base.As_PyObject());
        RegisterRuntimeClass(&Dtool_ios_base,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ios_base.As_PyTypeObject());
        PyModule_AddObject(module, "IosBase",(PyObject *)&Dtool_ios_base.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ostream | Ostream
//********************************************************************
PyMethodDef Dtool_Methods_ostream[]= {
  { "put",(PyCFunction ) &Dtool_ostream_put_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_put_336_comment},
  { "flush",(PyCFunction ) &Dtool_ostream_flush_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_flush_337_comment},
  { "tellp",(PyCFunction ) &Dtool_ostream_tellp_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_tellp_338_comment},
  { "seekp",(PyCFunction ) &Dtool_ostream_seekp_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_seekp_339_comment},
  { "upcastToIos",(PyCFunction ) &Dtool_ostream_upcast_to_ios_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_upcast_to_ios_335_comment},
  { "downcastToIostream",(PyCFunction ) &Dtool_ostream_downcast_to_iostream_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ostream_downcast_to_iostream_342_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ostream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ios._Dtool_ClassInit(NULL);
        Dtool_ostream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ios.As_PyTypeObject());
        Dtool_ostream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ostream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ostream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ostream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ostream)");
             printf(" Error In PyType_Readyostream");
             return;
        }
        Py_INCREF(&Dtool_ostream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ostream.As_PyTypeObject().tp_dict,"Ostream",&Dtool_ostream.As_PyObject());
        RegisterRuntimeClass(&Dtool_ostream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ostream.As_PyTypeObject());
        PyModule_AddObject(module, "Ostream",(PyObject *)&Dtool_ostream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Filename | Filename
//********************************************************************
PyMethodDef Dtool_Methods_Filename[]= {
  { "__reduce__",(PyCFunction ) &Dtool_Filename_reduce_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_reduce_353_comment},
  { "textFilename",(PyCFunction ) &Dtool_Filename_text_filename_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_text_filename_354_comment},
  { "binaryFilename",(PyCFunction ) &Dtool_Filename_binary_filename_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_binary_filename_355_comment},
  { "dsoFilename",(PyCFunction ) &Dtool_Filename_dso_filename_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_dso_filename_356_comment},
  { "executableFilename",(PyCFunction ) &Dtool_Filename_executable_filename_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_executable_filename_357_comment},
  { "patternFilename",(PyCFunction ) &Dtool_Filename_pattern_filename_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_pattern_filename_358_comment},
  { "fromOsSpecific",(PyCFunction ) &Dtool_Filename_from_os_specific_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_from_os_specific_359_comment},
  { "expandFrom",(PyCFunction ) &Dtool_Filename_expand_from_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_expand_from_360_comment},
  { "temporary",(PyCFunction ) &Dtool_Filename_temporary_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_temporary_361_comment},
  { "getHomeDirectory",(PyCFunction ) &Dtool_Filename_get_home_directory_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_home_directory_362_comment},
  { "getTempDirectory",(PyCFunction ) &Dtool_Filename_get_temp_directory_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_temp_directory_363_comment},
  { "getUserAppdataDirectory",(PyCFunction ) &Dtool_Filename_get_user_appdata_directory_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_user_appdata_directory_364_comment},
  { "getCommonAppdataDirectory",(PyCFunction ) &Dtool_Filename_get_common_appdata_directory_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_common_appdata_directory_365_comment},
  { "assign",(PyCFunction ) &Dtool_Filename_operator_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_366_comment},
  { "cStr",(PyCFunction ) &Dtool_Filename_c_str_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_c_str_368_comment},
  { "empty",(PyCFunction ) &Dtool_Filename_empty_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_empty_369_comment},
  { "length",(PyCFunction ) &Dtool_Filename_length_370, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_length_370_comment},
  { "__getitem__",(PyCFunction ) &Dtool_Filename_operator_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_371_comment},
  { "substr",(PyCFunction ) &Dtool_Filename_substr_372, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_substr_372_comment},
  { "__iadd__",(PyCFunction ) &Dtool_Filename_operator_373, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_373_comment},
  { "__add__",(PyCFunction ) &Dtool_Filename_operator_374, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_374_comment},
  { "getFullpath",(PyCFunction ) &Dtool_Filename_get_fullpath_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_fullpath_375_comment},
  { "getDirname",(PyCFunction ) &Dtool_Filename_get_dirname_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_dirname_376_comment},
  { "getBasename",(PyCFunction ) &Dtool_Filename_get_basename_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_basename_377_comment},
  { "getFullpathWoExtension",(PyCFunction ) &Dtool_Filename_get_fullpath_wo_extension_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_fullpath_wo_extension_378_comment},
  { "getBasenameWoExtension",(PyCFunction ) &Dtool_Filename_get_basename_wo_extension_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_basename_wo_extension_379_comment},
  { "getExtension",(PyCFunction ) &Dtool_Filename_get_extension_380, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_extension_380_comment},
  { "setFullpath",(PyCFunction ) &Dtool_Filename_set_fullpath_381, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_fullpath_381_comment},
  { "setDirname",(PyCFunction ) &Dtool_Filename_set_dirname_382, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_dirname_382_comment},
  { "setBasename",(PyCFunction ) &Dtool_Filename_set_basename_383, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_basename_383_comment},
  { "setFullpathWoExtension",(PyCFunction ) &Dtool_Filename_set_fullpath_wo_extension_384, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_fullpath_wo_extension_384_comment},
  { "setBasenameWoExtension",(PyCFunction ) &Dtool_Filename_set_basename_wo_extension_385, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_basename_wo_extension_385_comment},
  { "setExtension",(PyCFunction ) &Dtool_Filename_set_extension_386, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_extension_386_comment},
  { "setBinary",(PyCFunction ) &Dtool_Filename_set_binary_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_binary_387_comment},
  { "setText",(PyCFunction ) &Dtool_Filename_set_text_388, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_text_388_comment},
  { "isBinary",(PyCFunction ) &Dtool_Filename_is_binary_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_binary_389_comment},
  { "isText",(PyCFunction ) &Dtool_Filename_is_text_390, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_text_390_comment},
  { "setType",(PyCFunction ) &Dtool_Filename_set_type_391, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_type_391_comment},
  { "getType",(PyCFunction ) &Dtool_Filename_get_type_392, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_type_392_comment},
  { "setPattern",(PyCFunction ) &Dtool_Filename_set_pattern_393, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_pattern_393_comment},
  { "getPattern",(PyCFunction ) &Dtool_Filename_get_pattern_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_pattern_394_comment},
  { "hasHash",(PyCFunction ) &Dtool_Filename_has_hash_395, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_has_hash_395_comment},
  { "getFilenameIndex",(PyCFunction ) &Dtool_Filename_get_filename_index_396, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_filename_index_396_comment},
  { "getHashToEnd",(PyCFunction ) &Dtool_Filename_get_hash_to_end_397, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_hash_to_end_397_comment},
  { "setHashToEnd",(PyCFunction ) &Dtool_Filename_set_hash_to_end_398, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_set_hash_to_end_398_comment},
  { "standardize",(PyCFunction ) &Dtool_Filename_standardize_400, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_standardize_400_comment},
  { "isLocal",(PyCFunction ) &Dtool_Filename_is_local_401, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_local_401_comment},
  { "isFullyQualified",(PyCFunction ) &Dtool_Filename_is_fully_qualified_402, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_fully_qualified_402_comment},
  { "makeAbsolute",(PyCFunction ) &Dtool_Filename_make_absolute_403, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_make_absolute_403_comment},
  { "makeCanonical",(PyCFunction ) &Dtool_Filename_make_canonical_404, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_make_canonical_404_comment},
  { "makeTrueCase",(PyCFunction ) &Dtool_Filename_make_true_case_405, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_make_true_case_405_comment},
  { "toOsSpecific",(PyCFunction ) &Dtool_Filename_to_os_specific_406, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_to_os_specific_406_comment},
  { "toOsGeneric",(PyCFunction ) &Dtool_Filename_to_os_generic_407, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_to_os_generic_407_comment},
  { "toOsShortName",(PyCFunction ) &Dtool_Filename_to_os_short_name_408, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_to_os_short_name_408_comment},
  { "toOsLongName",(PyCFunction ) &Dtool_Filename_to_os_long_name_409, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_to_os_long_name_409_comment},
  { "exists",(PyCFunction ) &Dtool_Filename_exists_410, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_exists_410_comment},
  { "isRegularFile",(PyCFunction ) &Dtool_Filename_is_regular_file_411, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_regular_file_411_comment},
  { "isDirectory",(PyCFunction ) &Dtool_Filename_is_directory_412, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_directory_412_comment},
  { "isExecutable",(PyCFunction ) &Dtool_Filename_is_executable_413, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_is_executable_413_comment},
  { "compareTimestamps",(PyCFunction ) &Dtool_Filename_compare_timestamps_414, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_compare_timestamps_414_comment},
  { "getTimestamp",(PyCFunction ) &Dtool_Filename_get_timestamp_415, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_timestamp_415_comment},
  { "getAccessTimestamp",(PyCFunction ) &Dtool_Filename_get_access_timestamp_416, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_access_timestamp_416_comment},
  { "getFileSize",(PyCFunction ) &Dtool_Filename_get_file_size_417, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_file_size_417_comment},
  { "resolveFilename",(PyCFunction ) &Dtool_Filename_resolve_filename_418, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_resolve_filename_418_comment},
  { "makeRelativeTo",(PyCFunction ) &Dtool_Filename_make_relative_to_419, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_make_relative_to_419_comment},
  { "findOnSearchpath",(PyCFunction ) &Dtool_Filename_find_on_searchpath_420, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_find_on_searchpath_420_comment},
  { "scanDirectory",(PyCFunction ) &Dtool_Filename_scan_directory_421, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_scan_directory_421_comment},
  { "openRead",(PyCFunction ) &Dtool_Filename_open_read_422, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_open_read_422_comment},
  { "openWrite",(PyCFunction ) &Dtool_Filename_open_write_423, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_open_write_423_comment},
  { "openAppend",(PyCFunction ) &Dtool_Filename_open_append_424, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_open_append_424_comment},
  { "openReadWrite",(PyCFunction ) &Dtool_Filename_open_read_write_425, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_open_read_write_425_comment},
  { "openReadAppend",(PyCFunction ) &Dtool_Filename_open_read_append_426, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_open_read_append_426_comment},
  { "chdir",(PyCFunction ) &Dtool_Filename_chdir_427, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_chdir_427_comment},
  { "touch",(PyCFunction ) &Dtool_Filename_touch_428, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_touch_428_comment},
  { "unlink",(PyCFunction ) &Dtool_Filename_unlink_429, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_unlink_429_comment},
  { "renameTo",(PyCFunction ) &Dtool_Filename_rename_to_430, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_rename_to_430_comment},
  { "copyTo",(PyCFunction ) &Dtool_Filename_copy_to_431, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_copy_to_431_comment},
  { "makeDir",(PyCFunction ) &Dtool_Filename_make_dir_432, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_make_dir_432_comment},
  { "mkdir",(PyCFunction ) &Dtool_Filename_mkdir_433, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_mkdir_433_comment},
  { "rmdir",(PyCFunction ) &Dtool_Filename_rmdir_434, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_rmdir_434_comment},
  { "eq",(PyCFunction ) &Dtool_Filename_operator_435, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_435_comment},
  { "ne",(PyCFunction ) &Dtool_Filename_operator_436, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_436_comment},
  { "lessThan",(PyCFunction ) &Dtool_Filename_operator_437, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_437_comment},
  { "compareTo",(PyCFunction ) &Dtool_Filename_compare_to_438, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_compare_to_438_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_Filename_nonzero_439, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_nonzero_439_comment},
  { "getHash",(PyCFunction ) &Dtool_Filename_get_hash_440, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_hash_440_comment},
  { "output",(PyCFunction ) &Dtool_Filename_output_441, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_output_441_comment},
  { "getClassType",(PyCFunction ) &Dtool_Filename_get_class_type_442, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_get_class_type_442_comment},
  { "operatorTypecast",(PyCFunction ) &Dtool_Filename_operator_typecast_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Filename_operator_typecast_367_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Filename ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_Filename_operator_371__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Filename_operator_371(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Filename ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_Filename_operator_374__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Filename_operator_374(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Filename ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_Filename_operator_373__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Filename_operator_373(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Filename ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_Filename_nonzero_439__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_Filename_nonzero_439(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A LocalHash(getKey) Function for this type
//     Filename
//////////////////
static long  DTool_HashKey_Filename(PyObject * self)
{
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_hash();
}

//////////////////
//  A __repr__ Function
//     Filename
//////////////////
static PyObject *  Dtool_Repr_Filename(PyObject * self)
{
    Filename * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Filename,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Filename(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Filename.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Filename\n"
          "// Description : The name of a file, such as a texture file or an Egg\n"
          "//               file.  Stores the full pathname, and includes\n"
          "//               functions for extracting out the directory prefix\n"
          "//               part and the file extension and stuff.\n"
          "//\n"
          "//               A Filename is also aware of the mapping between the\n"
          "//               Unix-like filename convention we use internally, and\n"
          "//               the local OS's specific filename convention, and it\n"
          "//               knows how to perform basic OS-specific I/O, like\n"
          "//               testing for file existence and searching a\n"
          "//               searchpath, as well as the best way to open an\n"
          "//               fstream for reading or writing.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Filename.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Filename.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Filename.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_Filename.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_Filename_operator_371__getitem__;
        // tp_as_number->nb_add = __add__
        Dtool_Filename.As_PyTypeObject().tp_as_number->nb_add = &Dtool_Filename_operator_374__add__;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_Filename.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_Filename_operator_373__iadd__;
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_Filename.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_Filename_nonzero_439__nonzero__;
        // __hash__
        Dtool_Filename.As_PyTypeObject().tp_hash = &DTool_HashKey_Filename;
        Dtool_Filename.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        // __repr__
        Dtool_Filename.As_PyTypeObject().tp_repr = & Dtool_Repr_Filename;
        // __str__ Repr Proxy
        Dtool_Filename.As_PyTypeObject().tp_str = & Dtool_Repr_Filename;
        // Enum  Filename::Type;
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"TGeneral",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"TDso",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"TExecutable",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_Filename.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Filename)");
             printf(" Error In PyType_ReadyFilename");
             return;
        }
        Py_INCREF(&Dtool_Filename.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"Filename",&Dtool_Filename.As_PyObject());
        //  Static Method textFilename
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"textFilename",PyCFunction_New(&Dtool_Methods_Filename[1],&Dtool_Filename.As_PyObject()));
        //  Static Method binaryFilename
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"binaryFilename",PyCFunction_New(&Dtool_Methods_Filename[2],&Dtool_Filename.As_PyObject()));
        //  Static Method dsoFilename
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"dsoFilename",PyCFunction_New(&Dtool_Methods_Filename[3],&Dtool_Filename.As_PyObject()));
        //  Static Method executableFilename
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"executableFilename",PyCFunction_New(&Dtool_Methods_Filename[4],&Dtool_Filename.As_PyObject()));
        //  Static Method patternFilename
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"patternFilename",PyCFunction_New(&Dtool_Methods_Filename[5],&Dtool_Filename.As_PyObject()));
        //  Static Method fromOsSpecific
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"fromOsSpecific",PyCFunction_New(&Dtool_Methods_Filename[6],&Dtool_Filename.As_PyObject()));
        //  Static Method expandFrom
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"expandFrom",PyCFunction_New(&Dtool_Methods_Filename[7],&Dtool_Filename.As_PyObject()));
        //  Static Method temporary
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"temporary",PyCFunction_New(&Dtool_Methods_Filename[8],&Dtool_Filename.As_PyObject()));
        //  Static Method getHomeDirectory
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"getHomeDirectory",PyCFunction_New(&Dtool_Methods_Filename[9],&Dtool_Filename.As_PyObject()));
        //  Static Method getTempDirectory
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"getTempDirectory",PyCFunction_New(&Dtool_Methods_Filename[10],&Dtool_Filename.As_PyObject()));
        //  Static Method getUserAppdataDirectory
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"getUserAppdataDirectory",PyCFunction_New(&Dtool_Methods_Filename[11],&Dtool_Filename.As_PyObject()));
        //  Static Method getCommonAppdataDirectory
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"getCommonAppdataDirectory",PyCFunction_New(&Dtool_Methods_Filename[12],&Dtool_Filename.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Filename.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Filename[87],&Dtool_Filename.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Filename,Filename::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Filename.As_PyTypeObject());
        PyModule_AddObject(module, "Filename",(PyObject *)&Dtool_Filename.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GlobPattern | GlobPattern
//********************************************************************
PyMethodDef Dtool_Methods_GlobPattern[]= {
  { "assign",(PyCFunction ) &Dtool_GlobPattern_operator_445, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_operator_445_comment},
  { "eq",(PyCFunction ) &Dtool_GlobPattern_operator_446, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_operator_446_comment},
  { "ne",(PyCFunction ) &Dtool_GlobPattern_operator_447, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_operator_447_comment},
  { "lessThan",(PyCFunction ) &Dtool_GlobPattern_operator_448, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_operator_448_comment},
  { "setPattern",(PyCFunction ) &Dtool_GlobPattern_set_pattern_449, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_set_pattern_449_comment},
  { "getPattern",(PyCFunction ) &Dtool_GlobPattern_get_pattern_450, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_get_pattern_450_comment},
  { "setCaseSensitive",(PyCFunction ) &Dtool_GlobPattern_set_case_sensitive_451, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_set_case_sensitive_451_comment},
  { "getCaseSensitive",(PyCFunction ) &Dtool_GlobPattern_get_case_sensitive_452, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_get_case_sensitive_452_comment},
  { "setNomatchChars",(PyCFunction ) &Dtool_GlobPattern_set_nomatch_chars_453, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_set_nomatch_chars_453_comment},
  { "getNomatchChars",(PyCFunction ) &Dtool_GlobPattern_get_nomatch_chars_454, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_get_nomatch_chars_454_comment},
  { "matches",(PyCFunction ) &Dtool_GlobPattern_matches_455, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_matches_455_comment},
  { "output",(PyCFunction ) &Dtool_GlobPattern_output_456, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_output_456_comment},
  { "hasGlobCharacters",(PyCFunction ) &Dtool_GlobPattern_has_glob_characters_457, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_has_glob_characters_457_comment},
  { "getConstPrefix",(PyCFunction ) &Dtool_GlobPattern_get_const_prefix_458, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GlobPattern_get_const_prefix_458_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     GlobPattern
//////////////////
static PyObject *  Dtool_Repr_GlobPattern(PyObject * self)
{
    GlobPattern * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GlobPattern,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_GlobPattern(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GlobPattern.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GlobPattern\n"
          "// Description : This class can be used to test for string matches\n"
          "//               against standard Unix-shell filename globbing\n"
          "//               conventions.  It serves as a portable standin for the\n"
          "//               Posix fnmatch() call.\n"
          "//\n"
          "//               A GlobPattern is given a pattern string, which can\n"
          "//               contain operators like *, ?, and [].  Then it can be\n"
          "//               tested against any number of candidate strings; for\n"
          "//               each candidate, it will indicate whether the string\n"
          "//               matches the pattern or not.  It can be used, for\n"
          "//               example, to scan a directory for all files matching a\n"
          "//               particular pattern.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_GlobPattern.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_GlobPattern.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GlobPattern.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GlobPattern.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_GlobPattern.As_PyTypeObject().tp_repr = & Dtool_Repr_GlobPattern;
        // __str__ Repr Proxy
        Dtool_GlobPattern.As_PyTypeObject().tp_str = & Dtool_Repr_GlobPattern;
        if(PyType_Ready(&Dtool_GlobPattern.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GlobPattern)");
             printf(" Error In PyType_ReadyGlobPattern");
             return;
        }
        Py_INCREF(&Dtool_GlobPattern.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GlobPattern.As_PyTypeObject().tp_dict,"GlobPattern",&Dtool_GlobPattern.As_PyObject());
        RegisterRuntimeClass(&Dtool_GlobPattern,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GlobPattern.As_PyTypeObject());
        PyModule_AddObject(module, "GlobPattern",(PyObject *)&Dtool_GlobPattern.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. IDecryptStream | IDecryptStream
//********************************************************************
PyMethodDef Dtool_Methods_IDecryptStream[]= {
  { "open",(PyCFunction ) &Dtool_IDecryptStream_open_463, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecryptStream_open_463_comment},
  { "close",(PyCFunction ) &Dtool_IDecryptStream_close_464, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecryptStream_close_464_comment},
  { "getAlgorithm",(PyCFunction ) &Dtool_IDecryptStream_get_algorithm_465, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecryptStream_get_algorithm_465_comment},
  { "getKeyLength",(PyCFunction ) &Dtool_IDecryptStream_get_key_length_466, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecryptStream_get_key_length_466_comment},
  { "getIterationCount",(PyCFunction ) &Dtool_IDecryptStream_get_iteration_count_467, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecryptStream_get_iteration_count_467_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_IDecryptStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_IDecryptStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : IDecryptStream\n"
          "// Description : An input stream object that uses OpenSSL to decrypt\n"
          "//               the input from another source stream on-the-fly.\n"
          "//\n"
          "//               Attach an IDecryptStream to an existing istream that\n"
          "//               provides encrypted data, as generated by an\n"
          "//               OEncryptStream, and read the corresponding\n"
          "//               unencrypted data from the IDecryptStream.\n"
          "//\n"
          "//               Seeking is not supported.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_IDecryptStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_istream.As_PyTypeObject());
        Dtool_IDecryptStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_IDecryptStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_IDecryptStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_IDecryptStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(IDecryptStream)");
             printf(" Error In PyType_ReadyIDecryptStream");
             return;
        }
        Py_INCREF(&Dtool_IDecryptStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_IDecryptStream.As_PyTypeObject().tp_dict,"IDecryptStream",&Dtool_IDecryptStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_IDecryptStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_IDecryptStream.As_PyTypeObject());
        PyModule_AddObject(module, "IDecryptStream",(PyObject *)&Dtool_IDecryptStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. IFileStream | IFileStream
//********************************************************************
PyMethodDef Dtool_Methods_IFileStream[]= {
  { "open",(PyCFunction ) &Dtool_IFileStream_open_472, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IFileStream_open_472_comment},
  { "close",(PyCFunction ) &Dtool_IFileStream_close_473, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IFileStream_close_473_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_IFileStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_IFileStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : IFileStream\n"
          "// Description : Implements a C++ stream object suitable for reading\n"
          "//               from files on disk.  This is similar to ifstream, but\n"
          "//               it provides low-level support for Panda's\n"
          "//               simple-threading implementation (using this interface\n"
          "//               will block only the current thread, rather than the\n"
          "//               entire process, on I/O waits).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_IFileStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_istream.As_PyTypeObject());
        Dtool_IFileStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_IFileStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_IFileStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_IFileStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(IFileStream)");
             printf(" Error In PyType_ReadyIFileStream");
             return;
        }
        Py_INCREF(&Dtool_IFileStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_IFileStream.As_PyTypeObject().tp_dict,"IFileStream",&Dtool_IFileStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_IFileStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_IFileStream.As_PyTypeObject());
        PyModule_AddObject(module, "IFileStream",(PyObject *)&Dtool_IFileStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. IStreamWrapper | IStreamWrapper
//********************************************************************
PyMethodDef Dtool_Methods_IStreamWrapper[]= {
  { "getIstream",(PyCFunction ) &Dtool_IStreamWrapper_get_istream_482, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IStreamWrapper_get_istream_482_comment},
  { "upcastToStreamWrapperBase",(PyCFunction ) &Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_479, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_479_comment},
  { "downcastToStreamWrapper",(PyCFunction ) &Dtool_IStreamWrapper_downcast_to_StreamWrapper_660, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IStreamWrapper_downcast_to_StreamWrapper_660_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_IStreamWrapper(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_IStreamWrapper.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : IStreamWrapper\n"
          "// Description : This class provides a locking wrapper around an\n"
          "//               arbitrary istream pointer.  A thread may use this\n"
          "//               class to perform an atomic seek/read/gcount\n"
          "//               operation.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_StreamWrapperBase._Dtool_ClassInit(NULL);
        Dtool_IStreamWrapper.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_StreamWrapperBase.As_PyTypeObject());
        Dtool_IStreamWrapper.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_IStreamWrapper.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_IStreamWrapper.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_IStreamWrapper.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(IStreamWrapper)");
             printf(" Error In PyType_ReadyIStreamWrapper");
             return;
        }
        Py_INCREF(&Dtool_IStreamWrapper.As_PyTypeObject());
        PyDict_SetItemString(Dtool_IStreamWrapper.As_PyTypeObject().tp_dict,"IStreamWrapper",&Dtool_IStreamWrapper.As_PyObject());
        RegisterRuntimeClass(&Dtool_IStreamWrapper,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_IStreamWrapper.As_PyTypeObject());
        PyModule_AddObject(module, "IStreamWrapper",(PyObject *)&Dtool_IStreamWrapper.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StreamWrapperBase | StreamWrapperBase
//********************************************************************
PyMethodDef Dtool_Methods_StreamWrapperBase[]= {
  { "acquire",(PyCFunction ) &Dtool_StreamWrapperBase_acquire_476, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWrapperBase_acquire_476_comment},
  { "release",(PyCFunction ) &Dtool_StreamWrapperBase_release_477, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWrapperBase_release_477_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StreamWrapperBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StreamWrapperBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StreamWrapperBase\n"
          "// Description : The base class for both IStreamWrapper and\n"
          "//               OStreamWrapper, this provides the common locking\n"
          "//               interface.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StreamWrapperBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StreamWrapperBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StreamWrapperBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StreamWrapperBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StreamWrapperBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StreamWrapperBase)");
             printf(" Error In PyType_ReadyStreamWrapperBase");
             return;
        }
        Py_INCREF(&Dtool_StreamWrapperBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StreamWrapperBase.As_PyTypeObject().tp_dict,"StreamWrapperBase",&Dtool_StreamWrapperBase.As_PyObject());
        RegisterRuntimeClass(&Dtool_StreamWrapperBase,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StreamWrapperBase.As_PyTypeObject());
        PyModule_AddObject(module, "StreamWrapperBase",(PyObject *)&Dtool_StreamWrapperBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NeverFreeMemory | NeverFreeMemory
//********************************************************************
PyMethodDef Dtool_Methods_NeverFreeMemory[]= {
  { "getTotalAlloc",(PyCFunction ) &Dtool_NeverFreeMemory_get_total_alloc_484, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NeverFreeMemory_get_total_alloc_484_comment},
  { "getTotalUsed",(PyCFunction ) &Dtool_NeverFreeMemory_get_total_used_485, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NeverFreeMemory_get_total_used_485_comment},
  { "getTotalUnused",(PyCFunction ) &Dtool_NeverFreeMemory_get_total_unused_486, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NeverFreeMemory_get_total_unused_486_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NeverFreeMemory(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NeverFreeMemory.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NeverFreeMemory\n"
          "// Description : This class is used to allocate bytes of memory from a\n"
          "//               pool that is never intended to be freed.  It is\n"
          "//               particularly useful to support DeletedChain, which\n"
          "//               allocates memory in just such a fashion.\n"
          "//\n"
          "//               When it is known that memory will not be freed, it is\n"
          "//               preferable to use this instead of the standard\n"
          "//               malloc() (or global_operator_new()) call, since this\n"
          "//               will help reduce fragmentation problems in the\n"
          "//               dynamic heap.  Also, memory allocated from here will\n"
          "//               exhibit less wasted space.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NeverFreeMemory.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NeverFreeMemory.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NeverFreeMemory)");
             printf(" Error In PyType_ReadyNeverFreeMemory");
             return;
        }
        Py_INCREF(&Dtool_NeverFreeMemory.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict,"NeverFreeMemory",&Dtool_NeverFreeMemory.As_PyObject());
        //  Static Method getTotalAlloc
        PyDict_SetItemString(Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict,"getTotalAlloc",PyCFunction_New(&Dtool_Methods_NeverFreeMemory[0],&Dtool_NeverFreeMemory.As_PyObject()));
        //  Static Method getTotalUsed
        PyDict_SetItemString(Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict,"getTotalUsed",PyCFunction_New(&Dtool_Methods_NeverFreeMemory[1],&Dtool_NeverFreeMemory.As_PyObject()));
        //  Static Method getTotalUnused
        PyDict_SetItemString(Dtool_NeverFreeMemory.As_PyTypeObject().tp_dict,"getTotalUnused",PyCFunction_New(&Dtool_Methods_NeverFreeMemory[2],&Dtool_NeverFreeMemory.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NeverFreeMemory,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NeverFreeMemory.As_PyTypeObject());
        PyModule_AddObject(module, "NeverFreeMemory",(PyObject *)&Dtool_NeverFreeMemory.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Notify | Notify
//********************************************************************
PyMethodDef Dtool_Methods_Notify[]= {
  { "setOstreamPtr",(PyCFunction ) &Dtool_Notify_set_ostream_ptr_491, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_set_ostream_ptr_491_comment},
  { "getOstreamPtr",(PyCFunction ) &Dtool_Notify_get_ostream_ptr_492, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_get_ostream_ptr_492_comment},
  { "clearAssertHandler",(PyCFunction ) &Dtool_Notify_clear_assert_handler_494, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_clear_assert_handler_494_comment},
  { "hasAssertHandler",(PyCFunction ) &Dtool_Notify_has_assert_handler_495, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_has_assert_handler_495_comment},
  { "hasAssertFailed",(PyCFunction ) &Dtool_Notify_has_assert_failed_497, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_has_assert_failed_497_comment},
  { "getAssertErrorMessage",(PyCFunction ) &Dtool_Notify_get_assert_error_message_498, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_get_assert_error_message_498_comment},
  { "clearAssertFailed",(PyCFunction ) &Dtool_Notify_clear_assert_failed_499, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_clear_assert_failed_499_comment},
  { "getTopCategory",(PyCFunction ) &Dtool_Notify_get_top_category_500, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_get_top_category_500_comment},
  { "getCategory",(PyCFunction ) &Dtool_Notify_get_category_501, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_get_category_501_comment},
  { "out",(PyCFunction ) &Dtool_Notify_out_502, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_out_502_comment},
  { "null",(PyCFunction ) &Dtool_Notify_null_503, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_null_503_comment},
  { "writeString",(PyCFunction ) &Dtool_Notify_write_string_504, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_write_string_504_comment},
  { "ptr",(PyCFunction ) &Dtool_Notify_ptr_505, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Notify_ptr_505_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Notify(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Notify.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Notify\n"
          "// Description : An object that handles general error reporting to the\n"
          "//               user.  It contains a pointer to an ostream, initially\n"
          "//               cerr, which can be reset at will to point to\n"
          "//               different output devices, according to the needs of\n"
          "//               the application.  All output generated within Panda\n"
          "//               should vector through the Notify ostream.\n"
          "//\n"
          "//               This also includes a collection of Categories and\n"
          "//               Severities, which may be independently enabled or\n"
          "//               disabled, so that error messages may be squelched or\n"
          "//               respected according to the wishes of the user.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Notify.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Notify.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Notify.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Notify.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Notify)");
             printf(" Error In PyType_ReadyNotify");
             return;
        }
        Py_INCREF(&Dtool_Notify.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"Notify",&Dtool_Notify.As_PyObject());
        //  Static Method out
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"out",PyCFunction_New(&Dtool_Methods_Notify[9],&Dtool_Notify.As_PyObject()));
        //  Static Method null
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"null",PyCFunction_New(&Dtool_Methods_Notify[10],&Dtool_Notify.As_PyObject()));
        //  Static Method writeString
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"writeString",PyCFunction_New(&Dtool_Methods_Notify[11],&Dtool_Notify.As_PyObject()));
        //  Static Method ptr
        PyDict_SetItemString(Dtool_Notify.As_PyTypeObject().tp_dict,"ptr",PyCFunction_New(&Dtool_Methods_Notify[12],&Dtool_Notify.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Notify,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Notify.As_PyTypeObject());
        PyModule_AddObject(module, "Notify",(PyObject *)&Dtool_Notify.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NotifyCategory | NotifyCategory
//********************************************************************
PyMethodDef Dtool_Methods_NotifyCategory[]= {
  { "getFullname",(PyCFunction ) &Dtool_NotifyCategory_get_fullname_511, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_get_fullname_511_comment},
  { "getBasename",(PyCFunction ) &Dtool_NotifyCategory_get_basename_512, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_get_basename_512_comment},
  { "getSeverity",(PyCFunction ) &Dtool_NotifyCategory_get_severity_513, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_get_severity_513_comment},
  { "setSeverity",(PyCFunction ) &Dtool_NotifyCategory_set_severity_514, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_set_severity_514_comment},
  { "isOn",(PyCFunction ) &Dtool_NotifyCategory_is_on_515, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_on_515_comment},
  { "isSpam",(PyCFunction ) &Dtool_NotifyCategory_is_spam_516, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_spam_516_comment},
  { "isDebug",(PyCFunction ) &Dtool_NotifyCategory_is_debug_517, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_debug_517_comment},
  { "isInfo",(PyCFunction ) &Dtool_NotifyCategory_is_info_518, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_info_518_comment},
  { "isWarning",(PyCFunction ) &Dtool_NotifyCategory_is_warning_519, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_warning_519_comment},
  { "isError",(PyCFunction ) &Dtool_NotifyCategory_is_error_520, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_error_520_comment},
  { "isFatal",(PyCFunction ) &Dtool_NotifyCategory_is_fatal_521, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_is_fatal_521_comment},
  { "out",(PyCFunction ) &Dtool_NotifyCategory_out_522, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_out_522_comment},
  { "spam",(PyCFunction ) &Dtool_NotifyCategory_spam_523, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_spam_523_comment},
  { "debug",(PyCFunction ) &Dtool_NotifyCategory_debug_524, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_debug_524_comment},
  { "info",(PyCFunction ) &Dtool_NotifyCategory_info_525, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_info_525_comment},
  { "warning",(PyCFunction ) &Dtool_NotifyCategory_warning_526, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_warning_526_comment},
  { "error",(PyCFunction ) &Dtool_NotifyCategory_error_527, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_error_527_comment},
  { "fatal",(PyCFunction ) &Dtool_NotifyCategory_fatal_528, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_fatal_528_comment},
  { "getNumChildren",(PyCFunction ) &Dtool_NotifyCategory_get_num_children_529, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_get_num_children_529_comment},
  { "getChild",(PyCFunction ) &Dtool_NotifyCategory_get_child_530, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_get_child_530_comment},
  { "setServerDelta",(PyCFunction ) &Dtool_NotifyCategory_set_server_delta_531, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_set_server_delta_531_comment},
  { "upcastToConfigFlags",(PyCFunction ) &Dtool_NotifyCategory_upcast_to_ConfigFlags_509, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NotifyCategory_upcast_to_ConfigFlags_509_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NotifyCategory(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NotifyCategory.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NotifyCategory\n"
          "// Description : A particular category of error messages.  Typically\n"
          "//               there will be one of these per package, so that we\n"
          "//               can turn on or off error messages at least at a\n"
          "//               package level; further nested categories can be\n"
          "//               created within a package if a finer grain of control\n"
          "//               is required.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConfigFlags._Dtool_ClassInit(NULL);
        Dtool_NotifyCategory.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConfigFlags.As_PyTypeObject());
        Dtool_NotifyCategory.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NotifyCategory.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NotifyCategory.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NotifyCategory.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NotifyCategory)");
             printf(" Error In PyType_ReadyNotifyCategory");
             return;
        }
        Py_INCREF(&Dtool_NotifyCategory.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NotifyCategory.As_PyTypeObject().tp_dict,"NotifyCategory",&Dtool_NotifyCategory.As_PyObject());
        //  Static Method setServerDelta
        PyDict_SetItemString(Dtool_NotifyCategory.As_PyTypeObject().tp_dict,"setServerDelta",PyCFunction_New(&Dtool_Methods_NotifyCategory[20],&Dtool_NotifyCategory.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NotifyCategory,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NotifyCategory.As_PyTypeObject());
        PyModule_AddObject(module, "NotifyCategory",(PyObject *)&Dtool_NotifyCategory.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OEncryptStream | OEncryptStream
//********************************************************************
PyMethodDef Dtool_Methods_OEncryptStream[]= {
  { "open",(PyCFunction ) &Dtool_OEncryptStream_open_536, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OEncryptStream_open_536_comment},
  { "close",(PyCFunction ) &Dtool_OEncryptStream_close_537, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OEncryptStream_close_537_comment},
  { "setAlgorithm",(PyCFunction ) &Dtool_OEncryptStream_set_algorithm_538, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OEncryptStream_set_algorithm_538_comment},
  { "setKeyLength",(PyCFunction ) &Dtool_OEncryptStream_set_key_length_539, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OEncryptStream_set_key_length_539_comment},
  { "setIterationCount",(PyCFunction ) &Dtool_OEncryptStream_set_iteration_count_540, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OEncryptStream_set_iteration_count_540_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OEncryptStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OEncryptStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OEncryptStream\n"
          "// Description : An input stream object that uses OpenSSL to encrypt\n"
          "//               data to another destination stream on-the-fly.\n"
          "//\n"
          "//               Attach an OEncryptStream to an existing ostream that\n"
          "//               will accept encrypted data, and write your\n"
          "//               unencrypted source data to the OEncryptStream.\n"
          "//\n"
          "//               Seeking is not supported.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_OEncryptStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_OEncryptStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OEncryptStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OEncryptStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OEncryptStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OEncryptStream)");
             printf(" Error In PyType_ReadyOEncryptStream");
             return;
        }
        Py_INCREF(&Dtool_OEncryptStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OEncryptStream.As_PyTypeObject().tp_dict,"OEncryptStream",&Dtool_OEncryptStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_OEncryptStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OEncryptStream.As_PyTypeObject());
        PyModule_AddObject(module, "OEncryptStream",(PyObject *)&Dtool_OEncryptStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OFileStream | OFileStream
//********************************************************************
PyMethodDef Dtool_Methods_OFileStream[]= {
  { "open",(PyCFunction ) &Dtool_OFileStream_open_545, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OFileStream_open_545_comment},
  { "close",(PyCFunction ) &Dtool_OFileStream_close_546, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OFileStream_close_546_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OFileStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OFileStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OFileStream\n"
          "// Description : Implements a C++ stream object suitable for writing\n"
          "//               to files on disk.  This is similar to ofstream, but\n"
          "//               it provides low-level support for Panda's\n"
          "//               simple-threading implementation (using this interface\n"
          "//               will block only the current thread, rather than the\n"
          "//               entire process, on I/O waits).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_OFileStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_OFileStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OFileStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OFileStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OFileStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OFileStream)");
             printf(" Error In PyType_ReadyOFileStream");
             return;
        }
        Py_INCREF(&Dtool_OFileStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OFileStream.As_PyTypeObject().tp_dict,"OFileStream",&Dtool_OFileStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_OFileStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OFileStream.As_PyTypeObject());
        PyModule_AddObject(module, "OFileStream",(PyObject *)&Dtool_OFileStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OStreamWrapper | OStreamWrapper
//********************************************************************
PyMethodDef Dtool_Methods_OStreamWrapper[]= {
  { "getOstream",(PyCFunction ) &Dtool_OStreamWrapper_get_ostream_551, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OStreamWrapper_get_ostream_551_comment},
  { "upcastToStreamWrapperBase",(PyCFunction ) &Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_548, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_548_comment},
  { "downcastToStreamWrapper",(PyCFunction ) &Dtool_OStreamWrapper_downcast_to_StreamWrapper_662, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OStreamWrapper_downcast_to_StreamWrapper_662_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OStreamWrapper(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OStreamWrapper.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OStreamWrapper\n"
          "// Description : This class provides a locking wrapper around an\n"
          "//               arbitrary ostream pointer.  A thread may use this\n"
          "//               class to perform an atomic seek/write operation.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_StreamWrapperBase._Dtool_ClassInit(NULL);
        Dtool_OStreamWrapper.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_StreamWrapperBase.As_PyTypeObject());
        Dtool_OStreamWrapper.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OStreamWrapper.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OStreamWrapper.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OStreamWrapper.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OStreamWrapper)");
             printf(" Error In PyType_ReadyOStreamWrapper");
             return;
        }
        Py_INCREF(&Dtool_OStreamWrapper.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OStreamWrapper.As_PyTypeObject().tp_dict,"OStreamWrapper",&Dtool_OStreamWrapper.As_PyObject());
        RegisterRuntimeClass(&Dtool_OStreamWrapper,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OStreamWrapper.As_PyTypeObject());
        PyModule_AddObject(module, "OStreamWrapper",(PyObject *)&Dtool_OStreamWrapper.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PandaSystem | PandaSystem
//********************************************************************
PyMethodDef Dtool_Methods_PandaSystem[]= {
  { "getVersionString",(PyCFunction ) &Dtool_PandaSystem_get_version_string_553, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_version_string_553_comment},
  { "getPackageVersionString",(PyCFunction ) &Dtool_PandaSystem_get_package_version_string_554, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_package_version_string_554_comment},
  { "getPackageHostUrl",(PyCFunction ) &Dtool_PandaSystem_get_package_host_url_555, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_package_host_url_555_comment},
  { "getP3dCoreapiVersionString",(PyCFunction ) &Dtool_PandaSystem_get_p3d_coreapi_version_string_556, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_p3d_coreapi_version_string_556_comment},
  { "getMajorVersion",(PyCFunction ) &Dtool_PandaSystem_get_major_version_557, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_major_version_557_comment},
  { "getMinorVersion",(PyCFunction ) &Dtool_PandaSystem_get_minor_version_558, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_minor_version_558_comment},
  { "getSequenceVersion",(PyCFunction ) &Dtool_PandaSystem_get_sequence_version_559, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_sequence_version_559_comment},
  { "isOfficialVersion",(PyCFunction ) &Dtool_PandaSystem_is_official_version_560, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_is_official_version_560_comment},
  { "getDistributor",(PyCFunction ) &Dtool_PandaSystem_get_distributor_561, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_distributor_561_comment},
  { "getCompiler",(PyCFunction ) &Dtool_PandaSystem_get_compiler_562, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_compiler_562_comment},
  { "getBuildDate",(PyCFunction ) &Dtool_PandaSystem_get_build_date_563, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_build_date_563_comment},
  { "getPlatform",(PyCFunction ) &Dtool_PandaSystem_get_platform_564, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_platform_564_comment},
  { "hasSystem",(PyCFunction ) &Dtool_PandaSystem_has_system_565, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_has_system_565_comment},
  { "getNumSystems",(PyCFunction ) &Dtool_PandaSystem_get_num_systems_566, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_num_systems_566_comment},
  { "getSystem",(PyCFunction ) &Dtool_PandaSystem_get_system_567, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_system_567_comment},
  { "getSystemTag",(PyCFunction ) &Dtool_PandaSystem_get_system_tag_568, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_system_tag_568_comment},
  { "addSystem",(PyCFunction ) &Dtool_PandaSystem_add_system_569, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_add_system_569_comment},
  { "setSystemTag",(PyCFunction ) &Dtool_PandaSystem_set_system_tag_570, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_set_system_tag_570_comment},
  { "heapTrim",(PyCFunction ) &Dtool_PandaSystem_heap_trim_571, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_heap_trim_571_comment},
  { "output",(PyCFunction ) &Dtool_PandaSystem_output_572, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_output_572_comment},
  { "write",(PyCFunction ) &Dtool_PandaSystem_write_573, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_write_573_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_PandaSystem_get_global_ptr_574, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_global_ptr_574_comment},
  { "getClassType",(PyCFunction ) &Dtool_PandaSystem_get_class_type_575, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PandaSystem_get_class_type_575_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PandaSystem
//////////////////
static PyObject *  Dtool_Repr_PandaSystem(PyObject * self)
{
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     PandaSystem
//////////////////
static PyObject *  Dtool_Str_PandaSystem(PyObject * self)
{
    PandaSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PandaSystem,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PandaSystem(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PandaSystem.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PandaSystem\n"
          "// Description : This class is used as a namespace to group several\n"
          "//               global properties of Panda.  Application developers\n"
          "//               can use this class to query the runtime version or\n"
          "//               capabilities of the current Panda environment.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PandaSystem.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PandaSystem.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PandaSystem.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PandaSystem.As_PyTypeObject().tp_repr = & Dtool_Repr_PandaSystem;
        // __str__
        Dtool_PandaSystem.As_PyTypeObject().tp_str = & Dtool_Str_PandaSystem;
        if(PyType_Ready(&Dtool_PandaSystem.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PandaSystem)");
             printf(" Error In PyType_ReadyPandaSystem");
             return;
        }
        Py_INCREF(&Dtool_PandaSystem.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"PandaSystem",&Dtool_PandaSystem.As_PyObject());
        //  Static Method getVersionString
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getVersionString",PyCFunction_New(&Dtool_Methods_PandaSystem[0],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getPackageVersionString
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getPackageVersionString",PyCFunction_New(&Dtool_Methods_PandaSystem[1],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getPackageHostUrl
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getPackageHostUrl",PyCFunction_New(&Dtool_Methods_PandaSystem[2],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getP3dCoreapiVersionString
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getP3dCoreapiVersionString",PyCFunction_New(&Dtool_Methods_PandaSystem[3],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getMajorVersion
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getMajorVersion",PyCFunction_New(&Dtool_Methods_PandaSystem[4],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getMinorVersion
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getMinorVersion",PyCFunction_New(&Dtool_Methods_PandaSystem[5],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getSequenceVersion
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getSequenceVersion",PyCFunction_New(&Dtool_Methods_PandaSystem[6],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method isOfficialVersion
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"isOfficialVersion",PyCFunction_New(&Dtool_Methods_PandaSystem[7],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getDistributor
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getDistributor",PyCFunction_New(&Dtool_Methods_PandaSystem[8],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getCompiler
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getCompiler",PyCFunction_New(&Dtool_Methods_PandaSystem[9],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getBuildDate
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getBuildDate",PyCFunction_New(&Dtool_Methods_PandaSystem[10],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getPlatform
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getPlatform",PyCFunction_New(&Dtool_Methods_PandaSystem[11],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_PandaSystem[21],&Dtool_PandaSystem.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PandaSystem.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PandaSystem[22],&Dtool_PandaSystem.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PandaSystem,PandaSystem::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PandaSystem.As_PyTypeObject());
        PyModule_AddObject(module, "PandaSystem",(PyObject *)&Dtool_PandaSystem.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_float | PTAFloat
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_float[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_float_empty_array_578, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_empty_array_578_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_float_size_579, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_size_579_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_float_push_back_580, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_push_back_580_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_float_pop_back_581, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_pop_back_581_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_float_get_element_582, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_get_element_582_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_float_set_element_583, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_set_element_583_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_float_getitem_584, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_getitem_584_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_float_setitem_585, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_setitem_585_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_float_get_data_586, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_get_data_586_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_float_set_data_587, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_set_data_587_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_float_get_subdata_588, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_get_subdata_588_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_float_set_subdata_589, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_set_subdata_589_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_float_get_ref_count_590, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_get_ref_count_590_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_float_get_node_ref_count_591, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_float_get_node_ref_count_591_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_float ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_float_size_579size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_float_size_579(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_float ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_float_getitem_584Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_float_getitem_584(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_float ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_float_setitem_585Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_float_setitem_585(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

void   Dtool_PyModuleClassInit_PointerToArray_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_float._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_float.As_PyTypeObject());
        Dtool_PointerToArray_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_float.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_float.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_float_size_579size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_float.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_float_getitem_584Getitem;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_float.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_float_setitem_585Setitem;
        if(PyType_Ready(&Dtool_PointerToArray_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_float)");
             printf(" Error In PyType_ReadyPointerToArray_float");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_float.As_PyTypeObject().tp_dict,"PTAFloat",&Dtool_PointerToArray_float.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_float.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_float[0],&Dtool_PointerToArray_float.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_float,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_float.As_PyTypeObject());
        PyModule_AddObject(module, "PTAFloat",(PyObject *)&Dtool_PointerToArray_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_int | PTAInt
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_int[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_int_empty_array_595, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_empty_array_595_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_int_size_596, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_size_596_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_int_push_back_597, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_push_back_597_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_int_pop_back_598, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_pop_back_598_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_int_get_element_599, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_get_element_599_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_int_set_element_600, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_set_element_600_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_int_getitem_601, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_getitem_601_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_int_setitem_602, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_setitem_602_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_int_get_data_603, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_get_data_603_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_int_set_data_604, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_set_data_604_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_int_get_subdata_605, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_get_subdata_605_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_int_set_subdata_606, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_set_subdata_606_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_int_get_ref_count_607, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_get_ref_count_607_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_int_get_node_ref_count_608, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_int_get_node_ref_count_608_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_int ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_int_getitem_601Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_int_getitem_601(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_int ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_int_size_596size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_int_size_596(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_int ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_int_setitem_602Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_int_setitem_602(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

void   Dtool_PyModuleClassInit_PointerToArray_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_int._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_int.As_PyTypeObject());
        Dtool_PointerToArray_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_int.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_int.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_int_getitem_601Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_int.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_int_size_596size;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_int.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_int_setitem_602Setitem;
        if(PyType_Ready(&Dtool_PointerToArray_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_int)");
             printf(" Error In PyType_ReadyPointerToArray_int");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_int.As_PyTypeObject().tp_dict,"PTAInt",&Dtool_PointerToArray_int.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_int.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_int[0],&Dtool_PointerToArray_int.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_int,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_int.As_PyTypeObject());
        PyModule_AddObject(module, "PTAInt",(PyObject *)&Dtool_PointerToArray_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_unsigned_char | PTAUchar
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_unsigned_char[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_empty_array_612, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_empty_array_612_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_size_613, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_size_613_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_push_back_614, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_push_back_614_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_pop_back_615, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_pop_back_615_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_get_element_616, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_get_element_616_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_set_element_617, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_set_element_617_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_getitem_618, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_getitem_618_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_setitem_619, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_setitem_619_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_get_data_620, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_get_data_620_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_set_data_621, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_set_data_621_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_get_subdata_622, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_get_subdata_622_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_set_subdata_623, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_set_subdata_623_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_get_ref_count_624, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_get_ref_count_624_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_unsigned_char_get_node_ref_count_625, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_unsigned_char_get_node_ref_count_625_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_char ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_unsigned_char_setitem_619Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_unsigned_char_setitem_619(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_char ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_unsigned_char_getitem_618Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_unsigned_char_getitem_618(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_unsigned_char ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_unsigned_char_size_613size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_unsigned_char_size_613(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_PointerToArray_unsigned_char(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_unsigned_char._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_unsigned_char.As_PyTypeObject());
        Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_unsigned_char_setitem_619Setitem;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_unsigned_char_getitem_618Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_unsigned_char_size_613size;
        if(PyType_Ready(&Dtool_PointerToArray_unsigned_char.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_unsigned_char)");
             printf(" Error In PyType_ReadyPointerToArray_unsigned_char");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_unsigned_char.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_dict,"PTAUchar",&Dtool_PointerToArray_unsigned_char.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_unsigned_char.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_unsigned_char[0],&Dtool_PointerToArray_unsigned_char.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_unsigned_char,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_unsigned_char.As_PyTypeObject());
        PyModule_AddObject(module, "PTAUchar",(PyObject *)&Dtool_PointerToArray_unsigned_char.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StreamReader | StreamReader
//********************************************************************
PyMethodDef Dtool_Methods_StreamReader[]= {
  { "assign",(PyCFunction ) &Dtool_StreamReader_operator_629, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_operator_629_comment},
  { "getIstream",(PyCFunction ) &Dtool_StreamReader_get_istream_631, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_istream_631_comment},
  { "getBool",(PyCFunction ) &Dtool_StreamReader_get_bool_632, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_bool_632_comment},
  { "getInt8",(PyCFunction ) &Dtool_StreamReader_get_int8_633, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_int8_633_comment},
  { "getUint8",(PyCFunction ) &Dtool_StreamReader_get_uint8_634, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_uint8_634_comment},
  { "getInt16",(PyCFunction ) &Dtool_StreamReader_get_int16_635, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_int16_635_comment},
  { "getInt32",(PyCFunction ) &Dtool_StreamReader_get_int32_636, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_int32_636_comment},
  { "getInt64",(PyCFunction ) &Dtool_StreamReader_get_int64_637, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_int64_637_comment},
  { "getUint16",(PyCFunction ) &Dtool_StreamReader_get_uint16_638, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_uint16_638_comment},
  { "getUint32",(PyCFunction ) &Dtool_StreamReader_get_uint32_639, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_uint32_639_comment},
  { "getUint64",(PyCFunction ) &Dtool_StreamReader_get_uint64_640, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_uint64_640_comment},
  { "getFloat32",(PyCFunction ) &Dtool_StreamReader_get_float32_641, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_float32_641_comment},
  { "getFloat64",(PyCFunction ) &Dtool_StreamReader_get_float64_642, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_float64_642_comment},
  { "getBeInt16",(PyCFunction ) &Dtool_StreamReader_get_be_int16_643, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_int16_643_comment},
  { "getBeInt32",(PyCFunction ) &Dtool_StreamReader_get_be_int32_644, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_int32_644_comment},
  { "getBeInt64",(PyCFunction ) &Dtool_StreamReader_get_be_int64_645, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_int64_645_comment},
  { "getBeUint16",(PyCFunction ) &Dtool_StreamReader_get_be_uint16_646, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_uint16_646_comment},
  { "getBeUint32",(PyCFunction ) &Dtool_StreamReader_get_be_uint32_647, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_uint32_647_comment},
  { "getBeUint64",(PyCFunction ) &Dtool_StreamReader_get_be_uint64_648, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_uint64_648_comment},
  { "getBeFloat32",(PyCFunction ) &Dtool_StreamReader_get_be_float32_649, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_float32_649_comment},
  { "getBeFloat64",(PyCFunction ) &Dtool_StreamReader_get_be_float64_650, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_be_float64_650_comment},
  { "getString",(PyCFunction ) &Dtool_StreamReader_get_string_651, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_string_651_comment},
  { "getString32",(PyCFunction ) &Dtool_StreamReader_get_string32_652, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_string32_652_comment},
  { "getZString",(PyCFunction ) &Dtool_StreamReader_get_z_string_653, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_z_string_653_comment},
  { "getFixedString",(PyCFunction ) &Dtool_StreamReader_get_fixed_string_654, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_get_fixed_string_654_comment},
  { "skipBytes",(PyCFunction ) &Dtool_StreamReader_skip_bytes_655, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_skip_bytes_655_comment},
  { "extractBytes",(PyCFunction ) &Dtool_StreamReader_extract_bytes_656, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_extract_bytes_656_comment},
  { "readline",(PyCFunction ) &Dtool_StreamReader_readline_657, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamReader_readline_657_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StreamReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StreamReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StreamReader\n"
          "// Description : A class to read sequential binary data directly from\n"
          "//               an istream.  Its interface is similar to\n"
          "//               DatagramIterator by design; see also StreamWriter.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StreamReader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StreamReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StreamReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StreamReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StreamReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StreamReader)");
             printf(" Error In PyType_ReadyStreamReader");
             return;
        }
        Py_INCREF(&Dtool_StreamReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StreamReader.As_PyTypeObject().tp_dict,"StreamReader",&Dtool_StreamReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_StreamReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StreamReader.As_PyTypeObject());
        PyModule_AddObject(module, "StreamReader",(PyObject *)&Dtool_StreamReader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StreamWrapper | StreamWrapper
//********************************************************************
PyMethodDef Dtool_Methods_StreamWrapper[]= {
  { "getIostream",(PyCFunction ) &Dtool_StreamWrapper_get_iostream_665, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWrapper_get_iostream_665_comment},
  { "upcastToIStreamWrapper",(PyCFunction ) &Dtool_StreamWrapper_upcast_to_IStreamWrapper_659, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWrapper_upcast_to_IStreamWrapper_659_comment},
  { "upcastToOStreamWrapper",(PyCFunction ) &Dtool_StreamWrapper_upcast_to_OStreamWrapper_661, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWrapper_upcast_to_OStreamWrapper_661_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StreamWrapper(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StreamWrapper.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StreamWrapper\n"
          "// Description : This class provides a locking wrapper around a\n"
          "//               combination ostream/istream pointer.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_IStreamWrapper._Dtool_ClassInit(NULL);
        Dtool_OStreamWrapper._Dtool_ClassInit(NULL);
        Dtool_StreamWrapper.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_IStreamWrapper.As_PyTypeObject(),&Dtool_OStreamWrapper.As_PyTypeObject());
        Dtool_StreamWrapper.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StreamWrapper.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StreamWrapper.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StreamWrapper.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StreamWrapper)");
             printf(" Error In PyType_ReadyStreamWrapper");
             return;
        }
        Py_INCREF(&Dtool_StreamWrapper.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StreamWrapper.As_PyTypeObject().tp_dict,"StreamWrapper",&Dtool_StreamWrapper.As_PyObject());
        RegisterRuntimeClass(&Dtool_StreamWrapper,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StreamWrapper.As_PyTypeObject());
        PyModule_AddObject(module, "StreamWrapper",(PyObject *)&Dtool_StreamWrapper.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StreamWriter | StreamWriter
//********************************************************************
PyMethodDef Dtool_Methods_StreamWriter[]= {
  { "assign",(PyCFunction ) &Dtool_StreamWriter_operator_668, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_operator_668_comment},
  { "getOstream",(PyCFunction ) &Dtool_StreamWriter_get_ostream_670, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_get_ostream_670_comment},
  { "addBool",(PyCFunction ) &Dtool_StreamWriter_add_bool_671, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_bool_671_comment},
  { "addInt8",(PyCFunction ) &Dtool_StreamWriter_add_int8_672, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_int8_672_comment},
  { "addUint8",(PyCFunction ) &Dtool_StreamWriter_add_uint8_673, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_uint8_673_comment},
  { "addInt16",(PyCFunction ) &Dtool_StreamWriter_add_int16_674, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_int16_674_comment},
  { "addInt32",(PyCFunction ) &Dtool_StreamWriter_add_int32_675, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_int32_675_comment},
  { "addInt64",(PyCFunction ) &Dtool_StreamWriter_add_int64_676, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_int64_676_comment},
  { "addUint16",(PyCFunction ) &Dtool_StreamWriter_add_uint16_677, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_uint16_677_comment},
  { "addUint32",(PyCFunction ) &Dtool_StreamWriter_add_uint32_678, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_uint32_678_comment},
  { "addUint64",(PyCFunction ) &Dtool_StreamWriter_add_uint64_679, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_uint64_679_comment},
  { "addFloat32",(PyCFunction ) &Dtool_StreamWriter_add_float32_680, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_float32_680_comment},
  { "addFloat64",(PyCFunction ) &Dtool_StreamWriter_add_float64_681, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_float64_681_comment},
  { "addBeInt16",(PyCFunction ) &Dtool_StreamWriter_add_be_int16_682, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_int16_682_comment},
  { "addBeInt32",(PyCFunction ) &Dtool_StreamWriter_add_be_int32_683, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_int32_683_comment},
  { "addBeInt64",(PyCFunction ) &Dtool_StreamWriter_add_be_int64_684, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_int64_684_comment},
  { "addBeUint16",(PyCFunction ) &Dtool_StreamWriter_add_be_uint16_685, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_uint16_685_comment},
  { "addBeUint32",(PyCFunction ) &Dtool_StreamWriter_add_be_uint32_686, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_uint32_686_comment},
  { "addBeUint64",(PyCFunction ) &Dtool_StreamWriter_add_be_uint64_687, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_uint64_687_comment},
  { "addBeFloat32",(PyCFunction ) &Dtool_StreamWriter_add_be_float32_688, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_float32_688_comment},
  { "addBeFloat64",(PyCFunction ) &Dtool_StreamWriter_add_be_float64_689, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_be_float64_689_comment},
  { "addString",(PyCFunction ) &Dtool_StreamWriter_add_string_690, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_string_690_comment},
  { "addString32",(PyCFunction ) &Dtool_StreamWriter_add_string32_691, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_string32_691_comment},
  { "addZString",(PyCFunction ) &Dtool_StreamWriter_add_z_string_692, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_z_string_692_comment},
  { "addFixedString",(PyCFunction ) &Dtool_StreamWriter_add_fixed_string_693, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_add_fixed_string_693_comment},
  { "padBytes",(PyCFunction ) &Dtool_StreamWriter_pad_bytes_694, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_pad_bytes_694_comment},
  { "appendData",(PyCFunction ) &Dtool_StreamWriter_append_data_695, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_append_data_695_comment},
  { "flush",(PyCFunction ) &Dtool_StreamWriter_flush_696, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_flush_696_comment},
  { "write",(PyCFunction ) &Dtool_StreamWriter_write_697, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StreamWriter_write_697_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StreamWriter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StreamWriter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StreamWriter\n"
          "// Description : A StreamWriter object is used to write sequential\n"
          "//               binary data directly to an ostream.  Its interface is\n"
          "//               very similar to Datagram by design; it's primarily\n"
          "//               intended as a convenience to eliminate the overhead\n"
          "//               of writing bytes to a Datagram and then writing the\n"
          "//               Datagram to a stream.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StreamWriter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StreamWriter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StreamWriter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StreamWriter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_StreamWriter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StreamWriter)");
             printf(" Error In PyType_ReadyStreamWriter");
             return;
        }
        Py_INCREF(&Dtool_StreamWriter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StreamWriter.As_PyTypeObject().tp_dict,"StreamWriter",&Dtool_StreamWriter.As_PyObject());
        RegisterRuntimeClass(&Dtool_StreamWriter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StreamWriter.As_PyTypeObject());
        PyModule_AddObject(module, "StreamWriter",(PyObject *)&Dtool_StreamWriter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypeHandle | TypeHandle
//********************************************************************
PyMethodDef Dtool_Methods_TypeHandle[]= {
  { "make",(PyCFunction ) &Dtool_TypeHandle_make_701, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_make_701_comment},
  { "eq",(PyCFunction ) &Dtool_TypeHandle_operator_702, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_702_comment},
  { "ne",(PyCFunction ) &Dtool_TypeHandle_operator_703, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_703_comment},
  { "lessThan",(PyCFunction ) &Dtool_TypeHandle_operator_704, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_704_comment},
  { "lessThanOrEqual",(PyCFunction ) &Dtool_TypeHandle_operator_705, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_705_comment},
  { "greaterThan",(PyCFunction ) &Dtool_TypeHandle_operator_706, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_706_comment},
  { "greaterThanOrEqual",(PyCFunction ) &Dtool_TypeHandle_operator_707, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_operator_707_comment},
  { "compareTo",(PyCFunction ) &Dtool_TypeHandle_compare_to_708, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_compare_to_708_comment},
  { "getHash",(PyCFunction ) &Dtool_TypeHandle_get_hash_709, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_hash_709_comment},
  { "getName",(PyCFunction ) &Dtool_TypeHandle_get_name_710, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_name_710_comment},
  { "isDerivedFrom",(PyCFunction ) &Dtool_TypeHandle_is_derived_from_711, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_is_derived_from_711_comment},
  { "getNumParentClasses",(PyCFunction ) &Dtool_TypeHandle_get_num_parent_classes_712, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_num_parent_classes_712_comment},
  { "getParentClass",(PyCFunction ) &Dtool_TypeHandle_get_parent_class_713, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_parent_class_713_comment},
  { "getNumChildClasses",(PyCFunction ) &Dtool_TypeHandle_get_num_child_classes_714, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_num_child_classes_714_comment},
  { "getChildClass",(PyCFunction ) &Dtool_TypeHandle_get_child_class_715, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_child_class_715_comment},
  { "getParentTowards",(PyCFunction ) &Dtool_TypeHandle_get_parent_towards_716, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_parent_towards_716_comment},
  { "getMemoryUsage",(PyCFunction ) &Dtool_TypeHandle_get_memory_usage_718, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_memory_usage_718_comment},
  { "incMemoryUsage",(PyCFunction ) &Dtool_TypeHandle_inc_memory_usage_719, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_inc_memory_usage_719_comment},
  { "decMemoryUsage",(PyCFunction ) &Dtool_TypeHandle_dec_memory_usage_720, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_dec_memory_usage_720_comment},
  { "getIndex",(PyCFunction ) &Dtool_TypeHandle_get_index_721, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_get_index_721_comment},
  { "output",(PyCFunction ) &Dtool_TypeHandle_output_722, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_output_722_comment},
  { "none",(PyCFunction ) &Dtool_TypeHandle_none_723, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeHandle_none_723_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A LocalHash(getKey) Function for this type
//     TypeHandle
//////////////////
static long  DTool_HashKey_TypeHandle(PyObject * self)
{
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_hash();
}

//////////////////
//  A __repr__ Function
//     TypeHandle
//////////////////
static PyObject *  Dtool_Repr_TypeHandle(PyObject * self)
{
    TypeHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeHandle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TypeHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypeHandle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypeHandle\n"
          "// Description : TypeHandle is the identifier used to differentiate\n"
          "//               C++ class types.  Any C++ classes that inherit from\n"
          "//               some base class, and must be differentiated at run\n"
          "//               time, should store a static TypeHandle object that\n"
          "//               can be queried through a static member function\n"
          "//               named get_class_type().  Most of the time, it is also\n"
          "//               desirable to inherit from TypedObject, which provides\n"
          "//               some virtual functions to return the TypeHandle for a\n"
          "//               particular instance.\n"
          "//\n"
          "//               At its essence, a TypeHandle is simply a unique\n"
          "//               identifier that is assigned by the TypeRegistry.  The\n"
          "//               TypeRegistry stores a tree of TypeHandles, so that\n"
          "//               ancestry of a particular type may be queried, and the\n"
          "//               type name may be retrieved for run-time display.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TypeHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TypeHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypeHandle.As_PyTypeObject().tp_dict);
        // __hash__
        Dtool_TypeHandle.As_PyTypeObject().tp_hash = &DTool_HashKey_TypeHandle;
        Dtool_TypeHandle.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        // __repr__
        Dtool_TypeHandle.As_PyTypeObject().tp_repr = & Dtool_Repr_TypeHandle;
        // __str__ Repr Proxy
        Dtool_TypeHandle.As_PyTypeObject().tp_str = & Dtool_Repr_TypeHandle;
        // Enum  TypeHandle::MemoryClass;
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"MCSingleton",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"MCArray",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"MCDeletedChainActive",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"MCDeletedChainInactive",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"MCLimit",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_TypeHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypeHandle)");
             printf(" Error In PyType_ReadyTypeHandle");
             return;
        }
        Py_INCREF(&Dtool_TypeHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"TypeHandle",&Dtool_TypeHandle.As_PyObject());
        //  Static Method make
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"make",PyCFunction_New(&Dtool_Methods_TypeHandle[0],&Dtool_TypeHandle.As_PyObject()));
        //  Static Method none
        PyDict_SetItemString(Dtool_TypeHandle.As_PyTypeObject().tp_dict,"none",PyCFunction_New(&Dtool_Methods_TypeHandle[21],&Dtool_TypeHandle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypeHandle,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypeHandle.As_PyTypeObject());
        PyModule_AddObject(module, "TypeHandle",(PyObject *)&Dtool_TypeHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypeRegistry | TypeRegistry
//********************************************************************
PyMethodDef Dtool_Methods_TypeRegistry[]= {
  { "findType",(PyCFunction ) &Dtool_TypeRegistry_find_type_726, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_find_type_726_comment},
  { "findTypeById",(PyCFunction ) &Dtool_TypeRegistry_find_type_by_id_727, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_find_type_by_id_727_comment},
  { "getName",(PyCFunction ) &Dtool_TypeRegistry_get_name_728, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_name_728_comment},
  { "isDerivedFrom",(PyCFunction ) &Dtool_TypeRegistry_is_derived_from_729, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_is_derived_from_729_comment},
  { "getNumTypehandles",(PyCFunction ) &Dtool_TypeRegistry_get_num_typehandles_730, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_num_typehandles_730_comment},
  { "getTypehandle",(PyCFunction ) &Dtool_TypeRegistry_get_typehandle_731, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_typehandle_731_comment},
  { "getNumRootClasses",(PyCFunction ) &Dtool_TypeRegistry_get_num_root_classes_732, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_num_root_classes_732_comment},
  { "getRootClass",(PyCFunction ) &Dtool_TypeRegistry_get_root_class_733, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_root_class_733_comment},
  { "getNumParentClasses",(PyCFunction ) &Dtool_TypeRegistry_get_num_parent_classes_734, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_num_parent_classes_734_comment},
  { "getParentClass",(PyCFunction ) &Dtool_TypeRegistry_get_parent_class_735, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_parent_class_735_comment},
  { "getNumChildClasses",(PyCFunction ) &Dtool_TypeRegistry_get_num_child_classes_736, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_num_child_classes_736_comment},
  { "getChildClass",(PyCFunction ) &Dtool_TypeRegistry_get_child_class_737, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_child_class_737_comment},
  { "getParentTowards",(PyCFunction ) &Dtool_TypeRegistry_get_parent_towards_738, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_get_parent_towards_738_comment},
  { "reregisterTypes",(PyCFunction ) &Dtool_TypeRegistry_reregister_types_739, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_reregister_types_739_comment},
  { "write",(PyCFunction ) &Dtool_TypeRegistry_write_740, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_write_740_comment},
  { "ptr",(PyCFunction ) &Dtool_TypeRegistry_ptr_741, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypeRegistry_ptr_741_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     TypeRegistry
//////////////////
static PyObject *  Dtool_Str_TypeRegistry(PyObject * self)
{
    TypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypeRegistry,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_TypeRegistry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypeRegistry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypeRegistry\n"
          "// Description : The TypeRegistry class maintains all the assigned\n"
          "//               TypeHandles in a given system.  There should be only\n"
          "//               one TypeRegistry class during the lifetime of the\n"
          "//               application.  It will be created on the local heap\n"
          "//               initially, and it should be migrated to shared memory\n"
          "//               as soon as shared memory becomes available.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TypeRegistry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TypeRegistry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypeRegistry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypeRegistry.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_TypeRegistry.As_PyTypeObject().tp_str = & Dtool_Str_TypeRegistry;
        if(PyType_Ready(&Dtool_TypeRegistry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypeRegistry)");
             printf(" Error In PyType_ReadyTypeRegistry");
             return;
        }
        Py_INCREF(&Dtool_TypeRegistry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypeRegistry.As_PyTypeObject().tp_dict,"TypeRegistry",&Dtool_TypeRegistry.As_PyObject());
        //  Static Method reregisterTypes
        PyDict_SetItemString(Dtool_TypeRegistry.As_PyTypeObject().tp_dict,"reregisterTypes",PyCFunction_New(&Dtool_Methods_TypeRegistry[13],&Dtool_TypeRegistry.As_PyObject()));
        //  Static Method ptr
        PyDict_SetItemString(Dtool_TypeRegistry.As_PyTypeObject().tp_dict,"ptr",PyCFunction_New(&Dtool_Methods_TypeRegistry[15],&Dtool_TypeRegistry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypeRegistry,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypeRegistry.As_PyTypeObject());
        PyModule_AddObject(module, "TypeRegistry",(PyObject *)&Dtool_TypeRegistry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypedObject | TypedObject
//********************************************************************
PyMethodDef Dtool_Methods_TypedObject[]= {
  { "getType",(PyCFunction ) &Dtool_TypedObject_get_type_747, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_get_type_747_comment},
  { "getTypeIndex",(PyCFunction ) &Dtool_TypedObject_get_type_index_748, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_get_type_index_748_comment},
  { "isOfType",(PyCFunction ) &Dtool_TypedObject_is_of_type_749, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_is_of_type_749_comment},
  { "isExactType",(PyCFunction ) &Dtool_TypedObject_is_exact_type_750, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_is_exact_type_750_comment},
  { "getClassType",(PyCFunction ) &Dtool_TypedObject_get_class_type_751, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_get_class_type_751_comment},
  { "downcastToTypedReferenceCount",(PyCFunction ) &Dtool_TypedObject_downcast_to_TypedReferenceCount_940, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedObject_downcast_to_TypedReferenceCount_940_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TypedObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypedObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypedObject\n"
          "// Description : This is an abstract class that all classes which\n"
          "//               use TypeHandle, and also provide virtual functions to\n"
          "//               support polymorphism, should inherit from.  Each\n"
          "//               derived class should define get_type(), which should\n"
          "//               return the specific type of the derived class.\n"
          "//               Inheriting from this automatically provides support\n"
          "//               for is_of_type() and is_exact_type().\n"
          "//               \n"
          "//               All classes that inherit directly or indirectly from\n"
          "//               TypedObject should redefine get_type() and\n"
          "//               force_init_type(), as shown below.  Some classes that\n"
          "//               do not inherit from TypedObject may still declare\n"
          "//               TypeHandles for themselves by defining methods called\n"
          "//               get_class_type() and init_type().  Classes such as\n"
          "//               these may serve as base classes, but the dynamic type\n"
          "//               identification system will be limited.  Classes that\n"
          "//               do not inherit from TypedObject need not define the\n"
          "//               virtual functions get_type() and force_init_type()\n"
          "//               (or any other virtual functions).\n"
          "//               \n"
          "//               There is a specific layout for defining the\n"
          "//               overrides from this class.  Keeping the definitions\n"
          "//               formatted just like these examples will allow\n"
          "//               someone in the future to use a sed (or similar)\n"
          "//               script to make global changes, if necessary.  Avoid\n"
          "//               rearranging the braces or the order of the functions\n"
          "//               unless you're ready to change them in every file all\n"
          "//               at once.\n"
          "//               \n"
          "//               What follows are some examples that can be used in\n"
          "//               new classes that you create.\n"
          "//               \n"
          "//               ---------------------------------------------------\n"
          "//               In the class definition (.h file)\n"
          "//               ---------------------------------------------------\n"
          "//               \n"
          "//               public:\n"
          "//                 static TypeHandle get_class_type() {\n"
          "//                   return _type_handle;\n"
          "//                 }\n"
          "//                 static void init_type() {\n"
          "//                   <<<BaseClassOne>>>::init_type();\n"
          "//                   <<<BaseClassTwo>>>::init_type();\n"
          "//                   <<<BaseClassN>>>::init_type();\n"
          "//                   register_type(_type_handle, \"<<<ThisClassStringName>>>\",\n"
          "//                                 <<<BaseClassOne>>>::get_class_type(),\n"
          "//                                 <<<BaseClassTwo>>>::get_class_type(),\n"
          "//                                 <<<BaseClassN>>>::get_class_type());\n"
          "//                 }\n"
          "//                 virtual TypeHandle get_type() const {\n"
          "//                   return get_class_type();\n"
          "//                 }\n"
          "//                 virtual TypeHandle force_init_type() {init_type(); return get_class_type();}\n"
          "//               \n"
          "//               private:\n"
          "//                 static TypeHandle _type_handle;\n"
          "//               \n"
          "//               \n"
          "//               ----------------------\n"
          "//               In the class .cxx file\n"
          "//               ----------------------\n"
          "//               \n"
          "//               TypeHandle <<<ThisClassStringName>>>::_type_handle;\n"
          "//               \n"
          "//               \n"
          "//               ----------------------------------------------\n"
          "//               In the class config_<<<PackageName>>>.cxx file\n"
          "//               ----------------------------------------------\n"
          "//               \n"
          "//               ConfigureFn(config_<<<PackageName>>>) {\n"
          "//                 <<<ClassOne>>>::init_type();\n"
          "//                 <<<ClassTwo>>>::init_type();\n"
          "//                 <<<ClassN>>>::init_type();\n"
          "//               }\n"
          "//               \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TypedObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TypedObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypedObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypedObject.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TypedObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypedObject)");
             printf(" Error In PyType_ReadyTypedObject");
             return;
        }
        Py_INCREF(&Dtool_TypedObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypedObject.As_PyTypeObject().tp_dict,"TypedObject",&Dtool_TypedObject.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TypedObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TypedObject[4],&Dtool_TypedObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypedObject,TypedObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypedObject.As_PyTypeObject());
        PyModule_AddObject(module, "TypedObject",(PyObject *)&Dtool_TypedObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. fstream | Fstream
//********************************************************************
PyMethodDef Dtool_Methods_fstream[]= {
  { "close",(PyCFunction ) &Dtool_fstream_close_754, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_fstream_close_754_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_fstream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_iostream._Dtool_ClassInit(NULL);
        Dtool_fstream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_iostream.As_PyTypeObject());
        Dtool_fstream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_fstream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_fstream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_fstream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(fstream)");
             printf(" Error In PyType_Readyfstream");
             return;
        }
        Py_INCREF(&Dtool_fstream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_fstream.As_PyTypeObject().tp_dict,"Fstream",&Dtool_fstream.As_PyObject());
        RegisterRuntimeClass(&Dtool_fstream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_fstream.As_PyTypeObject());
        PyModule_AddObject(module, "Fstream",(PyObject *)&Dtool_fstream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ifstream | Ifstream
//********************************************************************
PyMethodDef Dtool_Methods_ifstream[]= {
  { "close",(PyCFunction ) &Dtool_ifstream_close_758, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ifstream_close_758_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ifstream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_ifstream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_istream.As_PyTypeObject());
        Dtool_ifstream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ifstream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ifstream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ifstream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ifstream)");
             printf(" Error In PyType_Readyifstream");
             return;
        }
        Py_INCREF(&Dtool_ifstream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ifstream.As_PyTypeObject().tp_dict,"Ifstream",&Dtool_ifstream.As_PyObject());
        RegisterRuntimeClass(&Dtool_ifstream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ifstream.As_PyTypeObject());
        PyModule_AddObject(module, "Ifstream",(PyObject *)&Dtool_ifstream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ofstream | Ofstream
//********************************************************************
PyMethodDef Dtool_Methods_ofstream[]= {
  { "close",(PyCFunction ) &Dtool_ofstream_close_762, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ofstream_close_762_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ofstream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_ofstream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_ofstream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ofstream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ofstream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ofstream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ofstream)");
             printf(" Error In PyType_Readyofstream");
             return;
        }
        Py_INCREF(&Dtool_ofstream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ofstream.As_PyTypeObject().tp_dict,"Ofstream",&Dtool_ofstream.As_PyObject());
        RegisterRuntimeClass(&Dtool_ofstream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ofstream.As_PyTypeObject());
        PyModule_AddObject(module, "Ofstream",(PyObject *)&Dtool_ofstream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ReferenceCount | ReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_ReferenceCount[]= {
  { "getRefCount",(PyCFunction ) &Dtool_ReferenceCount_get_ref_count_769, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_get_ref_count_769_comment},
  { "ref",(PyCFunction ) &Dtool_ReferenceCount_ref_770, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_ref_770_comment},
  { "unref",(PyCFunction ) &Dtool_ReferenceCount_unref_771, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_unref_771_comment},
  { "testRefCountIntegrity",(PyCFunction ) &Dtool_ReferenceCount_test_ref_count_integrity_772, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_test_ref_count_integrity_772_comment},
  { "testRefCountNonzero",(PyCFunction ) &Dtool_ReferenceCount_test_ref_count_nonzero_773, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_test_ref_count_nonzero_773_comment},
  { "getClassType",(PyCFunction ) &Dtool_ReferenceCount_get_class_type_774, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_get_class_type_774_comment},
  { "downcastToTypedReferenceCount",(PyCFunction ) &Dtool_ReferenceCount_downcast_to_TypedReferenceCount_942, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReferenceCount_downcast_to_TypedReferenceCount_942_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ReferenceCount\n"
          "// Description : A base class for all things that want to be\n"
          "//               reference-counted.  ReferenceCount works in\n"
          "//               conjunction with PointerTo to automatically delete\n"
          "//               objects when the last pointer to them goes away.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ReferenceCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ReferenceCount)");
             printf(" Error In PyType_ReadyReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_ReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ReferenceCount.As_PyTypeObject().tp_dict,"ReferenceCount",&Dtool_ReferenceCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ReferenceCount[5],&Dtool_ReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ReferenceCount,ReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "ReferenceCount",(PyObject *)&Dtool_ReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Buffer | Buffer
//********************************************************************
PyMethodDef Dtool_Methods_Buffer[]= {
  { "getLength",(PyCFunction ) &Dtool_Buffer_get_length_776, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffer_get_length_776_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Buffer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Buffer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Buffer\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Buffer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_Buffer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Buffer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Buffer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Buffer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Buffer)");
             printf(" Error In PyType_ReadyBuffer");
             return;
        }
        Py_INCREF(&Dtool_Buffer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Buffer.As_PyTypeObject().tp_dict,"Buffer",&Dtool_Buffer.As_PyObject());
        RegisterRuntimeClass(&Dtool_Buffer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Buffer.As_PyTypeObject());
        PyModule_AddObject(module, "Buffer",(PyObject *)&Dtool_Buffer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PStatCollectorForwardBase | PStatCollectorForwardBase
//********************************************************************
PyMethodDef Dtool_Methods_PStatCollectorForwardBase[]= {
  { "addLevel",(PyCFunction ) &Dtool_PStatCollectorForwardBase_add_level_785, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollectorForwardBase_add_level_785_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PStatCollectorForwardBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PStatCollectorForwardBase\n"
          "// Description : This class serves as a cheap forward reference to a\n"
          "//               PStatCollector, which is defined in the pstatclient\n"
          "//               module (and is not directly accessible here in the\n"
          "//               express module).\n"
          "//\n"
          "//               This is subclassed as PStatCollectorForward, which\n"
          "//               defines the actual functionality.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PStatCollectorForwardBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PStatCollectorForwardBase)");
             printf(" Error In PyType_ReadyPStatCollectorForwardBase");
             return;
        }
        Py_INCREF(&Dtool_PStatCollectorForwardBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PStatCollectorForwardBase.As_PyTypeObject().tp_dict,"PStatCollectorForwardBase",&Dtool_PStatCollectorForwardBase.As_PyObject());
        RegisterRuntimeClass(&Dtool_PStatCollectorForwardBase,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PStatCollectorForwardBase.As_PyTypeObject());
        PyModule_AddObject(module, "PStatCollectorForwardBase",(PyObject *)&Dtool_PStatCollectorForwardBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NodeReferenceCount | NodeReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_NodeReferenceCount[]= {
  { "getNodeRefCount",(PyCFunction ) &Dtool_NodeReferenceCount_get_node_ref_count_788, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeReferenceCount_get_node_ref_count_788_comment},
  { "nodeRef",(PyCFunction ) &Dtool_NodeReferenceCount_node_ref_789, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeReferenceCount_node_ref_789_comment},
  { "nodeUnref",(PyCFunction ) &Dtool_NodeReferenceCount_node_unref_790, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeReferenceCount_node_unref_790_comment},
  { "testRefCountIntegrity",(PyCFunction ) &Dtool_NodeReferenceCount_test_ref_count_integrity_791, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeReferenceCount_test_ref_count_integrity_791_comment},
  { "getClassType",(PyCFunction ) &Dtool_NodeReferenceCount_get_class_type_792, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeReferenceCount_get_class_type_792_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NodeReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NodeReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NodeReferenceCount\n"
          "// Description : This class specializes ReferenceCount to add an\n"
          "//               additional counter, called node_ref_count, for the\n"
          "//               purposes of counting the number of times the object\n"
          "//               is referenced by a \"node\", whatever that may mean in\n"
          "//               context.\n"
          "//\n"
          "//               The new methods node_ref() and node_unref()\n"
          "//               automatically increment and decrement the primary\n"
          "//               reference count as well.  There also exists a\n"
          "//               NodePointerTo<> class to maintain the node_ref\n"
          "//               counters automatically.\n"
          "//\n"
          "//               See also CachedTypedWritableReferenceCount, which is\n"
          "//               similar in principle, as well as\n"
          "//               NodeCachedReferenceCount, which combines both of\n"
          "//               these.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_NodeReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_NodeReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NodeReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NodeReferenceCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NodeReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NodeReferenceCount)");
             printf(" Error In PyType_ReadyNodeReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_NodeReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NodeReferenceCount.As_PyTypeObject().tp_dict,"NodeReferenceCount",&Dtool_NodeReferenceCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NodeReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NodeReferenceCount[4],&Dtool_NodeReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NodeReferenceCount,NodeReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NodeReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "NodeReferenceCount",(PyObject *)&Dtool_NodeReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Datagram | Datagram
//********************************************************************
PyMethodDef Dtool_Methods_Datagram[]= {
  { "assign",(PyCFunction ) &Dtool_Datagram_operator_795, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_operator_795_comment},
  { "clear",(PyCFunction ) &Dtool_Datagram_clear_796, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_clear_796_comment},
  { "dumpHex",(PyCFunction ) &Dtool_Datagram_dump_hex_797, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_dump_hex_797_comment},
  { "addBool",(PyCFunction ) &Dtool_Datagram_add_bool_798, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_bool_798_comment},
  { "addInt8",(PyCFunction ) &Dtool_Datagram_add_int8_799, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_int8_799_comment},
  { "addUint8",(PyCFunction ) &Dtool_Datagram_add_uint8_800, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_uint8_800_comment},
  { "addInt16",(PyCFunction ) &Dtool_Datagram_add_int16_801, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_int16_801_comment},
  { "addInt32",(PyCFunction ) &Dtool_Datagram_add_int32_802, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_int32_802_comment},
  { "addInt64",(PyCFunction ) &Dtool_Datagram_add_int64_803, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_int64_803_comment},
  { "addUint16",(PyCFunction ) &Dtool_Datagram_add_uint16_804, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_uint16_804_comment},
  { "addUint32",(PyCFunction ) &Dtool_Datagram_add_uint32_805, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_uint32_805_comment},
  { "addUint64",(PyCFunction ) &Dtool_Datagram_add_uint64_806, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_uint64_806_comment},
  { "addFloat32",(PyCFunction ) &Dtool_Datagram_add_float32_807, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_float32_807_comment},
  { "addFloat64",(PyCFunction ) &Dtool_Datagram_add_float64_808, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_float64_808_comment},
  { "addBeInt16",(PyCFunction ) &Dtool_Datagram_add_be_int16_809, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_int16_809_comment},
  { "addBeInt32",(PyCFunction ) &Dtool_Datagram_add_be_int32_810, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_int32_810_comment},
  { "addBeInt64",(PyCFunction ) &Dtool_Datagram_add_be_int64_811, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_int64_811_comment},
  { "addBeUint16",(PyCFunction ) &Dtool_Datagram_add_be_uint16_812, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_uint16_812_comment},
  { "addBeUint32",(PyCFunction ) &Dtool_Datagram_add_be_uint32_813, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_uint32_813_comment},
  { "addBeUint64",(PyCFunction ) &Dtool_Datagram_add_be_uint64_814, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_uint64_814_comment},
  { "addBeFloat32",(PyCFunction ) &Dtool_Datagram_add_be_float32_815, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_float32_815_comment},
  { "addBeFloat64",(PyCFunction ) &Dtool_Datagram_add_be_float64_816, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_be_float64_816_comment},
  { "addString",(PyCFunction ) &Dtool_Datagram_add_string_817, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_string_817_comment},
  { "addString32",(PyCFunction ) &Dtool_Datagram_add_string32_818, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_string32_818_comment},
  { "addZString",(PyCFunction ) &Dtool_Datagram_add_z_string_819, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_z_string_819_comment},
  { "addFixedString",(PyCFunction ) &Dtool_Datagram_add_fixed_string_820, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_fixed_string_820_comment},
  { "addWstring",(PyCFunction ) &Dtool_Datagram_add_wstring_821, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_add_wstring_821_comment},
  { "padBytes",(PyCFunction ) &Dtool_Datagram_pad_bytes_822, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_pad_bytes_822_comment},
  { "appendData",(PyCFunction ) &Dtool_Datagram_append_data_823, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_append_data_823_comment},
  { "getMessage",(PyCFunction ) &Dtool_Datagram_get_message_825, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_get_message_825_comment},
  { "getLength",(PyCFunction ) &Dtool_Datagram_get_length_827, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_get_length_827_comment},
  { "setArray",(PyCFunction ) &Dtool_Datagram_set_array_828, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_set_array_828_comment},
  { "copyArray",(PyCFunction ) &Dtool_Datagram_copy_array_829, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_copy_array_829_comment},
  { "getArray",(PyCFunction ) &Dtool_Datagram_get_array_830, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_get_array_830_comment},
  { "modifyArray",(PyCFunction ) &Dtool_Datagram_modify_array_831, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_modify_array_831_comment},
  { "eq",(PyCFunction ) &Dtool_Datagram_operator_832, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_operator_832_comment},
  { "ne",(PyCFunction ) &Dtool_Datagram_operator_833, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_operator_833_comment},
  { "lessThan",(PyCFunction ) &Dtool_Datagram_operator_834, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_operator_834_comment},
  { "output",(PyCFunction ) &Dtool_Datagram_output_835, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_output_835_comment},
  { "write",(PyCFunction ) &Dtool_Datagram_write_836, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_write_836_comment},
  { "getClassType",(PyCFunction ) &Dtool_Datagram_get_class_type_837, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Datagram_get_class_type_837_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Datagram
//////////////////
static PyObject *  Dtool_Repr_Datagram(PyObject * self)
{
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Datagram
//////////////////
static PyObject *  Dtool_Str_Datagram(PyObject * self)
{
    Datagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Datagram,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Datagram(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Datagram.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Datagram\n"
          "// Description : An ordered list of data elements, formatted in memory\n"
          "//               for transmission over a socket or writing to a data\n"
          "//               file.\n"
          "//\n"
          "//               Data elements should be added one at a time, in\n"
          "//               order, to the Datagram.  The nature and contents of\n"
          "//               the data elements are totally up to the user.  When a\n"
          "//               Datagram has been transmitted and received, its data\n"
          "//               elements may be extracted using a DatagramIterator;\n"
          "//               it is up to the caller to know the correct type of\n"
          "//               each data element in order.\n"
          "//\n"
          "//               A Datagram is itself headerless; it is simply a\n"
          "//               collection of data elements.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_Datagram.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_Datagram.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Datagram.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Datagram.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Datagram.As_PyTypeObject().tp_repr = & Dtool_Repr_Datagram;
        // __str__
        Dtool_Datagram.As_PyTypeObject().tp_str = & Dtool_Str_Datagram;
        if(PyType_Ready(&Dtool_Datagram.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Datagram)");
             printf(" Error In PyType_ReadyDatagram");
             return;
        }
        Py_INCREF(&Dtool_Datagram.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Datagram.As_PyTypeObject().tp_dict,"Datagram",&Dtool_Datagram.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Datagram.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Datagram[40],&Dtool_Datagram.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Datagram,Datagram::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Datagram.As_PyTypeObject());
        PyModule_AddObject(module, "Datagram",(PyObject *)&Dtool_Datagram.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DatagramGenerator | DatagramGenerator
//********************************************************************
PyMethodDef Dtool_Methods_DatagramGenerator[]= {
  { "getDatagram",(PyCFunction ) &Dtool_DatagramGenerator_get_datagram_840, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGenerator_get_datagram_840_comment},
  { "isEof",(PyCFunction ) &Dtool_DatagramGenerator_is_eof_841, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGenerator_is_eof_841_comment},
  { "isError",(PyCFunction ) &Dtool_DatagramGenerator_is_error_842, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGenerator_is_error_842_comment},
  { "getFile",(PyCFunction ) &Dtool_DatagramGenerator_get_file_843, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGenerator_get_file_843_comment},
  { "getFilePos",(PyCFunction ) &Dtool_DatagramGenerator_get_file_pos_844, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGenerator_get_file_pos_844_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DatagramGenerator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DatagramGenerator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DatagramGenerator\n"
          "// Description : This class defines the abstract interace to any\n"
          "//               source of datagrams, whether it be from a file or\n"
          "//               from the net\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DatagramGenerator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DatagramGenerator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DatagramGenerator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DatagramGenerator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DatagramGenerator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DatagramGenerator)");
             printf(" Error In PyType_ReadyDatagramGenerator");
             return;
        }
        Py_INCREF(&Dtool_DatagramGenerator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DatagramGenerator.As_PyTypeObject().tp_dict,"DatagramGenerator",&Dtool_DatagramGenerator.As_PyObject());
        RegisterRuntimeClass(&Dtool_DatagramGenerator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DatagramGenerator.As_PyTypeObject());
        PyModule_AddObject(module, "DatagramGenerator",(PyObject *)&Dtool_DatagramGenerator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DatagramIterator | DatagramIterator
//********************************************************************
PyMethodDef Dtool_Methods_DatagramIterator[]= {
  { "assign",(PyCFunction ) &Dtool_DatagramIterator_operator_847, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_operator_847_comment},
  { "getBool",(PyCFunction ) &Dtool_DatagramIterator_get_bool_849, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_bool_849_comment},
  { "getInt8",(PyCFunction ) &Dtool_DatagramIterator_get_int8_850, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_int8_850_comment},
  { "getUint8",(PyCFunction ) &Dtool_DatagramIterator_get_uint8_851, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_uint8_851_comment},
  { "getInt16",(PyCFunction ) &Dtool_DatagramIterator_get_int16_852, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_int16_852_comment},
  { "getInt32",(PyCFunction ) &Dtool_DatagramIterator_get_int32_853, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_int32_853_comment},
  { "getInt64",(PyCFunction ) &Dtool_DatagramIterator_get_int64_854, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_int64_854_comment},
  { "getUint16",(PyCFunction ) &Dtool_DatagramIterator_get_uint16_855, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_uint16_855_comment},
  { "getUint32",(PyCFunction ) &Dtool_DatagramIterator_get_uint32_856, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_uint32_856_comment},
  { "getUint64",(PyCFunction ) &Dtool_DatagramIterator_get_uint64_857, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_uint64_857_comment},
  { "getFloat32",(PyCFunction ) &Dtool_DatagramIterator_get_float32_858, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_float32_858_comment},
  { "getFloat64",(PyCFunction ) &Dtool_DatagramIterator_get_float64_859, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_float64_859_comment},
  { "getBeInt16",(PyCFunction ) &Dtool_DatagramIterator_get_be_int16_860, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_int16_860_comment},
  { "getBeInt32",(PyCFunction ) &Dtool_DatagramIterator_get_be_int32_861, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_int32_861_comment},
  { "getBeInt64",(PyCFunction ) &Dtool_DatagramIterator_get_be_int64_862, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_int64_862_comment},
  { "getBeUint16",(PyCFunction ) &Dtool_DatagramIterator_get_be_uint16_863, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_uint16_863_comment},
  { "getBeUint32",(PyCFunction ) &Dtool_DatagramIterator_get_be_uint32_864, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_uint32_864_comment},
  { "getBeUint64",(PyCFunction ) &Dtool_DatagramIterator_get_be_uint64_865, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_uint64_865_comment},
  { "getBeFloat32",(PyCFunction ) &Dtool_DatagramIterator_get_be_float32_866, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_float32_866_comment},
  { "getBeFloat64",(PyCFunction ) &Dtool_DatagramIterator_get_be_float64_867, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_be_float64_867_comment},
  { "getString",(PyCFunction ) &Dtool_DatagramIterator_get_string_868, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_string_868_comment},
  { "getString32",(PyCFunction ) &Dtool_DatagramIterator_get_string32_869, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_string32_869_comment},
  { "getZString",(PyCFunction ) &Dtool_DatagramIterator_get_z_string_870, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_z_string_870_comment},
  { "getFixedString",(PyCFunction ) &Dtool_DatagramIterator_get_fixed_string_871, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_fixed_string_871_comment},
  { "getWstring",(PyCFunction ) &Dtool_DatagramIterator_get_wstring_872, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_wstring_872_comment},
  { "skipBytes",(PyCFunction ) &Dtool_DatagramIterator_skip_bytes_873, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_skip_bytes_873_comment},
  { "extractBytes",(PyCFunction ) &Dtool_DatagramIterator_extract_bytes_874, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_extract_bytes_874_comment},
  { "getRemainingBytes",(PyCFunction ) &Dtool_DatagramIterator_get_remaining_bytes_875, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_remaining_bytes_875_comment},
  { "getRemainingSize",(PyCFunction ) &Dtool_DatagramIterator_get_remaining_size_876, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_remaining_size_876_comment},
  { "getDatagram",(PyCFunction ) &Dtool_DatagramIterator_get_datagram_877, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_datagram_877_comment},
  { "getCurrentIndex",(PyCFunction ) &Dtool_DatagramIterator_get_current_index_878, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_get_current_index_878_comment},
  { "output",(PyCFunction ) &Dtool_DatagramIterator_output_879, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_output_879_comment},
  { "write",(PyCFunction ) &Dtool_DatagramIterator_write_880, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramIterator_write_880_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DatagramIterator
//////////////////
static PyObject *  Dtool_Repr_DatagramIterator(PyObject * self)
{
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DatagramIterator
//////////////////
static PyObject *  Dtool_Str_DatagramIterator(PyObject * self)
{
    DatagramIterator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramIterator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DatagramIterator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DatagramIterator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DatagramIterator\n"
          "// Description : A class to retrieve the individual data elements\n"
          "//               previously stored in a Datagram.  Elements may be\n"
          "//               retrieved one at a time; it is up to the caller to\n"
          "//               know the correct type and order of each element.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DatagramIterator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DatagramIterator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DatagramIterator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DatagramIterator.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DatagramIterator.As_PyTypeObject().tp_repr = & Dtool_Repr_DatagramIterator;
        // __str__
        Dtool_DatagramIterator.As_PyTypeObject().tp_str = & Dtool_Str_DatagramIterator;
        if(PyType_Ready(&Dtool_DatagramIterator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DatagramIterator)");
             printf(" Error In PyType_ReadyDatagramIterator");
             return;
        }
        Py_INCREF(&Dtool_DatagramIterator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DatagramIterator.As_PyTypeObject().tp_dict,"DatagramIterator",&Dtool_DatagramIterator.As_PyObject());
        RegisterRuntimeClass(&Dtool_DatagramIterator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DatagramIterator.As_PyTypeObject());
        PyModule_AddObject(module, "DatagramIterator",(PyObject *)&Dtool_DatagramIterator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DatagramSink | DatagramSink
//********************************************************************
PyMethodDef Dtool_Methods_DatagramSink[]= {
  { "putDatagram",(PyCFunction ) &Dtool_DatagramSink_put_datagram_883, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSink_put_datagram_883_comment},
  { "isError",(PyCFunction ) &Dtool_DatagramSink_is_error_884, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSink_is_error_884_comment},
  { "flush",(PyCFunction ) &Dtool_DatagramSink_flush_885, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSink_flush_885_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DatagramSink(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DatagramSink.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DatagramSink\n"
          "// Description : This class defines the abstract interface to sending\n"
          "//               datagrams to any target, whether it be into a file\n"
          "//               or across the net\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DatagramSink.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DatagramSink.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DatagramSink.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DatagramSink.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DatagramSink.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DatagramSink)");
             printf(" Error In PyType_ReadyDatagramSink");
             return;
        }
        Py_INCREF(&Dtool_DatagramSink.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DatagramSink.As_PyTypeObject().tp_dict,"DatagramSink",&Dtool_DatagramSink.As_PyObject());
        RegisterRuntimeClass(&Dtool_DatagramSink,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DatagramSink.As_PyTypeObject());
        PyModule_AddObject(module, "DatagramSink",(PyObject *)&Dtool_DatagramSink.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TextEncoder | TextEncoder
//********************************************************************
PyMethodDef Dtool_Methods_TextEncoder[]= {
  { "setEncoding",(PyCFunction ) &Dtool_TextEncoder_set_encoding_900, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_set_encoding_900_comment},
  { "getEncoding",(PyCFunction ) &Dtool_TextEncoder_get_encoding_901, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_encoding_901_comment},
  { "setDefaultEncoding",(PyCFunction ) &Dtool_TextEncoder_set_default_encoding_902, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_set_default_encoding_902_comment},
  { "getDefaultEncoding",(PyCFunction ) &Dtool_TextEncoder_get_default_encoding_903, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_default_encoding_903_comment},
  { "setText",(PyCFunction ) &Dtool_TextEncoder_set_text_904, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_set_text_904_comment},
  { "clearText",(PyCFunction ) &Dtool_TextEncoder_clear_text_905, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_clear_text_905_comment},
  { "hasText",(PyCFunction ) &Dtool_TextEncoder_has_text_906, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_has_text_906_comment},
  { "makeUpper",(PyCFunction ) &Dtool_TextEncoder_make_upper_907, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_make_upper_907_comment},
  { "makeLower",(PyCFunction ) &Dtool_TextEncoder_make_lower_908, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_make_lower_908_comment},
  { "getText",(PyCFunction ) &Dtool_TextEncoder_get_text_909, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_text_909_comment},
  { "appendText",(PyCFunction ) &Dtool_TextEncoder_append_text_910, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_append_text_910_comment},
  { "appendUnicodeChar",(PyCFunction ) &Dtool_TextEncoder_append_unicode_char_911, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_append_unicode_char_911_comment},
  { "getNumChars",(PyCFunction ) &Dtool_TextEncoder_get_num_chars_912, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_num_chars_912_comment},
  { "getUnicodeChar",(PyCFunction ) &Dtool_TextEncoder_get_unicode_char_913, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_unicode_char_913_comment},
  { "setUnicodeChar",(PyCFunction ) &Dtool_TextEncoder_set_unicode_char_914, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_set_unicode_char_914_comment},
  { "getEncodedChar",(PyCFunction ) &Dtool_TextEncoder_get_encoded_char_915, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_encoded_char_915_comment},
  { "getTextAsAscii",(PyCFunction ) &Dtool_TextEncoder_get_text_as_ascii_916, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_text_as_ascii_916_comment},
  { "reencodeText",(PyCFunction ) &Dtool_TextEncoder_reencode_text_917, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_reencode_text_917_comment},
  { "unicodeIsalpha",(PyCFunction ) &Dtool_TextEncoder_unicode_isalpha_918, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_isalpha_918_comment},
  { "unicodeIsdigit",(PyCFunction ) &Dtool_TextEncoder_unicode_isdigit_919, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_isdigit_919_comment},
  { "unicodeIspunct",(PyCFunction ) &Dtool_TextEncoder_unicode_ispunct_920, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_ispunct_920_comment},
  { "unicodeIslower",(PyCFunction ) &Dtool_TextEncoder_unicode_islower_921, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_islower_921_comment},
  { "unicodeIsupper",(PyCFunction ) &Dtool_TextEncoder_unicode_isupper_922, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_isupper_922_comment},
  { "unicodeIsspace",(PyCFunction ) &Dtool_TextEncoder_unicode_isspace_923, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_isspace_923_comment},
  { "unicodeToupper",(PyCFunction ) &Dtool_TextEncoder_unicode_toupper_924, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_toupper_924_comment},
  { "unicodeTolower",(PyCFunction ) &Dtool_TextEncoder_unicode_tolower_925, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_unicode_tolower_925_comment},
  { "upper",(PyCFunction ) &Dtool_TextEncoder_upper_926, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_upper_926_comment},
  { "lower",(PyCFunction ) &Dtool_TextEncoder_lower_927, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_lower_927_comment},
  { "setWtext",(PyCFunction ) &Dtool_TextEncoder_set_wtext_928, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_set_wtext_928_comment},
  { "getWtext",(PyCFunction ) &Dtool_TextEncoder_get_wtext_929, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_wtext_929_comment},
  { "appendWtext",(PyCFunction ) &Dtool_TextEncoder_append_wtext_930, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_append_wtext_930_comment},
  { "getWtextAsAscii",(PyCFunction ) &Dtool_TextEncoder_get_wtext_as_ascii_931, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_wtext_as_ascii_931_comment},
  { "isWtext",(PyCFunction ) &Dtool_TextEncoder_is_wtext_932, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_is_wtext_932_comment},
  { "encodeWchar",(PyCFunction ) &Dtool_TextEncoder_encode_wchar_933, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_encode_wchar_933_comment},
  { "encodeWtext",(PyCFunction ) &Dtool_TextEncoder_encode_wtext_934, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_encode_wtext_934_comment},
  { "decodeText",(PyCFunction ) &Dtool_TextEncoder_decode_text_935, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_decode_text_935_comment},
  { "getClassType",(PyCFunction ) &Dtool_TextEncoder_get_class_type_936, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TextEncoder_get_class_type_936_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TextEncoder(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TextEncoder.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TextEncoder\n"
          "// Description : This class can be used to convert text between\n"
          "//               multiple representations, e.g. utf-8 to Unicode.  You\n"
          "//               may use it as a static class object, passing the\n"
          "//               encoding each time, or you may create an instance and\n"
          "//               use that object, which will record the current\n"
          "//               encoding and retain the current string.\n"
          "//\n"
          "//               This class is also a base class of TextNode, which\n"
          "//               inherits this functionality.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TextEncoder.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TextEncoder.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TextEncoder.As_PyTypeObject().tp_dict);
        // Enum  TextEncoder::Encoding;
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"EIso8859",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"EUtf8",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"EUnicode",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_TextEncoder.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TextEncoder)");
             printf(" Error In PyType_ReadyTextEncoder");
             return;
        }
        Py_INCREF(&Dtool_TextEncoder.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"TextEncoder",&Dtool_TextEncoder.As_PyObject());
        //  Static Method setDefaultEncoding
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"setDefaultEncoding",PyCFunction_New(&Dtool_Methods_TextEncoder[2],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method getDefaultEncoding
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"getDefaultEncoding",PyCFunction_New(&Dtool_Methods_TextEncoder[3],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method reencodeText
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"reencodeText",PyCFunction_New(&Dtool_Methods_TextEncoder[17],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIsalpha
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIsalpha",PyCFunction_New(&Dtool_Methods_TextEncoder[18],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIsdigit
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIsdigit",PyCFunction_New(&Dtool_Methods_TextEncoder[19],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIspunct
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIspunct",PyCFunction_New(&Dtool_Methods_TextEncoder[20],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIslower
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIslower",PyCFunction_New(&Dtool_Methods_TextEncoder[21],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIsupper
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIsupper",PyCFunction_New(&Dtool_Methods_TextEncoder[22],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeIsspace
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeIsspace",PyCFunction_New(&Dtool_Methods_TextEncoder[23],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeToupper
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeToupper",PyCFunction_New(&Dtool_Methods_TextEncoder[24],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method unicodeTolower
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"unicodeTolower",PyCFunction_New(&Dtool_Methods_TextEncoder[25],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method upper
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"upper",PyCFunction_New(&Dtool_Methods_TextEncoder[26],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method lower
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"lower",PyCFunction_New(&Dtool_Methods_TextEncoder[27],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method encodeWchar
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"encodeWchar",PyCFunction_New(&Dtool_Methods_TextEncoder[33],&Dtool_TextEncoder.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TextEncoder.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TextEncoder[36],&Dtool_TextEncoder.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TextEncoder,TextEncoder::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TextEncoder.As_PyTypeObject());
        PyModule_AddObject(module, "TextEncoder",(PyObject *)&Dtool_TextEncoder.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypedReferenceCount | TypedReferenceCount
//********************************************************************
PyMethodDef Dtool_Methods_TypedReferenceCount[]= {
  { "getClassType",(PyCFunction ) &Dtool_TypedReferenceCount_get_class_type_943, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedReferenceCount_get_class_type_943_comment},
  { "upcastToTypedObject",(PyCFunction ) &Dtool_TypedReferenceCount_upcast_to_TypedObject_939, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedReferenceCount_upcast_to_TypedObject_939_comment},
  { "upcastToReferenceCount",(PyCFunction ) &Dtool_TypedReferenceCount_upcast_to_ReferenceCount_941, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedReferenceCount_upcast_to_ReferenceCount_941_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TypedReferenceCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypedReferenceCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypedReferenceCount\n"
          "// Description : A base class for things which need to inherit from\n"
          "//               both TypedObject and from ReferenceCount.  It's\n"
          "//               convenient to define this intermediate base class\n"
          "//               instead of multiply inheriting from the two classes\n"
          "//               each time they are needed, so that we can sensibly\n"
          "//               pass around pointers to things which are both\n"
          "//               TypedObjects and ReferenceCounters.\n"
          "//               \n"
          "//               See also TypedObject for detailed instructions.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_TypedReferenceCount.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedObject.As_PyTypeObject(),&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_TypedReferenceCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypedReferenceCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypedReferenceCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TypedReferenceCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypedReferenceCount)");
             printf(" Error In PyType_ReadyTypedReferenceCount");
             return;
        }
        Py_INCREF(&Dtool_TypedReferenceCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypedReferenceCount.As_PyTypeObject().tp_dict,"TypedReferenceCount",&Dtool_TypedReferenceCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TypedReferenceCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TypedReferenceCount[0],&Dtool_TypedReferenceCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypedReferenceCount,TypedReferenceCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypedReferenceCount.As_PyTypeObject());
        PyModule_AddObject(module, "TypedReferenceCount",(PyObject *)&Dtool_TypedReferenceCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFile | VirtualFile
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFile[]= {
  { "getFileSystem",(PyCFunction ) &Dtool_VirtualFile_get_file_system_946, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_file_system_946_comment},
  { "getFilename",(PyCFunction ) &Dtool_VirtualFile_get_filename_947, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_filename_947_comment},
  { "getOriginalFilename",(PyCFunction ) &Dtool_VirtualFile_get_original_filename_948, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_original_filename_948_comment},
  { "hasFile",(PyCFunction ) &Dtool_VirtualFile_has_file_949, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_has_file_949_comment},
  { "isDirectory",(PyCFunction ) &Dtool_VirtualFile_is_directory_950, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_is_directory_950_comment},
  { "isRegularFile",(PyCFunction ) &Dtool_VirtualFile_is_regular_file_951, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_is_regular_file_951_comment},
  { "scanDirectory",(PyCFunction ) &Dtool_VirtualFile_scan_directory_952, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_scan_directory_952_comment},
  { "output",(PyCFunction ) &Dtool_VirtualFile_output_953, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_output_953_comment},
  { "ls",(PyCFunction ) &Dtool_VirtualFile_ls_954, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_ls_954_comment},
  { "lsAll",(PyCFunction ) &Dtool_VirtualFile_ls_all_955, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_ls_all_955_comment},
  { "readFile",(PyCFunction ) &Dtool_VirtualFile_read_file_956, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_read_file_956_comment},
  { "openReadFile",(PyCFunction ) &Dtool_VirtualFile_open_read_file_957, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_open_read_file_957_comment},
  { "closeReadFile",(PyCFunction ) &Dtool_VirtualFile_close_read_file_958, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_close_read_file_958_comment},
  { "wasReadSuccessful",(PyCFunction ) &Dtool_VirtualFile_was_read_successful_959, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_was_read_successful_959_comment},
  { "getFileSize",(PyCFunction ) &Dtool_VirtualFile_get_file_size_960, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_file_size_960_comment},
  { "getTimestamp",(PyCFunction ) &Dtool_VirtualFile_get_timestamp_961, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_timestamp_961_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFile_get_class_type_962, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFile_get_class_type_962_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     VirtualFile
//////////////////
static PyObject *  Dtool_Repr_VirtualFile(PyObject * self)
{
    VirtualFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFile,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_VirtualFile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFile\n"
          "// Description : The abstract base class for a file or directory\n"
          "//               within the VirtualFileSystem.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_VirtualFile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_VirtualFile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFile.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_VirtualFile.As_PyTypeObject().tp_repr = & Dtool_Repr_VirtualFile;
        // __str__ Repr Proxy
        Dtool_VirtualFile.As_PyTypeObject().tp_str = & Dtool_Repr_VirtualFile;
        if(PyType_Ready(&Dtool_VirtualFile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFile)");
             printf(" Error In PyType_ReadyVirtualFile");
             return;
        }
        Py_INCREF(&Dtool_VirtualFile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFile.As_PyTypeObject().tp_dict,"VirtualFile",&Dtool_VirtualFile.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFile.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFile[16],&Dtool_VirtualFile.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFile,VirtualFile::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFile.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFile",(PyObject *)&Dtool_VirtualFile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileComposite | VirtualFileComposite
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileComposite[]= {
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileComposite_get_class_type_965, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileComposite_get_class_type_965_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileComposite(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileComposite.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileComposite\n"
          "// Description : A composite directory within the VirtualFileSystem:\n"
          "//               this maps to more than one directory on different\n"
          "//               mount points.  The resulting directory appears to be\n"
          "//               the union of all the individual simple directories.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFile._Dtool_ClassInit(NULL);
        Dtool_VirtualFileComposite.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFile.As_PyTypeObject());
        Dtool_VirtualFileComposite.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileComposite.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileComposite.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileComposite.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileComposite)");
             printf(" Error In PyType_ReadyVirtualFileComposite");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileComposite.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileComposite.As_PyTypeObject().tp_dict,"VirtualFileComposite",&Dtool_VirtualFileComposite.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileComposite.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileComposite[0],&Dtool_VirtualFileComposite.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileComposite,VirtualFileComposite::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileComposite.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileComposite",(PyObject *)&Dtool_VirtualFileComposite.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileMount | VirtualFileMount
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileMount[]= {
  { "getFileSystem",(PyCFunction ) &Dtool_VirtualFileMount_get_file_system_968, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_get_file_system_968_comment},
  { "getMountPoint",(PyCFunction ) &Dtool_VirtualFileMount_get_mount_point_969, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_get_mount_point_969_comment},
  { "getMountFlags",(PyCFunction ) &Dtool_VirtualFileMount_get_mount_flags_970, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_get_mount_flags_970_comment},
  { "output",(PyCFunction ) &Dtool_VirtualFileMount_output_971, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_output_971_comment},
  { "write",(PyCFunction ) &Dtool_VirtualFileMount_write_972, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_write_972_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileMount_get_class_type_973, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMount_get_class_type_973_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     VirtualFileMount
//////////////////
static PyObject *  Dtool_Repr_VirtualFileMount(PyObject * self)
{
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     VirtualFileMount
//////////////////
static PyObject *  Dtool_Str_VirtualFileMount(PyObject * self)
{
    VirtualFileMount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileMount,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_VirtualFileMount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileMount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileMount\n"
          "// Description : The abstract base class for a mount definition used\n"
          "//               within a VirtualFileSystem.  Normally users don't\n"
          "//               need to monkey with this class directly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_VirtualFileMount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_VirtualFileMount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileMount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileMount.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_VirtualFileMount.As_PyTypeObject().tp_repr = & Dtool_Repr_VirtualFileMount;
        // __str__
        Dtool_VirtualFileMount.As_PyTypeObject().tp_str = & Dtool_Str_VirtualFileMount;
        if(PyType_Ready(&Dtool_VirtualFileMount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileMount)");
             printf(" Error In PyType_ReadyVirtualFileMount");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileMount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileMount.As_PyTypeObject().tp_dict,"VirtualFileMount",&Dtool_VirtualFileMount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileMount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileMount[5],&Dtool_VirtualFileMount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileMount,VirtualFileMount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileMount.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileMount",(PyObject *)&Dtool_VirtualFileMount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ISubStream | ISubStream
//********************************************************************
PyMethodDef Dtool_Methods_ISubStream[]= {
  { "open",(PyCFunction ) &Dtool_ISubStream_open_976, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISubStream_open_976_comment},
  { "close",(PyCFunction ) &Dtool_ISubStream_close_977, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ISubStream_close_977_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ISubStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ISubStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ISubStream\n"
          "// Description : An istream object that presents a subwindow into\n"
          "//               another istream.  The first character read from this\n"
          "//               stream will be the \"start\" character from the source\n"
          "//               istream; just before the file pointer reaches the\n"
          "//               \"end\" character, eof is returned.\n"
          "//\n"
          "//               The source stream must be one that we can randomly\n"
          "//               seek within.  The resulting ISubStream will also\n"
          "//               support arbitrary seeks.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_ISubStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_istream.As_PyTypeObject());
        Dtool_ISubStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ISubStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ISubStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ISubStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ISubStream)");
             printf(" Error In PyType_ReadyISubStream");
             return;
        }
        Py_INCREF(&Dtool_ISubStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ISubStream.As_PyTypeObject().tp_dict,"ISubStream",&Dtool_ISubStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_ISubStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ISubStream.As_PyTypeObject());
        PyModule_AddObject(module, "ISubStream",(PyObject *)&Dtool_ISubStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Multifile_CertRecord | CertRecord
//********************************************************************
PyMethodDef Dtool_Methods_Multifile_CertRecord[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Multifile_CertRecord(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Multifile_CertRecord.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Multifile_CertRecord.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Multifile_CertRecord.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Multifile_CertRecord.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Multifile_CertRecord.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Multifile_CertRecord)");
             printf(" Error In PyType_ReadyMultifile_CertRecord");
             return;
        }
        Py_INCREF(&Dtool_Multifile_CertRecord.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Multifile_CertRecord.As_PyTypeObject().tp_dict,"CertRecord",&Dtool_Multifile_CertRecord.As_PyObject());
        RegisterRuntimeClass(&Dtool_Multifile_CertRecord,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Multifile_CertRecord.As_PyTypeObject());
        PyModule_AddObject(module, "CertRecord",(PyObject *)&Dtool_Multifile_CertRecord.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Multifile | Multifile
//********************************************************************
PyMethodDef Dtool_Methods_Multifile[]= {
  { "openRead",(PyCFunction ) &Dtool_Multifile_open_read_981, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_open_read_981_comment},
  { "openWrite",(PyCFunction ) &Dtool_Multifile_open_write_982, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_open_write_982_comment},
  { "openReadWrite",(PyCFunction ) &Dtool_Multifile_open_read_write_983, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_open_read_write_983_comment},
  { "close",(PyCFunction ) &Dtool_Multifile_close_984, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_close_984_comment},
  { "getMultifileName",(PyCFunction ) &Dtool_Multifile_get_multifile_name_985, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_multifile_name_985_comment},
  { "setMultifileName",(PyCFunction ) &Dtool_Multifile_set_multifile_name_986, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_multifile_name_986_comment},
  { "isReadValid",(PyCFunction ) &Dtool_Multifile_is_read_valid_987, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_is_read_valid_987_comment},
  { "isWriteValid",(PyCFunction ) &Dtool_Multifile_is_write_valid_988, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_is_write_valid_988_comment},
  { "needsRepack",(PyCFunction ) &Dtool_Multifile_needs_repack_989, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_needs_repack_989_comment},
  { "getTimestamp",(PyCFunction ) &Dtool_Multifile_get_timestamp_990, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_timestamp_990_comment},
  { "setRecordTimestamp",(PyCFunction ) &Dtool_Multifile_set_record_timestamp_991, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_record_timestamp_991_comment},
  { "getRecordTimestamp",(PyCFunction ) &Dtool_Multifile_get_record_timestamp_992, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_record_timestamp_992_comment},
  { "setScaleFactor",(PyCFunction ) &Dtool_Multifile_set_scale_factor_993, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_scale_factor_993_comment},
  { "getScaleFactor",(PyCFunction ) &Dtool_Multifile_get_scale_factor_994, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_scale_factor_994_comment},
  { "setEncryptionFlag",(PyCFunction ) &Dtool_Multifile_set_encryption_flag_995, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_encryption_flag_995_comment},
  { "getEncryptionFlag",(PyCFunction ) &Dtool_Multifile_get_encryption_flag_996, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_encryption_flag_996_comment},
  { "setEncryptionPassword",(PyCFunction ) &Dtool_Multifile_set_encryption_password_997, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_encryption_password_997_comment},
  { "getEncryptionPassword",(PyCFunction ) &Dtool_Multifile_get_encryption_password_998, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_encryption_password_998_comment},
  { "setEncryptionAlgorithm",(PyCFunction ) &Dtool_Multifile_set_encryption_algorithm_999, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_encryption_algorithm_999_comment},
  { "getEncryptionAlgorithm",(PyCFunction ) &Dtool_Multifile_get_encryption_algorithm_1000, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_encryption_algorithm_1000_comment},
  { "setEncryptionKeyLength",(PyCFunction ) &Dtool_Multifile_set_encryption_key_length_1001, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_encryption_key_length_1001_comment},
  { "getEncryptionKeyLength",(PyCFunction ) &Dtool_Multifile_get_encryption_key_length_1002, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_encryption_key_length_1002_comment},
  { "setEncryptionIterationCount",(PyCFunction ) &Dtool_Multifile_set_encryption_iteration_count_1003, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_encryption_iteration_count_1003_comment},
  { "getEncryptionIterationCount",(PyCFunction ) &Dtool_Multifile_get_encryption_iteration_count_1004, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_encryption_iteration_count_1004_comment},
  { "addSubfile",(PyCFunction ) &Dtool_Multifile_add_subfile_1005, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_add_subfile_1005_comment},
  { "updateSubfile",(PyCFunction ) &Dtool_Multifile_update_subfile_1006, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_update_subfile_1006_comment},
  { "addSignature",(PyCFunction ) &Dtool_Multifile_add_signature_1009, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_add_signature_1009_comment},
  { "getNumSignatures",(PyCFunction ) &Dtool_Multifile_get_num_signatures_1010, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_num_signatures_1010_comment},
  { "getSignatureSubjectName",(PyCFunction ) &Dtool_Multifile_get_signature_subject_name_1012, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_signature_subject_name_1012_comment},
  { "getSignatureFriendlyName",(PyCFunction ) &Dtool_Multifile_get_signature_friendly_name_1013, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_signature_friendly_name_1013_comment},
  { "getSignaturePublicKey",(PyCFunction ) &Dtool_Multifile_get_signature_public_key_1014, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_signature_public_key_1014_comment},
  { "writeSignatureCertificate",(PyCFunction ) &Dtool_Multifile_write_signature_certificate_1015, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_write_signature_certificate_1015_comment},
  { "validateSignatureCertificate",(PyCFunction ) &Dtool_Multifile_validate_signature_certificate_1016, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_validate_signature_certificate_1016_comment},
  { "flush",(PyCFunction ) &Dtool_Multifile_flush_1017, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_flush_1017_comment},
  { "repack",(PyCFunction ) &Dtool_Multifile_repack_1018, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_repack_1018_comment},
  { "getNumSubfiles",(PyCFunction ) &Dtool_Multifile_get_num_subfiles_1019, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_num_subfiles_1019_comment},
  { "findSubfile",(PyCFunction ) &Dtool_Multifile_find_subfile_1020, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_find_subfile_1020_comment},
  { "hasDirectory",(PyCFunction ) &Dtool_Multifile_has_directory_1021, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_has_directory_1021_comment},
  { "removeSubfile",(PyCFunction ) &Dtool_Multifile_remove_subfile_1023, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_remove_subfile_1023_comment},
  { "getSubfileName",(PyCFunction ) &Dtool_Multifile_get_subfile_name_1024, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_subfile_name_1024_comment},
  { "getSubfileLength",(PyCFunction ) &Dtool_Multifile_get_subfile_length_1025, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_subfile_length_1025_comment},
  { "getSubfileTimestamp",(PyCFunction ) &Dtool_Multifile_get_subfile_timestamp_1026, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_subfile_timestamp_1026_comment},
  { "isSubfileCompressed",(PyCFunction ) &Dtool_Multifile_is_subfile_compressed_1027, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_is_subfile_compressed_1027_comment},
  { "isSubfileEncrypted",(PyCFunction ) &Dtool_Multifile_is_subfile_encrypted_1028, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_is_subfile_encrypted_1028_comment},
  { "getIndexEnd",(PyCFunction ) &Dtool_Multifile_get_index_end_1029, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_index_end_1029_comment},
  { "getSubfileInternalStart",(PyCFunction ) &Dtool_Multifile_get_subfile_internal_start_1030, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_subfile_internal_start_1030_comment},
  { "getSubfileInternalLength",(PyCFunction ) &Dtool_Multifile_get_subfile_internal_length_1031, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_subfile_internal_length_1031_comment},
  { "readSubfile",(PyCFunction ) &Dtool_Multifile_read_subfile_1032, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_read_subfile_1032_comment},
  { "openReadSubfile",(PyCFunction ) &Dtool_Multifile_open_read_subfile_1033, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_open_read_subfile_1033_comment},
  { "closeReadSubfile",(PyCFunction ) &Dtool_Multifile_close_read_subfile_1034, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_close_read_subfile_1034_comment},
  { "extractSubfile",(PyCFunction ) &Dtool_Multifile_extract_subfile_1035, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_extract_subfile_1035_comment},
  { "extractSubfileTo",(PyCFunction ) &Dtool_Multifile_extract_subfile_to_1036, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_extract_subfile_to_1036_comment},
  { "compareSubfile",(PyCFunction ) &Dtool_Multifile_compare_subfile_1037, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_compare_subfile_1037_comment},
  { "output",(PyCFunction ) &Dtool_Multifile_output_1038, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_output_1038_comment},
  { "ls",(PyCFunction ) &Dtool_Multifile_ls_1039, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_ls_1039_comment},
  { "getMagicNumber",(PyCFunction ) &Dtool_Multifile_get_magic_number_1040, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_magic_number_1040_comment},
  { "setHeaderPrefix",(PyCFunction ) &Dtool_Multifile_set_header_prefix_1041, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_set_header_prefix_1041_comment},
  { "getHeaderPrefix",(PyCFunction ) &Dtool_Multifile_get_header_prefix_1042, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Multifile_get_header_prefix_1042_comment},
  { "getSubfileNames",(PyCFunction) &MakeSeq_Multifile_get_subfile_names, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Multifile
//////////////////
static PyObject *  Dtool_Repr_Multifile(PyObject * self)
{
    Multifile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Multifile,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Multifile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Multifile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Multifile\n"
          "// Description : A file that contains a set of files.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Multifile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_Multifile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Multifile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Multifile.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Multifile.As_PyTypeObject().tp_repr = & Dtool_Repr_Multifile;
        // __str__ Repr Proxy
        Dtool_Multifile.As_PyTypeObject().tp_str = & Dtool_Repr_Multifile;
        // Nested Object   Multifile_CertRecord;
        Dtool_Multifile_CertRecord._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_Multifile.As_PyTypeObject().tp_dict,"CertRecord",(PyObject *)&Dtool_Multifile_CertRecord.As_PyTypeObject());
        if(PyType_Ready(&Dtool_Multifile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Multifile)");
             printf(" Error In PyType_ReadyMultifile");
             return;
        }
        Py_INCREF(&Dtool_Multifile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Multifile.As_PyTypeObject().tp_dict,"Multifile",&Dtool_Multifile.As_PyObject());
        //  Static Method closeReadSubfile
        PyDict_SetItemString(Dtool_Multifile.As_PyTypeObject().tp_dict,"closeReadSubfile",PyCFunction_New(&Dtool_Methods_Multifile[49],&Dtool_Multifile.As_PyObject()));
        //  Static Method getMagicNumber
        PyDict_SetItemString(Dtool_Multifile.As_PyTypeObject().tp_dict,"getMagicNumber",PyCFunction_New(&Dtool_Methods_Multifile[55],&Dtool_Multifile.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Multifile,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Multifile.As_PyTypeObject());
        PyModule_AddObject(module, "Multifile",(PyObject *)&Dtool_Multifile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileMountMultifile | VirtualFileMountMultifile
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileMountMultifile[]= {
  { "getMultifile",(PyCFunction ) &Dtool_VirtualFileMountMultifile_get_multifile_1045, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountMultifile_get_multifile_1045_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileMountMultifile_get_class_type_1046, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountMultifile_get_class_type_1046_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileMountMultifile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileMountMultifile\n"
          "// Description : Maps a Multifile's contents into the\n"
          "//               VirtualFileSystem.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFileMount._Dtool_ClassInit(NULL);
        Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFileMount.As_PyTypeObject());
        Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileMountMultifile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileMountMultifile)");
             printf(" Error In PyType_ReadyVirtualFileMountMultifile");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileMountMultifile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_dict,"VirtualFileMountMultifile",&Dtool_VirtualFileMountMultifile.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileMountMultifile.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileMountMultifile[1],&Dtool_VirtualFileMountMultifile.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileMountMultifile,VirtualFileMountMultifile::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileMountMultifile.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileMountMultifile",(PyObject *)&Dtool_VirtualFileMountMultifile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileMountSystem | VirtualFileMountSystem
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileMountSystem[]= {
  { "getPhysicalFilename",(PyCFunction ) &Dtool_VirtualFileMountSystem_get_physical_filename_1049, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountSystem_get_physical_filename_1049_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileMountSystem_get_class_type_1050, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileMountSystem_get_class_type_1050_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileMountSystem(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileMountSystem\n"
          "// Description : Maps an actual OS directory into the\n"
          "//               VirtualFileSystem.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFileMount._Dtool_ClassInit(NULL);
        Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFileMount.As_PyTypeObject());
        Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileMountSystem.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileMountSystem)");
             printf(" Error In PyType_ReadyVirtualFileMountSystem");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileMountSystem.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_dict,"VirtualFileMountSystem",&Dtool_VirtualFileMountSystem.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileMountSystem.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileMountSystem[1],&Dtool_VirtualFileMountSystem.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileMountSystem,VirtualFileMountSystem::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileMountSystem.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileMountSystem",(PyObject *)&Dtool_VirtualFileMountSystem.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileSimple | VirtualFileSimple
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileSimple[]= {
  { "getMount",(PyCFunction ) &Dtool_VirtualFileSimple_get_mount_1053, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSimple_get_mount_1053_comment},
  { "isImplicitPzFile",(PyCFunction ) &Dtool_VirtualFileSimple_is_implicit_pz_file_1054, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSimple_is_implicit_pz_file_1054_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualFileSimple_get_class_type_1055, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSimple_get_class_type_1055_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualFileSimple(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileSimple.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileSimple\n"
          "// Description : A simple file or directory within the\n"
          "//               VirtualFileSystem: this maps to exactly one file on\n"
          "//               one mount point.  Most directories, and all regular\n"
          "//               files, are of this kind.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VirtualFile._Dtool_ClassInit(NULL);
        Dtool_VirtualFileSimple.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VirtualFile.As_PyTypeObject());
        Dtool_VirtualFileSimple.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileSimple.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileSimple.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualFileSimple.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileSimple)");
             printf(" Error In PyType_ReadyVirtualFileSimple");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileSimple.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileSimple.As_PyTypeObject().tp_dict,"VirtualFileSimple",&Dtool_VirtualFileSimple.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualFileSimple.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualFileSimple[2],&Dtool_VirtualFileSimple.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileSimple,VirtualFileSimple::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileSimple.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileSimple",(PyObject *)&Dtool_VirtualFileSimple.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Namable | Namable
//********************************************************************
PyMethodDef Dtool_Methods_Namable[]= {
  { "assign",(PyCFunction ) &Dtool_Namable_operator_1059, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_operator_1059_comment},
  { "setName",(PyCFunction ) &Dtool_Namable_set_name_1060, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_set_name_1060_comment},
  { "clearName",(PyCFunction ) &Dtool_Namable_clear_name_1061, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_clear_name_1061_comment},
  { "hasName",(PyCFunction ) &Dtool_Namable_has_name_1062, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_has_name_1062_comment},
  { "getName",(PyCFunction ) &Dtool_Namable_get_name_1063, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_get_name_1063_comment},
  { "output",(PyCFunction ) &Dtool_Namable_output_1064, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_output_1064_comment},
  { "getClassType",(PyCFunction ) &Dtool_Namable_get_class_type_1065, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Namable_get_class_type_1065_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Namable
//////////////////
static PyObject *  Dtool_Repr_Namable(PyObject * self)
{
    Namable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Namable,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Namable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Namable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Namable\n"
          "// Description : A base class for all things which can have a name.\n"
          "//               The name is either empty or nonempty, but it is never\n"
          "//               NULL.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Namable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Namable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Namable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Namable.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Namable.As_PyTypeObject().tp_repr = & Dtool_Repr_Namable;
        // __str__ Repr Proxy
        Dtool_Namable.As_PyTypeObject().tp_str = & Dtool_Repr_Namable;
        if(PyType_Ready(&Dtool_Namable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Namable)");
             printf(" Error In PyType_ReadyNamable");
             return;
        }
        Py_INCREF(&Dtool_Namable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Namable.As_PyTypeObject().tp_dict,"Namable",&Dtool_Namable.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Namable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Namable[6],&Dtool_Namable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Namable,Namable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Namable.As_PyTypeObject());
        PyModule_AddObject(module, "Namable",(PyObject *)&Dtool_Namable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. IDecompressStream | IDecompressStream
//********************************************************************
PyMethodDef Dtool_Methods_IDecompressStream[]= {
  { "open",(PyCFunction ) &Dtool_IDecompressStream_open_1069, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecompressStream_open_1069_comment},
  { "close",(PyCFunction ) &Dtool_IDecompressStream_close_1070, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_IDecompressStream_close_1070_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_IDecompressStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_IDecompressStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : IDecompressStream\n"
          "// Description : An input stream object that uses zlib to decompress\n"
          "//               (inflate) the input from another source stream\n"
          "//               on-the-fly.\n"
          "//\n"
          "//               Attach an IDecompressStream to an existing istream that\n"
          "//               provides compressed data, and read the corresponding\n"
          "//               uncompressed data from the IDecompressStream.\n"
          "//\n"
          "//               Seeking is not supported.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_istream._Dtool_ClassInit(NULL);
        Dtool_IDecompressStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_istream.As_PyTypeObject());
        Dtool_IDecompressStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_IDecompressStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_IDecompressStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_IDecompressStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(IDecompressStream)");
             printf(" Error In PyType_ReadyIDecompressStream");
             return;
        }
        Py_INCREF(&Dtool_IDecompressStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_IDecompressStream.As_PyTypeObject().tp_dict,"IDecompressStream",&Dtool_IDecompressStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_IDecompressStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_IDecompressStream.As_PyTypeObject());
        PyModule_AddObject(module, "IDecompressStream",(PyObject *)&Dtool_IDecompressStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OCompressStream | OCompressStream
//********************************************************************
PyMethodDef Dtool_Methods_OCompressStream[]= {
  { "open",(PyCFunction ) &Dtool_OCompressStream_open_1074, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OCompressStream_open_1074_comment},
  { "close",(PyCFunction ) &Dtool_OCompressStream_close_1075, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OCompressStream_close_1075_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OCompressStream(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OCompressStream.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OCompressStream\n"
          "// Description : An input stream object that uses zlib to compress\n"
          "//               (deflate) data to another destination stream\n"
          "//               on-the-fly.\n"
          "//\n"
          "//               Attach an OCompressStream to an existing ostream that will\n"
          "//               accept compressed data, and write your uncompressed\n"
          "//               source data to the OCompressStream.\n"
          "//\n"
          "//               Seeking is not supported.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ostream._Dtool_ClassInit(NULL);
        Dtool_OCompressStream.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ostream.As_PyTypeObject());
        Dtool_OCompressStream.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OCompressStream.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OCompressStream.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OCompressStream.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OCompressStream)");
             printf(" Error In PyType_ReadyOCompressStream");
             return;
        }
        Py_INCREF(&Dtool_OCompressStream.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OCompressStream.As_PyTypeObject().tp_dict,"OCompressStream",&Dtool_OCompressStream.As_PyObject());
        RegisterRuntimeClass(&Dtool_OCompressStream,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OCompressStream.As_PyTypeObject());
        PyModule_AddObject(module, "OCompressStream",(PyObject *)&Dtool_OCompressStream.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileList | VirtualFileList
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileList[]= {
  { "getNumFiles",(PyCFunction ) &Dtool_VirtualFileList_get_num_files_1078, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_get_num_files_1078_comment},
  { "getFile",(PyCFunction ) &Dtool_VirtualFileList_get_file_1079, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_get_file_1079_comment},
  { "__getitem__",(PyCFunction ) &Dtool_VirtualFileList_operator_1080, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_operator_1080_comment},
  { "size",(PyCFunction ) &Dtool_VirtualFileList_size_1081, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_size_1081_comment},
  { "__iadd__",(PyCFunction ) &Dtool_VirtualFileList_operator_1082, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_operator_1082_comment},
  { "__add__",(PyCFunction ) &Dtool_VirtualFileList_operator_1083, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileList_operator_1083_comment},
  { "getFiles",(PyCFunction) &MakeSeq_VirtualFileList_get_files, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     VirtualFileList ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_VirtualFileList_operator_1082__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_VirtualFileList_operator_1082(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     VirtualFileList ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_VirtualFileList_size_1081size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_VirtualFileList_size_1081(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     VirtualFileList ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_VirtualFileList_operator_1080__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_VirtualFileList_operator_1080(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     VirtualFileList ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_VirtualFileList_operator_1083__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_VirtualFileList_operator_1083(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_VirtualFileList(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileList.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileList\n"
          "// Description : A list of VirtualFiles, as returned by \n"
          "//               VirtualFile::scan_directory().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_VirtualFileList.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_VirtualFileList.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileList.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileList.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_VirtualFileList.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_VirtualFileList_operator_1082__iadd__;
        // tp_as_sequence->sq_length = size
        Dtool_VirtualFileList.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_VirtualFileList_size_1081size;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_VirtualFileList.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_VirtualFileList_operator_1080__getitem__;
        // tp_as_number->nb_add = __add__
        Dtool_VirtualFileList.As_PyTypeObject().tp_as_number->nb_add = &Dtool_VirtualFileList_operator_1083__add__;
        if(PyType_Ready(&Dtool_VirtualFileList.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileList)");
             printf(" Error In PyType_ReadyVirtualFileList");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileList.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileList.As_PyTypeObject().tp_dict,"VirtualFileList",&Dtool_VirtualFileList.As_PyObject());
        RegisterRuntimeClass(&Dtool_VirtualFileList,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileList.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileList",(PyObject *)&Dtool_VirtualFileList.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualFileSystem | VirtualFileSystem
//********************************************************************
PyMethodDef Dtool_Methods_VirtualFileSystem[]= {
  { "mount",(PyCFunction ) &Dtool_VirtualFileSystem_mount_1088, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_mount_1088_comment},
  { "mountLoop",(PyCFunction ) &Dtool_VirtualFileSystem_mount_loop_1089, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_mount_loop_1089_comment},
  { "unmount",(PyCFunction ) &Dtool_VirtualFileSystem_unmount_1090, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_unmount_1090_comment},
  { "unmountPoint",(PyCFunction ) &Dtool_VirtualFileSystem_unmount_point_1091, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_unmount_point_1091_comment},
  { "unmountAll",(PyCFunction ) &Dtool_VirtualFileSystem_unmount_all_1092, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_unmount_all_1092_comment},
  { "getNumMounts",(PyCFunction ) &Dtool_VirtualFileSystem_get_num_mounts_1093, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_get_num_mounts_1093_comment},
  { "getMount",(PyCFunction ) &Dtool_VirtualFileSystem_get_mount_1094, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_get_mount_1094_comment},
  { "chdir",(PyCFunction ) &Dtool_VirtualFileSystem_chdir_1095, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_chdir_1095_comment},
  { "getCwd",(PyCFunction ) &Dtool_VirtualFileSystem_get_cwd_1096, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_get_cwd_1096_comment},
  { "getFile",(PyCFunction ) &Dtool_VirtualFileSystem_get_file_1097, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_get_file_1097_comment},
  { "findFile",(PyCFunction ) &Dtool_VirtualFileSystem_find_file_1098, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_find_file_1098_comment},
  { "resolveFilename",(PyCFunction ) &Dtool_VirtualFileSystem_resolve_filename_1099, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_resolve_filename_1099_comment},
  { "findAllFiles",(PyCFunction ) &Dtool_VirtualFileSystem_find_all_files_1100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_find_all_files_1100_comment},
  { "exists",(PyCFunction ) &Dtool_VirtualFileSystem_exists_1101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_exists_1101_comment},
  { "isDirectory",(PyCFunction ) &Dtool_VirtualFileSystem_is_directory_1102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_is_directory_1102_comment},
  { "isRegularFile",(PyCFunction ) &Dtool_VirtualFileSystem_is_regular_file_1103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_is_regular_file_1103_comment},
  { "scanDirectory",(PyCFunction ) &Dtool_VirtualFileSystem_scan_directory_1104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_scan_directory_1104_comment},
  { "ls",(PyCFunction ) &Dtool_VirtualFileSystem_ls_1105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_ls_1105_comment},
  { "lsAll",(PyCFunction ) &Dtool_VirtualFileSystem_ls_all_1106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_ls_all_1106_comment},
  { "write",(PyCFunction ) &Dtool_VirtualFileSystem_write_1107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_write_1107_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_VirtualFileSystem_get_global_ptr_1108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_get_global_ptr_1108_comment},
  { "readFile",(PyCFunction ) &Dtool_VirtualFileSystem_py_read_file_1109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_py_read_file_1109_comment},
  { "readFile",(PyCFunction ) &Dtool_VirtualFileSystem_read_file_1110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_read_file_1110_comment},
  { "openReadFile",(PyCFunction ) &Dtool_VirtualFileSystem_open_read_file_1111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_open_read_file_1111_comment},
  { "closeReadFile",(PyCFunction ) &Dtool_VirtualFileSystem_close_read_file_1112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualFileSystem_close_read_file_1112_comment},
  { "getMounts",(PyCFunction) &MakeSeq_VirtualFileSystem_get_mounts, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     VirtualFileSystem
//////////////////
static PyObject *  Dtool_Str_VirtualFileSystem(PyObject * self)
{
    VirtualFileSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualFileSystem,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_VirtualFileSystem(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualFileSystem.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualFileSystem\n"
          "// Description : A hierarchy of directories and files that appears to\n"
          "//               be one continuous file system, even though the files\n"
          "//               may originate from several different sources that may\n"
          "//               not be related to the actual OS's file system.\n"
          "//\n"
          "//               For instance, a VirtualFileSystem can transparently\n"
          "//               mount one or more Multifiles as their own\n"
          "//               subdirectory hierarchies.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_VirtualFileSystem.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_VirtualFileSystem.As_PyTypeObject().tp_str = & Dtool_Str_VirtualFileSystem;
        // Enum  VirtualFileSystem::MountFlags;
        PyDict_SetItemString(Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict,"MFReadOnly",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_VirtualFileSystem.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualFileSystem)");
             printf(" Error In PyType_ReadyVirtualFileSystem");
             return;
        }
        Py_INCREF(&Dtool_VirtualFileSystem.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict,"VirtualFileSystem",&Dtool_VirtualFileSystem.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_VirtualFileSystem[20],&Dtool_VirtualFileSystem.As_PyObject()));
        //  Static Method closeReadFile
        PyDict_SetItemString(Dtool_VirtualFileSystem.As_PyTypeObject().tp_dict,"closeReadFile",PyCFunction_New(&Dtool_Methods_VirtualFileSystem[24],&Dtool_VirtualFileSystem.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualFileSystem,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualFileSystem.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualFileSystem",(PyObject *)&Dtool_VirtualFileSystem.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Ramfile | Ramfile
//********************************************************************
PyMethodDef Dtool_Methods_Ramfile[]= {
  { "seek",(PyCFunction ) &Dtool_Ramfile_seek_1115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_seek_1115_comment},
  { "tell",(PyCFunction ) &Dtool_Ramfile_tell_1116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_tell_1116_comment},
  { "read",(PyCFunction ) &Dtool_Ramfile_read_1117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_read_1117_comment},
  { "readline",(PyCFunction ) &Dtool_Ramfile_readline_1118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_readline_1118_comment},
  { "getData",(PyCFunction ) &Dtool_Ramfile_get_data_1119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_get_data_1119_comment},
  { "getDataSize",(PyCFunction ) &Dtool_Ramfile_get_data_size_1120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_get_data_size_1120_comment},
  { "clear",(PyCFunction ) &Dtool_Ramfile_clear_1121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Ramfile_clear_1121_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Ramfile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Ramfile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Ramfile\n"
          "// Description : An in-memory buffer specifically designed for\n"
          "//               downloading files to memory.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Ramfile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Ramfile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Ramfile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Ramfile.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Ramfile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Ramfile)");
             printf(" Error In PyType_ReadyRamfile");
             return;
        }
        Py_INCREF(&Dtool_Ramfile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Ramfile.As_PyTypeObject().tp_dict,"Ramfile",&Dtool_Ramfile.As_PyObject());
        RegisterRuntimeClass(&Dtool_Ramfile,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Ramfile.As_PyTypeObject());
        PyModule_AddObject(module, "Ramfile",(PyObject *)&Dtool_Ramfile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HashVal | HashVal
//********************************************************************
PyMethodDef Dtool_Methods_HashVal[]= {
  { "assign",(PyCFunction ) &Dtool_HashVal_operator_1125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_operator_1125_comment},
  { "eq",(PyCFunction ) &Dtool_HashVal_operator_1126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_operator_1126_comment},
  { "ne",(PyCFunction ) &Dtool_HashVal_operator_1127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_operator_1127_comment},
  { "lessThan",(PyCFunction ) &Dtool_HashVal_operator_1128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_operator_1128_comment},
  { "compareTo",(PyCFunction ) &Dtool_HashVal_compare_to_1129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_compare_to_1129_comment},
  { "mergeWith",(PyCFunction ) &Dtool_HashVal_merge_with_1130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_merge_with_1130_comment},
  { "outputDec",(PyCFunction ) &Dtool_HashVal_output_dec_1131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_output_dec_1131_comment},
  { "inputDec",(PyCFunction ) &Dtool_HashVal_input_dec_1132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_input_dec_1132_comment},
  { "outputHex",(PyCFunction ) &Dtool_HashVal_output_hex_1133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_output_hex_1133_comment},
  { "inputHex",(PyCFunction ) &Dtool_HashVal_input_hex_1134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_input_hex_1134_comment},
  { "outputBinary",(PyCFunction ) &Dtool_HashVal_output_binary_1135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_output_binary_1135_comment},
  { "inputBinary",(PyCFunction ) &Dtool_HashVal_input_binary_1136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_input_binary_1136_comment},
  { "output",(PyCFunction ) &Dtool_HashVal_output_1137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_output_1137_comment},
  { "asDec",(PyCFunction ) &Dtool_HashVal_as_dec_1138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_as_dec_1138_comment},
  { "setFromDec",(PyCFunction ) &Dtool_HashVal_set_from_dec_1139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_set_from_dec_1139_comment},
  { "asHex",(PyCFunction ) &Dtool_HashVal_as_hex_1140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_as_hex_1140_comment},
  { "setFromHex",(PyCFunction ) &Dtool_HashVal_set_from_hex_1141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_set_from_hex_1141_comment},
  { "asBin",(PyCFunction ) &Dtool_HashVal_as_bin_1142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_as_bin_1142_comment},
  { "setFromBin",(PyCFunction ) &Dtool_HashVal_set_from_bin_1143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_set_from_bin_1143_comment},
  { "writeDatagram",(PyCFunction ) &Dtool_HashVal_write_datagram_1144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_write_datagram_1144_comment},
  { "readDatagram",(PyCFunction ) &Dtool_HashVal_read_datagram_1145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_read_datagram_1145_comment},
  { "writeStream",(PyCFunction ) &Dtool_HashVal_write_stream_1146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_write_stream_1146_comment},
  { "readStream",(PyCFunction ) &Dtool_HashVal_read_stream_1147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_read_stream_1147_comment},
  { "hashFile",(PyCFunction ) &Dtool_HashVal_hash_file_1148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_hash_file_1148_comment},
  { "hashStream",(PyCFunction ) &Dtool_HashVal_hash_stream_1149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_hash_stream_1149_comment},
  { "hashRamfile",(PyCFunction ) &Dtool_HashVal_hash_ramfile_1150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_hash_ramfile_1150_comment},
  { "hashString",(PyCFunction ) &Dtool_HashVal_hash_string_1151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_hash_string_1151_comment},
  { "hashBuffer",(PyCFunction ) &Dtool_HashVal_hash_buffer_1152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HashVal_hash_buffer_1152_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     HashVal
//////////////////
static PyObject *  Dtool_Repr_HashVal(PyObject * self)
{
    HashVal * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_HashVal,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_HashVal(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HashVal.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HashVal\n"
          "// Description : Stores a 128-bit value that represents the hashed\n"
          "//               contents (typically MD5) of a file or buffer.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_HashVal.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_HashVal.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HashVal.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HashVal.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_HashVal.As_PyTypeObject().tp_repr = & Dtool_Repr_HashVal;
        // __str__ Repr Proxy
        Dtool_HashVal.As_PyTypeObject().tp_str = & Dtool_Repr_HashVal;
        if(PyType_Ready(&Dtool_HashVal.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HashVal)");
             printf(" Error In PyType_ReadyHashVal");
             return;
        }
        Py_INCREF(&Dtool_HashVal.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HashVal.As_PyTypeObject().tp_dict,"HashVal",&Dtool_HashVal.As_PyObject());
        RegisterRuntimeClass(&Dtool_HashVal,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HashVal.As_PyTypeObject());
        PyModule_AddObject(module, "HashVal",(PyObject *)&Dtool_HashVal.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Patchfile | Patchfile
//********************************************************************
PyMethodDef Dtool_Methods_Patchfile[]= {
  { "build",(PyCFunction ) &Dtool_Patchfile_build_1157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_build_1157_comment},
  { "readHeader",(PyCFunction ) &Dtool_Patchfile_read_header_1158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_read_header_1158_comment},
  { "initiate",(PyCFunction ) &Dtool_Patchfile_initiate_1159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_initiate_1159_comment},
  { "run",(PyCFunction ) &Dtool_Patchfile_run_1160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_run_1160_comment},
  { "apply",(PyCFunction ) &Dtool_Patchfile_apply_1161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_apply_1161_comment},
  { "getProgress",(PyCFunction ) &Dtool_Patchfile_get_progress_1162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_get_progress_1162_comment},
  { "setAllowMultifile",(PyCFunction ) &Dtool_Patchfile_set_allow_multifile_1163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_set_allow_multifile_1163_comment},
  { "getAllowMultifile",(PyCFunction ) &Dtool_Patchfile_get_allow_multifile_1164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_get_allow_multifile_1164_comment},
  { "setFootprintLength",(PyCFunction ) &Dtool_Patchfile_set_footprint_length_1165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_set_footprint_length_1165_comment},
  { "getFootprintLength",(PyCFunction ) &Dtool_Patchfile_get_footprint_length_1166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_get_footprint_length_1166_comment},
  { "resetFootprintLength",(PyCFunction ) &Dtool_Patchfile_reset_footprint_length_1167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_reset_footprint_length_1167_comment},
  { "hasSourceHash",(PyCFunction ) &Dtool_Patchfile_has_source_hash_1168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_has_source_hash_1168_comment},
  { "getSourceHash",(PyCFunction ) &Dtool_Patchfile_get_source_hash_1169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_get_source_hash_1169_comment},
  { "getResultHash",(PyCFunction ) &Dtool_Patchfile_get_result_hash_1170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Patchfile_get_result_hash_1170_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Patchfile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Patchfile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Patchfile\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Patchfile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Patchfile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Patchfile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Patchfile.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Patchfile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Patchfile)");
             printf(" Error In PyType_ReadyPatchfile");
             return;
        }
        Py_INCREF(&Dtool_Patchfile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Patchfile.As_PyTypeObject().tp_dict,"Patchfile",&Dtool_Patchfile.As_PyObject());
        RegisterRuntimeClass(&Dtool_Patchfile,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Patchfile.As_PyTypeObject());
        PyModule_AddObject(module, "Patchfile",(PyObject *)&Dtool_Patchfile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TrueClock | TrueClock
//********************************************************************
PyMethodDef Dtool_Methods_TrueClock[]= {
  { "getLongTime",(PyCFunction ) &Dtool_TrueClock_get_long_time_1173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_get_long_time_1173_comment},
  { "getShortTime",(PyCFunction ) &Dtool_TrueClock_get_short_time_1174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_get_short_time_1174_comment},
  { "getShortRawTime",(PyCFunction ) &Dtool_TrueClock_get_short_raw_time_1175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_get_short_raw_time_1175_comment},
  { "getErrorCount",(PyCFunction ) &Dtool_TrueClock_get_error_count_1176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_get_error_count_1176_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_TrueClock_get_global_ptr_1177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_get_global_ptr_1177_comment},
  { "setCpuAffinity",(PyCFunction ) &Dtool_TrueClock_set_cpu_affinity_1178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrueClock_set_cpu_affinity_1178_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TrueClock(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TrueClock.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TrueClock\n"
          "// Description : An interface to whatever real-time clock we might\n"
          "//               have available in the current environment.  There is\n"
          "//               only one TrueClock in existence, and it constructs\n"
          "//               itself.\n"
          "//\n"
          "//               The TrueClock returns elapsed real time in seconds\n"
          "//               since some undefined epoch.  Since it is not defined\n"
          "//               at what time precisely the clock indicates zero, this\n"
          "//               value can only be meaningfully used to measure\n"
          "//               elapsed time, by sampling it at two different times\n"
          "//               and subtracting.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TrueClock.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TrueClock.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TrueClock.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TrueClock.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TrueClock.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TrueClock)");
             printf(" Error In PyType_ReadyTrueClock");
             return;
        }
        Py_INCREF(&Dtool_TrueClock.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TrueClock.As_PyTypeObject().tp_dict,"TrueClock",&Dtool_TrueClock.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_TrueClock.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_TrueClock[4],&Dtool_TrueClock.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TrueClock,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TrueClock.As_PyTypeObject());
        PyModule_AddObject(module, "TrueClock",(PyObject *)&Dtool_TrueClock.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ProfileTimer | ProfileTimer
//********************************************************************
PyMethodDef Dtool_Methods_ProfileTimer[]= {
  { "init",(PyCFunction ) &Dtool_ProfileTimer_init_1182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_init_1182_comment},
  { "on",(PyCFunction ) &Dtool_ProfileTimer_on_1183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_on_1183_comment},
  { "mark",(PyCFunction ) &Dtool_ProfileTimer_mark_1184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_mark_1184_comment},
  { "off",(PyCFunction ) &Dtool_ProfileTimer_off_1185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_off_1185_comment},
  { "getTotalTime",(PyCFunction ) &Dtool_ProfileTimer_getTotalTime_1186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_getTotalTime_1186_comment},
  { "consolidateAllTo",(PyCFunction ) &Dtool_ProfileTimer_consolidateAllTo_1187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_consolidateAllTo_1187_comment},
  { "consolidateTo",(PyCFunction ) &Dtool_ProfileTimer_consolidateTo_1188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_consolidateTo_1188_comment},
  { "printAllTo",(PyCFunction ) &Dtool_ProfileTimer_printAllTo_1189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_printAllTo_1189_comment},
  { "printTo",(PyCFunction ) &Dtool_ProfileTimer_printTo_1190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProfileTimer_printTo_1190_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ProfileTimer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ProfileTimer.As_PyTypeObject().tp_doc =
          "/*\n"
          "    ProfileTimer\n"
          "\n"
          "    HowTo:\n"
          "      Create a ProfileTimer and hold onto it.\n"
          "      Call init() whenever you like (the timer doesn't\n"
          "        start yet).\n"
          "      Call on() to start the timer.\n"
          "      While the timer is on, call mark() at each point of interest,\n"
          "        in the code you are timing.\n"
          "      You can turn the timer off() and on() to skip things you\n"
          "        don't want to time.\n"
          "      When your timing is finished, call printTo() to see the\n"
          "        results (e.g. myTimer.printTo(cerr)).\n"
          "\n"
          "    Notes:\n"
          "      You should be able to time things down to the millisecond\n"
          "      well enough, but if you call on() and off() within micro-\n"
          "      seconds of each other, I don't think you'll get very good\n"
          "      results.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ProfileTimer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ProfileTimer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ProfileTimer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ProfileTimer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ProfileTimer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ProfileTimer)");
             printf(" Error In PyType_ReadyProfileTimer");
             return;
        }
        Py_INCREF(&Dtool_ProfileTimer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ProfileTimer.As_PyTypeObject().tp_dict,"ProfileTimer",&Dtool_ProfileTimer.As_PyObject());
        //  Static Method consolidateAllTo
        PyDict_SetItemString(Dtool_ProfileTimer.As_PyTypeObject().tp_dict,"consolidateAllTo",PyCFunction_New(&Dtool_Methods_ProfileTimer[5],&Dtool_ProfileTimer.As_PyObject()));
        //  Static Method printAllTo
        PyDict_SetItemString(Dtool_ProfileTimer.As_PyTypeObject().tp_dict,"printAllTo",PyCFunction_New(&Dtool_Methods_ProfileTimer[7],&Dtool_ProfileTimer.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ProfileTimer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ProfileTimer.As_PyTypeObject());
        PyModule_AddObject(module, "ProfileTimer",(PyObject *)&Dtool_ProfileTimer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WeakPointerToVoid | WeakPointerToVoid
//********************************************************************
PyMethodDef Dtool_Methods_WeakPointerToVoid[]= {
  { "wasDeleted",(PyCFunction ) &Dtool_WeakPointerToVoid_was_deleted_1192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WeakPointerToVoid_was_deleted_1192_comment},
  { "isValidPointer",(PyCFunction ) &Dtool_WeakPointerToVoid_is_valid_pointer_1193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WeakPointerToVoid_is_valid_pointer_1193_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_WeakPointerToVoid(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WeakPointerToVoid.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WeakPointerToVoid\n"
          "// Description : This is the specialization of PointerToVoid for weak\n"
          "//               pointers.  It needs an additional flag to indicate\n"
          "//               that the pointer has been deleted.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_WeakPointerToVoid.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_WeakPointerToVoid.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WeakPointerToVoid.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WeakPointerToVoid.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_WeakPointerToVoid.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WeakPointerToVoid)");
             printf(" Error In PyType_ReadyWeakPointerToVoid");
             return;
        }
        Py_INCREF(&Dtool_WeakPointerToVoid.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WeakPointerToVoid.As_PyTypeObject().tp_dict,"WeakPointerToVoid",&Dtool_WeakPointerToVoid.As_PyObject());
        RegisterRuntimeClass(&Dtool_WeakPointerToVoid,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WeakPointerToVoid.As_PyTypeObject());
        PyModule_AddObject(module, "WeakPointerToVoid",(PyObject *)&Dtool_WeakPointerToVoid.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WindowsRegistry | WindowsRegistry
//********************************************************************
PyMethodDef Dtool_Methods_WindowsRegistry[]= {
  { "setStringValue",(PyCFunction ) &Dtool_WindowsRegistry_set_string_value_1196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowsRegistry_set_string_value_1196_comment},
  { "setIntValue",(PyCFunction ) &Dtool_WindowsRegistry_set_int_value_1197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowsRegistry_set_int_value_1197_comment},
  { "getKeyType",(PyCFunction ) &Dtool_WindowsRegistry_get_key_type_1199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowsRegistry_get_key_type_1199_comment},
  { "getStringValue",(PyCFunction ) &Dtool_WindowsRegistry_get_string_value_1200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowsRegistry_get_string_value_1200_comment},
  { "getIntValue",(PyCFunction ) &Dtool_WindowsRegistry_get_int_value_1201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WindowsRegistry_get_int_value_1201_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_WindowsRegistry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WindowsRegistry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WindowsRegistry\n"
          "// Description : This class provides a hook to Python to read and\n"
          "//               write strings and integers to the windows registry.\n"
          "//               It automatically converts strings from utf-8 encoding\n"
          "//               and stores them in Unicode (and conversely reconverts\n"
          "//               them on retrieval).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_WindowsRegistry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_WindowsRegistry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WindowsRegistry.As_PyTypeObject().tp_dict);
        // Enum  WindowsRegistry::RegLevel;
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"RlMachine",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"RlUser",PyInt_FromLong(1));
        // Enum  WindowsRegistry::Type;
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"TNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"TInt",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"TString",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_WindowsRegistry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WindowsRegistry)");
             printf(" Error In PyType_ReadyWindowsRegistry");
             return;
        }
        Py_INCREF(&Dtool_WindowsRegistry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"WindowsRegistry",&Dtool_WindowsRegistry.As_PyObject());
        //  Static Method setStringValue
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"setStringValue",PyCFunction_New(&Dtool_Methods_WindowsRegistry[0],&Dtool_WindowsRegistry.As_PyObject()));
        //  Static Method setIntValue
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"setIntValue",PyCFunction_New(&Dtool_Methods_WindowsRegistry[1],&Dtool_WindowsRegistry.As_PyObject()));
        //  Static Method getKeyType
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"getKeyType",PyCFunction_New(&Dtool_Methods_WindowsRegistry[2],&Dtool_WindowsRegistry.As_PyObject()));
        //  Static Method getStringValue
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"getStringValue",PyCFunction_New(&Dtool_Methods_WindowsRegistry[3],&Dtool_WindowsRegistry.As_PyObject()));
        //  Static Method getIntValue
        PyDict_SetItemString(Dtool_WindowsRegistry.As_PyTypeObject().tp_dict,"getIntValue",PyCFunction_New(&Dtool_Methods_WindowsRegistry[4],&Dtool_WindowsRegistry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WindowsRegistry,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WindowsRegistry.As_PyTypeObject());
        PyModule_AddObject(module, "WindowsRegistry",(PyObject *)&Dtool_WindowsRegistry.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..NotifySeverity
//********************************************************************
   PyModule_AddIntConstant(module,"NSUnspecified",0);
   PyModule_AddIntConstant(module,"NSSpam",1);
   PyModule_AddIntConstant(module,"NSDebug",2);
   PyModule_AddIntConstant(module,"NSInfo",3);
   PyModule_AddIntConstant(module,"NSWarning",4);
   PyModule_AddIntConstant(module,"NSError",5);
   PyModule_AddIntConstant(module,"NSFatal",6);
//********************************************************************
//*** Module Enums  ..ErrorUtilCode
//********************************************************************
   PyModule_AddIntConstant(module,"EUHttpRedirect",7);
   PyModule_AddIntConstant(module,"EUEof",6);
   PyModule_AddIntConstant(module,"EUNetworkNoData",5);
   PyModule_AddIntConstant(module,"EUWriteRam",4);
   PyModule_AddIntConstant(module,"EUWrite",3);
   PyModule_AddIntConstant(module,"EUOk",2);
   PyModule_AddIntConstant(module,"EUSuccess",1);
   PyModule_AddIntConstant(module,"EUErrorAbort",-1);
   PyModule_AddIntConstant(module,"EUErrorFileEmpty",-2);
   PyModule_AddIntConstant(module,"EUErrorFileInvalid",-3);
   PyModule_AddIntConstant(module,"EUErrorInvalidChecksum",-4);
   PyModule_AddIntConstant(module,"EUErrorNetworkDead",-30);
   PyModule_AddIntConstant(module,"EUErrorNetworkUnreachable",-31);
   PyModule_AddIntConstant(module,"EUErrorNetworkDisconnected",-32);
   PyModule_AddIntConstant(module,"EUErrorNetworkTimeout",-33);
   PyModule_AddIntConstant(module,"EUErrorNetworkNoData",-34);
   PyModule_AddIntConstant(module,"EUErrorNetworkDisconnectedLocally",-40);
   PyModule_AddIntConstant(module,"EUErrorNetworkBufferOverflow",-41);
   PyModule_AddIntConstant(module,"EUErrorNetworkDiskQuotaExceeded",-42);
   PyModule_AddIntConstant(module,"EUErrorNetworkRemoteHostDisconnected",-50);
   PyModule_AddIntConstant(module,"EUErrorNetworkRemoteHostDown",-51);
   PyModule_AddIntConstant(module,"EUErrorNetworkRemoteHostUnreachable",-52);
   PyModule_AddIntConstant(module,"EUErrorNetworkRemoteHostNotFound",-53);
   PyModule_AddIntConstant(module,"EUErrorNetworkRemoteHostNoResponse",-54);
   PyModule_AddIntConstant(module,"EUErrorWriteOutOfFiles",-60);
   PyModule_AddIntConstant(module,"EUErrorWriteOutOfMemory",-61);
   PyModule_AddIntConstant(module,"EUErrorWriteSharingViolation",-62);
   PyModule_AddIntConstant(module,"EUErrorWriteDiskFull",-63);
   PyModule_AddIntConstant(module,"EUErrorWriteDiskNotFound",-64);
   PyModule_AddIntConstant(module,"EUErrorWriteDiskSectorNotFound",-65);
   PyModule_AddIntConstant(module,"EUErrorWriteDiskFault",-66);
   PyModule_AddIntConstant(module,"EUErrorWriteFileRename",-67);
   PyModule_AddIntConstant(module,"EUErrorHttpServerTimeout",-70);
   PyModule_AddIntConstant(module,"EUErrorHttpGatewayTimeout",-71);
   PyModule_AddIntConstant(module,"EUErrorHttpServiceUnavailable",-72);
   PyModule_AddIntConstant(module,"EUErrorHttpProxyAuthentication",-73);
   PyModule_AddIntConstant(module,"EUErrorZlib",-80);
//********************************************************************
//*** Module Init Updcall ..ConfigFlags
//********************************************************************
   Dtool_PyModuleClassInit_ConfigFlags(module);
//********************************************************************
//*** Module Init Updcall ..ConfigPage
//********************************************************************
   Dtool_PyModuleClassInit_ConfigPage(module);
//********************************************************************
//*** Module Init Updcall ..ConfigPageManager
//********************************************************************
   Dtool_PyModuleClassInit_ConfigPageManager(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariable
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariable(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableBase
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableBase(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableBool
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableBool(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableDouble
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableDouble(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableFilename
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableFilename(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableInt
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableInt(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableInt64
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableInt64(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableList
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableList(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableManager
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableManager(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableSearchPath
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableSearchPath(module);
//********************************************************************
//*** Module Init Updcall ..ConfigVariableString
//********************************************************************
   Dtool_PyModuleClassInit_ConfigVariableString(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< float >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< float >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_float(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< float > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(module);
//********************************************************************
//*** Module Init Updcall ..PointerToVoid
//********************************************************************
   Dtool_PyModuleClassInit_PointerToVoid(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< int >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_int(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< int >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_int(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< int > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< unsigned char >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< unsigned char >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< unsigned char > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(module);
//********************************************************************
//*** Module Init Updcall ..DConfig
//********************************************************************
   Dtool_PyModuleClassInit_DConfig(module);
//********************************************************************
//*** Module Init Updcall ..DSearchPath
//********************************************************************
   Dtool_PyModuleClassInit_DSearchPath(module);
//********************************************************************
//*** Module Init Updcall ..ExecutionEnvironment
//********************************************************************
   Dtool_PyModuleClassInit_ExecutionEnvironment(module);
//********************************************************************
//*** Module Init Updcall ..FileStream
//********************************************************************
   Dtool_PyModuleClassInit_FileStream(module);
//********************************************************************
//*** Module Init Updcall ..iostream
//********************************************************************
   Dtool_PyModuleClassInit_iostream(module);
//********************************************************************
//*** Module Init Updcall ..istream
//********************************************************************
   Dtool_PyModuleClassInit_istream(module);
//********************************************************************
//*** Module Init Updcall ..ios
//********************************************************************
   Dtool_PyModuleClassInit_ios(module);
//********************************************************************
//*** Module Init Updcall ..ios_base
//********************************************************************
   Dtool_PyModuleClassInit_ios_base(module);
//********************************************************************
//*** Module Init Updcall ..ostream
//********************************************************************
   Dtool_PyModuleClassInit_ostream(module);
//********************************************************************
//*** Module Init Updcall ..Filename
//********************************************************************
   Dtool_PyModuleClassInit_Filename(module);
//********************************************************************
//*** Module Init Updcall ..GlobPattern
//********************************************************************
   Dtool_PyModuleClassInit_GlobPattern(module);
//********************************************************************
//*** Module Init Updcall ..IDecryptStream
//********************************************************************
   Dtool_PyModuleClassInit_IDecryptStream(module);
//********************************************************************
//*** Module Init Updcall ..IFileStream
//********************************************************************
   Dtool_PyModuleClassInit_IFileStream(module);
//********************************************************************
//*** Module Init Updcall ..IStreamWrapper
//********************************************************************
   Dtool_PyModuleClassInit_IStreamWrapper(module);
//********************************************************************
//*** Module Init Updcall ..StreamWrapperBase
//********************************************************************
   Dtool_PyModuleClassInit_StreamWrapperBase(module);
//********************************************************************
//*** Module Init Updcall ..NeverFreeMemory
//********************************************************************
   Dtool_PyModuleClassInit_NeverFreeMemory(module);
//********************************************************************
//*** Module Init Updcall ..Notify
//********************************************************************
   Dtool_PyModuleClassInit_Notify(module);
//********************************************************************
//*** Module Init Updcall ..NotifyCategory
//********************************************************************
   Dtool_PyModuleClassInit_NotifyCategory(module);
//********************************************************************
//*** Module Init Updcall ..OEncryptStream
//********************************************************************
   Dtool_PyModuleClassInit_OEncryptStream(module);
//********************************************************************
//*** Module Init Updcall ..OFileStream
//********************************************************************
   Dtool_PyModuleClassInit_OFileStream(module);
//********************************************************************
//*** Module Init Updcall ..OStreamWrapper
//********************************************************************
   Dtool_PyModuleClassInit_OStreamWrapper(module);
//********************************************************************
//*** Module Init Updcall ..PandaSystem
//********************************************************************
   Dtool_PyModuleClassInit_PandaSystem(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< float >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_float(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< int >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_int(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< unsigned char >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_unsigned_char(module);
//********************************************************************
//*** Module Init Updcall ..StreamReader
//********************************************************************
   Dtool_PyModuleClassInit_StreamReader(module);
//********************************************************************
//*** Module Init Updcall ..StreamWrapper
//********************************************************************
   Dtool_PyModuleClassInit_StreamWrapper(module);
//********************************************************************
//*** Module Init Updcall ..StreamWriter
//********************************************************************
   Dtool_PyModuleClassInit_StreamWriter(module);
//********************************************************************
//*** Module Init Updcall ..TypeHandle
//********************************************************************
   Dtool_PyModuleClassInit_TypeHandle(module);
//********************************************************************
//*** Module Init Updcall ..TypeRegistry
//********************************************************************
   Dtool_PyModuleClassInit_TypeRegistry(module);
//********************************************************************
//*** Module Init Updcall ..TypedObject
//********************************************************************
   Dtool_PyModuleClassInit_TypedObject(module);
//********************************************************************
//*** Module Init Updcall ..fstream
//********************************************************************
   Dtool_PyModuleClassInit_fstream(module);
//********************************************************************
//*** Module Init Updcall ..ifstream
//********************************************************************
   Dtool_PyModuleClassInit_ifstream(module);
//********************************************************************
//*** Module Init Updcall ..ofstream
//********************************************************************
   Dtool_PyModuleClassInit_ofstream(module);
//********************************************************************
//*** Module Init Updcall ..ReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_ReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..Buffer
//********************************************************************
   Dtool_PyModuleClassInit_Buffer(module);
//********************************************************************
//*** Module Init Updcall ..PStatCollectorForwardBase
//********************************************************************
   Dtool_PyModuleClassInit_PStatCollectorForwardBase(module);
//********************************************************************
//*** Module Init Updcall ..NodeReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_NodeReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..Datagram
//********************************************************************
   Dtool_PyModuleClassInit_Datagram(module);
//********************************************************************
//*** Module Init Updcall ..DatagramGenerator
//********************************************************************
   Dtool_PyModuleClassInit_DatagramGenerator(module);
//********************************************************************
//*** Module Init Updcall ..DatagramIterator
//********************************************************************
   Dtool_PyModuleClassInit_DatagramIterator(module);
//********************************************************************
//*** Module Init Updcall ..DatagramSink
//********************************************************************
   Dtool_PyModuleClassInit_DatagramSink(module);
//********************************************************************
//*** Module Init Updcall ..TextEncoder
//********************************************************************
   Dtool_PyModuleClassInit_TextEncoder(module);
//********************************************************************
//*** Module Init Updcall ..TypedReferenceCount
//********************************************************************
   Dtool_PyModuleClassInit_TypedReferenceCount(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFile
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFile(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileComposite
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileComposite(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileMount
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileMount(module);
//********************************************************************
//*** Module Init Updcall ..ISubStream
//********************************************************************
   Dtool_PyModuleClassInit_ISubStream(module);
//********************************************************************
//*** Module Init Updcall ..Multifile
//********************************************************************
   Dtool_PyModuleClassInit_Multifile(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileMountMultifile
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileMountMultifile(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileMountSystem
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileMountSystem(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileSimple
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileSimple(module);
//********************************************************************
//*** Module Init Updcall ..Namable
//********************************************************************
   Dtool_PyModuleClassInit_Namable(module);
//********************************************************************
//*** Module Init Updcall ..IDecompressStream
//********************************************************************
   Dtool_PyModuleClassInit_IDecompressStream(module);
//********************************************************************
//*** Module Init Updcall ..OCompressStream
//********************************************************************
   Dtool_PyModuleClassInit_OCompressStream(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileList
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileList(module);
//********************************************************************
//*** Module Init Updcall ..VirtualFileSystem
//********************************************************************
   Dtool_PyModuleClassInit_VirtualFileSystem(module);
//********************************************************************
//*** Module Init Updcall ..Ramfile
//********************************************************************
   Dtool_PyModuleClassInit_Ramfile(module);
//********************************************************************
//*** Module Init Updcall ..HashVal
//********************************************************************
   Dtool_PyModuleClassInit_HashVal(module);
//********************************************************************
//*** Module Init Updcall ..Patchfile
//********************************************************************
   Dtool_PyModuleClassInit_Patchfile(module);
//********************************************************************
//*** Module Init Updcall ..TrueClock
//********************************************************************
   Dtool_PyModuleClassInit_TrueClock(module);
//********************************************************************
//*** Module Init Updcall ..ProfileTimer
//********************************************************************
   Dtool_PyModuleClassInit_ProfileTimer(module);
//********************************************************************
//*** Module Init Updcall ..WeakPointerToVoid
//********************************************************************
   Dtool_PyModuleClassInit_WeakPointerToVoid(module);
//********************************************************************
//*** Module Init Updcall ..WindowsRegistry
//********************************************************************
   Dtool_PyModuleClassInit_WindowsRegistry(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "getConfigExpress", (PyCFunction) &Dtool_get_config_express_764, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_config_express_764_comment},
  { "compressString", (PyCFunction) &Dtool_compress_string_777, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_compress_string_777_comment},
  { "decompressString", (PyCFunction) &Dtool_decompress_string_778, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decompress_string_778_comment},
  { "compressFile", (PyCFunction) &Dtool_compress_file_779, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_compress_file_779_comment},
  { "decompressFile", (PyCFunction) &Dtool_decompress_file_780, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decompress_file_780_comment},
  { "compressStream", (PyCFunction) &Dtool_compress_stream_781, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_compress_stream_781_comment},
  { "decompressStream", (PyCFunction) &Dtool_decompress_stream_782, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decompress_stream_782_comment},
  { "copyStream", (PyCFunction) &Dtool_copy_stream_783, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_copy_stream_783_comment},
  { "encryptString", (PyCFunction) &Dtool_encrypt_string_886, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_encrypt_string_886_comment},
  { "decryptString", (PyCFunction) &Dtool_decrypt_string_887, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decrypt_string_887_comment},
  { "encryptFile", (PyCFunction) &Dtool_encrypt_file_888, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_encrypt_file_888_comment},
  { "decryptFile", (PyCFunction) &Dtool_decrypt_file_889, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decrypt_file_889_comment},
  { "encryptStream", (PyCFunction) &Dtool_encrypt_stream_890, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_encrypt_stream_890_comment},
  { "decryptStream", (PyCFunction) &Dtool_decrypt_stream_891, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_decrypt_stream_891_comment},
  { "errorToText", (PyCFunction) &Dtool_error_to_text_893, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_error_to_text_893_comment},
  { "getWriteError", (PyCFunction) &Dtool_get_write_error_894, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_write_error_894_comment},
  { "handleSocketError", (PyCFunction) &Dtool_handle_socket_error_895, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_handle_socket_error_895_comment},
  { "getNetworkError", (PyCFunction) &Dtool_get_network_error_896, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_network_error_896_comment},
  { "passwordHash", (PyCFunction) &Dtool_password_hash_1171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_password_hash_1171_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libexpress_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212817,  /* file_identifier */
  "libexpress",  /* library_name */
  "Koxt",  /* library_hash_name */
  "pandaexpress",  /* module_name */
  "libexpress.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  2681  /* next_index */
};

Configure(_in_configure_libexpress);
ConfigureFn(_in_configure_libexpress) {
  interrogate_request_module(&_in_module_def);
}

