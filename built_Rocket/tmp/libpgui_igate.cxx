/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pgui -Ipanda/src/pgui -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpgui_igate.cxx -od built_Rocket/pandac/input/libpgui.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pgui -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpgui config_pgui.h pgButton.h pgButtonNotify.h pgCullTraverser.h pgEntry.h pgFrameStyle.h pgItem.h pgItemNotify.h pgMouseWatcherBackground.h pgMouseWatcherGroup.h pgMouseWatcherParameter.h pgMouseWatcherRegion.h pgScrollFrame.h pgSliderBar.h pgSliderBarNotify.h pgTop.h pgVirtualFrame.h pgWaitBar.h pgui_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpgui
#include "py_panda.h"  

#include "clockObject.h"
#include "configVariableDouble.h"
#include "config_pgui.h"
#include "cullTraverser.h"
#include "mouseWatcherParameter.h"
#include "mouseWatcherRegion.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pgButton.h"
#include "pgButtonNotify.h"
#include "pgCullTraverser.h"
#include "pgEntry.h"
#include "pgFrameStyle.h"
#include "pgItem.h"
#include "pgItemNotify.h"
#include "pgMouseWatcherBackground.h"
#include "pgMouseWatcherGroup.h"
#include "pgMouseWatcherParameter.h"
#include "pgMouseWatcherRegion.h"
#include "pgScrollFrame.h"
#include "pgSliderBar.h"
#include "pgSliderBarNotify.h"
#include "pgTop.h"
#include "pgVirtualFrame.h"
#include "pgWaitBar.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "textAssembler.h"
#include "textNode.h"
#include "typedWritableReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PGFrameStyle
//********************************************************************
typedef  PGFrameStyle  PGFrameStyle_localtype;
Define_Module_Class(panda,PGFrameStyle,PGFrameStyle_localtype,PGFrameStyle);
//********************************************************************
//*** prototypes for .. PGItem
//********************************************************************
typedef  PGItem  PGItem_localtype;
Define_Module_ClassRef(panda,PGItem,PGItem_localtype,PGItem);
//********************************************************************
//*** prototypes for .. PGButton
//********************************************************************
typedef  PGButton  PGButton_localtype;
Define_Module_ClassRef(panda,PGButton,PGButton_localtype,PGButton);
//********************************************************************
//*** prototypes for .. PGTop
//********************************************************************
typedef  PGTop  PGTop_localtype;
Define_Module_ClassRef(panda,PGTop,PGTop_localtype,PGTop);
//********************************************************************
//*** prototypes for .. PGEntry
//********************************************************************
typedef  PGEntry  PGEntry_localtype;
Define_Module_ClassRef(panda,PGEntry,PGEntry_localtype,PGEntry);
//********************************************************************
//*** prototypes for .. PGMouseWatcherBackground
//********************************************************************
typedef  PGMouseWatcherBackground  PGMouseWatcherBackground_localtype;
Define_Module_ClassRef(panda,PGMouseWatcherBackground,PGMouseWatcherBackground_localtype,PGMouseWatcherBackground);
//********************************************************************
//*** prototypes for .. PGMouseWatcherParameter
//********************************************************************
typedef  PGMouseWatcherParameter  PGMouseWatcherParameter_localtype;
Define_Module_ClassRef(panda,PGMouseWatcherParameter,PGMouseWatcherParameter_localtype,PGMouseWatcherParameter);
//********************************************************************
//*** prototypes for .. PGVirtualFrame
//********************************************************************
typedef  PGVirtualFrame  PGVirtualFrame_localtype;
Define_Module_ClassRef(panda,PGVirtualFrame,PGVirtualFrame_localtype,PGVirtualFrame);
//********************************************************************
//*** prototypes for .. PGSliderBar
//********************************************************************
typedef  PGSliderBar  PGSliderBar_localtype;
Define_Module_ClassRef(panda,PGSliderBar,PGSliderBar_localtype,PGSliderBar);
//********************************************************************
//*** prototypes for .. PGScrollFrame
//********************************************************************
typedef  PGScrollFrame  PGScrollFrame_localtype;
Define_Module_ClassRef(panda,PGScrollFrame,PGScrollFrame_localtype,PGScrollFrame);
//********************************************************************
//*** prototypes for .. PGWaitBar
//********************************************************************
typedef  PGWaitBar  PGWaitBar_localtype;
Define_Module_ClassRef(panda,PGWaitBar,PGWaitBar_localtype,PGWaitBar);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AudioSound;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ButtonHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseWatcher;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseWatcherGroup;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseWatcherParameter;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseWatcherRegion;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextGraphic;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextProperties;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TransformState;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PGFrameStyle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::operator =(PGFrameStyle const &copy)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_operator_3(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::operator =(PGFrameStyle const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PGFrameStyle *param1_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGFrameStyle, 1, "PGFrameStyle.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PGFrameStyle *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PGFrameStyle,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PGFrameStyle this, const PGFrameStyle copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_operator_3_comment =
    "C++ Interface:\n"
    "assign(non-const PGFrameStyle this, const PGFrameStyle copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_operator_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_type(PGFrameStyle::Type type)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_type_6(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGFrameStyle::set_type(PGFrameStyle::Type type)
        int param1;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_type((PGFrameStyle::Type)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGFrameStyle.setType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setType(non-const PGFrameStyle this, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_type_6_comment =
    "C++ Interface:\n"
    "setType(non-const PGFrameStyle this, int type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_type\n"
    "//       Access: Published\n"
    "//  Description: Sets the basic type of frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_type_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGFrameStyle::Type PGFrameStyle::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_type_7(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGFrameStyle::Type PGFrameStyle::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            PGFrameStyle::Type return_value = ((const PGFrameStyle*)local_this)->get_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_type_7_comment =
    "C++ Interface:\n"
    "getType(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the basic type of frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_type_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_color(LVecBase4f const &color)
 * inline void PGFrameStyle::set_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_color_8(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGFrameStyle::set_color(LVecBase4f const &color)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setColor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PGFrameStyle.setColor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_color(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGFrameStyle.setColor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::set_color(float r, float g, float b, float a)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setColor", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setColor() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setColor(non-const PGFrameStyle this, const VBase4 color)\n"
          "setColor(non-const PGFrameStyle this, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_color_8_comment =
    "C++ Interface:\n"
    "setColor(non-const PGFrameStyle this, const VBase4 color)\n"
    "setColor(non-const PGFrameStyle this, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_color\n"
    "//       Access: Published\n"
    "//  Description: Sets the dominant color of the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_color\n"
    "//       Access: Published\n"
    "//  Description: Sets the dominant color of the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_color_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PGFrameStyle::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_color_9(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PGFrameStyle::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PGFrameStyle*)local_this)->get_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_color_9_comment =
    "C++ Interface:\n"
    "getColor(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the dominant color of the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_color_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_texture(Texture *texture)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_texture_10(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::set_texture(Texture *texture)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"texture", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTexture", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTexture", &param1));
            if(!PyErr_Occurred())
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "PGFrameStyle.setTexture", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_texture(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.setTexture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTexture(non-const PGFrameStyle this, non-const Texture texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_texture_10_comment =
    "C++ Interface:\n"
    "setTexture(non-const PGFrameStyle this, non-const Texture texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_texture\n"
    "//       Access: Published\n"
    "//  Description: Specifies a texture that should be applied to the\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_texture_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGFrameStyle::has_texture(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_has_texture_11(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGFrameStyle::has_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTexture", key_word_list));
        else
            (PyArg_Parse(args, ":hasTexture"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGFrameStyle*)local_this)->has_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTexture(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_has_texture_11_comment =
    "C++ Interface:\n"
    "hasTexture(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::has_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a texture has been applied to the\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_has_texture_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *PGFrameStyle::get_texture(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_texture_12(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Texture *PGFrameStyle::get_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getTexture"));
        if(!PyErr_Occurred())
        {
            Texture *return_value = ((const PGFrameStyle*)local_this)->get_texture();
            if (return_value != (Texture *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexture(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_texture_12_comment =
    "C++ Interface:\n"
    "getTexture(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_texture\n"
    "//       Access: Published\n"
    "//  Description: Returns the texture that has been applied to the\n"
    "//               frame, or NULL if no texture has been applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_texture_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::clear_texture(void)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_clear_texture_13(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGFrameStyle::clear_texture(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTexture", key_word_list));
        else
            (PyArg_Parse(args, ":clearTexture"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGFrameStyle.clearTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTexture(non-const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_clear_texture_13_comment =
    "C++ Interface:\n"
    "clearTexture(non-const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::clear_texture\n"
    "//       Access: Published\n"
    "//  Description: Removes the texture from the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_clear_texture_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_width(LVecBase2f const &width)
 * inline void PGFrameStyle::set_width(float x, float y)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_width_14(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGFrameStyle::set_width(LVecBase2f const &width)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"width", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWidth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setWidth", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PGFrameStyle.setWidth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_width(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGFrameStyle.setWidth() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::set_width(float x, float y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setWidth", key_word_list, &param1, &param2))
            {
                (local_this)->set_width((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.setWidth() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setWidth() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setWidth(non-const PGFrameStyle this, const VBase2 width)\n"
          "setWidth(non-const PGFrameStyle this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_width_14_comment =
    "C++ Interface:\n"
    "setWidth(non-const PGFrameStyle this, const VBase2 width)\n"
    "setWidth(non-const PGFrameStyle this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the width parameter, which has meaning only for\n"
    "//               certain frame types.  For instance, this is the width\n"
    "//               of the bevel for T_bevel_in or T_bevel_out.  The\n"
    "//               units are in screen units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the width parameter, which has meaning only for\n"
    "//               certain frame types.  For instance, this is the width\n"
    "//               of the bevel for T_bevel_in or T_bevel_out.  The\n"
    "//               units are in screen units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_width_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &PGFrameStyle::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_width_15(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &PGFrameStyle::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            LVecBase2f const *return_value = &(((const PGFrameStyle*)local_this)->get_width());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_width_15_comment =
    "C++ Interface:\n"
    "getWidth(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the width parameter, which has meaning only\n"
    "//               for certain frame types.  For instance, this is the\n"
    "//               width of the bevel for T_bevel_in or T_bevel_out.\n"
    "//               The units are in screen units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_width_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_uv_width(LVecBase2f const &uv_width)
 * inline void PGFrameStyle::set_uv_width(float u, float v)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_uv_width_16(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGFrameStyle::set_uv_width(LVecBase2f const &uv_width)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"uv_width", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUvWidth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setUvWidth", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PGFrameStyle.setUvWidth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_uv_width(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGFrameStyle.setUvWidth() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::set_uv_width(float u, float v)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"u", (char *)"v", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setUvWidth", key_word_list, &param1, &param2))
            {
                (local_this)->set_uv_width((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.setUvWidth() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setUvWidth() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setUvWidth(non-const PGFrameStyle this, const VBase2 uv_width)\n"
          "setUvWidth(non-const PGFrameStyle this, float u, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_uv_width_16_comment =
    "C++ Interface:\n"
    "setUvWidth(non-const PGFrameStyle this, const VBase2 uv_width)\n"
    "setUvWidth(non-const PGFrameStyle this, float u, float v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_uv_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the uv_width parameter, which indicates the\n"
    "//               amount of the texture that is consumed by the inner\n"
    "//               bevel--the width in texture space of the amount\n"
    "//               indicated by set_width.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_uv_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the uv_width parameter, which indicates the\n"
    "//               amount of the texture that is consumed by the inner\n"
    "//               bevel--the width in texture space of the amount\n"
    "//               indicated by set_width.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_uv_width_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &PGFrameStyle::get_uv_width(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_uv_width_17(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &PGFrameStyle::get_uv_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUvWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getUvWidth"));
        if(!PyErr_Occurred())
        {
            LVecBase2f const *return_value = &(((const PGFrameStyle*)local_this)->get_uv_width());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUvWidth(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_uv_width_17_comment =
    "C++ Interface:\n"
    "getUvWidth(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_uv_width\n"
    "//       Access: Published\n"
    "//  Description: See set_uv_width().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_uv_width_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGFrameStyle::set_visible_scale(LVecBase2f const &visible_scale)
 * inline void PGFrameStyle::set_visible_scale(float x, float y)
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_set_visible_scale_18(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGFrameStyle::set_visible_scale(LVecBase2f const &visible_scale)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"visible_scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVisibleScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setVisibleScale", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PGFrameStyle.setVisibleScale", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_visible_scale(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGFrameStyle.setVisibleScale() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGFrameStyle::set_visible_scale(float x, float y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setVisibleScale", key_word_list, &param1, &param2))
            {
                (local_this)->set_visible_scale((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGFrameStyle.setVisibleScale() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVisibleScale() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVisibleScale(non-const PGFrameStyle this, const VBase2 visible_scale)\n"
          "setVisibleScale(non-const PGFrameStyle this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_set_visible_scale_18_comment =
    "C++ Interface:\n"
    "setVisibleScale(non-const PGFrameStyle this, const VBase2 visible_scale)\n"
    "setVisibleScale(non-const PGFrameStyle this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_visible_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets a scale factor on the visible representation of\n"
    "//               the frame, in the X and Y directions.  If this scale\n"
    "//               factor is other than 1, it will affect the size of\n"
    "//               the visible frame representation within the actual\n"
    "//               frame border.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::set_visible_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets a scale factor on the visible representation of\n"
    "//               the frame, in the X and Y directions.  If this scale\n"
    "//               factor is other than 1, it will affect the size of\n"
    "//               the visible frame representation within the actual\n"
    "//               frame border.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_set_visible_scale_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &PGFrameStyle::get_visible_scale(void) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_visible_scale_19(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &PGFrameStyle::get_visible_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVisibleScale", key_word_list));
        else
            (PyArg_Parse(args, ":getVisibleScale"));
        if(!PyErr_Occurred())
        {
            LVecBase2f const *return_value = &(((const PGFrameStyle*)local_this)->get_visible_scale());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVisibleScale(const PGFrameStyle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_visible_scale_19_comment =
    "C++ Interface:\n"
    "getVisibleScale(const PGFrameStyle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_visible_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scale factor on the visible\n"
    "//               representation of the frame, in the X and Y\n"
    "//               directions.  If this scale factor is other than 1, it\n"
    "//               will affect the size of the visible frame\n"
    "//               representation within the actual frame border.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_visible_scale_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f PGFrameStyle::get_internal_frame(LVecBase4f const &frame) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_get_internal_frame_20(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LVecBase4f PGFrameStyle::get_internal_frame(LVecBase4f const &frame) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"frame", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getInternalFrame", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getInternalFrame", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PGFrameStyle.getInternalFrame", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LVecBase4f result = ((const PGFrameStyle*)local_this)->get_internal_frame(*param1_this);
                    LVecBase4f *return_value = new LVecBase4f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInternalFrame(const PGFrameStyle this, const VBase4 frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_get_internal_frame_20_comment =
    "C++ Interface:\n"
    "getInternalFrame(const PGFrameStyle this, const VBase4 frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::get_internal_frame\n"
    "//       Access: Published\n"
    "//  Description: Computes the size of the internal frame, given the\n"
    "//               indicated external frame, appropriate for this kind\n"
    "//               of frame style.  This simply subtracts the border\n"
    "//               width for those frame styles that include a border.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_get_internal_frame_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGFrameStyle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PGFrameStyle_output_21(PyObject *self, PyObject *args,PyObject *kwds) {
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PGFrameStyle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PGFrameStyle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PGFrameStyle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PGFrameStyle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGFrameStyle_output_21_comment =
    "C++ Interface:\n"
    "output(const PGFrameStyle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGFrameStyle::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGFrameStyle_output_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGFrameStyle::PGFrameStyle(void)
 * inline PGFrameStyle::PGFrameStyle(PGFrameStyle const &copy)
 *******************************************************************/
int  Dtool_Init_PGFrameStyle(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline PGFrameStyle::PGFrameStyle(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGFrameStyle", key_word_list))
            {
                PGFrameStyle *return_value = new PGFrameStyle();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGFrameStyle,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PGFrameStyle::PGFrameStyle(PGFrameStyle const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PGFrameStyle", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PGFrameStyle", &param0));
                if(!PyErr_Occurred())
                {
                    PGFrameStyle *param0_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PGFrameStyle, 0, "PGFrameStyle.PGFrameStyle", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PGFrameStyle *return_value = new PGFrameStyle(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PGFrameStyle,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PGFrameStyle() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PGFrameStyle()\n"
          "PGFrameStyle(const PGFrameStyle copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGFrameStyle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGFrameStyle)
    {
        printf("PGFrameStyle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGFrameStyle * local_this = (PGFrameStyle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGFrameStyle)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGFrameStyle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGFrameStyle)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGItem 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_name_25(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGItem::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const PGItem this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_name_25_comment =
    "C++ Interface:\n"
    "setName(non-const PGItem this, string name)\n"
    "\n"
    "// Filename: pgItem.I\n"
    "// Created by:  drose (13Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_name\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_name_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::set_frame(LVecBase4f const &frame)
 * inline void PGItem::set_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_frame_26(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGItem::set_frame(LVecBase4f const &frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PGItem.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGItem.setFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGItem::set_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGItem.setFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrame(non-const PGItem this, const VBase4 frame)\n"
          "setFrame(non-const PGItem this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_frame_26_comment =
    "C++ Interface:\n"
    "setFrame(non-const PGItem this, const VBase4 frame)\n"
    "setFrame(non-const PGItem this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the item, in local\n"
    "//               coordinates.  This is the region on screen within\n"
    "//               which the mouse will be considered to be within the\n"
    "//               item.  Normally, it should correspond to the bounding\n"
    "//               rectangle of the visible geometry of the item.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the item, in local\n"
    "//               coordinates.  This is the region on screen within\n"
    "//               which the mouse will be considered to be within the\n"
    "//               item.  Normally, it should correspond to the bounding\n"
    "//               rectangle of the visible geometry of the item.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_frame_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PGItem::get_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_frame_27(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PGItem::get_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PGItem*)local_this)->get_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrame(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_frame_27_comment =
    "C++ Interface:\n"
    "getFrame(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the bounding rectangle of the item.  See\n"
    "//               set_frame().  It is an error to call this if\n"
    "//               has_frame() returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_frame_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGItem::has_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_has_frame_28(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGItem::has_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasFrame", key_word_list));
        else
            (PyArg_Parse(args, ":hasFrame"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->has_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasFrame(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_has_frame_28_comment =
    "C++ Interface:\n"
    "hasFrame(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::has_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the item has a bounding rectangle;\n"
    "//               see set_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_has_frame_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::clear_frame(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_clear_frame_29(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGItem::clear_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFrame", key_word_list));
        else
            (PyArg_Parse(args, ":clearFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.clearFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFrame(non-const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_clear_frame_29_comment =
    "C++ Interface:\n"
    "clearFrame(non-const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::clear_frame\n"
    "//       Access: Published\n"
    "//  Description: Removes the bounding rectangle from the item.  It\n"
    "//               will no longer be possible to position the mouse\n"
    "//               within the item; see set_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_clear_frame_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::set_state(int state)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_state_30(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGItem::set_state(int state)
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setState", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setState", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_state((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setState() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setState(non-const PGItem this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_state_30_comment =
    "C++ Interface:\n"
    "setState(non-const PGItem this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_state\n"
    "//       Access: Published\n"
    "//  Description: Sets the \"state\" of this particular PGItem.  \n"
    "//\n"
    "//               The PGItem node will render as if it were the\n"
    "//               subgraph assigned to the corresponding index via\n"
    "//               set_state_def().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_state_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGItem::get_state(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_state_31(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGItem::get_state(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getState", key_word_list));
        else
            (PyArg_Parse(args, ":getState"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGItem*)local_this)->get_state();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getState(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_state_31_comment =
    "C++ Interface:\n"
    "getState(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_state\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"state\" of this particular PGItem.  See\n"
    "//               set_state().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_state_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PGItem::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_active_32(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void PGItem::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const PGItem this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_active_32_comment =
    "C++ Interface:\n"
    "setActive(non-const PGItem this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets whether the PGItem is active for mouse watching.\n"
    "//               This is not necessarily related to the\n"
    "//               active/inactive appearance of the item, which is\n"
    "//               controlled by set_state(), but it does affect whether\n"
    "//               it responds to mouse events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_active_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGItem::get_active(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_active_33(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGItem::get_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_active_33_comment =
    "C++ Interface:\n"
    "getActive(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_active\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the PGItem is currently active for\n"
    "//               mouse events.  See set_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_active_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PGItem::set_focus(bool focus)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_focus_34(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void PGItem::set_focus(bool focus)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"focus", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFocus", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFocus", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_focus((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setFocus() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFocus(non-const PGItem this, bool focus)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_focus_34_comment =
    "C++ Interface:\n"
    "setFocus(non-const PGItem this, bool focus)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_focus\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets whether the PGItem currently has keyboard focus.\n"
    "//               This simply means that the item may respond to\n"
    "//               keyboard events as well as to mouse events; precisely\n"
    "//               what this means is up to the individual item.  \n"
    "//\n"
    "//               Only one PGItem in the world is allowed to have focus\n"
    "//               at any given time.  Setting the focus on any other\n"
    "//               item automatically disables the focus from the\n"
    "//               previous item.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_focus_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGItem::get_focus(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_35(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGItem::get_focus(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocus", key_word_list));
        else
            (PyArg_Parse(args, ":getFocus"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->get_focus();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocus(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_35_comment =
    "C++ Interface:\n"
    "getFocus(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the PGItem currently has focus for\n"
    "//               keyboard events.  See set_focus().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGItem::set_background_focus(bool focus)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_background_focus_36(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGItem::set_background_focus(bool focus)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"focus", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBackgroundFocus", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBackgroundFocus", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_background_focus((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setBackgroundFocus() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBackgroundFocus(non-const PGItem this, bool focus)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_background_focus_36_comment =
    "C++ Interface:\n"
    "setBackgroundFocus(non-const PGItem this, bool focus)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_background_focus\n"
    "//       Access: Published\n"
    "//  Description: Sets the background_focus flag for this item.  When\n"
    "//               background_focus is enabled, the item will receive\n"
    "//               keypress events even if it is not in focus; in fact,\n"
    "//               even if it is not onscreen.  Unlike normal focus,\n"
    "//               many items may have background_focus simultaneously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_background_focus_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGItem::get_background_focus(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_background_focus_37(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGItem::get_background_focus(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBackgroundFocus", key_word_list));
        else
            (PyArg_Parse(args, ":getBackgroundFocus"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->get_background_focus();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBackgroundFocus(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_background_focus_37_comment =
    "C++ Interface:\n"
    "getBackgroundFocus(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_background_focus\n"
    "//       Access: Published\n"
    "//  Description: Returns whether background_focus is currently\n"
    "//               enabled.  See set_background_focus().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_background_focus_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::set_suppress_flags(int suppress_flags)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_suppress_flags_38(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGItem::set_suppress_flags(int suppress_flags)
        int param1;
        static char * key_word_list[] = {(char *)"suppress_flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSuppressFlags", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSuppressFlags", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_suppress_flags((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setSuppressFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSuppressFlags(non-const PGItem this, int suppress_flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_suppress_flags_38_comment =
    "C++ Interface:\n"
    "setSuppressFlags(non-const PGItem this, int suppress_flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_suppress_flags\n"
    "//       Access: Published\n"
    "//  Description: This is just an interface to set the suppress flags\n"
    "//               on the underlying MouseWatcherRegion.  See\n"
    "//               MouseWatcherRegion::set_suppress_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_suppress_flags_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGItem::get_suppress_flags(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_suppress_flags_39(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGItem::get_suppress_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSuppressFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getSuppressFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGItem*)local_this)->get_suppress_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuppressFlags(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_suppress_flags_39_comment =
    "C++ Interface:\n"
    "getSuppressFlags(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_suppress_flags\n"
    "//       Access: Published\n"
    "//  Description: This is just an interface to get the suppress flags\n"
    "//               on the underlying MouseWatcherRegion.  See\n"
    "//               MouseWatcherRegion::get_suppress_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_suppress_flags_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PGItem::get_num_state_defs(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_num_state_defs_40(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PGItem::get_num_state_defs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumStateDefs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumStateDefs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGItem*)local_this)->get_num_state_defs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumStateDefs(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_num_state_defs_40_comment =
    "C++ Interface:\n"
    "getNumStateDefs(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_num_state_defs\n"
    "//       Access: Published\n"
    "//  Description: Returns one more than the highest-numbered state def\n"
    "//               that was ever assigned to the PGItem.  The complete\n"
    "//               set of state defs assigned may then be retrieved by\n"
    "//               indexing from 0 to (get_num_state_defs() - 1).\n"
    "//\n"
    "//               This is only an upper limit on the actual number of\n"
    "//               state defs, since there may be holes in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_num_state_defs_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGItem::clear_state_def(int state)
 *******************************************************************/
static PyObject *Dtool_PGItem_clear_state_def_41(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGItem::clear_state_def(int state)
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearStateDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearStateDef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_state_def((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.clearStateDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearStateDef(non-const PGItem this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_clear_state_def_41_comment =
    "C++ Interface:\n"
    "clearStateDef(non-const PGItem this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::clear_state_def\n"
    "//       Access: Published\n"
    "//  Description: Resets the NodePath assigned to the indicated state\n"
    "//               to its initial default, with only a frame\n"
    "//               representation if appropriate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_clear_state_def_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGItem::has_state_def(int state) const
 *******************************************************************/
static PyObject *Dtool_PGItem_has_state_def_42(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PGItem::has_state_def(int state) const
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasStateDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasStateDef", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->has_state_def((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasStateDef(const PGItem this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_has_state_def_42_comment =
    "C++ Interface:\n"
    "hasStateDef(const PGItem this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::has_state_def\n"
    "//       Access: Published\n"
    "//  Description: Returns true if get_state_def() has ever been called\n"
    "//               for the indicated state (thus defining a render\n"
    "//               subgraph for this state index), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_has_state_def_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath &PGItem::get_state_def(int state)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_state_def_43(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePath &PGItem::get_state_def(int state)
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getStateDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getStateDef", &param1));
        if(!PyErr_Occurred())
        {
            NodePath *return_value = &((local_this)->get_state_def((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.getStateDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStateDef(non-const PGItem this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_state_def_43_comment =
    "C++ Interface:\n"
    "getStateDef(non-const PGItem this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_state_def\n"
    "//       Access: Published\n"
    "//  Description: Returns the Node that is the root of the subgraph\n"
    "//               that will be drawn when the PGItem is in the\n"
    "//               indicated state.  The first time this is called for a\n"
    "//               particular state index, it may create the Node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_state_def_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath PGItem::instance_to_state_def(int state, NodePath const &path)
 *******************************************************************/
static PyObject *Dtool_PGItem_instance_to_state_def_44(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-NodePath PGItem::instance_to_state_def(int state, NodePath const &path)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"state", (char *)"path", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:instanceToStateDef", key_word_list, &param1, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "PGItem.instanceToStateDef", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    NodePath result = (local_this)->instance_to_state_def((int)param1, *param2_this);
                    NodePath *return_value = new NodePath(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGItem.instanceToStateDef() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "instanceToStateDef(non-const PGItem this, int state, const NodePath path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_instance_to_state_def_44_comment =
    "C++ Interface:\n"
    "instanceToStateDef(non-const PGItem this, int state, const NodePath path)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::instance_to_state_def\n"
    "//       Access: Published\n"
    "//  Description: Parents an instance of the bottom node of the\n"
    "//               indicated NodePath to the indicated state index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_instance_to_state_def_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGFrameStyle PGItem::get_frame_style(int state)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_frame_style_45(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PGFrameStyle PGItem::get_frame_style(int state)
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFrameStyle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFrameStyle", &param1));
        if(!PyErr_Occurred())
        {
            PGFrameStyle result = (local_this)->get_frame_style((int)param1);
            PGFrameStyle *return_value = new PGFrameStyle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PGFrameStyle,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.getFrameStyle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameStyle(non-const PGItem this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_frame_style_45_comment =
    "C++ Interface:\n"
    "getFrameStyle(non-const PGItem this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_frame_style\n"
    "//       Access: Published\n"
    "//  Description: Returns the kind of frame that will be drawn behind\n"
    "//               the item when it is in the indicated state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_frame_style_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGItem::set_frame_style(int state, PGFrameStyle const &style)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_frame_style_46(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PGItem::set_frame_style(int state, PGFrameStyle const &style)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"state", (char *)"style", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setFrameStyle", key_word_list, &param1, &param2))
            {
                PGFrameStyle *param2_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PGFrameStyle, 2, "PGItem.setFrameStyle", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_frame_style((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGItem.setFrameStyle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameStyle(non-const PGItem this, int state, const PGFrameStyle style)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_frame_style_46_comment =
    "C++ Interface:\n"
    "setFrameStyle(non-const PGItem this, int state, const PGFrameStyle style)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_frame_style\n"
    "//       Access: Published\n"
    "//  Description: Changes the kind of frame that will be drawn behind\n"
    "//               the item when it is in the indicated state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_frame_style_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &PGItem::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_id_47(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &PGItem::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const PGItem*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_id_47_comment =
    "C++ Interface:\n"
    "getId(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the unique ID assigned to this PGItem.  This\n"
    "//               will be assigned to the region created with the\n"
    "//               MouseWatcher, and will thus be used to generate event\n"
    "//               names.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_id_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGItem::set_id(basic_string< char > const &id)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_id_48(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGItem::set_id(basic_string< char > const &id)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setId", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setId", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_id(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.setId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setId(non-const PGItem this, string id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_id_48_comment =
    "C++ Interface:\n"
    "setId(non-const PGItem this, string id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_id\n"
    "//       Access: Published\n"
    "//  Description: Set the unique ID assigned to this PGItem.  It is the\n"
    "//               user's responsibility to ensure that this ID is\n"
    "//               unique.\n"
    "//\n"
    "//               Normally, this should not need to be called, as the\n"
    "//               PGItem will assign itself an ID when it is created,\n"
    "//               but this function allows the user to decide to\n"
    "//               redefine the ID to be something possibly more\n"
    "//               meaningful.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_id_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_enter_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_enter_prefix_49(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_enter_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnterPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_enter_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnterPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_enter_prefix_49_comment =
    "C++ Interface:\n"
    "getEnterPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_enter_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the enter\n"
    "//               event for all PGItems.  The enter event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_enter_prefix_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_exit_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_exit_prefix_50(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_exit_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getExitPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_exit_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExitPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_exit_prefix_50_comment =
    "C++ Interface:\n"
    "getExitPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_exit_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the exit\n"
    "//               event for all PGItems.  The exit event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_exit_prefix_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_within_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_within_prefix_51(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_within_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithinPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_within_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithinPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_within_prefix_51_comment =
    "C++ Interface:\n"
    "getWithinPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_within_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the within\n"
    "//               event for all PGItems.  The within event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_within_prefix_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_without_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_without_prefix_52(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_without_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithoutPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_without_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithoutPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_without_prefix_52_comment =
    "C++ Interface:\n"
    "getWithoutPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_without_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the without\n"
    "//               event for all PGItems.  The without event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_without_prefix_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_focus_in_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_in_prefix_53(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_focus_in_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocusInPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_focus_in_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocusInPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_in_prefix_53_comment =
    "C++ Interface:\n"
    "getFocusInPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus_in_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the focus_in\n"
    "//               event for all PGItems.  The focus_in event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "//\n"
    "//               Unlike most item events, this event is thrown with no\n"
    "//               parameters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_in_prefix_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_focus_out_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_out_prefix_54(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_focus_out_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocusOutPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_focus_out_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocusOutPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_out_prefix_54_comment =
    "C++ Interface:\n"
    "getFocusOutPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus_out_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the focus_out\n"
    "//               event for all PGItems.  The focus_out event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "//\n"
    "//               Unlike most item events, this event is thrown with no\n"
    "//               parameters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_out_prefix_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_press_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_press_prefix_55(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_press_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getPressPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_press_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPressPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_press_prefix_55_comment =
    "C++ Interface:\n"
    "getPressPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_press_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the press\n"
    "//               event for all PGItems.  The press event is the\n"
    "//               concatenation of this string followed by a button\n"
    "//               name, followed by a hyphen and get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_press_prefix_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_repeat_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_repeat_prefix_56(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_repeat_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getRepeatPrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_repeat_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRepeatPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_repeat_prefix_56_comment =
    "C++ Interface:\n"
    "getRepeatPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_repeat_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the repeat\n"
    "//               event for all PGItems.  The repeat event is the\n"
    "//               concatenation of this string followed by a button\n"
    "//               name, followed by a hyphen and get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_repeat_prefix_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_release_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_release_prefix_57(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_release_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getReleasePrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_release_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReleasePrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_release_prefix_57_comment =
    "C++ Interface:\n"
    "getReleasePrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_release_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the release\n"
    "//               event for all PGItems.  The release event is the\n"
    "//               concatenation of this string followed by a button\n"
    "//               name, followed by a hyphen and get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_release_prefix_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGItem::get_keystroke_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_keystroke_prefix_58(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGItem::get_keystroke_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeystrokePrefix", key_word_list))
        {
            basic_string< char > return_value = PGItem::get_keystroke_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeystrokePrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_keystroke_prefix_58_comment =
    "C++ Interface:\n"
    "getKeystrokePrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_keystroke_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the\n"
    "//               keystroke event for all PGItems.  The keystroke event\n"
    "//               is the concatenation of this string followed by a\n"
    "//               hyphen and get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_keystroke_prefix_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_enter_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_enter_event_59(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_enter_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnterEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getEnterEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_enter_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnterEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_enter_event_59_comment =
    "C++ Interface:\n"
    "getEnterEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_enter_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the mouse enters its frame, but\n"
    "//               not any nested frames.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_enter_event_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_exit_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_exit_event_60(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_exit_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExitEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getExitEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_exit_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExitEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_exit_event_60_comment =
    "C++ Interface:\n"
    "getExitEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_exit_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the mouse exits its frame, or\n"
    "//               enters a nested frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_exit_event_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_within_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_within_event_61(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_within_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithinEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getWithinEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_within_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithinEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_within_event_61_comment =
    "C++ Interface:\n"
    "getWithinEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_within_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the mouse moves within the\n"
    "//               boundaries of the frame.  This is different from the\n"
    "//               enter_event in that the mouse is considered within\n"
    "//               the frame even if it is also within a nested frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_within_event_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_without_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_without_event_62(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_without_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithoutEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getWithoutEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_without_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithoutEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_without_event_62_comment =
    "C++ Interface:\n"
    "getWithoutEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_without_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the mouse moves completely outside\n"
    "//               the boundaries of the frame.  This is different from\n"
    "//               the exit_event in that the mouse is considered\n"
    "//               within the frame even if it is also within a nested\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_without_event_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_focus_in_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_in_event_63(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_focus_in_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocusInEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getFocusInEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_focus_in_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocusInEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_in_event_63_comment =
    "C++ Interface:\n"
    "getFocusInEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus_in_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item gets the keyboard focus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_in_event_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_focus_out_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_out_event_64(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_focus_out_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocusOutEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getFocusOutEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_focus_out_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocusOutEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_out_event_64_comment =
    "C++ Interface:\n"
    "getFocusOutEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus_out_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item loses the keyboard focus.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_out_event_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_press_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_press_event_65(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGItem::get_press_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPressEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getPressEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGItem.getPressEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGItem*)local_this)->get_press_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPressEvent(const PGItem this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_press_event_65_comment =
    "C++ Interface:\n"
    "getPressEvent(const PGItem this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_press_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the indicated mouse or keyboard\n"
    "//               button is depressed while the mouse is within the\n"
    "//               frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_press_event_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_repeat_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_repeat_event_66(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGItem::get_repeat_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getRepeatEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getRepeatEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGItem.getRepeatEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGItem*)local_this)->get_repeat_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRepeatEvent(const PGItem this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_repeat_event_66_comment =
    "C++ Interface:\n"
    "getRepeatEvent(const PGItem this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_repeat_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the indicated mouse or keyboard\n"
    "//               button is continuously held down while the mouse is\n"
    "//               within the frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_repeat_event_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_release_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_release_event_67(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGItem::get_release_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getReleaseEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getReleaseEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGItem.getReleaseEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGItem*)local_this)->get_release_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReleaseEvent(const PGItem this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_release_event_67_comment =
    "C++ Interface:\n"
    "getReleaseEvent(const PGItem this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_release_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and the indicated mouse or keyboard\n"
    "//               button, formerly clicked down is within the frame, is\n"
    "//               released.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_release_event_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGItem::get_keystroke_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_keystroke_event_68(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGItem::get_keystroke_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeystrokeEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getKeystrokeEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGItem*)local_this)->get_keystroke_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeystrokeEvent(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_keystroke_event_68_comment =
    "C++ Interface:\n"
    "getKeystrokeEvent(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_keystroke_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               item is active and any key is pressed by the user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_keystroke_event_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f PGItem::get_frame_inv_xform(void) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_frame_inv_xform_69(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f PGItem::get_frame_inv_xform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameInvXform", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameInvXform"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const PGItem*)local_this)->get_frame_inv_xform();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameInvXform(const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_frame_inv_xform_69_comment =
    "C++ Interface:\n"
    "getFrameInvXform(const PGItem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_frame_inv_xform\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the inverse of the frame transform matrix\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_frame_inv_xform_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGItem::set_sound(basic_string< char > const &event, AudioSound *sound)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_sound_70(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PGItem::set_sound(basic_string< char > const &event, AudioSound *sound)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"event", (char *)"sound", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:setSound", key_word_list, &param1_str, &param1_len, &param2))
            {
                AudioSound *param2_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_AudioSound, 2, "PGItem.setSound", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_sound(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGItem.setSound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSound(non-const PGItem this, string event, non-const AudioSound sound)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_sound_70_comment =
    "C++ Interface:\n"
    "setSound(non-const PGItem this, string event, non-const AudioSound sound)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_sound\n"
    "//       Access: Published\n"
    "//  Description: Sets the sound that will be played whenever the\n"
    "//               indicated event occurs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_sound_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGItem::clear_sound(basic_string< char > const &event)
 *******************************************************************/
static PyObject *Dtool_PGItem_clear_sound_71(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGItem::clear_sound(basic_string< char > const &event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:clearSound", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:clearSound", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_sound(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.clearSound() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSound(non-const PGItem this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_clear_sound_71_comment =
    "C++ Interface:\n"
    "clearSound(non-const PGItem this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::clear_sound\n"
    "//       Access: Published\n"
    "//  Description: Removes the sound associated with the indicated\n"
    "//               event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_clear_sound_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AudioSound *PGItem::get_sound(basic_string< char > const &event) const
 *******************************************************************/
static PyObject *Dtool_PGItem_get_sound_72(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AudioSound *PGItem::get_sound(basic_string< char > const &event) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getSound", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getSound", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AudioSound *return_value = ((const PGItem*)local_this)->get_sound(basic_string<char>(param1_str, param1_len));
            if (return_value != (AudioSound *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AudioSound,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSound(const PGItem this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_sound_72_comment =
    "C++ Interface:\n"
    "getSound(const PGItem this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_sound\n"
    "//       Access: Published\n"
    "//  Description: Returns the sound associated with the indicated\n"
    "//               event, or NULL if there is no associated sound.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_sound_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGItem::has_sound(basic_string< char > const &event) const
 *******************************************************************/
static PyObject *Dtool_PGItem_has_sound_73(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PGItem::has_sound(basic_string< char > const &event) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasSound", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:hasSound", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGItem*)local_this)->has_sound(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSound(const PGItem this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_has_sound_73_comment =
    "C++ Interface:\n"
    "hasSound(const PGItem this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::has_sound\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there is a sound associated with the\n"
    "//               indicated event, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_has_sound_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TextNode *PGItem::get_text_node(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_text_node_74(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TextNode *PGItem::get_text_node(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextNode", key_word_list))
        {
            TextNode *return_value = PGItem::get_text_node();
            if (return_value != (TextNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextNode()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_text_node_74_comment =
    "C++ Interface:\n"
    "getTextNode()\n"
    "\n"
    "// HAVE_AUDIO\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_text_node\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the TextNode object that will be used by all\n"
    "//               PGItems to generate default labels given a string.\n"
    "//               This can be loaded with the default font, etc.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_text_node_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void PGItem::set_text_node(TextNode *node)
 *******************************************************************/
static PyObject *Dtool_PGItem_set_text_node_75(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void PGItem::set_text_node(TextNode *node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTextNode", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setTextNode", &param0));
            if(!PyErr_Occurred())
            {
                TextNode *param0_this = (TextNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TextNode, 0, "PGItem.setTextNode", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PGItem::set_text_node(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextNode(non-const TextNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_set_text_node_75_comment =
    "C++ Interface:\n"
    "setTextNode(non-const TextNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::set_text_node\n"
    "//       Access: Published, Static\n"
    "//  Description: Changes the TextNode object that will be used by all\n"
    "//               PGItems to generate default labels given a string.\n"
    "//               This can be loaded with the default font, etc.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_set_text_node_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline PGItem *PGItem::get_focus_item(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_focus_item_76(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline PGItem *PGItem::get_focus_item(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getFocusItem", key_word_list))
        {
            PGItem *return_value = PGItem::get_focus_item();
            if (return_value != (PGItem *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGItem,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFocusItem()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_focus_item_76_comment =
    "C++ Interface:\n"
    "getFocusItem()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGItem::get_focus_item\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the one PGItem in the world that currently\n"
    "//               has keyboard focus, if any, or NULL if no item has\n"
    "//               keyboard focus.  Use PGItem::set_focus() to activate\n"
    "//               or deactivate keyboard focus on a particular item.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGItem_get_focus_item_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGItem::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGItem::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGItem::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGItem_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGSliderBar *PGItem::downcast_to_PGSliderBar(void)
 *******************************************************************/
static PyObject *Dtool_PGItem_downcast_to_PGSliderBar_181(PyObject *self, PyObject *args,PyObject *kwds) {
    PGItem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGItem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PGSliderBar *PGItem::downcast_to_PGSliderBar(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToPGSliderBar", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToPGSliderBar"));
        if(!PyErr_Occurred())
        {
            PGSliderBar *return_value = (PGSliderBar *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGSliderBar,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGItem.downcastToPGSliderBar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToPGSliderBar(non-const PGItem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGItem_downcast_to_PGSliderBar_181_comment =
    "C++ Interface:\n"
    "downcastToPGSliderBar(non-const PGItem this)\n"
    "\n"
    "downcast from PGItem to PGSliderBar\n"
    "";
#else
static const char * Dtool_PGItem_downcast_to_PGSliderBar_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGItem::PGItem(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PGItem(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PGItem::PGItem(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGItem", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PGItem", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PGItem *return_value = new PGItem(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PGItem,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PGItem(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PGItem_get_state_defs(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumStateDefs", "getStateDef");
}
inline void  * Dtool_UpcastInterface_PGItem(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGItem)
    {
        printf("PGItem ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGItem * local_this = (PGItem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGItem)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGItem(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGItem)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGItem*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGItem*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGItem*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGItem*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGButton 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PGButton::setup(NodePath const &ready)
 * inline void PGButton::setup(NodePath const &ready, NodePath const &depressed)
 * inline void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover)
 * void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover, NodePath const &inactive)
 * void PGButton::setup(basic_string< char > const &label, float bevel)
 * void PGButton::setup(basic_string< char > const &label, float bevel = (0.1))
 *******************************************************************/
static PyObject *Dtool_PGButton_setup_81(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PGButton::setup(NodePath const &ready)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"ready", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setup", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setup", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "PGButton.setup", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->setup(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void PGButton::setup(basic_string< char > const &label, float bevel = (0.1))
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"label", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setup", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:setup", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    (local_this)->setup(basic_string<char>(param1_str, param1_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PGButton::setup(NodePath const &ready, NodePath const &depressed)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"ready", (char *)"depressed", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setup", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "PGButton.setup", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->setup(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void PGButton::setup(basic_string< char > const &label, float bevel)
                char *param1_str; int param1_len;
                double param2;
                static char * key_word_list[] = {(char *)"label", (char *)"bevel", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:setup", key_word_list, &param1_str, &param1_len, &param2))
                {
                    (local_this)->setup(basic_string<char>(param1_str, param1_len), (float)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"ready", (char *)"depressed", (char *)"rollover", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setup", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "PGButton.setup", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->setup(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGButton.setup() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PGButton::setup(NodePath const &ready, NodePath const &depressed, NodePath const &rollover, NodePath const &inactive)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"ready", (char *)"depressed", (char *)"rollover", (char *)"inactive", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:setup", key_word_list, &param1, &param2, &param3, &param4))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "PGButton.setup", 1, coerced_ptr, report_errors);
NodePath *param4_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_NodePath, 4, "PGButton.setup", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->setup(*param1_this, *param2_this, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGButton.setup() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setup() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setup(non-const PGButton this, const NodePath ready)\n"
          "setup(non-const PGButton this, string label)\n"
          "setup(non-const PGButton this, const NodePath ready, const NodePath depressed)\n"
          "setup(non-const PGButton this, string label, float bevel)\n"
          "setup(non-const PGButton this, const NodePath ready, const NodePath depressed, const NodePath rollover)\n"
          "setup(non-const PGButton this, const NodePath ready, const NodePath depressed, const NodePath rollover, const NodePath inactive)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_setup_81_comment =
    "C++ Interface:\n"
    "setup(non-const PGButton this, const NodePath ready)\n"
    "setup(non-const PGButton this, string label)\n"
    "setup(non-const PGButton this, const NodePath ready, const NodePath depressed)\n"
    "setup(non-const PGButton this, string label, float bevel)\n"
    "setup(non-const PGButton this, const NodePath ready, const NodePath depressed, const NodePath rollover)\n"
    "setup(non-const PGButton this, const NodePath ready, const NodePath depressed, const NodePath rollover, const NodePath inactive)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the button using the indicated NodePath as\n"
    "//               arbitrary geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the button using the indicated NodePath as\n"
    "//               arbitrary geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the button using the indicated NodePath as\n"
    "//               arbitrary geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the button as a default text button using the\n"
    "//               indicated label string.  The TextNode defined by\n"
    "//               PGItem::get_text_node() will be used to create the\n"
    "//               label geometry.  This automatically sets up the frame\n"
    "//               according to the size of the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the button using the indicated NodePath as\n"
    "//               arbitrary geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_setup_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGButton::add_click_button(ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_PGButton_add_click_button_82(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PGButton::add_click_button(ButtonHandle const &button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addClickButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addClickButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGButton.addClickButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_click_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGButton.addClickButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addClickButton(non-const PGButton this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_add_click_button_82_comment =
    "C++ Interface:\n"
    "addClickButton(non-const PGButton this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::add_click_button\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated button to the set of buttons that\n"
    "//               can effectively \"click\" the PGButton.  Normally, this\n"
    "//               is just MouseButton::one().  Returns true if the\n"
    "//               button was added, or false if it was already there.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_add_click_button_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGButton::remove_click_button(ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_PGButton_remove_click_button_83(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PGButton::remove_click_button(ButtonHandle const &button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeClickButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeClickButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGButton.removeClickButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_click_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGButton.removeClickButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeClickButton(non-const PGButton this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_remove_click_button_83_comment =
    "C++ Interface:\n"
    "removeClickButton(non-const PGButton this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::remove_click_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated button from the set of buttons\n"
    "//               that can effectively \"click\" the PGButton.  Normally,\n"
    "//               this is just MouseButton::one().  Returns true if the\n"
    "//               button was removed, or false if it was not in the\n"
    "//               set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_remove_click_button_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGButton::has_click_button(ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_PGButton_has_click_button_84(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PGButton::has_click_button(ButtonHandle const &button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasClickButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasClickButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGButton.hasClickButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->has_click_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGButton.hasClickButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasClickButton(non-const PGButton this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_has_click_button_84_comment =
    "C++ Interface:\n"
    "hasClickButton(non-const PGButton this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::has_click_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is on the set of\n"
    "//               buttons that can effectively \"click\" the PGButton.\n"
    "//               Normally, this is just MouseButton::one().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_has_click_button_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGButton::is_button_down(void)
 *******************************************************************/
static PyObject *Dtool_PGButton_is_button_down_85(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool PGButton::is_button_down(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isButtonDown", key_word_list));
        else
            (PyArg_Parse(args, ":isButtonDown"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_button_down();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGButton.isButtonDown() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isButtonDown(non-const PGButton this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_is_button_down_85_comment =
    "C++ Interface:\n"
    "isButtonDown(non-const PGButton this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::is_button_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the user is currently holding the\n"
    "//               mouse button down on the button, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_is_button_down_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGButton::get_click_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGButton_get_click_prefix_86(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGButton::get_click_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClickPrefix", key_word_list))
        {
            basic_string< char > return_value = PGButton::get_click_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClickPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_get_click_prefix_86_comment =
    "C++ Interface:\n"
    "getClickPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::get_click_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the click\n"
    "//               event for all PGButtons.  The click event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_get_click_prefix_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGButton::get_click_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGButton_get_click_event_87(PyObject *self, PyObject *args,PyObject *kwds) {
    PGButton * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGButton,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGButton::get_click_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getClickEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getClickEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGButton.getClickEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGButton*)local_this)->get_click_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClickEvent(const PGButton this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_get_click_event_87_comment =
    "C++ Interface:\n"
    "getClickEvent(const PGButton this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGButton::get_click_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               button is clicked normally.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGButton_get_click_event_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGButton::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGButton_get_class_type_88(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGButton::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGButton::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGButton_get_class_type_88_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGButton_get_class_type_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGButton::PGButton(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PGButton(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PGButton::PGButton(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGButton", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PGButton", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PGButton *return_value = new PGButton(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PGButton,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PGButton(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGButton(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGButton)
    {
        printf("PGButton ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGButton * local_this = (PGButton *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGButton)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGButton(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGButton)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGButton*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGButton*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGButton*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGButton*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGButton*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGTop 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGTop::set_mouse_watcher(MouseWatcher *watcher)
 *******************************************************************/
static PyObject *Dtool_PGTop_set_mouse_watcher_91(PyObject *self, PyObject *args,PyObject *kwds) {
    PGTop * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGTop,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PGTop::set_mouse_watcher(MouseWatcher *watcher)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"watcher", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMouseWatcher", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMouseWatcher", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcher *param1_this = (MouseWatcher *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcher, 1, "PGTop.setMouseWatcher", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_mouse_watcher(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGTop.setMouseWatcher() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMouseWatcher(non-const PGTop this, non-const MouseWatcher watcher)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_set_mouse_watcher_91_comment =
    "C++ Interface:\n"
    "setMouseWatcher(non-const PGTop this, non-const MouseWatcher watcher)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGTop::set_mouse_watcher\n"
    "//       Access: Published\n"
    "//  Description: Sets the MouseWatcher pointer that the PGTop object\n"
    "//               registers its PG items with.  This must be set before\n"
    "//               the PG items are active.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGTop_set_mouse_watcher_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MouseWatcher *PGTop::get_mouse_watcher(void) const
 *******************************************************************/
static PyObject *Dtool_PGTop_get_mouse_watcher_92(PyObject *self, PyObject *args,PyObject *kwds) {
    PGTop * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGTop,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline MouseWatcher *PGTop::get_mouse_watcher(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouseWatcher", key_word_list));
        else
            (PyArg_Parse(args, ":getMouseWatcher"));
        if(!PyErr_Occurred())
        {
            MouseWatcher *return_value = ((const PGTop*)local_this)->get_mouse_watcher();
            if (return_value != (MouseWatcher *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcher,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouseWatcher(const PGTop this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_get_mouse_watcher_92_comment =
    "C++ Interface:\n"
    "getMouseWatcher(const PGTop this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGTop::get_mouse_watcher\n"
    "//       Access: Published\n"
    "//  Description: Returns the MouseWatcher pointer that the PGTop object\n"
    "//               registers its PG items with, or NULL if the\n"
    "//               MouseWatcher has not yet been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGTop_get_mouse_watcher_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MouseWatcherGroup *PGTop::get_group(void) const
 *******************************************************************/
static PyObject *Dtool_PGTop_get_group_93(PyObject *self, PyObject *args,PyObject *kwds) {
    PGTop * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGTop,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline MouseWatcherGroup *PGTop::get_group(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGroup", key_word_list));
        else
            (PyArg_Parse(args, ":getGroup"));
        if(!PyErr_Occurred())
        {
            MouseWatcherGroup *return_value = ((const PGTop*)local_this)->get_group();
            if (return_value != (MouseWatcherGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MouseWatcherGroup,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGroup(const PGTop this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_get_group_93_comment =
    "C++ Interface:\n"
    "getGroup(const PGTop this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGTop::get_group\n"
    "//       Access: Published\n"
    "//  Description: Returns the MouseWatcherGroup pointer that the PGTop\n"
    "//               object registers its PG items with, or NULL if the\n"
    "//               MouseWatcher has not yet been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGTop_get_group_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGTop::set_start_sort(int start_sort)
 *******************************************************************/
static PyObject *Dtool_PGTop_set_start_sort_94(PyObject *self, PyObject *args,PyObject *kwds) {
    PGTop * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGTop,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGTop::set_start_sort(int start_sort)
        int param1;
        static char * key_word_list[] = {(char *)"start_sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setStartSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setStartSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_start_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGTop.setStartSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartSort(non-const PGTop this, int start_sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_set_start_sort_94_comment =
    "C++ Interface:\n"
    "setStartSort(non-const PGTop this, int start_sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGTop::set_start_sort\n"
    "//       Access: Published\n"
    "//  Description: Specifies the sort index that is assigned during the\n"
    "//               traversal to the first PGItem that is discovered\n"
    "//               during traversal.  Subsequent PGItems will be\n"
    "//               assigned consecutively higher sort indexes.\n"
    "//\n"
    "//               This number is used by the MouseWatcher system to\n"
    "//               rank the clickable mouse regions in the same order in\n"
    "//               which the items are rendered, so that items on top\n"
    "//               will receive mouse priority.\n"
    "//\n"
    "//               Normally, it makes the most sense to leave this\n"
    "//               initial value at its default value of 0, unless you\n"
    "//               need the PGItems to have a particular sort value with\n"
    "//               respect to some other objects in the scene\n"
    "//               (particularly with a second PGTop node).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGTop_set_start_sort_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGTop::get_start_sort(void) const
 *******************************************************************/
static PyObject *Dtool_PGTop_get_start_sort_95(PyObject *self, PyObject *args,PyObject *kwds) {
    PGTop * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGTop,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGTop::get_start_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartSort", key_word_list));
        else
            (PyArg_Parse(args, ":getStartSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGTop*)local_this)->get_start_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartSort(const PGTop this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_get_start_sort_95_comment =
    "C++ Interface:\n"
    "getStartSort(const PGTop this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGTop::get_start_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the sort index that is assigned during the\n"
    "//               traversal to the first PGItem that is discovered\n"
    "//               during traversal.  See set_start_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGTop_get_start_sort_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGTop::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGTop_get_class_type_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGTop::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGTop::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGTop_get_class_type_96_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGTop_get_class_type_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGTop::PGTop(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PGTop(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PGTop::PGTop(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGTop", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PGTop", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PGTop *return_value = new PGTop(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PGTop,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PGTop(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGTop(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGTop)
    {
        printf("PGTop ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGTop * local_this = (PGTop *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGTop)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGTop(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGTop)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGTop*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGTop*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGTop*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGTop*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGEntry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGEntry::setup(float width, int num_lines)
 *******************************************************************/
static PyObject *Dtool_PGEntry_setup_100(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGEntry::setup(float width, int num_lines)
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"width", (char *)"num_lines", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:setup", key_word_list, &param1, &param2))
        {
            (local_this)->setup((float)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setup(non-const PGEntry this, float width, int num_lines)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_setup_100_comment =
    "C++ Interface:\n"
    "setup(non-const PGEntry this, float width, int num_lines)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::setup\n"
    "//       Access: Published\n"
    "//  Description: Sets up the entry for normal use.  The width is the\n"
    "//               maximum width of characters that will be typed, and\n"
    "//               num_lines is the integer number of lines of text of\n"
    "//               the entry.  Both of these together determine the size\n"
    "//               of the entry, based on the TextNode in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_setup_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGEntry::setup_minimal(float width, int num_lines)
 *******************************************************************/
static PyObject *Dtool_PGEntry_setup_minimal_101(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGEntry::setup_minimal(float width, int num_lines)
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"width", (char *)"num_lines", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:setupMinimal", key_word_list, &param1, &param2))
        {
            (local_this)->setup_minimal((float)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setupMinimal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupMinimal(non-const PGEntry this, float width, int num_lines)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_setup_minimal_101_comment =
    "C++ Interface:\n"
    "setupMinimal(non-const PGEntry this, float width, int num_lines)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::setup_minimal\n"
    "//       Access: Published\n"
    "//  Description: Sets up the entry without creating any frame or other\n"
    "//               decoration.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_setup_minimal_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGEntry::set_text(basic_string< char > const &text)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_text_102(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool PGEntry::set_text(basic_string< char > const &text)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"text", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setText", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setText", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_text(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setText() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setText(non-const PGEntry this, string text)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_text_102_comment =
    "C++ Interface:\n"
    "setText(non-const PGEntry this, string text)\n"
    "\n"
    "// Filename: pgEntry.I\n"
    "// Created by:  drose (13Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_text\n"
    "//       Access: Published\n"
    "//  Description: Changes the text currently displayed within the\n"
    "//               entry.  This uses the Unicode encoding currently\n"
    "//               specified for the \"focus\" TextNode; therefore, the\n"
    "//               TextNode must exist before calling set_text().\n"
    "//\n"
    "//               The return value is true if all the text is accepted,\n"
    "//               or false if some was truncated (see set_max_width(),\n"
    "//               etc.).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_text_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_plain_text(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_plain_text_103(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_plain_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlainText", key_word_list));
        else
            (PyArg_Parse(args, ":getPlainText"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_plain_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlainText(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_plain_text_103_comment =
    "C++ Interface:\n"
    "getPlainText(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_plain_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the text currently displayed within the\n"
    "//               entry, without any embedded properties characters.\n"
    "//\n"
    "//               This uses the Unicode encoding currently specified\n"
    "//               for the \"focus\" TextNode; therefore, the TextNode\n"
    "//               must exist before calling get_text().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_plain_text_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_text(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_text_104(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getText", key_word_list));
        else
            (PyArg_Parse(args, ":getText"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getText(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_text_104_comment =
    "C++ Interface:\n"
    "getText(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the text currently displayed within the\n"
    "//               entry.  This uses the Unicode encoding currently\n"
    "//               specified for the \"focus\" TextNode; therefore, the\n"
    "//               TextNode must exist before calling get_text().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_text_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGEntry::get_num_characters(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_num_characters_105(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGEntry::get_num_characters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCharacters", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCharacters"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGEntry*)local_this)->get_num_characters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCharacters(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_num_characters_105_comment =
    "C++ Interface:\n"
    "getNumCharacters(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_num_characters\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of characters of text in the\n"
    "//               entry.  This is the actual number of visible\n"
    "//               characters, not counting implicit newlines due to\n"
    "//               wordwrapping, or formatted characters for text\n"
    "//               properties changes.  If there is an embedded\n"
    "//               TextGraphic object, it counts as one character.\n"
    "//\n"
    "//               This is also the length of the string returned by\n"
    "//               get_plain_text().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_num_characters_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline wchar_t PGEntry::get_character(int n) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_character_106(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline wchar_t PGEntry::get_character(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCharacter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCharacter", &param1));
        if(!PyErr_Occurred())
        {
            wchar_t return_value = ((const PGEntry*)local_this)->get_character((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCharacter(const PGEntry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_character_106_comment =
    "C++ Interface:\n"
    "getCharacter(const PGEntry this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_character\n"
    "//       Access: Published\n"
    "//  Description: Returns the character at the indicated position in\n"
    "//               the entry.  If the object at this position is a\n"
    "//               graphic object instead of a character, returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_character_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextGraphic const *PGEntry::get_graphic(int n) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_graphic_107(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextGraphic const *PGEntry::get_graphic(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGraphic", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getGraphic", &param1));
        if(!PyErr_Occurred())
        {
            TextGraphic const *return_value = ((const PGEntry*)local_this)->get_graphic((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextGraphic,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGraphic(const PGEntry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_graphic_107_comment =
    "C++ Interface:\n"
    "getGraphic(const PGEntry this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_graphic\n"
    "//       Access: Published\n"
    "//  Description: Returns the graphic object at the indicated position\n"
    "//               in the pre-wordwrapped string.  If the object at this\n"
    "//               position is a character instead of a graphic object,\n"
    "//               returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_graphic_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextProperties const &PGEntry::get_properties(int n) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_properties_108(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextProperties const &PGEntry::get_properties(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getProperties", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getProperties", &param1));
        if(!PyErr_Occurred())
        {
            TextProperties const *return_value = &(((const PGEntry*)local_this)->get_properties((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TextProperties,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProperties(const PGEntry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_properties_108_comment =
    "C++ Interface:\n"
    "getProperties(const PGEntry this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_properties\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextProperties in effect for the object\n"
    "//               at the indicated position in the pre-wordwrapped\n"
    "//               string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_properties_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_cursor_position(int position)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_cursor_position_109(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_cursor_position(int position)
        int param1;
        static char * key_word_list[] = {(char *)"position", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCursorPosition", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCursorPosition", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cursor_position((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setCursorPosition() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCursorPosition(non-const PGEntry this, int position)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_cursor_position_109_comment =
    "C++ Interface:\n"
    "setCursorPosition(non-const PGEntry this, int position)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_cursor_position\n"
    "//       Access: Published\n"
    "//  Description: Sets the current position of the cursor.  This is the\n"
    "//               position within the text at which the next letter\n"
    "//               typed by the user will be inserted; normally it is\n"
    "//               the same as the length of the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_cursor_position_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGEntry::get_cursor_position(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursor_position_110(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGEntry::get_cursor_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorPosition"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGEntry*)local_this)->get_cursor_position();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorPosition(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursor_position_110_comment =
    "C++ Interface:\n"
    "getCursorPosition(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursor_position\n"
    "//       Access: Published\n"
    "//  Description: Returns the current position of the cursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursor_position_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGEntry::get_cursor_X(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursor_X_111(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGEntry::get_cursor_X(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorX", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorX"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGEntry*)local_this)->get_cursor_X();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorX(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursor_X_111_comment =
    "C++ Interface:\n"
    "getCursorX(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursor_X\n"
    "//       Access: Published\n"
    "//  Description: Returns the node position x of the cursor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursor_X_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGEntry::get_cursor_Y(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursor_Y_112(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGEntry::get_cursor_Y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorY", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorY"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGEntry*)local_this)->get_cursor_Y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorY(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursor_Y_112_comment =
    "C++ Interface:\n"
    "getCursorY(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursor_y\n"
    "//       Access: Published\n"
    "//  Description: Returns the node position y of the cursor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursor_Y_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_max_chars(int max_chars)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_max_chars_113(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_max_chars(int max_chars)
        int param1;
        static char * key_word_list[] = {(char *)"max_chars", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxChars", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxChars", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_chars((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setMaxChars() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxChars(non-const PGEntry this, int max_chars)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_max_chars_113_comment =
    "C++ Interface:\n"
    "setMaxChars(non-const PGEntry this, int max_chars)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_max_chars\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum number of characters that may be\n"
    "//               typed into the entry.  This is a limit on the number\n"
    "//               of characters, as opposed to the width of the entry;\n"
    "//               see also set_max_width().\n"
    "//\n"
    "//               If this is 0, there is no limit.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_max_chars_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGEntry::get_max_chars(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_max_chars_114(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGEntry::get_max_chars(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxChars", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxChars"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGEntry*)local_this)->get_max_chars();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxChars(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_max_chars_114_comment =
    "C++ Interface:\n"
    "getMaxChars(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_max_chars\n"
    "//       Access: Published\n"
    "//  Description: Returns the current maximum number of characters that\n"
    "//               may be typed into the entry, or 0 if there is no\n"
    "//               limit.  See set_max_chars().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_max_chars_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_max_width(float max_width)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_max_width_115(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_max_width(float max_width)
        double param1;
        static char * key_word_list[] = {(char *)"max_width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setMaxWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxWidth(non-const PGEntry this, float max_width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_max_width_115_comment =
    "C++ Interface:\n"
    "setMaxWidth(non-const PGEntry this, float max_width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_max_width\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum width of all characters that may be\n"
    "//               typed into the entry.  This is a limit on the width\n"
    "//               of the formatted text, not a fixed limit on the\n"
    "//               number of characters; also set_max_chars().\n"
    "//\n"
    "//               If this is 0, there is no limit.\n"
    "//\n"
    "//               If _num_lines is more than 1, rather than being a\n"
    "//               fixed width on the whole entry, this becomes instead\n"
    "//               the wordwrap width (and the width limit on the entry\n"
    "//               is essentially _max_width * _num_lines).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_max_width_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGEntry::get_max_width(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_max_width_116(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGEntry::get_max_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGEntry*)local_this)->get_max_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxWidth(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_max_width_116_comment =
    "C++ Interface:\n"
    "getMaxWidth(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_max_width\n"
    "//       Access: Published\n"
    "//  Description: Returns the current maximum width of the characters\n"
    "//               that may be typed into the entry, or 0 if there is no\n"
    "//               limit.  See set_max_width().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_max_width_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_num_lines(int num_lines)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_num_lines_117(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_num_lines(int num_lines)
        int param1;
        static char * key_word_list[] = {(char *)"num_lines", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumLines", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumLines", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_lines((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setNumLines() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumLines(non-const PGEntry this, int num_lines)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_num_lines_117_comment =
    "C++ Interface:\n"
    "setNumLines(non-const PGEntry this, int num_lines)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_num_lines\n"
    "//       Access: Published\n"
    "//  Description: Sets the number of lines of text the PGEntry will\n"
    "//               use.  This only has meaning if _max_width is not 0;\n"
    "//               _max_width indicates the wordwrap width of each line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_num_lines_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PGEntry::get_num_lines(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_num_lines_118(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PGEntry::get_num_lines(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLines", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLines"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PGEntry*)local_this)->get_num_lines();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLines(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_num_lines_118_comment =
    "C++ Interface:\n"
    "getNumLines(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_num_lines\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of lines of text the PGEntry will\n"
    "//               use, if _max_width is not 0.  See set_num_lines().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_num_lines_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_blink_rate(float blink_rate)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_blink_rate_119(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_blink_rate(float blink_rate)
        double param1;
        static char * key_word_list[] = {(char *)"blink_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBlinkRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBlinkRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_blink_rate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setBlinkRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlinkRate(non-const PGEntry this, float blink_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_blink_rate_119_comment =
    "C++ Interface:\n"
    "setBlinkRate(non-const PGEntry this, float blink_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_blink_rate\n"
    "//       Access: Published\n"
    "//  Description: Sets the number of times per second the cursor will\n"
    "//               blink while the entry has keyboard focus.\n"
    "//\n"
    "//               If this is 0, the cursor does not blink, but is held\n"
    "//               steady.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_blink_rate_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGEntry::get_blink_rate(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_blink_rate_120(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGEntry::get_blink_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlinkRate", key_word_list));
        else
            (PyArg_Parse(args, ":getBlinkRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGEntry*)local_this)->get_blink_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlinkRate(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_blink_rate_120_comment =
    "C++ Interface:\n"
    "getBlinkRate(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_blink_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of times per second the cursor\n"
    "//               will blink, or 0 if the cursor is not to blink.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_blink_rate_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath PGEntry::get_cursor_def(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursor_def_121(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline NodePath PGEntry::get_cursor_def(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorDef", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorDef"));
        if(!PyErr_Occurred())
        {
            NodePath result = (local_this)->get_cursor_def();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.getCursorDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorDef(non-const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursor_def_121_comment =
    "C++ Interface:\n"
    "getCursorDef(non-const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursor_def\n"
    "//       Access: Published\n"
    "//  Description: Returns the Node that will be rendered to represent\n"
    "//               the cursor.  You can attach suitable cursor geometry\n"
    "//               to this node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursor_def_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::clear_cursor_def(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_clear_cursor_def_122(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::clear_cursor_def(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCursorDef", key_word_list));
        else
            (PyArg_Parse(args, ":clearCursorDef"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cursor_def();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.clearCursorDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCursorDef(non-const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_clear_cursor_def_122_comment =
    "C++ Interface:\n"
    "clearCursorDef(non-const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::clear_cursor_def\n"
    "//       Access: Published\n"
    "//  Description: Removes all the children from the cursor_def node, in\n"
    "//               preparation for adding a new definition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_clear_cursor_def_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_cursor_keys_active(bool flag)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_cursor_keys_active_123(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_cursor_keys_active(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCursorKeysActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCursorKeysActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cursor_keys_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setCursorKeysActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCursorKeysActive(non-const PGEntry this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_cursor_keys_active_123_comment =
    "C++ Interface:\n"
    "setCursorKeysActive(non-const PGEntry this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_cursor_keys_active\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the arrow keys (and home/end) control\n"
    "//               movement of the cursor.  If true, they are active; if\n"
    "//               false, they are ignored.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_cursor_keys_active_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGEntry::get_cursor_keys_active(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursor_keys_active_124(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGEntry::get_cursor_keys_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorKeysActive", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorKeysActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGEntry*)local_this)->get_cursor_keys_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorKeysActive(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursor_keys_active_124_comment =
    "C++ Interface:\n"
    "getCursorKeysActive(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursor_keys_active\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the arrow keys are currently set to\n"
    "//               control movement of the cursor; see\n"
    "//               set_cursor_keys_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursor_keys_active_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_obscure_mode(bool flag)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_obscure_mode_125(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_obscure_mode(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setObscureMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setObscureMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_obscure_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setObscureMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setObscureMode(non-const PGEntry this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_obscure_mode_125_comment =
    "C++ Interface:\n"
    "setObscureMode(non-const PGEntry this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_obscure_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether obscure mode should be enabled.  In\n"
    "//               obscure mode, a string of asterisks is displayed\n"
    "//               instead of the literal text, e.g. for entering\n"
    "//               passwords.\n"
    "//\n"
    "//               In obscure mode, the width of the text is computed\n"
    "//               based on the width of the string of asterisks, not on\n"
    "//               the width of the actual text.  This has implications\n"
    "//               on the maximum length of text that may be entered if\n"
    "//               max_width is in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_obscure_mode_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGEntry::get_obscure_mode(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_obscure_mode_126(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGEntry::get_obscure_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getObscureMode", key_word_list));
        else
            (PyArg_Parse(args, ":getObscureMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGEntry*)local_this)->get_obscure_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getObscureMode(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_obscure_mode_126_comment =
    "C++ Interface:\n"
    "getObscureMode(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_obscure_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether obscure mode is enabled.  See\n"
    "//               set_obscure_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_obscure_mode_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_overflow_mode(bool flag)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_overflow_mode_127(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_overflow_mode(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOverflowMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOverflowMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_overflow_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setOverflowMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOverflowMode(non-const PGEntry this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_overflow_mode_127_comment =
    "C++ Interface:\n"
    "setOverflowMode(non-const PGEntry this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_overflow_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether overflow mode should be enabled.\n"
    "//               In overflow mode, text can overflow the boundaries\n"
    "//               of the Entry element horizontally.\n"
    "//\n"
    "//               Overflow mode only works when the number of lines\n"
    "//               is 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_overflow_mode_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGEntry::get_overflow_mode(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_overflow_mode_128(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGEntry::get_overflow_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowMode", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGEntry*)local_this)->get_overflow_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowMode(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_overflow_mode_128_comment =
    "C++ Interface:\n"
    "getOverflowMode(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_overflow_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether overflow mode is enabled.  See\n"
    "//               set_overflow_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_overflow_mode_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_candidate_active(basic_string< char > const &candidate_active)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_candidate_active_129(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_candidate_active(basic_string< char > const &candidate_active)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"candidate_active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCandidateActive", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCandidateActive", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_candidate_active(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setCandidateActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCandidateActive(non-const PGEntry this, string candidate_active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_candidate_active_129_comment =
    "C++ Interface:\n"
    "setCandidateActive(non-const PGEntry this, string candidate_active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_candidate_active\n"
    "//       Access: Published\n"
    "//  Description: Specifies the name of the TextProperties structure\n"
    "//               added to the TextPropertiesManager that will be used\n"
    "//               to render candidate strings from the IME, used for\n"
    "//               typing characters in east Asian languages.  Each\n"
    "//               candidate string represents one possible way to\n"
    "//               interpret the sequence of keys the user has just\n"
    "//               entered; it should not be considered typed yet, but\n"
    "//               it is important for the user to be able to see what\n"
    "//               he is considering entering.\n"
    "//\n"
    "//               This particular method sets the properties for the\n"
    "//               subset of the current candidate string that the user\n"
    "//               can actively scroll through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_candidate_active_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &PGEntry::get_candidate_active(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_candidate_active_130(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &PGEntry::get_candidate_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCandidateActive", key_word_list));
        else
            (PyArg_Parse(args, ":getCandidateActive"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const PGEntry*)local_this)->get_candidate_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCandidateActive(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_candidate_active_130_comment =
    "C++ Interface:\n"
    "getCandidateActive(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_candidate_active\n"
    "//       Access: Published\n"
    "//  Description: See set_candidate_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_candidate_active_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_candidate_inactive(basic_string< char > const &candidate_inactive)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_candidate_inactive_131(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_candidate_inactive(basic_string< char > const &candidate_inactive)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"candidate_inactive", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCandidateInactive", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCandidateInactive", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_candidate_inactive(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setCandidateInactive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCandidateInactive(non-const PGEntry this, string candidate_inactive)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_candidate_inactive_131_comment =
    "C++ Interface:\n"
    "setCandidateInactive(non-const PGEntry this, string candidate_inactive)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_candidate_inactive\n"
    "//       Access: Published\n"
    "//  Description: Specifies the name of the TextProperties structure\n"
    "//               added to the TextPropertiesManager that will be used\n"
    "//               to render candidate strings from the IME, used for\n"
    "//               typing characters in east Asian languages.  Each\n"
    "//               candidate string represents one possible way to\n"
    "//               interpret the sequence of keys the user has just\n"
    "//               entered; it should not be considered typed yet, but\n"
    "//               it is important for the user to be able to see what\n"
    "//               he is considering entering.\n"
    "//\n"
    "//               This particular method sets the properties for the\n"
    "//               subset of the current candidate string that the user\n"
    "//               is not actively scrolling through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_candidate_inactive_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &PGEntry::get_candidate_inactive(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_candidate_inactive_132(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &PGEntry::get_candidate_inactive(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCandidateInactive", key_word_list));
        else
            (PyArg_Parse(args, ":getCandidateInactive"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const PGEntry*)local_this)->get_candidate_inactive();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCandidateInactive(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_candidate_inactive_132_comment =
    "C++ Interface:\n"
    "getCandidateInactive(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_candidate_inactive\n"
    "//       Access: Published\n"
    "//  Description: See set_candidate_inactive().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_candidate_inactive_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGEntry::set_text_def(int state, TextNode *node)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_text_def_133(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PGEntry::set_text_def(int state, TextNode *node)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"state", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setTextDef", key_word_list, &param1, &param2))
            {
                TextNode *param2_this = (TextNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextNode, 2, "PGEntry.setTextDef", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_text_def((int)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGEntry.setTextDef() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextDef(non-const PGEntry this, int state, non-const TextNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_text_def_133_comment =
    "C++ Interface:\n"
    "setTextDef(non-const PGEntry this, int state, non-const TextNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_text_def\n"
    "//       Access: Published\n"
    "//  Description: Changes the TextNode that will be used to render the\n"
    "//               text within the entry when the entry is in the\n"
    "//               indicated state.  The default if nothing is specified\n"
    "//               is the same TextNode returned by\n"
    "//               PGItem::get_text_node().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_text_def_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TextNode *PGEntry::get_text_def(int state) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_text_def_134(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TextNode *PGEntry::get_text_def(int state) const
        int param1;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTextDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTextDef", &param1));
        if(!PyErr_Occurred())
        {
            TextNode *return_value = ((const PGEntry*)local_this)->get_text_def((int)param1);
            if (return_value != (TextNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextDef(const PGEntry this, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_text_def_134_comment =
    "C++ Interface:\n"
    "getTextDef(const PGEntry this, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_text_def\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextNode that will be used to render the\n"
    "//               text within the entry when the entry is in the\n"
    "//               indicated state.  See set_text_def().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_text_def_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_accept_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_accept_prefix_135(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_accept_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAcceptPrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_accept_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_accept_prefix_135_comment =
    "C++ Interface:\n"
    "getAcceptPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_accept_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the accept\n"
    "//               event for all PGEntries.  The accept event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_accept_prefix_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_accept_failed_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_accept_failed_prefix_136(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_accept_failed_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAcceptFailedPrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_accept_failed_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptFailedPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_accept_failed_prefix_136_comment =
    "C++ Interface:\n"
    "getAcceptFailedPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_accept_failed_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the accept\n"
    "//               failed event for all PGEntries.  This event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_accept_failed_prefix_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_overflow_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_overflow_prefix_137(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_overflow_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowPrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_overflow_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_overflow_prefix_137_comment =
    "C++ Interface:\n"
    "getOverflowPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_overflow_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the overflow\n"
    "//               event for all PGEntries.  The overflow event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_overflow_prefix_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_type_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_type_prefix_138(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_type_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTypePrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_type_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypePrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_type_prefix_138_comment =
    "C++ Interface:\n"
    "getTypePrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_type_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the type\n"
    "//               event for all PGEntries.  The type event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_type_prefix_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_erase_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_erase_prefix_139(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_erase_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getErasePrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_erase_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getErasePrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_erase_prefix_139_comment =
    "C++ Interface:\n"
    "getErasePrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_erase_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the erase\n"
    "//               event for all PGEntries.  The erase event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_erase_prefix_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGEntry::get_cursormove_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursormove_prefix_140(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGEntry::get_cursormove_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursormovePrefix", key_word_list))
        {
            basic_string< char > return_value = PGEntry::get_cursormove_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursormovePrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursormove_prefix_140_comment =
    "C++ Interface:\n"
    "getCursormovePrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursormove_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the cursor\n"
    "//               event for all PGEntries.  The cursor event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursormove_prefix_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_accept_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_accept_event_141(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGEntry::get_accept_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getAcceptEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getAcceptEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGEntry.getAcceptEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGEntry*)local_this)->get_accept_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptEvent(const PGEntry this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_accept_event_141_comment =
    "C++ Interface:\n"
    "getAcceptEvent(const PGEntry this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_accept_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               entry is accepted normally.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_accept_event_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_accept_failed_event(ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_accept_failed_event_142(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline basic_string< char > PGEntry::get_accept_failed_event(ButtonHandle const &button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getAcceptFailedEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getAcceptFailedEvent", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "PGEntry.getAcceptFailedEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    basic_string< char > return_value = ((const PGEntry*)local_this)->get_accept_failed_event(*param1_this);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptFailedEvent(const PGEntry this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_accept_failed_event_142_comment =
    "C++ Interface:\n"
    "getAcceptFailedEvent(const PGEntry this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_accept_failed_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               entry cannot accept an input\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_accept_failed_event_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_overflow_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_overflow_event_143(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_overflow_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_overflow_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowEvent(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_overflow_event_143_comment =
    "C++ Interface:\n"
    "getOverflowEvent(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_overflow_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when too\n"
    "//               much text is attempted to be entered into the\n"
    "//               PGEntry, exceeding either the limit set via\n"
    "//               set_max_chars() or via set_max_width().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_overflow_event_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_type_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_type_event_144(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_type_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTypeEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getTypeEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_type_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeEvent(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_type_event_144_comment =
    "C++ Interface:\n"
    "getTypeEvent(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_type_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown whenever\n"
    "//               the user extends the text by typing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_type_event_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_erase_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_erase_event_145(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_erase_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEraseEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getEraseEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_erase_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEraseEvent(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_erase_event_145_comment =
    "C++ Interface:\n"
    "getEraseEvent(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_erase_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown whenever\n"
    "//               the user erases characters in the text.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_erase_event_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGEntry::get_cursormove_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_cursormove_event_146(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGEntry::get_cursormove_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursormoveEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getCursormoveEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGEntry*)local_this)->get_cursormove_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursormoveEvent(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_cursormove_event_146_comment =
    "C++ Interface:\n"
    "getCursormoveEvent(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_cursormove_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown whenever\n"
    "//               the cursor moves\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_cursormove_event_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGEntry::set_wtext(basic_string< wchar_t > const &wtext)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_wtext_147(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool PGEntry::set_wtext(basic_string< wchar_t > const &wtext)
        PyUnicodeObject *param1
;
        static char * key_word_list[] = {(char *)"wtext", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "U:setWtext", key_word_list, &param1));
        else
            (PyArg_Parse(args, "U:setWtext", &param1));
        if(!PyErr_Occurred())
        {
             int param1_len = PyUnicode_GetSize((PyObject *)param1); wchar_t *param1_str = new wchar_t[param1_len]; PyUnicode_AsWideChar(param1, param1_str, param1_len);
            bool return_value = (local_this)->set_wtext(basic_string<wchar_t>((wchar_t *)param1_str, param1_len));
             delete[] param1_str;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setWtext() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWtext(non-const PGEntry this, string wtext)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_wtext_147_comment =
    "C++ Interface:\n"
    "setWtext(non-const PGEntry this, string wtext)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_wtext\n"
    "//       Access: Published\n"
    "//  Description: Changes the text currently displayed within the\n"
    "//               entry.\n"
    "//\n"
    "//               The return value is true if all the text is accepted,\n"
    "//               or false if some was truncated (see set_max_width(),\n"
    "//               etc.).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_wtext_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > PGEntry::get_plain_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_plain_wtext_148(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< wchar_t > PGEntry::get_plain_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlainWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getPlainWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const PGEntry*)local_this)->get_plain_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlainWtext(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_plain_wtext_148_comment =
    "C++ Interface:\n"
    "getPlainWtext(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_plain_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns the text currently displayed within the\n"
    "//               entry, without any embedded properties characters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_plain_wtext_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > PGEntry::get_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_wtext_149(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< wchar_t > PGEntry::get_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWtext", key_word_list));
        else
            (PyArg_Parse(args, ":getWtext"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const PGEntry*)local_this)->get_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWtext(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_wtext_149_comment =
    "C++ Interface:\n"
    "getWtext(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::get_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns the text currently displayed within the\n"
    "//               entry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_get_wtext_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGEntry::set_accept_enabled(bool enabled)
 *******************************************************************/
static PyObject *Dtool_PGEntry_set_accept_enabled_150(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGEntry::set_accept_enabled(bool enabled)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"enabled", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAcceptEnabled", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAcceptEnabled", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_accept_enabled((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGEntry.setAcceptEnabled() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAcceptEnabled(non-const PGEntry this, bool enabled)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_set_accept_enabled_150_comment =
    "C++ Interface:\n"
    "setAcceptEnabled(non-const PGEntry this, bool enabled)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::set_accept_enabled\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the input may be accepted--use to \n"
    "//               disable submission by the user\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_set_accept_enabled_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PGEntry::is_wtext(void) const
 *******************************************************************/
static PyObject *Dtool_PGEntry_is_wtext_151(PyObject *self, PyObject *args,PyObject *kwds) {
    PGEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PGEntry::is_wtext(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWtext", key_word_list));
        else
            (PyArg_Parse(args, ":isWtext"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGEntry*)local_this)->is_wtext();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWtext(const PGEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_is_wtext_151_comment =
    "C++ Interface:\n"
    "isWtext(const PGEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGEntry::is_wtext\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any of the characters in the string\n"
    "//               returned by get_wtext() are out of the range of an\n"
    "//               ASCII character (and, therefore, get_wtext() should\n"
    "//               be called in preference to get_text()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGEntry_is_wtext_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGEntry::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGEntry_get_class_type_152(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGEntry::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGEntry::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGEntry_get_class_type_152_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGEntry_get_class_type_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGEntry::PGEntry(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PGEntry(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PGEntry::PGEntry(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGEntry", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PGEntry", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PGEntry *return_value = new PGEntry(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PGEntry,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PGEntry(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGEntry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGEntry)
    {
        printf("PGEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGEntry * local_this = (PGEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGEntry)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGEntry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGEntry)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGEntry*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGEntry*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGEntry*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGEntry*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGEntry*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGMouseWatcherBackground 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGMouseWatcherBackground::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGMouseWatcherBackground_get_class_type_156(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGMouseWatcherBackground::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGMouseWatcherBackground::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGMouseWatcherBackground_get_class_type_156_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGMouseWatcherBackground_get_class_type_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGMouseWatcherBackground::PGMouseWatcherBackground(void)
 *******************************************************************/
int  Dtool_Init_PGMouseWatcherBackground(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PGMouseWatcherBackground::PGMouseWatcherBackground(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGMouseWatcherBackground", key_word_list))
        {
            PGMouseWatcherBackground *return_value = new PGMouseWatcherBackground();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PGMouseWatcherBackground,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PGMouseWatcherBackground()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGMouseWatcherBackground(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGMouseWatcherBackground)
    {
        printf("PGMouseWatcherBackground ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGMouseWatcherBackground * local_this = (PGMouseWatcherBackground *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGMouseWatcherBackground)
        return local_this;
    if(requested_type == &Dtool_MouseWatcherRegion)
        return ( MouseWatcherRegion *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MouseWatcherRegion *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MouseWatcherRegion *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MouseWatcherRegion *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MouseWatcherRegion *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MouseWatcherRegion *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGMouseWatcherBackground(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGMouseWatcherBackground)
        return from_this;
    if(from_type == &Dtool_MouseWatcherRegion)
    {
          MouseWatcherRegion* other_this = (MouseWatcherRegion*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PGMouseWatcherBackground*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGMouseWatcherParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGMouseWatcherParameter::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PGMouseWatcherParameter_output_165(PyObject *self, PyObject *args,PyObject *kwds) {
    PGMouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGMouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PGMouseWatcherParameter::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PGMouseWatcherParameter.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PGMouseWatcherParameter*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PGMouseWatcherParameter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGMouseWatcherParameter_output_165_comment =
    "C++ Interface:\n"
    "output(const PGMouseWatcherParameter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGMouseWatcherParameter::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGMouseWatcherParameter_output_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGMouseWatcherParameter::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGMouseWatcherParameter_get_class_type_166(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGMouseWatcherParameter::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGMouseWatcherParameter::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGMouseWatcherParameter_get_class_type_166_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGMouseWatcherParameter_get_class_type_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *PGMouseWatcherParameter::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_159(PyObject *self, PyObject *args,PyObject *kwds) {
    PGMouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGMouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *PGMouseWatcherParameter::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGMouseWatcherParameter.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const PGMouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_159_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const PGMouseWatcherParameter this)\n"
    "\n"
    "upcast from PGMouseWatcherParameter to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcherParameter *PGMouseWatcherParameter::upcast_to_MouseWatcherParameter(void)
 *******************************************************************/
static PyObject *Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_162(PyObject *self, PyObject *args,PyObject *kwds) {
    PGMouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGMouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MouseWatcherParameter *PGMouseWatcherParameter::upcast_to_MouseWatcherParameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToMouseWatcherParameter", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToMouseWatcherParameter"));
        if(!PyErr_Occurred())
        {
            MouseWatcherParameter *return_value = (MouseWatcherParameter *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MouseWatcherParameter,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGMouseWatcherParameter.upcastToMouseWatcherParameter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToMouseWatcherParameter(non-const PGMouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_162_comment =
    "C++ Interface:\n"
    "upcastToMouseWatcherParameter(non-const PGMouseWatcherParameter this)\n"
    "\n"
    "upcast from PGMouseWatcherParameter to MouseWatcherParameter\n"
    "";
#else
static const char * Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_162_comment = NULL;
#endif

int  Dtool_Init_PGMouseWatcherParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PGMouseWatcherParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PGMouseWatcherParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGMouseWatcherParameter)
    {
        printf("PGMouseWatcherParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGMouseWatcherParameter * local_this = (PGMouseWatcherParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGMouseWatcherParameter)
        return local_this;
    if(requested_type == &Dtool_MouseWatcherParameter)
        return ( MouseWatcherParameter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGMouseWatcherParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGMouseWatcherParameter)
        return from_this;
    if(from_type == &Dtool_MouseWatcherParameter)
    {
          MouseWatcherParameter* other_this = (MouseWatcherParameter*)from_this;
          return (PGMouseWatcherParameter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PGMouseWatcherParameter*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGMouseWatcherParameter*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGMouseWatcherParameter*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PGMouseWatcherParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGVirtualFrame 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGVirtualFrame::setup(float width, float height)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_setup_169(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGVirtualFrame::setup(float width, float height)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setup", key_word_list, &param1, &param2))
        {
            (local_this)->setup((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGVirtualFrame.setup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setup(non-const PGVirtualFrame this, float width, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_setup_169_comment =
    "C++ Interface:\n"
    "setup(non-const PGVirtualFrame this, float width, float height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::setup\n"
    "//       Access: Published\n"
    "//  Description: Creates a PGVirtualFrame with the indicated \n"
    "//               dimensions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_setup_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGVirtualFrame::set_clip_frame(LVecBase4f const &clip_frame)
 * inline void PGVirtualFrame::set_clip_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_set_clip_frame_170(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PGVirtualFrame::set_clip_frame(LVecBase4f const &clip_frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"clip_frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClipFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setClipFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PGVirtualFrame.setClipFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_clip_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGVirtualFrame.setClipFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGVirtualFrame::set_clip_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setClipFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_clip_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGVirtualFrame.setClipFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setClipFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setClipFrame(non-const PGVirtualFrame this, const VBase4 clip_frame)\n"
          "setClipFrame(non-const PGVirtualFrame this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_set_clip_frame_170_comment =
    "C++ Interface:\n"
    "setClipFrame(non-const PGVirtualFrame this, const VBase4 clip_frame)\n"
    "setClipFrame(non-const PGVirtualFrame this, float left, float right, float bottom, float top)\n"
    "\n"
    "// Filename: pgVirtualFrame.I\n"
    "// Created by:  drose (17Aug05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::set_clip_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the clip frame.\n"
    "//               This is the size of the small window through which we\n"
    "//               can see the virtual canvas.  Normally, this is the\n"
    "//               same size as the actual frame or smaller (typically\n"
    "//               it is smaller by the size of the bevel, or to make\n"
    "//               room for scroll bars).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::set_clip_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the clip frame.\n"
    "//               This is the size of the small window through which we\n"
    "//               can see the virtual canvas.  Normally, this is the\n"
    "//               same size as the actual frame or smaller (typically\n"
    "//               it is smaller by the size of the bevel, or to make\n"
    "//               room for scroll bars).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_set_clip_frame_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PGVirtualFrame::get_clip_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_get_clip_frame_171(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PGVirtualFrame::get_clip_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClipFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getClipFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PGVirtualFrame*)local_this)->get_clip_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClipFrame(const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_get_clip_frame_171_comment =
    "C++ Interface:\n"
    "getClipFrame(const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::get_clip_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the bounding rectangle of the clip frame.\n"
    "//               See set_clip_frame().  If has_clip_frame() is\n"
    "//               false, this returns the item's actual frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_get_clip_frame_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGVirtualFrame::has_clip_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_has_clip_frame_172(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGVirtualFrame::has_clip_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasClipFrame", key_word_list));
        else
            (PyArg_Parse(args, ":hasClipFrame"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGVirtualFrame*)local_this)->has_clip_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasClipFrame(const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_has_clip_frame_172_comment =
    "C++ Interface:\n"
    "hasClipFrame(const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::has_clip_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the clip frame has been set; see\n"
    "//               set_clip_frame().  If it has not been set, objects in\n"
    "//               the virtual frame will not be clipped.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_has_clip_frame_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGVirtualFrame::clear_clip_frame(void)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_clear_clip_frame_173(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGVirtualFrame::clear_clip_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearClipFrame", key_word_list));
        else
            (PyArg_Parse(args, ":clearClipFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_clip_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGVirtualFrame.clearClipFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearClipFrame(non-const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_clear_clip_frame_173_comment =
    "C++ Interface:\n"
    "clearClipFrame(non-const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::clear_clip_frame\n"
    "//       Access: Published\n"
    "//  Description: Removes the clip frame from the item.  This\n"
    "//               disables clipping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_clear_clip_frame_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGVirtualFrame::set_canvas_transform(TransformState const *transform)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_set_canvas_transform_174(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGVirtualFrame::set_canvas_transform(TransformState const *transform)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCanvasTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCanvasTransform", &param1));
            if(!PyErr_Occurred())
            {
                TransformState *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TransformState, 1, "PGVirtualFrame.setCanvasTransform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_canvas_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGVirtualFrame.setCanvasTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCanvasTransform(non-const PGVirtualFrame this, const TransformState transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_set_canvas_transform_174_comment =
    "C++ Interface:\n"
    "setCanvasTransform(non-const PGVirtualFrame this, const TransformState transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::set_canvas_transform\n"
    "//       Access: Published\n"
    "//  Description: Changes the transform of the virtual canvas.  This\n"
    "//               transform is applied to all child nodes of the\n"
    "//               canvas_node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_set_canvas_transform_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TransformState const *PGVirtualFrame::get_canvas_transform(void) const
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_get_canvas_transform_175(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TransformState const *PGVirtualFrame::get_canvas_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCanvasTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getCanvasTransform"));
        if(!PyErr_Occurred())
        {
            TransformState const *return_value = ((const PGVirtualFrame*)local_this)->get_canvas_transform();
            if (return_value != (TransformState const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TransformState,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCanvasTransform(const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_get_canvas_transform_175_comment =
    "C++ Interface:\n"
    "getCanvasTransform(const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::get_canvas_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns the transform of the virtual canvas.  This\n"
    "//               transform is applied to all child nodes of the\n"
    "//               canvas_node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_get_canvas_transform_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *PGVirtualFrame::get_canvas_node(void) const
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_get_canvas_node_176(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *PGVirtualFrame::get_canvas_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCanvasNode", key_word_list));
        else
            (PyArg_Parse(args, ":getCanvasNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const PGVirtualFrame*)local_this)->get_canvas_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCanvasNode(const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_get_canvas_node_176_comment =
    "C++ Interface:\n"
    "getCanvasNode(const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::get_canvas_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the special node that holds all of the\n"
    "//               children that appear in the virtual canvas.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_get_canvas_node_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *PGVirtualFrame::get_canvas_parent(void) const
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_get_canvas_parent_177(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *PGVirtualFrame::get_canvas_parent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCanvasParent", key_word_list));
        else
            (PyArg_Parse(args, ":getCanvasParent"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const PGVirtualFrame*)local_this)->get_canvas_parent();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCanvasParent(const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_get_canvas_parent_177_comment =
    "C++ Interface:\n"
    "getCanvasParent(const PGVirtualFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGVirtualFrame::get_canvas_parent\n"
    "//       Access: Published\n"
    "//  Description: Returns the parent node of the canvas_node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_get_canvas_parent_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGVirtualFrame::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_get_class_type_178(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGVirtualFrame::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGVirtualFrame::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_get_class_type_178_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_get_class_type_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGScrollFrame *PGVirtualFrame::downcast_to_PGScrollFrame(void)
 *******************************************************************/
static PyObject *Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_224(PyObject *self, PyObject *args,PyObject *kwds) {
    PGVirtualFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGVirtualFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PGScrollFrame *PGVirtualFrame::downcast_to_PGScrollFrame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToPGScrollFrame", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToPGScrollFrame"));
        if(!PyErr_Occurred())
        {
            PGScrollFrame *return_value = (PGScrollFrame *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGScrollFrame,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGVirtualFrame.downcastToPGScrollFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToPGScrollFrame(non-const PGVirtualFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_224_comment =
    "C++ Interface:\n"
    "downcastToPGScrollFrame(non-const PGVirtualFrame this)\n"
    "\n"
    "downcast from PGVirtualFrame to PGScrollFrame\n"
    "";
#else
static const char * Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGVirtualFrame::PGVirtualFrame(basic_string< char > const &name)
 * PGVirtualFrame::PGVirtualFrame(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_PGVirtualFrame(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PGVirtualFrame::PGVirtualFrame(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGVirtualFrame", key_word_list))
            {
                PGVirtualFrame *return_value = new PGVirtualFrame();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGVirtualFrame,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PGVirtualFrame::PGVirtualFrame(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGVirtualFrame", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PGVirtualFrame", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PGVirtualFrame *return_value = new PGVirtualFrame(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGVirtualFrame,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PGVirtualFrame() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PGVirtualFrame()\n"
          "PGVirtualFrame(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGVirtualFrame(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGVirtualFrame)
    {
        printf("PGVirtualFrame ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGVirtualFrame * local_this = (PGVirtualFrame *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGVirtualFrame)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGVirtualFrame(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGVirtualFrame)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGVirtualFrame*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGVirtualFrame*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGVirtualFrame*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGVirtualFrame*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGVirtualFrame*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGSliderBar 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGSliderBar::setup_scroll_bar(bool vertical, float length, float width, float bevel)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_setup_scroll_bar_187(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGSliderBar::setup_scroll_bar(bool vertical, float length, float width, float bevel)
        PyObject *param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"vertical", (char *)"length", (char *)"width", (char *)"bevel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddd:setupScrollBar", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->setup_scroll_bar((PyObject_IsTrue(param1)!=0), (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setupScrollBar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupScrollBar(non-const PGSliderBar this, bool vertical, float length, float width, float bevel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_setup_scroll_bar_187_comment =
    "C++ Interface:\n"
    "setupScrollBar(non-const PGSliderBar this, bool vertical, float length, float width, float bevel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::setup_scroll_bar\n"
    "//       Access: Published\n"
    "//  Description: Creates PGSliderBar that represents a vertical or\n"
    "//               horizontal scroll bar (if vertical is true or false,\n"
    "//               respectively), with additional buttons for scrolling,\n"
    "//               and a range of 0 .. 1.\n"
    "//\n"
    "//               length here is the measurement along the scroll bar,\n"
    "//               and width is the measurement across the scroll bar,\n"
    "//               whether it is vertical or horizontal (so for a\n"
    "//               horizontal scroll bar, the length is actually the x\n"
    "//               dimension, and the width is the y dimension).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_setup_scroll_bar_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGSliderBar::setup_slider(bool vertical, float length, float width, float bevel)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_setup_slider_188(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGSliderBar::setup_slider(bool vertical, float length, float width, float bevel)
        PyObject *param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"vertical", (char *)"length", (char *)"width", (char *)"bevel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddd:setupSlider", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->setup_slider((PyObject_IsTrue(param1)!=0), (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setupSlider() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupSlider(non-const PGSliderBar this, bool vertical, float length, float width, float bevel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_setup_slider_188_comment =
    "C++ Interface:\n"
    "setupSlider(non-const PGSliderBar this, bool vertical, float length, float width, float bevel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::setup_slider\n"
    "//       Access: Published\n"
    "//  Description: Creates PGSliderBar that represents a slider that the\n"
    "//               user can use to control an analog quantity.\n"
    "//\n"
    "//               This is functionally the same as a scroll bar, but it\n"
    "//               has a distinctive look.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_setup_slider_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_axis(LVector3f const &axis)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_axis_189(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGSliderBar::set_axis(LVector3f const &axis)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"axis", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAxis", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "PGSliderBar.setAxis", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_axis(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGSliderBar.setAxis() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAxis(non-const PGSliderBar this, const Vec3 axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_axis_189_comment =
    "C++ Interface:\n"
    "setAxis(non-const PGSliderBar this, const Vec3 axis)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_axis\n"
    "//       Access: Published\n"
    "//  Description: Specifies the axis of the slider bar's motion.  This\n"
    "//               should be only one of four vectors: (1, 0, 0), (0, 0,\n"
    "//               1), (-1, 0, 0), or (0, 0, -1).\n"
    "//\n"
    "//               This specifies the vector in which the thumb moves\n"
    "//               when it is moving from the minimum to the maximum\n"
    "//               value.\n"
    "//\n"
    "//               The axis must be parallel to one of the screen axes,\n"
    "//               and it must be normalized.  Hence, it may only be one\n"
    "//               of the above four possibilities; anything else is an\n"
    "//               error and will result in indeterminate behavior.\n"
    "//\n"
    "//               Normally, you should not try to set the axis\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_axis_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &PGSliderBar::get_axis(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_axis_190(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &PGSliderBar::get_axis(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const PGSliderBar*)local_this)->get_axis());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_axis_190_comment =
    "C++ Interface:\n"
    "getAxis(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_axis\n"
    "//       Access: Published\n"
    "//  Description: Returns the axis of the slider bar's motion.  See\n"
    "//               set_axis().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_axis_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_range(float min_value, float max_value)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_range_191(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_range(float min_value, float max_value)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"min_value", (char *)"max_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setRange", key_word_list, &param1, &param2))
        {
            (local_this)->set_range((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const PGSliderBar this, float min_value, float max_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_range_191_comment =
    "C++ Interface:\n"
    "setRange(non-const PGSliderBar this, float min_value, float max_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the minimum and maxmimum value for the slider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_range_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_min_value(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_min_value_192(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_min_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinValue", key_word_list));
        else
            (PyArg_Parse(args, ":getMinValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_min_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinValue(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_min_value_192_comment =
    "C++ Interface:\n"
    "getMinValue(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_min_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the value when the slider is all the way to\n"
    "//               the left.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_min_value_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_max_value(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_max_value_193(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_max_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxValue", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_max_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxValue(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_max_value_193_comment =
    "C++ Interface:\n"
    "getMaxValue(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_max_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the value when the slider is all the way to\n"
    "//               the right.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_max_value_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_scroll_size(float scroll_size)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_scroll_size_194(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_scroll_size(float scroll_size)
        double param1;
        static char * key_word_list[] = {(char *)"scroll_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setScrollSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setScrollSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_scroll_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setScrollSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScrollSize(non-const PGSliderBar this, float scroll_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_scroll_size_194_comment =
    "C++ Interface:\n"
    "setScrollSize(non-const PGSliderBar this, float scroll_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_scroll_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount the slider will move when the\n"
    "//               user clicks on the left or right buttons.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_scroll_size_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_scroll_size(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_scroll_size_195(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_scroll_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScrollSize", key_word_list));
        else
            (PyArg_Parse(args, ":getScrollSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_scroll_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScrollSize(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_scroll_size_195_comment =
    "C++ Interface:\n"
    "getScrollSize(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_scroll_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the value last set by set_scroll_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_scroll_size_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_page_size(float page_size)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_page_size_196(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_page_size(float page_size)
        double param1;
        static char * key_word_list[] = {(char *)"page_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPageSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPageSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_page_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setPageSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPageSize(non-const PGSliderBar this, float page_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_page_size_196_comment =
    "C++ Interface:\n"
    "setPageSize(non-const PGSliderBar this, float page_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_page_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount of data contained in a single\n"
    "//               page.  This indicates how much the thumb will jump\n"
    "//               when the trough is directly clicked; and if\n"
    "//               resize_thumb is true, it also controls the visible\n"
    "//               size of the thumb button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_page_size_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_page_size(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_page_size_197(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_page_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPageSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_page_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageSize(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_page_size_197_comment =
    "C++ Interface:\n"
    "getPageSize(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_page_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the value last set by set_page_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_page_size_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_value(float value)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_value_198(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_value(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const PGSliderBar this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_value_198_comment =
    "C++ Interface:\n"
    "setValue(non-const PGSliderBar this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_value\n"
    "//       Access: Published\n"
    "//  Description: Sets the current value of the slider\n"
    "//               programmatically.  This should range between\n"
    "//               get_min_value() and get_max_value().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_value_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_value_199(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_value_199_comment =
    "C++ Interface:\n"
    "getValue(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the current value of the slider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_value_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_ratio(float ratio)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_ratio_200(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_ratio(float ratio)
        double param1;
        static char * key_word_list[] = {(char *)"ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRatio", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRatio", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_ratio((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setRatio() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRatio(non-const PGSliderBar this, float ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_ratio_200_comment =
    "C++ Interface:\n"
    "setRatio(non-const PGSliderBar this, float ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_ratio\n"
    "//       Access: Published\n"
    "//  Description: Sets the current value of the slider, expressed in\n"
    "//               the range 0 .. 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_ratio_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGSliderBar::get_ratio(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_ratio_201(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGSliderBar::get_ratio(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRatio", key_word_list));
        else
            (PyArg_Parse(args, ":getRatio"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGSliderBar*)local_this)->get_ratio();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRatio(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_ratio_201_comment =
    "C++ Interface:\n"
    "getRatio(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_ratio\n"
    "//       Access: Published\n"
    "//  Description: Returns the current value of the slider, expressed in\n"
    "//               the range 0 .. 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_ratio_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGSliderBar::is_button_down(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_is_button_down_202(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGSliderBar::is_button_down(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isButtonDown", key_word_list));
        else
            (PyArg_Parse(args, ":isButtonDown"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGSliderBar*)local_this)->is_button_down();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isButtonDown(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_is_button_down_202_comment =
    "C++ Interface:\n"
    "isButtonDown(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::is_button_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the user is currently holding down\n"
    "//               the mouse button to manipulate the slider.  When\n"
    "//               true, calls to set_ratio() or set_value() will have\n"
    "//               no effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_is_button_down_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_resize_thumb(bool resize_thumb)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_resize_thumb_203(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_resize_thumb(bool resize_thumb)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"resize_thumb", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setResizeThumb", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setResizeThumb", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_resize_thumb((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setResizeThumb() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setResizeThumb(non-const PGSliderBar this, bool resize_thumb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_resize_thumb_203_comment =
    "C++ Interface:\n"
    "setResizeThumb(non-const PGSliderBar this, bool resize_thumb)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_resize_thumb\n"
    "//       Access: Published\n"
    "//  Description: Sets the resize_thumb flag.  When this is true, the\n"
    "//               thumb button's frame will be adjusted so that its\n"
    "//               width visually represents the page size.  When this\n"
    "//               is false, the thumb button will be left alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_resize_thumb_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGSliderBar::get_resize_thumb(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_resize_thumb_204(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGSliderBar::get_resize_thumb(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getResizeThumb", key_word_list));
        else
            (PyArg_Parse(args, ":getResizeThumb"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGSliderBar*)local_this)->get_resize_thumb();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getResizeThumb(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_resize_thumb_204_comment =
    "C++ Interface:\n"
    "getResizeThumb(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_resize_thumb\n"
    "//       Access: Published\n"
    "//  Description: Returns the resize_thumb flag.  See\n"
    "//               set_resize_thumb().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_resize_thumb_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_manage_pieces(bool manage_pieces)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_manage_pieces_205(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::set_manage_pieces(bool manage_pieces)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"manage_pieces", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setManagePieces", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setManagePieces", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_manage_pieces((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setManagePieces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setManagePieces(non-const PGSliderBar this, bool manage_pieces)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_manage_pieces_205_comment =
    "C++ Interface:\n"
    "setManagePieces(non-const PGSliderBar this, bool manage_pieces)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_manage_pieces\n"
    "//       Access: Published\n"
    "//  Description: Sets the manage_pieces flag.  When this is true, the\n"
    "//               sub-pieces of the slider bar--that is, the thumb, and\n"
    "//               the left and right scroll buttons--are automatically\n"
    "//               positioned and/or resized when the slider bar's\n"
    "//               overall frame is changed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_manage_pieces_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGSliderBar::get_manage_pieces(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_manage_pieces_206(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGSliderBar::get_manage_pieces(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManagePieces", key_word_list));
        else
            (PyArg_Parse(args, ":getManagePieces"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGSliderBar*)local_this)->get_manage_pieces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManagePieces(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_manage_pieces_206_comment =
    "C++ Interface:\n"
    "getManagePieces(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_manage_pieces\n"
    "//       Access: Published\n"
    "//  Description: Returns the manage_pieces flag.  See\n"
    "//               set_manage_pieces().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_manage_pieces_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_thumb_button(PGButton *thumb_button)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_thumb_button_207(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGSliderBar::set_thumb_button(PGButton *thumb_button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"thumb_button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setThumbButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setThumbButton", &param1));
            if(!PyErr_Occurred())
            {
                PGButton *param1_this = (PGButton *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGButton, 1, "PGSliderBar.setThumbButton", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_thumb_button(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGSliderBar.setThumbButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThumbButton(non-const PGSliderBar this, non-const PGButton thumb_button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_thumb_button_207_comment =
    "C++ Interface:\n"
    "setThumbButton(non-const PGSliderBar this, non-const PGButton thumb_button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_thumb_button\n"
    "//       Access: Published\n"
    "//  Description: Sets the PGButton object that will serve as the thumb\n"
    "//               for this slider.  This button visually represents the\n"
    "//               position of the slider, and can be dragged left and\n"
    "//               right by the user.\n"
    "//\n"
    "//               It is the responsibility of the caller to ensure that\n"
    "//               the button object is parented to the PGSliderBar\n"
    "//               node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_thumb_button_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::clear_thumb_button(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_clear_thumb_button_208(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::clear_thumb_button(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearThumbButton", key_word_list));
        else
            (PyArg_Parse(args, ":clearThumbButton"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_thumb_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.clearThumbButton() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearThumbButton(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_clear_thumb_button_208_comment =
    "C++ Interface:\n"
    "clearThumbButton(non-const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::clear_thumb_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the thumb button object from control of the\n"
    "//               frame.  It is your responsibility to actually remove\n"
    "//               or hide the button itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_clear_thumb_button_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGButton *PGSliderBar::get_thumb_button(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_thumb_button_209(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGButton *PGSliderBar::get_thumb_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThumbButton", key_word_list));
        else
            (PyArg_Parse(args, ":getThumbButton"));
        if(!PyErr_Occurred())
        {
            PGButton *return_value = ((const PGSliderBar*)local_this)->get_thumb_button();
            if (return_value != (PGButton *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGButton,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThumbButton(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_thumb_button_209_comment =
    "C++ Interface:\n"
    "getThumbButton(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_thumb_button\n"
    "//       Access: Published\n"
    "//  Description: Returns the PGButton that serves as the thumb for\n"
    "//               this slider, or NULL if it is not set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_thumb_button_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_left_button(PGButton *left_button)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_left_button_210(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGSliderBar::set_left_button(PGButton *left_button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"left_button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLeftButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLeftButton", &param1));
            if(!PyErr_Occurred())
            {
                PGButton *param1_this = (PGButton *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGButton, 1, "PGSliderBar.setLeftButton", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_left_button(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGSliderBar.setLeftButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLeftButton(non-const PGSliderBar this, non-const PGButton left_button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_left_button_210_comment =
    "C++ Interface:\n"
    "setLeftButton(non-const PGSliderBar this, non-const PGButton left_button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_left_button\n"
    "//       Access: Published\n"
    "//  Description: Sets the PGButton object that will serve as the left\n"
    "//               scroll button for this slider.  This button is\n"
    "//               optional; if present, the user can click on it to\n"
    "//               move scroll_size units at a time to the left.\n"
    "//\n"
    "//               It is the responsibility of the caller to ensure that\n"
    "//               the button object is parented to the PGSliderBar\n"
    "//               node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_left_button_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::clear_left_button(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_clear_left_button_211(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::clear_left_button(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLeftButton", key_word_list));
        else
            (PyArg_Parse(args, ":clearLeftButton"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_left_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.clearLeftButton() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLeftButton(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_clear_left_button_211_comment =
    "C++ Interface:\n"
    "clearLeftButton(non-const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::clear_left_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the left button object from control of the\n"
    "//               frame.  It is your responsibility to actually remove\n"
    "//               or hide the button itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_clear_left_button_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGButton *PGSliderBar::get_left_button(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_left_button_212(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGButton *PGSliderBar::get_left_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeftButton", key_word_list));
        else
            (PyArg_Parse(args, ":getLeftButton"));
        if(!PyErr_Occurred())
        {
            PGButton *return_value = ((const PGSliderBar*)local_this)->get_left_button();
            if (return_value != (PGButton *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGButton,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeftButton(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_left_button_212_comment =
    "C++ Interface:\n"
    "getLeftButton(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_left_button\n"
    "//       Access: Published\n"
    "//  Description: Returns the PGButton that serves as the left scroll\n"
    "//               button for this slider, if any, or NULL if it is not\n"
    "//               set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_left_button_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::set_right_button(PGButton *right_button)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_right_button_213(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGSliderBar::set_right_button(PGButton *right_button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"right_button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRightButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRightButton", &param1));
            if(!PyErr_Occurred())
            {
                PGButton *param1_this = (PGButton *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGButton, 1, "PGSliderBar.setRightButton", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_right_button(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGSliderBar.setRightButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRightButton(non-const PGSliderBar this, non-const PGButton right_button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_right_button_213_comment =
    "C++ Interface:\n"
    "setRightButton(non-const PGSliderBar this, non-const PGButton right_button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_right_button\n"
    "//       Access: Published\n"
    "//  Description: Sets the PGButton object that will serve as the right\n"
    "//               scroll button for this slider.  This button is\n"
    "//               optional; if present, the user can click on it to\n"
    "//               move scroll_size units at a time to the right.\n"
    "//\n"
    "//               It is the responsibility of the caller to ensure that\n"
    "//               the button object is parented to the PGSliderBar\n"
    "//               node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_right_button_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGSliderBar::clear_right_button(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_clear_right_button_214(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGSliderBar::clear_right_button(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearRightButton", key_word_list));
        else
            (PyArg_Parse(args, ":clearRightButton"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_right_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.clearRightButton() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRightButton(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_clear_right_button_214_comment =
    "C++ Interface:\n"
    "clearRightButton(non-const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::clear_right_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the right button object from control of the\n"
    "//               frame.  It is your responsibility to actually remove\n"
    "//               or hide the button itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_clear_right_button_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGButton *PGSliderBar::get_right_button(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_right_button_215(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGButton *PGSliderBar::get_right_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRightButton", key_word_list));
        else
            (PyArg_Parse(args, ":getRightButton"));
        if(!PyErr_Occurred())
        {
            PGButton *return_value = ((const PGSliderBar*)local_this)->get_right_button();
            if (return_value != (PGButton *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGButton,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRightButton(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_right_button_215_comment =
    "C++ Interface:\n"
    "getRightButton(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_right_button\n"
    "//       Access: Published\n"
    "//  Description: Returns the PGButton that serves as the right scroll\n"
    "//               button for this slider, if any, or NULL if it is not\n"
    "//               set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_right_button_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > PGSliderBar::get_adjust_prefix(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_adjust_prefix_216(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > PGSliderBar::get_adjust_prefix(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getAdjustPrefix", key_word_list))
        {
            basic_string< char > return_value = PGSliderBar::get_adjust_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAdjustPrefix()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_adjust_prefix_216_comment =
    "C++ Interface:\n"
    "getAdjustPrefix()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_adjust_prefix\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the prefix that is used to define the adjust\n"
    "//               event for all PGSliderBars.  The adjust event is the\n"
    "//               concatenation of this string followed by get_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_adjust_prefix_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PGSliderBar::get_adjust_event(void) const
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_adjust_event_217(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PGSliderBar::get_adjust_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAdjustEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getAdjustEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PGSliderBar*)local_this)->get_adjust_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAdjustEvent(const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_adjust_event_217_comment =
    "C++ Interface:\n"
    "getAdjustEvent(const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::get_adjust_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               slider bar value is adjusted by the user or\n"
    "//               programmatically.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_adjust_event_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PGSliderBar::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_set_active_218(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void PGSliderBar::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const PGSliderBar this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_set_active_218_comment =
    "C++ Interface:\n"
    "setActive(non-const PGSliderBar this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::set_active\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sets whether the PGItem is active for mouse watching.\n"
    "//               This is not necessarily related to the\n"
    "//               active/inactive appearance of the item, which is\n"
    "//               controlled by set_state(), but it does affect whether\n"
    "//               it responds to mouse events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_set_active_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGSliderBar::remanage(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_remanage_219(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGSliderBar::remanage(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":remanage", key_word_list));
        else
            (PyArg_Parse(args, ":remanage"));
        if(!PyErr_Occurred())
        {
            (local_this)->remanage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.remanage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remanage(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_remanage_219_comment =
    "C++ Interface:\n"
    "remanage(non-const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::remanage\n"
    "//       Access: Published\n"
    "//  Description: Manages the position and size of the scroll bars and\n"
    "//               the thumb.  Normally this should not need to be\n"
    "//               called directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_remanage_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGSliderBar::recompute(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_recompute_220(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGSliderBar::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_recompute_220_comment =
    "C++ Interface:\n"
    "recompute(non-const PGSliderBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGSliderBar::recompute\n"
    "//       Access: Published\n"
    "//  Description: Recomputes the position and size of the thumb.\n"
    "//               Normally this should not need to be called directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGSliderBar_recompute_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGSliderBar::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_get_class_type_221(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGSliderBar::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGSliderBar::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_get_class_type_221_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGSliderBar_get_class_type_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGItem *PGSliderBar::upcast_to_PGItem(void)
 *******************************************************************/
static PyObject *Dtool_PGSliderBar_upcast_to_PGItem_180(PyObject *self, PyObject *args,PyObject *kwds) {
    PGSliderBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGSliderBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PGItem *PGSliderBar::upcast_to_PGItem(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPGItem", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPGItem"));
        if(!PyErr_Occurred())
        {
            PGItem *return_value = (PGItem *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGItem,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGSliderBar.upcastToPGItem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPGItem(non-const PGSliderBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGSliderBar_upcast_to_PGItem_180_comment =
    "C++ Interface:\n"
    "upcastToPGItem(non-const PGSliderBar this)\n"
    "\n"
    "upcast from PGSliderBar to PGItem\n"
    "";
#else
static const char * Dtool_PGSliderBar_upcast_to_PGItem_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGSliderBar::PGSliderBar(basic_string< char > const &name)
 * PGSliderBar::PGSliderBar(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_PGSliderBar(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PGSliderBar::PGSliderBar(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGSliderBar", key_word_list))
            {
                PGSliderBar *return_value = new PGSliderBar();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGSliderBar,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PGSliderBar::PGSliderBar(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGSliderBar", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PGSliderBar", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PGSliderBar *return_value = new PGSliderBar(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGSliderBar,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PGSliderBar() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PGSliderBar()\n"
          "PGSliderBar(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGSliderBar(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGSliderBar)
    {
        printf("PGSliderBar ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGSliderBar * local_this = (PGSliderBar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGSliderBar)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGSliderBar(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGSliderBar)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGSliderBar*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGSliderBar*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGSliderBar*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGSliderBar*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGSliderBar*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGScrollFrame 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGScrollFrame::setup(float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_setup_230(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGScrollFrame::setup(float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        static char * key_word_list[] = {(char *)"width", (char *)"height", (char *)"left", (char *)"right", (char *)"bottom", (char *)"top", (char *)"slider_width", (char *)"bevel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddd:setup", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
        {
            (local_this)->setup((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.setup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setup(non-const PGScrollFrame this, float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_setup_230_comment =
    "C++ Interface:\n"
    "setup(non-const PGScrollFrame this, float width, float height, float left, float right, float bottom, float top, float slider_width, float bevel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::setup\n"
    "//       Access: Published\n"
    "//  Description: Creates a PGScrollFrame with the indicated \n"
    "//               dimensions, and the indicated virtual frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_setup_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::set_virtual_frame(LVecBase4f const &virtual_frame)
 * inline void PGScrollFrame::set_virtual_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_set_virtual_frame_231(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PGScrollFrame::set_virtual_frame(LVecBase4f const &virtual_frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"virtual_frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVirtualFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setVirtualFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PGScrollFrame.setVirtualFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_virtual_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PGScrollFrame.setVirtualFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGScrollFrame::set_virtual_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setVirtualFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_virtual_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGScrollFrame.setVirtualFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVirtualFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVirtualFrame(non-const PGScrollFrame this, const VBase4 virtual_frame)\n"
          "setVirtualFrame(non-const PGScrollFrame this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_set_virtual_frame_231_comment =
    "C++ Interface:\n"
    "setVirtualFrame(non-const PGScrollFrame this, const VBase4 virtual_frame)\n"
    "setVirtualFrame(non-const PGScrollFrame this, float left, float right, float bottom, float top)\n"
    "\n"
    "// Filename: pgScrollFrame.I\n"
    "// Created by:  drose (17Aug05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_virtual_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the virtual frame.\n"
    "//               This is the size of the large, virtual canvas which\n"
    "//               we can see only a portion of at any given time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_virtual_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the bounding rectangle of the virtual frame.\n"
    "//               This is the size of the large, virtual canvas which\n"
    "//               we can see only a portion of at any given time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_set_virtual_frame_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PGScrollFrame::get_virtual_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_virtual_frame_232(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PGScrollFrame::get_virtual_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVirtualFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getVirtualFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PGScrollFrame*)local_this)->get_virtual_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVirtualFrame(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_virtual_frame_232_comment =
    "C++ Interface:\n"
    "getVirtualFrame(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::get_virtual_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the bounding rectangle of the virtual frame.\n"
    "//               See set_virtual_frame().  If has_virtual_frame() is\n"
    "//               false, this returns the item's clip frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_virtual_frame_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGScrollFrame::has_virtual_frame(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_has_virtual_frame_233(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGScrollFrame::has_virtual_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasVirtualFrame", key_word_list));
        else
            (PyArg_Parse(args, ":hasVirtualFrame"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGScrollFrame*)local_this)->has_virtual_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasVirtualFrame(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_has_virtual_frame_233_comment =
    "C++ Interface:\n"
    "hasVirtualFrame(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::has_virtual_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the virtual frame has a bounding\n"
    "//               rectangle; see set_virtual_frame().  Most\n"
    "//               PGScrollFrame objects will have a virtual frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_has_virtual_frame_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::clear_virtual_frame(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_clear_virtual_frame_234(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::clear_virtual_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearVirtualFrame", key_word_list));
        else
            (PyArg_Parse(args, ":clearVirtualFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_virtual_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.clearVirtualFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearVirtualFrame(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_clear_virtual_frame_234_comment =
    "C++ Interface:\n"
    "clearVirtualFrame(non-const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::clear_virtual_frame\n"
    "//       Access: Published\n"
    "//  Description: Removes the virtual frame from the item.  This\n"
    "//               effectively sets the virtual frame to the same size\n"
    "//               as the clip frame.  Scrolling will no longer be\n"
    "//               possible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_clear_virtual_frame_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::set_manage_pieces(bool manage_pieces)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_set_manage_pieces_235(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::set_manage_pieces(bool manage_pieces)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"manage_pieces", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setManagePieces", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setManagePieces", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_manage_pieces((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.setManagePieces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setManagePieces(non-const PGScrollFrame this, bool manage_pieces)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_set_manage_pieces_235_comment =
    "C++ Interface:\n"
    "setManagePieces(non-const PGScrollFrame this, bool manage_pieces)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_manage_pieces\n"
    "//       Access: Published\n"
    "//  Description: Sets the manage_pieces flag.  When this is true, the\n"
    "//               sub-pieces of the scroll frame--that is, the two\n"
    "//               scroll bars--are automatically positioned and/or\n"
    "//               resized when the scroll frame's overall frame is\n"
    "//               changed.  They are also automatically resized to fill\n"
    "//               in the gap when one or the other is hidden.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_set_manage_pieces_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGScrollFrame::get_manage_pieces(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_manage_pieces_236(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGScrollFrame::get_manage_pieces(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManagePieces", key_word_list));
        else
            (PyArg_Parse(args, ":getManagePieces"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGScrollFrame*)local_this)->get_manage_pieces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManagePieces(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_manage_pieces_236_comment =
    "C++ Interface:\n"
    "getManagePieces(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::get_manage_pieces\n"
    "//       Access: Published\n"
    "//  Description: Returns the manage_pieces flag.  See\n"
    "//               set_manage_pieces().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_manage_pieces_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::set_auto_hide(bool auto_hide)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_set_auto_hide_237(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::set_auto_hide(bool auto_hide)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_hide", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoHide", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAutoHide", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_hide((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.setAutoHide() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoHide(non-const PGScrollFrame this, bool auto_hide)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_set_auto_hide_237_comment =
    "C++ Interface:\n"
    "setAutoHide(non-const PGScrollFrame this, bool auto_hide)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_auto_hide\n"
    "//       Access: Published\n"
    "//  Description: Sets the auto_hide flag.  When this is true, the\n"
    "//               two scroll bars are automatically hidden if they are\n"
    "//               not needed (that is, if the virtual frame would fit\n"
    "//               within the clip frame without them), and they are\n"
    "//               automatically shown when they are needed.\n"
    "//\n"
    "//               Setting this flag true forces the manage_pieces flag\n"
    "//               to also be set true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_set_auto_hide_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PGScrollFrame::get_auto_hide(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_auto_hide_238(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PGScrollFrame::get_auto_hide(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoHide", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoHide"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PGScrollFrame*)local_this)->get_auto_hide();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoHide(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_auto_hide_238_comment =
    "C++ Interface:\n"
    "getAutoHide(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::get_auto_hide\n"
    "//       Access: Published\n"
    "//  Description: Returns the auto_hide flag.  See\n"
    "//               set_auto_hide().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_auto_hide_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::set_horizontal_slider(PGSliderBar *horizontal_slider)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_set_horizontal_slider_239(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGScrollFrame::set_horizontal_slider(PGSliderBar *horizontal_slider)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"horizontal_slider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHorizontalSlider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHorizontalSlider", &param1));
            if(!PyErr_Occurred())
            {
                PGSliderBar *param1_this = (PGSliderBar *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGSliderBar, 1, "PGScrollFrame.setHorizontalSlider", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_horizontal_slider(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGScrollFrame.setHorizontalSlider() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontalSlider(non-const PGScrollFrame this, non-const PGSliderBar horizontal_slider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_set_horizontal_slider_239_comment =
    "C++ Interface:\n"
    "setHorizontalSlider(non-const PGScrollFrame this, non-const PGSliderBar horizontal_slider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_horizontal_slider\n"
    "//       Access: Published\n"
    "//  Description: Sets the PGSliderBar object that will serve as the\n"
    "//               horizontal scroll bar for this frame.  It is your\n"
    "//               responsibility to parent this slider bar to the frame\n"
    "//               and move it to the appropriate place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_set_horizontal_slider_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::clear_horizontal_slider(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_clear_horizontal_slider_240(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::clear_horizontal_slider(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearHorizontalSlider", key_word_list));
        else
            (PyArg_Parse(args, ":clearHorizontalSlider"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_horizontal_slider();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.clearHorizontalSlider() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearHorizontalSlider(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_clear_horizontal_slider_240_comment =
    "C++ Interface:\n"
    "clearHorizontalSlider(non-const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::clear_horizontal_slider\n"
    "//       Access: Published\n"
    "//  Description: Removes the horizontal scroll bar from control of the\n"
    "//               frame.  It is your responsibility to actually remove\n"
    "//               or hide the object itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_clear_horizontal_slider_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGSliderBar *PGScrollFrame::get_horizontal_slider(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_horizontal_slider_241(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGSliderBar *PGScrollFrame::get_horizontal_slider(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHorizontalSlider", key_word_list));
        else
            (PyArg_Parse(args, ":getHorizontalSlider"));
        if(!PyErr_Occurred())
        {
            PGSliderBar *return_value = ((const PGScrollFrame*)local_this)->get_horizontal_slider();
            if (return_value != (PGSliderBar *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGSliderBar,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHorizontalSlider(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_horizontal_slider_241_comment =
    "C++ Interface:\n"
    "getHorizontalSlider(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::get_horizontal_slider\n"
    "//       Access: Published\n"
    "//  Description: Returns the PGSliderBar that serves as the horizontal\n"
    "//               scroll bar for this frame, if any, or NULL if it is\n"
    "//               not set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_horizontal_slider_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::set_vertical_slider(PGSliderBar *vertical_slider)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_set_vertical_slider_242(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGScrollFrame::set_vertical_slider(PGSliderBar *vertical_slider)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vertical_slider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVerticalSlider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setVerticalSlider", &param1));
            if(!PyErr_Occurred())
            {
                PGSliderBar *param1_this = (PGSliderBar *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGSliderBar, 1, "PGScrollFrame.setVerticalSlider", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_vertical_slider(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGScrollFrame.setVerticalSlider() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerticalSlider(non-const PGScrollFrame this, non-const PGSliderBar vertical_slider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_set_vertical_slider_242_comment =
    "C++ Interface:\n"
    "setVerticalSlider(non-const PGScrollFrame this, non-const PGSliderBar vertical_slider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::set_vertical_slider\n"
    "//       Access: Published\n"
    "//  Description: Sets the PGSliderBar object that will serve as the\n"
    "//               vertical scroll bar for this frame.  It is your\n"
    "//               responsibility to parent this slider bar to the frame\n"
    "//               and move it to the appropriate place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_set_vertical_slider_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::clear_vertical_slider(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_clear_vertical_slider_243(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::clear_vertical_slider(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearVerticalSlider", key_word_list));
        else
            (PyArg_Parse(args, ":clearVerticalSlider"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_vertical_slider();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.clearVerticalSlider() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearVerticalSlider(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_clear_vertical_slider_243_comment =
    "C++ Interface:\n"
    "clearVerticalSlider(non-const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::clear_vertical_slider\n"
    "//       Access: Published\n"
    "//  Description: Removes the vertical scroll bar from control of the\n"
    "//               frame.  It is your responsibility to actually remove\n"
    "//               or hide the object itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_clear_vertical_slider_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGSliderBar *PGScrollFrame::get_vertical_slider(void) const
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_vertical_slider_244(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGSliderBar *PGScrollFrame::get_vertical_slider(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerticalSlider", key_word_list));
        else
            (PyArg_Parse(args, ":getVerticalSlider"));
        if(!PyErr_Occurred())
        {
            PGSliderBar *return_value = ((const PGScrollFrame*)local_this)->get_vertical_slider();
            if (return_value != (PGSliderBar *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGSliderBar,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerticalSlider(const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_vertical_slider_244_comment =
    "C++ Interface:\n"
    "getVerticalSlider(const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::get_vertical_slider\n"
    "//       Access: Published\n"
    "//  Description: Returns the PGSliderBar that serves as the vertical\n"
    "//               scroll bar for this frame, if any, or NULL if it is\n"
    "//               not set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_vertical_slider_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PGScrollFrame::remanage(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_remanage_245(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGScrollFrame::remanage(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":remanage", key_word_list));
        else
            (PyArg_Parse(args, ":remanage"));
        if(!PyErr_Occurred())
        {
            (local_this)->remanage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.remanage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remanage(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_remanage_245_comment =
    "C++ Interface:\n"
    "remanage(non-const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::remanage\n"
    "//       Access: Published\n"
    "//  Description: Manages the position and size of the scroll bars.\n"
    "//               Normally this should not need to be called directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_remanage_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGScrollFrame::recompute(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_recompute_246(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGScrollFrame::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_recompute_246_comment =
    "C++ Interface:\n"
    "recompute(non-const PGScrollFrame this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGScrollFrame::recompute\n"
    "//       Access: Published\n"
    "//  Description: Forces the PGScrollFrame to recompute itself right\n"
    "//               now.  Normally this should not be required.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGScrollFrame_recompute_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGScrollFrame::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_get_class_type_247(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGScrollFrame::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGScrollFrame::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_get_class_type_247_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGScrollFrame_get_class_type_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGVirtualFrame *PGScrollFrame::upcast_to_PGVirtualFrame(void)
 *******************************************************************/
static PyObject *Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_223(PyObject *self, PyObject *args,PyObject *kwds) {
    PGScrollFrame * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGScrollFrame,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PGVirtualFrame *PGScrollFrame::upcast_to_PGVirtualFrame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPGVirtualFrame", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPGVirtualFrame"));
        if(!PyErr_Occurred())
        {
            PGVirtualFrame *return_value = (PGVirtualFrame *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PGVirtualFrame,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGScrollFrame.upcastToPGVirtualFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPGVirtualFrame(non-const PGScrollFrame this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_223_comment =
    "C++ Interface:\n"
    "upcastToPGVirtualFrame(non-const PGScrollFrame this)\n"
    "\n"
    "upcast from PGScrollFrame to PGVirtualFrame\n"
    "";
#else
static const char * Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGScrollFrame::PGScrollFrame(basic_string< char > const &name)
 * PGScrollFrame::PGScrollFrame(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_PGScrollFrame(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PGScrollFrame::PGScrollFrame(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGScrollFrame", key_word_list))
            {
                PGScrollFrame *return_value = new PGScrollFrame();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGScrollFrame,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PGScrollFrame::PGScrollFrame(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGScrollFrame", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PGScrollFrame", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PGScrollFrame *return_value = new PGScrollFrame(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGScrollFrame,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PGScrollFrame() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PGScrollFrame()\n"
          "PGScrollFrame(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGScrollFrame(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGScrollFrame)
    {
        printf("PGScrollFrame ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGScrollFrame * local_this = (PGScrollFrame *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGScrollFrame)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *)( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *)( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_PGVirtualFrame)
        return ( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *)( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *)( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *)( PGVirtualFrame *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *)( PGVirtualFrame *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGScrollFrame(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGScrollFrame)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGScrollFrame*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGScrollFrame*)other_this;
    }
    if(from_type == &Dtool_PGVirtualFrame)
    {
          PGVirtualFrame* other_this = (PGVirtualFrame*)from_this;
          return (PGScrollFrame*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGScrollFrame*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGScrollFrame*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGScrollFrame*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PGWaitBar 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PGWaitBar::setup(float width, float height, float range)
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_setup_250(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PGWaitBar::setup(float width, float height, float range)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"width", (char *)"height", (char *)"range", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setup", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->setup((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGWaitBar.setup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setup(non-const PGWaitBar this, float width, float height, float range)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_setup_250_comment =
    "C++ Interface:\n"
    "setup(non-const PGWaitBar this, float width, float height, float range)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::setup\n"
    "//       Access: Published\n"
    "//  Description: Creates a PGWaitBar with the indicated dimensions,\n"
    "//               with the indicated maximum range.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_setup_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGWaitBar::set_range(float range)
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_set_range_251(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGWaitBar::set_range(float range)
        double param1;
        static char * key_word_list[] = {(char *)"range", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRange", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRange", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_range((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGWaitBar.setRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRange(non-const PGWaitBar this, float range)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_set_range_251_comment =
    "C++ Interface:\n"
    "setRange(non-const PGWaitBar this, float range)\n"
    "\n"
    "// Filename: pgWaitBar.I\n"
    "// Created by:  drose (14Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::set_range\n"
    "//       Access: Published\n"
    "//  Description: Sets the value at which the WaitBar indicates 100%.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_set_range_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGWaitBar::get_range(void) const
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_get_range_252(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGWaitBar::get_range(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRange", key_word_list));
        else
            (PyArg_Parse(args, ":getRange"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGWaitBar*)local_this)->get_range();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRange(const PGWaitBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_get_range_252_comment =
    "C++ Interface:\n"
    "getRange(const PGWaitBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::get_range\n"
    "//       Access: Published\n"
    "//  Description: Returns the value at which the WaitBar indicates 100%.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_get_range_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGWaitBar::set_value(float value)
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_set_value_253(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PGWaitBar::set_value(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PGWaitBar.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const PGWaitBar this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_set_value_253_comment =
    "C++ Interface:\n"
    "setValue(non-const PGWaitBar this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::set_value\n"
    "//       Access: Published\n"
    "//  Description: Sets the current value of the bar.  This should range\n"
    "//               between 0 and get_range().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_set_value_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGWaitBar::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_get_value_254(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGWaitBar::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGWaitBar*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const PGWaitBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_get_value_254_comment =
    "C++ Interface:\n"
    "getValue(const PGWaitBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the current value of the bar.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_get_value_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PGWaitBar::get_percent(void) const
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_get_percent_255(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PGWaitBar::get_percent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPercent", key_word_list));
        else
            (PyArg_Parse(args, ":getPercent"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PGWaitBar*)local_this)->get_percent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPercent(const PGWaitBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_get_percent_255_comment =
    "C++ Interface:\n"
    "getPercent(const PGWaitBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::get_percent\n"
    "//       Access: Published\n"
    "//  Description: Returns the percentage complete.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_get_percent_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PGWaitBar::set_bar_style(PGFrameStyle const &style)
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_set_bar_style_256(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PGWaitBar::set_bar_style(PGFrameStyle const &style)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"style", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBarStyle", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setBarStyle", &param1));
            if(!PyErr_Occurred())
            {
                PGFrameStyle *param1_this = (PGFrameStyle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PGFrameStyle, 1, "PGWaitBar.setBarStyle", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_bar_style(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PGWaitBar.setBarStyle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBarStyle(non-const PGWaitBar this, const PGFrameStyle style)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_set_bar_style_256_comment =
    "C++ Interface:\n"
    "setBarStyle(non-const PGWaitBar this, const PGFrameStyle style)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::set_bar_style\n"
    "//       Access: Published\n"
    "//  Description: Sets the kind of frame that is drawn on top of the\n"
    "//               WaitBar to represent the amount completed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_set_bar_style_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PGFrameStyle PGWaitBar::get_bar_style(void) const
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_get_bar_style_257(PyObject *self, PyObject *args,PyObject *kwds) {
    PGWaitBar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGWaitBar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PGFrameStyle PGWaitBar::get_bar_style(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBarStyle", key_word_list));
        else
            (PyArg_Parse(args, ":getBarStyle"));
        if(!PyErr_Occurred())
        {
            PGFrameStyle result = ((const PGWaitBar*)local_this)->get_bar_style();
            PGFrameStyle *return_value = new PGFrameStyle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PGFrameStyle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBarStyle(const PGWaitBar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_get_bar_style_257_comment =
    "C++ Interface:\n"
    "getBarStyle(const PGWaitBar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PGWaitBar::get_bar_style\n"
    "//       Access: Published\n"
    "//  Description: Returns the kind of frame that is drawn on top of the\n"
    "//               WaitBar to represent the amount completed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PGWaitBar_get_bar_style_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PGWaitBar::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PGWaitBar_get_class_type_258(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PGWaitBar::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PGWaitBar::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PGWaitBar_get_class_type_258_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PGWaitBar_get_class_type_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PGWaitBar::PGWaitBar(basic_string< char > const &name)
 * PGWaitBar::PGWaitBar(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_PGWaitBar(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PGWaitBar::PGWaitBar(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PGWaitBar", key_word_list))
            {
                PGWaitBar *return_value = new PGWaitBar();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGWaitBar,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PGWaitBar::PGWaitBar(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PGWaitBar", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PGWaitBar", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PGWaitBar *return_value = new PGWaitBar(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PGWaitBar,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PGWaitBar() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PGWaitBar()\n"
          "PGWaitBar(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PGWaitBar(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PGWaitBar)
    {
        printf("PGWaitBar ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PGWaitBar * local_this = (PGWaitBar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PGWaitBar)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_PGItem)
        return ( PGItem *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PGItem *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PGWaitBar(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PGWaitBar)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PGWaitBar*)other_this;
    }
    if(from_type == &Dtool_PGItem)
    {
          PGItem* other_this = (PGItem*)from_this;
          return (PGWaitBar*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PGWaitBar*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PGWaitBar*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PGWaitBar*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PGFrameStyle | PGFrameStyle
//********************************************************************
PyMethodDef Dtool_Methods_PGFrameStyle[]= {
  { "assign",(PyCFunction ) &Dtool_PGFrameStyle_operator_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_operator_3_comment},
  { "setType",(PyCFunction ) &Dtool_PGFrameStyle_set_type_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_type_6_comment},
  { "getType",(PyCFunction ) &Dtool_PGFrameStyle_get_type_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_type_7_comment},
  { "setColor",(PyCFunction ) &Dtool_PGFrameStyle_set_color_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_color_8_comment},
  { "getColor",(PyCFunction ) &Dtool_PGFrameStyle_get_color_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_color_9_comment},
  { "setTexture",(PyCFunction ) &Dtool_PGFrameStyle_set_texture_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_texture_10_comment},
  { "hasTexture",(PyCFunction ) &Dtool_PGFrameStyle_has_texture_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_has_texture_11_comment},
  { "getTexture",(PyCFunction ) &Dtool_PGFrameStyle_get_texture_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_texture_12_comment},
  { "clearTexture",(PyCFunction ) &Dtool_PGFrameStyle_clear_texture_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_clear_texture_13_comment},
  { "setWidth",(PyCFunction ) &Dtool_PGFrameStyle_set_width_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_width_14_comment},
  { "getWidth",(PyCFunction ) &Dtool_PGFrameStyle_get_width_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_width_15_comment},
  { "setUvWidth",(PyCFunction ) &Dtool_PGFrameStyle_set_uv_width_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_uv_width_16_comment},
  { "getUvWidth",(PyCFunction ) &Dtool_PGFrameStyle_get_uv_width_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_uv_width_17_comment},
  { "setVisibleScale",(PyCFunction ) &Dtool_PGFrameStyle_set_visible_scale_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_set_visible_scale_18_comment},
  { "getVisibleScale",(PyCFunction ) &Dtool_PGFrameStyle_get_visible_scale_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_visible_scale_19_comment},
  { "getInternalFrame",(PyCFunction ) &Dtool_PGFrameStyle_get_internal_frame_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_get_internal_frame_20_comment},
  { "output",(PyCFunction ) &Dtool_PGFrameStyle_output_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGFrameStyle_output_21_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PGFrameStyle
//////////////////
static PyObject *  Dtool_Repr_PGFrameStyle(PyObject * self)
{
    PGFrameStyle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGFrameStyle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PGFrameStyle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGFrameStyle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGFrameStyle\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PGFrameStyle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PGFrameStyle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGFrameStyle.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PGFrameStyle.As_PyTypeObject().tp_repr = & Dtool_Repr_PGFrameStyle;
        // __str__ Repr Proxy
        Dtool_PGFrameStyle.As_PyTypeObject().tp_str = & Dtool_Repr_PGFrameStyle;
        // Enum  PGFrameStyle::Type;
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TFlat",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TBevelOut",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TBevelIn",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TGroove",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TRidge",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"TTextureBorder",PyInt_FromLong(6));
        if(PyType_Ready(&Dtool_PGFrameStyle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGFrameStyle)");
             printf(" Error In PyType_ReadyPGFrameStyle");
             return;
        }
        Py_INCREF(&Dtool_PGFrameStyle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGFrameStyle.As_PyTypeObject().tp_dict,"PGFrameStyle",&Dtool_PGFrameStyle.As_PyObject());
        RegisterRuntimeClass(&Dtool_PGFrameStyle,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGFrameStyle.As_PyTypeObject());
        PyModule_AddObject(module, "PGFrameStyle",(PyObject *)&Dtool_PGFrameStyle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGItem | PGItem
//********************************************************************
PyMethodDef Dtool_Methods_PGItem[]= {
  { "setName",(PyCFunction ) &Dtool_PGItem_set_name_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_name_25_comment},
  { "setFrame",(PyCFunction ) &Dtool_PGItem_set_frame_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_frame_26_comment},
  { "getFrame",(PyCFunction ) &Dtool_PGItem_get_frame_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_frame_27_comment},
  { "hasFrame",(PyCFunction ) &Dtool_PGItem_has_frame_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_has_frame_28_comment},
  { "clearFrame",(PyCFunction ) &Dtool_PGItem_clear_frame_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_clear_frame_29_comment},
  { "setState",(PyCFunction ) &Dtool_PGItem_set_state_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_state_30_comment},
  { "getState",(PyCFunction ) &Dtool_PGItem_get_state_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_state_31_comment},
  { "setActive",(PyCFunction ) &Dtool_PGItem_set_active_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_active_32_comment},
  { "getActive",(PyCFunction ) &Dtool_PGItem_get_active_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_active_33_comment},
  { "setFocus",(PyCFunction ) &Dtool_PGItem_set_focus_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_focus_34_comment},
  { "getFocus",(PyCFunction ) &Dtool_PGItem_get_focus_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_35_comment},
  { "setBackgroundFocus",(PyCFunction ) &Dtool_PGItem_set_background_focus_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_background_focus_36_comment},
  { "getBackgroundFocus",(PyCFunction ) &Dtool_PGItem_get_background_focus_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_background_focus_37_comment},
  { "setSuppressFlags",(PyCFunction ) &Dtool_PGItem_set_suppress_flags_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_suppress_flags_38_comment},
  { "getSuppressFlags",(PyCFunction ) &Dtool_PGItem_get_suppress_flags_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_suppress_flags_39_comment},
  { "getNumStateDefs",(PyCFunction ) &Dtool_PGItem_get_num_state_defs_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_num_state_defs_40_comment},
  { "clearStateDef",(PyCFunction ) &Dtool_PGItem_clear_state_def_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_clear_state_def_41_comment},
  { "hasStateDef",(PyCFunction ) &Dtool_PGItem_has_state_def_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_has_state_def_42_comment},
  { "getStateDef",(PyCFunction ) &Dtool_PGItem_get_state_def_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_state_def_43_comment},
  { "instanceToStateDef",(PyCFunction ) &Dtool_PGItem_instance_to_state_def_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_instance_to_state_def_44_comment},
  { "getFrameStyle",(PyCFunction ) &Dtool_PGItem_get_frame_style_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_frame_style_45_comment},
  { "setFrameStyle",(PyCFunction ) &Dtool_PGItem_set_frame_style_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_frame_style_46_comment},
  { "getId",(PyCFunction ) &Dtool_PGItem_get_id_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_id_47_comment},
  { "setId",(PyCFunction ) &Dtool_PGItem_set_id_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_id_48_comment},
  { "getEnterPrefix",(PyCFunction ) &Dtool_PGItem_get_enter_prefix_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_enter_prefix_49_comment},
  { "getExitPrefix",(PyCFunction ) &Dtool_PGItem_get_exit_prefix_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_exit_prefix_50_comment},
  { "getWithinPrefix",(PyCFunction ) &Dtool_PGItem_get_within_prefix_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_within_prefix_51_comment},
  { "getWithoutPrefix",(PyCFunction ) &Dtool_PGItem_get_without_prefix_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_without_prefix_52_comment},
  { "getFocusInPrefix",(PyCFunction ) &Dtool_PGItem_get_focus_in_prefix_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_in_prefix_53_comment},
  { "getFocusOutPrefix",(PyCFunction ) &Dtool_PGItem_get_focus_out_prefix_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_out_prefix_54_comment},
  { "getPressPrefix",(PyCFunction ) &Dtool_PGItem_get_press_prefix_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_press_prefix_55_comment},
  { "getRepeatPrefix",(PyCFunction ) &Dtool_PGItem_get_repeat_prefix_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_repeat_prefix_56_comment},
  { "getReleasePrefix",(PyCFunction ) &Dtool_PGItem_get_release_prefix_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_release_prefix_57_comment},
  { "getKeystrokePrefix",(PyCFunction ) &Dtool_PGItem_get_keystroke_prefix_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_keystroke_prefix_58_comment},
  { "getEnterEvent",(PyCFunction ) &Dtool_PGItem_get_enter_event_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_enter_event_59_comment},
  { "getExitEvent",(PyCFunction ) &Dtool_PGItem_get_exit_event_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_exit_event_60_comment},
  { "getWithinEvent",(PyCFunction ) &Dtool_PGItem_get_within_event_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_within_event_61_comment},
  { "getWithoutEvent",(PyCFunction ) &Dtool_PGItem_get_without_event_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_without_event_62_comment},
  { "getFocusInEvent",(PyCFunction ) &Dtool_PGItem_get_focus_in_event_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_in_event_63_comment},
  { "getFocusOutEvent",(PyCFunction ) &Dtool_PGItem_get_focus_out_event_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_out_event_64_comment},
  { "getPressEvent",(PyCFunction ) &Dtool_PGItem_get_press_event_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_press_event_65_comment},
  { "getRepeatEvent",(PyCFunction ) &Dtool_PGItem_get_repeat_event_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_repeat_event_66_comment},
  { "getReleaseEvent",(PyCFunction ) &Dtool_PGItem_get_release_event_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_release_event_67_comment},
  { "getKeystrokeEvent",(PyCFunction ) &Dtool_PGItem_get_keystroke_event_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_keystroke_event_68_comment},
  { "getFrameInvXform",(PyCFunction ) &Dtool_PGItem_get_frame_inv_xform_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_frame_inv_xform_69_comment},
  { "setSound",(PyCFunction ) &Dtool_PGItem_set_sound_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_sound_70_comment},
  { "clearSound",(PyCFunction ) &Dtool_PGItem_clear_sound_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_clear_sound_71_comment},
  { "getSound",(PyCFunction ) &Dtool_PGItem_get_sound_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_sound_72_comment},
  { "hasSound",(PyCFunction ) &Dtool_PGItem_has_sound_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_has_sound_73_comment},
  { "getTextNode",(PyCFunction ) &Dtool_PGItem_get_text_node_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_text_node_74_comment},
  { "setTextNode",(PyCFunction ) &Dtool_PGItem_set_text_node_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_set_text_node_75_comment},
  { "getFocusItem",(PyCFunction ) &Dtool_PGItem_get_focus_item_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_focus_item_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGItem_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_get_class_type_77_comment},
  { "downcastToPGSliderBar",(PyCFunction ) &Dtool_PGItem_downcast_to_PGSliderBar_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGItem_downcast_to_PGSliderBar_181_comment},
  { "getStateDefs",(PyCFunction) &MakeSeq_PGItem_get_state_defs, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGItem(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGItem.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGItem\n"
          "// Description : This is the base class for all the various kinds of\n"
          "//               gui widget objects.\n"
          "//\n"
          "//               It is a Node which corresponds to a rectangular\n"
          "//               region on the screen, and it may have any number of\n"
          "//               \"state\" subgraphs, one of which is rendered at any\n"
          "//               given time according to its current state.\n"
          "//\n"
          "//               The PGItem node must be parented to the scene graph\n"
          "//               somewhere beneath a PGTop node in order for this\n"
          "//               behavior to work.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_PGItem.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_PGItem.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGItem.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGItem.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGItem)");
             printf(" Error In PyType_ReadyPGItem");
             return;
        }
        Py_INCREF(&Dtool_PGItem.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"PGItem",&Dtool_PGItem.As_PyObject());
        //  Static Method getEnterPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getEnterPrefix",PyCFunction_New(&Dtool_Methods_PGItem[24],&Dtool_PGItem.As_PyObject()));
        //  Static Method getExitPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getExitPrefix",PyCFunction_New(&Dtool_Methods_PGItem[25],&Dtool_PGItem.As_PyObject()));
        //  Static Method getWithinPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getWithinPrefix",PyCFunction_New(&Dtool_Methods_PGItem[26],&Dtool_PGItem.As_PyObject()));
        //  Static Method getWithoutPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getWithoutPrefix",PyCFunction_New(&Dtool_Methods_PGItem[27],&Dtool_PGItem.As_PyObject()));
        //  Static Method getFocusInPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getFocusInPrefix",PyCFunction_New(&Dtool_Methods_PGItem[28],&Dtool_PGItem.As_PyObject()));
        //  Static Method getFocusOutPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getFocusOutPrefix",PyCFunction_New(&Dtool_Methods_PGItem[29],&Dtool_PGItem.As_PyObject()));
        //  Static Method getPressPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getPressPrefix",PyCFunction_New(&Dtool_Methods_PGItem[30],&Dtool_PGItem.As_PyObject()));
        //  Static Method getRepeatPrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getRepeatPrefix",PyCFunction_New(&Dtool_Methods_PGItem[31],&Dtool_PGItem.As_PyObject()));
        //  Static Method getReleasePrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getReleasePrefix",PyCFunction_New(&Dtool_Methods_PGItem[32],&Dtool_PGItem.As_PyObject()));
        //  Static Method getKeystrokePrefix
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getKeystrokePrefix",PyCFunction_New(&Dtool_Methods_PGItem[33],&Dtool_PGItem.As_PyObject()));
        //  Static Method getTextNode
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getTextNode",PyCFunction_New(&Dtool_Methods_PGItem[49],&Dtool_PGItem.As_PyObject()));
        //  Static Method setTextNode
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"setTextNode",PyCFunction_New(&Dtool_Methods_PGItem[50],&Dtool_PGItem.As_PyObject()));
        //  Static Method getFocusItem
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getFocusItem",PyCFunction_New(&Dtool_Methods_PGItem[51],&Dtool_PGItem.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGItem.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGItem[52],&Dtool_PGItem.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGItem,PGItem::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGItem.As_PyTypeObject());
        PyModule_AddObject(module, "PGItem",(PyObject *)&Dtool_PGItem.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGButton | PGButton
//********************************************************************
PyMethodDef Dtool_Methods_PGButton[]= {
  { "setup",(PyCFunction ) &Dtool_PGButton_setup_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_setup_81_comment},
  { "addClickButton",(PyCFunction ) &Dtool_PGButton_add_click_button_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_add_click_button_82_comment},
  { "removeClickButton",(PyCFunction ) &Dtool_PGButton_remove_click_button_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_remove_click_button_83_comment},
  { "hasClickButton",(PyCFunction ) &Dtool_PGButton_has_click_button_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_has_click_button_84_comment},
  { "isButtonDown",(PyCFunction ) &Dtool_PGButton_is_button_down_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_is_button_down_85_comment},
  { "getClickPrefix",(PyCFunction ) &Dtool_PGButton_get_click_prefix_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_get_click_prefix_86_comment},
  { "getClickEvent",(PyCFunction ) &Dtool_PGButton_get_click_event_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_get_click_event_87_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGButton_get_class_type_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGButton_get_class_type_88_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGButton(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGButton.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGButton\n"
          "// Description : This is a particular kind of PGItem that is\n"
          "//               specialized to behave like a normal button object.\n"
          "//               It keeps track of its own state, and handles mouse\n"
          "//               events sensibly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGItem._Dtool_ClassInit(NULL);
        Dtool_PGButton.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGItem.As_PyTypeObject());
        Dtool_PGButton.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGButton.As_PyTypeObject().tp_dict);
        // Enum  PGButton::State;
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"SReady",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"SDepressed",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"SRollover",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"SInactive",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_PGButton.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGButton)");
             printf(" Error In PyType_ReadyPGButton");
             return;
        }
        Py_INCREF(&Dtool_PGButton.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"PGButton",&Dtool_PGButton.As_PyObject());
        //  Static Method getClickPrefix
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"getClickPrefix",PyCFunction_New(&Dtool_Methods_PGButton[5],&Dtool_PGButton.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGButton.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGButton[7],&Dtool_PGButton.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGButton,PGButton::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGButton.As_PyTypeObject());
        PyModule_AddObject(module, "PGButton",(PyObject *)&Dtool_PGButton.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGTop | PGTop
//********************************************************************
PyMethodDef Dtool_Methods_PGTop[]= {
  { "setMouseWatcher",(PyCFunction ) &Dtool_PGTop_set_mouse_watcher_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_set_mouse_watcher_91_comment},
  { "getMouseWatcher",(PyCFunction ) &Dtool_PGTop_get_mouse_watcher_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_get_mouse_watcher_92_comment},
  { "getGroup",(PyCFunction ) &Dtool_PGTop_get_group_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_get_group_93_comment},
  { "setStartSort",(PyCFunction ) &Dtool_PGTop_set_start_sort_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_set_start_sort_94_comment},
  { "getStartSort",(PyCFunction ) &Dtool_PGTop_get_start_sort_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_get_start_sort_95_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGTop_get_class_type_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGTop_get_class_type_96_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGTop(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGTop.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGTop\n"
          "// Description : The \"top\" node of the new Panda GUI system.  This\n"
          "//               node must be parented to the 2-d scene graph, and all\n"
          "//               PG objects should be parented to this node or\n"
          "//               somewhere below it.  PG objects not parented within\n"
          "//               this hierarchy will not be clickable.\n"
          "//\n"
          "//               This node begins the special traversal of the PG\n"
          "//               objects that registers each node within the\n"
          "//               MouseWatcher and forces everything to render in a\n"
          "//               depth-first, left-to-right order, appropriate for 2-d\n"
          "//               objects.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_PGTop.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_PGTop.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGTop.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGTop.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGTop.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGTop)");
             printf(" Error In PyType_ReadyPGTop");
             return;
        }
        Py_INCREF(&Dtool_PGTop.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGTop.As_PyTypeObject().tp_dict,"PGTop",&Dtool_PGTop.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGTop.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGTop[5],&Dtool_PGTop.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGTop,PGTop::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGTop.As_PyTypeObject());
        PyModule_AddObject(module, "PGTop",(PyObject *)&Dtool_PGTop.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGEntry | PGEntry
//********************************************************************
PyMethodDef Dtool_Methods_PGEntry[]= {
  { "setup",(PyCFunction ) &Dtool_PGEntry_setup_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_setup_100_comment},
  { "setupMinimal",(PyCFunction ) &Dtool_PGEntry_setup_minimal_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_setup_minimal_101_comment},
  { "setText",(PyCFunction ) &Dtool_PGEntry_set_text_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_text_102_comment},
  { "getPlainText",(PyCFunction ) &Dtool_PGEntry_get_plain_text_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_plain_text_103_comment},
  { "getText",(PyCFunction ) &Dtool_PGEntry_get_text_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_text_104_comment},
  { "getNumCharacters",(PyCFunction ) &Dtool_PGEntry_get_num_characters_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_num_characters_105_comment},
  { "getCharacter",(PyCFunction ) &Dtool_PGEntry_get_character_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_character_106_comment},
  { "getGraphic",(PyCFunction ) &Dtool_PGEntry_get_graphic_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_graphic_107_comment},
  { "getProperties",(PyCFunction ) &Dtool_PGEntry_get_properties_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_properties_108_comment},
  { "setCursorPosition",(PyCFunction ) &Dtool_PGEntry_set_cursor_position_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_cursor_position_109_comment},
  { "getCursorPosition",(PyCFunction ) &Dtool_PGEntry_get_cursor_position_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursor_position_110_comment},
  { "getCursorX",(PyCFunction ) &Dtool_PGEntry_get_cursor_X_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursor_X_111_comment},
  { "getCursorY",(PyCFunction ) &Dtool_PGEntry_get_cursor_Y_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursor_Y_112_comment},
  { "setMaxChars",(PyCFunction ) &Dtool_PGEntry_set_max_chars_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_max_chars_113_comment},
  { "getMaxChars",(PyCFunction ) &Dtool_PGEntry_get_max_chars_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_max_chars_114_comment},
  { "setMaxWidth",(PyCFunction ) &Dtool_PGEntry_set_max_width_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_max_width_115_comment},
  { "getMaxWidth",(PyCFunction ) &Dtool_PGEntry_get_max_width_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_max_width_116_comment},
  { "setNumLines",(PyCFunction ) &Dtool_PGEntry_set_num_lines_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_num_lines_117_comment},
  { "getNumLines",(PyCFunction ) &Dtool_PGEntry_get_num_lines_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_num_lines_118_comment},
  { "setBlinkRate",(PyCFunction ) &Dtool_PGEntry_set_blink_rate_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_blink_rate_119_comment},
  { "getBlinkRate",(PyCFunction ) &Dtool_PGEntry_get_blink_rate_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_blink_rate_120_comment},
  { "getCursorDef",(PyCFunction ) &Dtool_PGEntry_get_cursor_def_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursor_def_121_comment},
  { "clearCursorDef",(PyCFunction ) &Dtool_PGEntry_clear_cursor_def_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_clear_cursor_def_122_comment},
  { "setCursorKeysActive",(PyCFunction ) &Dtool_PGEntry_set_cursor_keys_active_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_cursor_keys_active_123_comment},
  { "getCursorKeysActive",(PyCFunction ) &Dtool_PGEntry_get_cursor_keys_active_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursor_keys_active_124_comment},
  { "setObscureMode",(PyCFunction ) &Dtool_PGEntry_set_obscure_mode_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_obscure_mode_125_comment},
  { "getObscureMode",(PyCFunction ) &Dtool_PGEntry_get_obscure_mode_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_obscure_mode_126_comment},
  { "setOverflowMode",(PyCFunction ) &Dtool_PGEntry_set_overflow_mode_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_overflow_mode_127_comment},
  { "getOverflowMode",(PyCFunction ) &Dtool_PGEntry_get_overflow_mode_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_overflow_mode_128_comment},
  { "setCandidateActive",(PyCFunction ) &Dtool_PGEntry_set_candidate_active_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_candidate_active_129_comment},
  { "getCandidateActive",(PyCFunction ) &Dtool_PGEntry_get_candidate_active_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_candidate_active_130_comment},
  { "setCandidateInactive",(PyCFunction ) &Dtool_PGEntry_set_candidate_inactive_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_candidate_inactive_131_comment},
  { "getCandidateInactive",(PyCFunction ) &Dtool_PGEntry_get_candidate_inactive_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_candidate_inactive_132_comment},
  { "setTextDef",(PyCFunction ) &Dtool_PGEntry_set_text_def_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_text_def_133_comment},
  { "getTextDef",(PyCFunction ) &Dtool_PGEntry_get_text_def_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_text_def_134_comment},
  { "getAcceptPrefix",(PyCFunction ) &Dtool_PGEntry_get_accept_prefix_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_accept_prefix_135_comment},
  { "getAcceptFailedPrefix",(PyCFunction ) &Dtool_PGEntry_get_accept_failed_prefix_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_accept_failed_prefix_136_comment},
  { "getOverflowPrefix",(PyCFunction ) &Dtool_PGEntry_get_overflow_prefix_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_overflow_prefix_137_comment},
  { "getTypePrefix",(PyCFunction ) &Dtool_PGEntry_get_type_prefix_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_type_prefix_138_comment},
  { "getErasePrefix",(PyCFunction ) &Dtool_PGEntry_get_erase_prefix_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_erase_prefix_139_comment},
  { "getCursormovePrefix",(PyCFunction ) &Dtool_PGEntry_get_cursormove_prefix_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursormove_prefix_140_comment},
  { "getAcceptEvent",(PyCFunction ) &Dtool_PGEntry_get_accept_event_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_accept_event_141_comment},
  { "getAcceptFailedEvent",(PyCFunction ) &Dtool_PGEntry_get_accept_failed_event_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_accept_failed_event_142_comment},
  { "getOverflowEvent",(PyCFunction ) &Dtool_PGEntry_get_overflow_event_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_overflow_event_143_comment},
  { "getTypeEvent",(PyCFunction ) &Dtool_PGEntry_get_type_event_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_type_event_144_comment},
  { "getEraseEvent",(PyCFunction ) &Dtool_PGEntry_get_erase_event_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_erase_event_145_comment},
  { "getCursormoveEvent",(PyCFunction ) &Dtool_PGEntry_get_cursormove_event_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_cursormove_event_146_comment},
  { "setWtext",(PyCFunction ) &Dtool_PGEntry_set_wtext_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_wtext_147_comment},
  { "getPlainWtext",(PyCFunction ) &Dtool_PGEntry_get_plain_wtext_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_plain_wtext_148_comment},
  { "getWtext",(PyCFunction ) &Dtool_PGEntry_get_wtext_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_wtext_149_comment},
  { "setAcceptEnabled",(PyCFunction ) &Dtool_PGEntry_set_accept_enabled_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_set_accept_enabled_150_comment},
  { "isWtext",(PyCFunction ) &Dtool_PGEntry_is_wtext_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_is_wtext_151_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGEntry_get_class_type_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGEntry_get_class_type_152_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGEntry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGEntry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGEntry\n"
          "// Description : This is a particular kind of PGItem that handles\n"
          "//               simple one-line or short multi-line text entries, of\n"
          "//               the sort where the user can type any string.\n"
          "//\n"
          "//               A PGEntry does all of its internal manipulation on a\n"
          "//               wide string, so it can store the full Unicode\n"
          "//               character set.  The interface can support either the\n"
          "//               wide string getters and setters, or the normal 8-bit\n"
          "//               string getters and setters, which use whatever\n"
          "//               encoding method is specified by the associated\n"
          "//               TextNode.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGItem._Dtool_ClassInit(NULL);
        Dtool_PGEntry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGItem.As_PyTypeObject());
        Dtool_PGEntry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGEntry.As_PyTypeObject().tp_dict);
        // Enum  PGEntry::State;
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"SFocus",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"SNoFocus",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"SInactive",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_PGEntry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGEntry)");
             printf(" Error In PyType_ReadyPGEntry");
             return;
        }
        Py_INCREF(&Dtool_PGEntry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"PGEntry",&Dtool_PGEntry.As_PyObject());
        //  Static Method getAcceptPrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getAcceptPrefix",PyCFunction_New(&Dtool_Methods_PGEntry[35],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getAcceptFailedPrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getAcceptFailedPrefix",PyCFunction_New(&Dtool_Methods_PGEntry[36],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getOverflowPrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getOverflowPrefix",PyCFunction_New(&Dtool_Methods_PGEntry[37],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getTypePrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getTypePrefix",PyCFunction_New(&Dtool_Methods_PGEntry[38],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getErasePrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getErasePrefix",PyCFunction_New(&Dtool_Methods_PGEntry[39],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getCursormovePrefix
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getCursormovePrefix",PyCFunction_New(&Dtool_Methods_PGEntry[40],&Dtool_PGEntry.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGEntry.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGEntry[52],&Dtool_PGEntry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGEntry,PGEntry::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGEntry.As_PyTypeObject());
        PyModule_AddObject(module, "PGEntry",(PyObject *)&Dtool_PGEntry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGMouseWatcherBackground | PGMouseWatcherBackground
//********************************************************************
PyMethodDef Dtool_Methods_PGMouseWatcherBackground[]= {
  { "getClassType",(PyCFunction ) &Dtool_PGMouseWatcherBackground_get_class_type_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGMouseWatcherBackground_get_class_type_156_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGMouseWatcherBackground(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGMouseWatcherBackground\n"
          "// Description : This is a special kind of MouseWatcherRegion that\n"
          "//               doesn't have a rectangle and is never active, but\n"
          "//               just quietly listens for keypresses and sends them to\n"
          "//               all the PGItems with background focus.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MouseWatcherRegion._Dtool_ClassInit(NULL);
        Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MouseWatcherRegion.As_PyTypeObject());
        Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGMouseWatcherBackground.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGMouseWatcherBackground)");
             printf(" Error In PyType_ReadyPGMouseWatcherBackground");
             return;
        }
        Py_INCREF(&Dtool_PGMouseWatcherBackground.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_dict,"PGMouseWatcherBackground",&Dtool_PGMouseWatcherBackground.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGMouseWatcherBackground.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGMouseWatcherBackground[0],&Dtool_PGMouseWatcherBackground.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGMouseWatcherBackground,PGMouseWatcherBackground::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGMouseWatcherBackground.As_PyTypeObject());
        PyModule_AddObject(module, "PGMouseWatcherBackground",(PyObject *)&Dtool_PGMouseWatcherBackground.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGMouseWatcherParameter | PGMouseWatcherParameter
//********************************************************************
PyMethodDef Dtool_Methods_PGMouseWatcherParameter[]= {
  { "output",(PyCFunction ) &Dtool_PGMouseWatcherParameter_output_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGMouseWatcherParameter_output_165_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGMouseWatcherParameter_get_class_type_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGMouseWatcherParameter_get_class_type_166_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGMouseWatcherParameter_upcast_to_TypedWritableReferenceCount_159_comment},
  { "upcastToMouseWatcherParameter",(PyCFunction ) &Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGMouseWatcherParameter_upcast_to_MouseWatcherParameter_162_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PGMouseWatcherParameter
//////////////////
static PyObject *  Dtool_Repr_PGMouseWatcherParameter(PyObject * self)
{
    PGMouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PGMouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PGMouseWatcherParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGMouseWatcherParameter\n"
          "// Description : This specialization on MouseWatcherParameter allows\n"
          "//               us to tag on additional elements to events for the\n"
          "//               gui system, and also inherits from\n"
          "//               TypedWritableReferenceCount so we can attach this thing to an\n"
          "//               event.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_MouseWatcherParameter._Dtool_ClassInit(NULL);
        Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_MouseWatcherParameter.As_PyTypeObject());
        Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_repr = & Dtool_Repr_PGMouseWatcherParameter;
        // __str__ Repr Proxy
        Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_str = & Dtool_Repr_PGMouseWatcherParameter;
        if(PyType_Ready(&Dtool_PGMouseWatcherParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGMouseWatcherParameter)");
             printf(" Error In PyType_ReadyPGMouseWatcherParameter");
             return;
        }
        Py_INCREF(&Dtool_PGMouseWatcherParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_dict,"PGMouseWatcherParameter",&Dtool_PGMouseWatcherParameter.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGMouseWatcherParameter.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGMouseWatcherParameter[1],&Dtool_PGMouseWatcherParameter.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGMouseWatcherParameter,PGMouseWatcherParameter::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGMouseWatcherParameter.As_PyTypeObject());
        PyModule_AddObject(module, "PGMouseWatcherParameter",(PyObject *)&Dtool_PGMouseWatcherParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGVirtualFrame | PGVirtualFrame
//********************************************************************
PyMethodDef Dtool_Methods_PGVirtualFrame[]= {
  { "setup",(PyCFunction ) &Dtool_PGVirtualFrame_setup_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_setup_169_comment},
  { "setClipFrame",(PyCFunction ) &Dtool_PGVirtualFrame_set_clip_frame_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_set_clip_frame_170_comment},
  { "getClipFrame",(PyCFunction ) &Dtool_PGVirtualFrame_get_clip_frame_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_get_clip_frame_171_comment},
  { "hasClipFrame",(PyCFunction ) &Dtool_PGVirtualFrame_has_clip_frame_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_has_clip_frame_172_comment},
  { "clearClipFrame",(PyCFunction ) &Dtool_PGVirtualFrame_clear_clip_frame_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_clear_clip_frame_173_comment},
  { "setCanvasTransform",(PyCFunction ) &Dtool_PGVirtualFrame_set_canvas_transform_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_set_canvas_transform_174_comment},
  { "getCanvasTransform",(PyCFunction ) &Dtool_PGVirtualFrame_get_canvas_transform_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_get_canvas_transform_175_comment},
  { "getCanvasNode",(PyCFunction ) &Dtool_PGVirtualFrame_get_canvas_node_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_get_canvas_node_176_comment},
  { "getCanvasParent",(PyCFunction ) &Dtool_PGVirtualFrame_get_canvas_parent_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_get_canvas_parent_177_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGVirtualFrame_get_class_type_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_get_class_type_178_comment},
  { "downcastToPGScrollFrame",(PyCFunction ) &Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGVirtualFrame_downcast_to_PGScrollFrame_224_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGVirtualFrame(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGVirtualFrame.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGVirtualFrame\n"
          "// Description : This represents a frame that is rendered as a window\n"
          "//               onto another (possibly much larger) canvas.  You can\n"
          "//               only see the portion of the canvas that is below the\n"
          "//               window at any given time.\n"
          "//\n"
          "//               This works simply by automatically defining a scissor\n"
          "//               effect to be applied to a special child node, called\n"
          "//               the canvas_node, of the PGVirtualFrame node.  Every\n"
          "//               object that is parented to the canvas_node will be\n"
          "//               clipped by the scissor effect.  Also, you can modify\n"
          "//               the canvas_transform through convenience methods\n"
          "//               here, which actually modifies the transform on the\n"
          "//               canvas_node.\n"
          "//\n"
          "//               The net effect is that the virtual canvas is\n"
          "//               arbitrarily large, and we can peek at it through the\n"
          "//               scissor region, and scroll through different parts of\n"
          "//               it by modifying the canvas_transform.\n"
          "//\n"
          "//               See PGScrollFrame for a specialization of this class\n"
          "//               that handles the traditional scrolling canvas, with\n"
          "//               scroll bars.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGItem._Dtool_ClassInit(NULL);
        Dtool_PGVirtualFrame.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGItem.As_PyTypeObject());
        Dtool_PGVirtualFrame.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGVirtualFrame.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGVirtualFrame.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGVirtualFrame.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGVirtualFrame)");
             printf(" Error In PyType_ReadyPGVirtualFrame");
             return;
        }
        Py_INCREF(&Dtool_PGVirtualFrame.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGVirtualFrame.As_PyTypeObject().tp_dict,"PGVirtualFrame",&Dtool_PGVirtualFrame.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGVirtualFrame.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGVirtualFrame[9],&Dtool_PGVirtualFrame.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGVirtualFrame,PGVirtualFrame::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGVirtualFrame.As_PyTypeObject());
        PyModule_AddObject(module, "PGVirtualFrame",(PyObject *)&Dtool_PGVirtualFrame.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGSliderBar | PGSliderBar
//********************************************************************
PyMethodDef Dtool_Methods_PGSliderBar[]= {
  { "setupScrollBar",(PyCFunction ) &Dtool_PGSliderBar_setup_scroll_bar_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_setup_scroll_bar_187_comment},
  { "setupSlider",(PyCFunction ) &Dtool_PGSliderBar_setup_slider_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_setup_slider_188_comment},
  { "setAxis",(PyCFunction ) &Dtool_PGSliderBar_set_axis_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_axis_189_comment},
  { "getAxis",(PyCFunction ) &Dtool_PGSliderBar_get_axis_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_axis_190_comment},
  { "setRange",(PyCFunction ) &Dtool_PGSliderBar_set_range_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_range_191_comment},
  { "getMinValue",(PyCFunction ) &Dtool_PGSliderBar_get_min_value_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_min_value_192_comment},
  { "getMaxValue",(PyCFunction ) &Dtool_PGSliderBar_get_max_value_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_max_value_193_comment},
  { "setScrollSize",(PyCFunction ) &Dtool_PGSliderBar_set_scroll_size_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_scroll_size_194_comment},
  { "getScrollSize",(PyCFunction ) &Dtool_PGSliderBar_get_scroll_size_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_scroll_size_195_comment},
  { "setPageSize",(PyCFunction ) &Dtool_PGSliderBar_set_page_size_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_page_size_196_comment},
  { "getPageSize",(PyCFunction ) &Dtool_PGSliderBar_get_page_size_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_page_size_197_comment},
  { "setValue",(PyCFunction ) &Dtool_PGSliderBar_set_value_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_value_198_comment},
  { "getValue",(PyCFunction ) &Dtool_PGSliderBar_get_value_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_value_199_comment},
  { "setRatio",(PyCFunction ) &Dtool_PGSliderBar_set_ratio_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_ratio_200_comment},
  { "getRatio",(PyCFunction ) &Dtool_PGSliderBar_get_ratio_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_ratio_201_comment},
  { "isButtonDown",(PyCFunction ) &Dtool_PGSliderBar_is_button_down_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_is_button_down_202_comment},
  { "setResizeThumb",(PyCFunction ) &Dtool_PGSliderBar_set_resize_thumb_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_resize_thumb_203_comment},
  { "getResizeThumb",(PyCFunction ) &Dtool_PGSliderBar_get_resize_thumb_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_resize_thumb_204_comment},
  { "setManagePieces",(PyCFunction ) &Dtool_PGSliderBar_set_manage_pieces_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_manage_pieces_205_comment},
  { "getManagePieces",(PyCFunction ) &Dtool_PGSliderBar_get_manage_pieces_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_manage_pieces_206_comment},
  { "setThumbButton",(PyCFunction ) &Dtool_PGSliderBar_set_thumb_button_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_thumb_button_207_comment},
  { "clearThumbButton",(PyCFunction ) &Dtool_PGSliderBar_clear_thumb_button_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_clear_thumb_button_208_comment},
  { "getThumbButton",(PyCFunction ) &Dtool_PGSliderBar_get_thumb_button_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_thumb_button_209_comment},
  { "setLeftButton",(PyCFunction ) &Dtool_PGSliderBar_set_left_button_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_left_button_210_comment},
  { "clearLeftButton",(PyCFunction ) &Dtool_PGSliderBar_clear_left_button_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_clear_left_button_211_comment},
  { "getLeftButton",(PyCFunction ) &Dtool_PGSliderBar_get_left_button_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_left_button_212_comment},
  { "setRightButton",(PyCFunction ) &Dtool_PGSliderBar_set_right_button_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_right_button_213_comment},
  { "clearRightButton",(PyCFunction ) &Dtool_PGSliderBar_clear_right_button_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_clear_right_button_214_comment},
  { "getRightButton",(PyCFunction ) &Dtool_PGSliderBar_get_right_button_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_right_button_215_comment},
  { "getAdjustPrefix",(PyCFunction ) &Dtool_PGSliderBar_get_adjust_prefix_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_adjust_prefix_216_comment},
  { "getAdjustEvent",(PyCFunction ) &Dtool_PGSliderBar_get_adjust_event_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_adjust_event_217_comment},
  { "setActive",(PyCFunction ) &Dtool_PGSliderBar_set_active_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_set_active_218_comment},
  { "remanage",(PyCFunction ) &Dtool_PGSliderBar_remanage_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_remanage_219_comment},
  { "recompute",(PyCFunction ) &Dtool_PGSliderBar_recompute_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_recompute_220_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGSliderBar_get_class_type_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_get_class_type_221_comment},
  { "upcastToPGItem",(PyCFunction ) &Dtool_PGSliderBar_upcast_to_PGItem_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGSliderBar_upcast_to_PGItem_180_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGSliderBar(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGSliderBar.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGSliderBar\n"
          "// Description : This is a particular kind of PGItem that draws a\n"
          "//               little bar with a slider that moves from left to \n"
          "//               right indicating a value between the ranges.\n"
          "//\n"
          "//               This is used as an implementation for both\n"
          "//               DirectSlider and for DirectScrollBar.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGItem._Dtool_ClassInit(NULL);
        Dtool_PGSliderBar.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGItem.As_PyTypeObject());
        Dtool_PGSliderBar.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGSliderBar.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGSliderBar.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGSliderBar.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGSliderBar)");
             printf(" Error In PyType_ReadyPGSliderBar");
             return;
        }
        Py_INCREF(&Dtool_PGSliderBar.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGSliderBar.As_PyTypeObject().tp_dict,"PGSliderBar",&Dtool_PGSliderBar.As_PyObject());
        //  Static Method getAdjustPrefix
        PyDict_SetItemString(Dtool_PGSliderBar.As_PyTypeObject().tp_dict,"getAdjustPrefix",PyCFunction_New(&Dtool_Methods_PGSliderBar[29],&Dtool_PGSliderBar.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGSliderBar.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGSliderBar[34],&Dtool_PGSliderBar.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGSliderBar,PGSliderBar::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGSliderBar.As_PyTypeObject());
        PyModule_AddObject(module, "PGSliderBar",(PyObject *)&Dtool_PGSliderBar.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGScrollFrame | PGScrollFrame
//********************************************************************
PyMethodDef Dtool_Methods_PGScrollFrame[]= {
  { "setup",(PyCFunction ) &Dtool_PGScrollFrame_setup_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_setup_230_comment},
  { "setVirtualFrame",(PyCFunction ) &Dtool_PGScrollFrame_set_virtual_frame_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_set_virtual_frame_231_comment},
  { "getVirtualFrame",(PyCFunction ) &Dtool_PGScrollFrame_get_virtual_frame_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_virtual_frame_232_comment},
  { "hasVirtualFrame",(PyCFunction ) &Dtool_PGScrollFrame_has_virtual_frame_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_has_virtual_frame_233_comment},
  { "clearVirtualFrame",(PyCFunction ) &Dtool_PGScrollFrame_clear_virtual_frame_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_clear_virtual_frame_234_comment},
  { "setManagePieces",(PyCFunction ) &Dtool_PGScrollFrame_set_manage_pieces_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_set_manage_pieces_235_comment},
  { "getManagePieces",(PyCFunction ) &Dtool_PGScrollFrame_get_manage_pieces_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_manage_pieces_236_comment},
  { "setAutoHide",(PyCFunction ) &Dtool_PGScrollFrame_set_auto_hide_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_set_auto_hide_237_comment},
  { "getAutoHide",(PyCFunction ) &Dtool_PGScrollFrame_get_auto_hide_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_auto_hide_238_comment},
  { "setHorizontalSlider",(PyCFunction ) &Dtool_PGScrollFrame_set_horizontal_slider_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_set_horizontal_slider_239_comment},
  { "clearHorizontalSlider",(PyCFunction ) &Dtool_PGScrollFrame_clear_horizontal_slider_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_clear_horizontal_slider_240_comment},
  { "getHorizontalSlider",(PyCFunction ) &Dtool_PGScrollFrame_get_horizontal_slider_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_horizontal_slider_241_comment},
  { "setVerticalSlider",(PyCFunction ) &Dtool_PGScrollFrame_set_vertical_slider_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_set_vertical_slider_242_comment},
  { "clearVerticalSlider",(PyCFunction ) &Dtool_PGScrollFrame_clear_vertical_slider_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_clear_vertical_slider_243_comment},
  { "getVerticalSlider",(PyCFunction ) &Dtool_PGScrollFrame_get_vertical_slider_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_vertical_slider_244_comment},
  { "remanage",(PyCFunction ) &Dtool_PGScrollFrame_remanage_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_remanage_245_comment},
  { "recompute",(PyCFunction ) &Dtool_PGScrollFrame_recompute_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_recompute_246_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGScrollFrame_get_class_type_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_get_class_type_247_comment},
  { "upcastToPGVirtualFrame",(PyCFunction ) &Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGScrollFrame_upcast_to_PGVirtualFrame_223_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGScrollFrame(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGScrollFrame.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGScrollFrame\n"
          "// Description : This is a special kind of frame that pretends to be\n"
          "//               much larger than it actually is.  You can scroll\n"
          "//               through the frame, as if you're looking through a\n"
          "//               window at the larger frame beneath.  All children of\n"
          "//               this frame node are scrolled and clipped as if they\n"
          "//               were children of the larger, virtual frame.\n"
          "//\n"
          "//               This is implemented as a specialization of\n"
          "//               PGVirtualFrame, which handles the meat of the virtual\n"
          "//               canvas.  This class adds automatic support for scroll\n"
          "//               bars, and restricts the virtual transform to\n"
          "//               translate only (no scale or rotate).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGVirtualFrame._Dtool_ClassInit(NULL);
        Dtool_PGScrollFrame.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGVirtualFrame.As_PyTypeObject());
        Dtool_PGScrollFrame.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGScrollFrame.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGScrollFrame.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGScrollFrame.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGScrollFrame)");
             printf(" Error In PyType_ReadyPGScrollFrame");
             return;
        }
        Py_INCREF(&Dtool_PGScrollFrame.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGScrollFrame.As_PyTypeObject().tp_dict,"PGScrollFrame",&Dtool_PGScrollFrame.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGScrollFrame.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGScrollFrame[17],&Dtool_PGScrollFrame.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGScrollFrame,PGScrollFrame::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGScrollFrame.As_PyTypeObject());
        PyModule_AddObject(module, "PGScrollFrame",(PyObject *)&Dtool_PGScrollFrame.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PGWaitBar | PGWaitBar
//********************************************************************
PyMethodDef Dtool_Methods_PGWaitBar[]= {
  { "setup",(PyCFunction ) &Dtool_PGWaitBar_setup_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_setup_250_comment},
  { "setRange",(PyCFunction ) &Dtool_PGWaitBar_set_range_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_set_range_251_comment},
  { "getRange",(PyCFunction ) &Dtool_PGWaitBar_get_range_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_get_range_252_comment},
  { "setValue",(PyCFunction ) &Dtool_PGWaitBar_set_value_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_set_value_253_comment},
  { "getValue",(PyCFunction ) &Dtool_PGWaitBar_get_value_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_get_value_254_comment},
  { "getPercent",(PyCFunction ) &Dtool_PGWaitBar_get_percent_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_get_percent_255_comment},
  { "setBarStyle",(PyCFunction ) &Dtool_PGWaitBar_set_bar_style_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_set_bar_style_256_comment},
  { "getBarStyle",(PyCFunction ) &Dtool_PGWaitBar_get_bar_style_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_get_bar_style_257_comment},
  { "getClassType",(PyCFunction ) &Dtool_PGWaitBar_get_class_type_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PGWaitBar_get_class_type_258_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PGWaitBar(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PGWaitBar.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PGWaitBar\n"
          "// Description : This is a particular kind of PGItem that draws a\n"
          "//               little bar that fills from left to right to indicate\n"
          "//               a slow process gradually completing, like a\n"
          "//               traditional \"wait, loading\" bar.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PGItem._Dtool_ClassInit(NULL);
        Dtool_PGWaitBar.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PGItem.As_PyTypeObject());
        Dtool_PGWaitBar.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PGWaitBar.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PGWaitBar.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PGWaitBar.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PGWaitBar)");
             printf(" Error In PyType_ReadyPGWaitBar");
             return;
        }
        Py_INCREF(&Dtool_PGWaitBar.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PGWaitBar.As_PyTypeObject().tp_dict,"PGWaitBar",&Dtool_PGWaitBar.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PGWaitBar.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PGWaitBar[8],&Dtool_PGWaitBar.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PGWaitBar,PGWaitBar::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PGWaitBar.As_PyTypeObject());
        PyModule_AddObject(module, "PGWaitBar",(PyObject *)&Dtool_PGWaitBar.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PGFrameStyle
//********************************************************************
   Dtool_PyModuleClassInit_PGFrameStyle(module);
//********************************************************************
//*** Module Init Updcall ..PGItem
//********************************************************************
   Dtool_PyModuleClassInit_PGItem(module);
//********************************************************************
//*** Module Init Updcall ..PGButton
//********************************************************************
   Dtool_PyModuleClassInit_PGButton(module);
//********************************************************************
//*** Module Init Updcall ..PGTop
//********************************************************************
   Dtool_PyModuleClassInit_PGTop(module);
//********************************************************************
//*** Module Init Updcall ..PGEntry
//********************************************************************
   Dtool_PyModuleClassInit_PGEntry(module);
//********************************************************************
//*** Module Init Updcall ..PGMouseWatcherBackground
//********************************************************************
   Dtool_PyModuleClassInit_PGMouseWatcherBackground(module);
//********************************************************************
//*** Module Init Updcall ..PGMouseWatcherParameter
//********************************************************************
   Dtool_PyModuleClassInit_PGMouseWatcherParameter(module);
//********************************************************************
//*** Module Init Updcall ..PGVirtualFrame
//********************************************************************
   Dtool_PyModuleClassInit_PGVirtualFrame(module);
//********************************************************************
//*** Module Init Updcall ..PGSliderBar
//********************************************************************
   Dtool_PyModuleClassInit_PGSliderBar(module);
//********************************************************************
//*** Module Init Updcall ..PGScrollFrame
//********************************************************************
   Dtool_PyModuleClassInit_PGScrollFrame(module);
//********************************************************************
//*** Module Init Updcall ..PGWaitBar
//********************************************************************
   Dtool_PyModuleClassInit_PGWaitBar(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpgui_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212922,  /* file_identifier */
  "libpgui",  /* library_name */
  "Vvim",  /* library_hash_name */
  "panda",  /* module_name */
  "libpgui.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  597  /* next_index */
};

Configure(_in_configure_libpgui);
ConfigureFn(_in_configure_libpgui) {
  interrogate_request_module(&_in_module_def);
}

