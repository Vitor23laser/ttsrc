/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pnmimage -Ipanda/src/pnmimage -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpnmimage_igate.cxx -od built_Rocket/pandac/input/libpnmimage.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pnmimage -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpnmimage config_pnmimage.h pnmBrush.h pnmFileType.h pnmFileTypeRegistry.h pnmImage.h pnmImageHeader.h pnmPainter.h pnmReader.h pnmWriter.h pnmbitio.h pnmimage_base.h pnmimage_composite.cxx ppmcmap.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpnmimage
#include "py_panda.h"  

#include "config_pnmimage.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pnmBrush.h"
#include "pnmFileType.h"
#include "pnmFileTypeRegistry.h"
#include "pnmImage.h"
#include "pnmImageHeader.h"
#include "pnmPainter.h"
#include "pnmReader.h"
#include "pnmWriter.h"
#include "pnmbitio.h"
#include "pnmimage_base.h"
#include "pointerTo.h"
#include "ppmcmap.h"
#include "pvector.h"
#include "referenceCount.h"
#include "typedObject.h"
#include "typedWritable.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PNMBrush
//********************************************************************
typedef  PNMBrush  PNMBrush_localtype;
Define_Module_ClassRef(panda,PNMBrush,PNMBrush_localtype,PNMBrush);
//********************************************************************
//*** prototypes for .. pixel
//********************************************************************
typedef  pixel  pixel_localtype;
Define_Module_Class(panda,pixel,pixel_localtype,Pixel);
//********************************************************************
//*** prototypes for .. PNMFileType
//********************************************************************
typedef  PNMFileType  PNMFileType_localtype;
Define_Module_Class(panda,PNMFileType,PNMFileType_localtype,PNMFileType);
//********************************************************************
//*** prototypes for .. PNMFileTypeRegistry
//********************************************************************
typedef  PNMFileTypeRegistry  PNMFileTypeRegistry_localtype;
Define_Module_Class(panda,PNMFileTypeRegistry,PNMFileTypeRegistry_localtype,PNMFileTypeRegistry);
//********************************************************************
//*** prototypes for .. PNMImageHeader
//********************************************************************
typedef  PNMImageHeader  PNMImageHeader_localtype;
Define_Module_Class(panda,PNMImageHeader,PNMImageHeader_localtype,PNMImageHeader);
//********************************************************************
//*** prototypes for .. PNMImageHeader_PixelSpec
//********************************************************************
typedef  PNMImageHeader::PixelSpec  PNMImageHeader_PixelSpec_localtype;
Define_Module_Class(panda,PNMImageHeader_PixelSpec,PNMImageHeader_PixelSpec_localtype,PNMImageHeader::PixelSpec);
//********************************************************************
//*** prototypes for .. PNMImageHeader_PixelSpecCount
//********************************************************************
typedef  PNMImageHeader::PixelSpecCount  PNMImageHeader_PixelSpecCount_localtype;
Define_Module_Class(panda,PNMImageHeader_PixelSpecCount,PNMImageHeader_PixelSpecCount_localtype,PNMImageHeader::PixelSpecCount);
//********************************************************************
//*** prototypes for .. PNMImageHeader_Histogram
//********************************************************************
typedef  PNMImageHeader::Histogram  PNMImageHeader_Histogram_localtype;
Define_Module_Class(panda,PNMImageHeader_Histogram,PNMImageHeader_Histogram_localtype,PNMImageHeader::Histogram);
//********************************************************************
//*** prototypes for .. PNMImage
//********************************************************************
typedef  PNMImage  PNMImage_localtype;
Define_Module_Class(panda,PNMImage,PNMImage_localtype,PNMImage);
//********************************************************************
//*** prototypes for .. PNMPainter
//********************************************************************
typedef  PNMPainter  PNMPainter_localtype;
Define_Module_Class(panda,PNMPainter,PNMPainter_localtype,PNMPainter);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_StackedPerlinNoise2;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_basic_string_char;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_istream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PNMBrush 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
 *******************************************************************/
static PyObject *Dtool_PNMBrush_make_transparent_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":makeTransparent", key_word_list))
        {
            PointerTo< PNMBrush > return_value = PNMBrush::make_transparent();
            if (return_value != (PNMBrush *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeTransparent()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMBrush_make_transparent_4_comment =
    "C++ Interface:\n"
    "makeTransparent()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMBrush::make_transparent\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a new brush that does not paint anything.\n"
    "//               Can be used as either a pen or a fill brush to make\n"
    "//               borderless or unfilled shapes, respectively.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMBrush_make_transparent_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< PNMBrush > PNMBrush::make_pixel(LVecBase4d const &color, PNMBrush::BrushEffect effect)
 * static PointerTo< PNMBrush > PNMBrush::make_pixel(LVecBase4d const &color, PNMBrush::BrushEffect effect = (BE_blend))
 *******************************************************************/
static PyObject *Dtool_PNMBrush_make_pixel_5(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_pixel(LVecBase4d const &color, PNMBrush::BrushEffect effect = (BE_blend))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"color", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:makePixel", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:makePixel", &param0));
                if(!PyErr_Occurred())
                {
                    LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4d, 0, "PNMBrush.makePixel", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_pixel(*param0_this);
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_pixel(LVecBase4d const &color, PNMBrush::BrushEffect effect)
                PyObject *param0;
                int param1;
                static char * key_word_list[] = {(char *)"color", (char *)"effect", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:makePixel", key_word_list, &param0, &param1))
                {
                    LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4d, 0, "PNMBrush.makePixel", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_pixel(*param0_this, (PNMBrush::BrushEffect)param1);
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makePixel() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makePixel(const VBase4D color)\n"
          "makePixel(const VBase4D color, int effect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMBrush_make_pixel_5_comment =
    "C++ Interface:\n"
    "makePixel(const VBase4D color)\n"
    "makePixel(const VBase4D color, int effect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMBrush::make_pixel\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a new brush that paints a single pixel of the\n"
    "//               indicated color on a border, or paints a solid color\n"
    "//               in an interior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMBrush_make_pixel_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< PNMBrush > PNMBrush::make_spot(LVecBase4d const &color, double radius, bool fuzzy, PNMBrush::BrushEffect effect)
 * static PointerTo< PNMBrush > PNMBrush::make_spot(LVecBase4d const &color, double radius, bool fuzzy, PNMBrush::BrushEffect effect = (BE_blend))
 *******************************************************************/
static PyObject *Dtool_PNMBrush_make_spot_6(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_spot(LVecBase4d const &color, double radius, bool fuzzy, PNMBrush::BrushEffect effect = (BE_blend))
                PyObject *param0;
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"color", (char *)"radius", (char *)"fuzzy", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdO:makeSpot", key_word_list, &param0, &param1, &param2))
                {
                    LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4d, 0, "PNMBrush.makeSpot", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_spot(*param0_this, (double)param1, (PyObject_IsTrue(param2)!=0));
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_spot(LVecBase4d const &color, double radius, bool fuzzy, PNMBrush::BrushEffect effect)
                PyObject *param0;
                double param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"color", (char *)"radius", (char *)"fuzzy", (char *)"effect", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdOi:makeSpot", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4d, 0, "PNMBrush.makeSpot", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_spot(*param0_this, (double)param1, (PyObject_IsTrue(param2)!=0), (PNMBrush::BrushEffect)param3);
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeSpot() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeSpot(const VBase4D color, float radius, bool fuzzy)\n"
          "makeSpot(const VBase4D color, float radius, bool fuzzy, int effect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMBrush_make_spot_6_comment =
    "C++ Interface:\n"
    "makeSpot(const VBase4D color, float radius, bool fuzzy)\n"
    "makeSpot(const VBase4D color, float radius, bool fuzzy, int effect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMBrush::make_spot\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a new brush that paints a spot of the\n"
    "//               indicated color and radius.  If fuzzy is true, the\n"
    "//               spot is fuzzy; otherwise, it is hard-edged.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMBrush_make_spot_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, double xc, double yc, PNMBrush::BrushEffect effect)
 * static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, double xc, double yc, PNMBrush::BrushEffect effect = (BE_blend))
 *******************************************************************/
static PyObject *Dtool_PNMBrush_make_image_7(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, double xc, double yc, PNMBrush::BrushEffect effect = (BE_blend))
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"image", (char *)"xc", (char *)"yc", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:makeImage", key_word_list, &param0, &param1, &param2))
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMBrush.makeImage", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_image(*param0_this, (double)param1, (double)param2);
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, double xc, double yc, PNMBrush::BrushEffect effect)
                PyObject *param0;
                double param1;
                double param2;
                int param3;
                static char * key_word_list[] = {(char *)"image", (char *)"xc", (char *)"yc", (char *)"effect", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddi:makeImage", key_word_list, &param0, &param1, &param2, &param3))
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMBrush.makeImage", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PNMBrush > return_value = PNMBrush::make_image(*param0_this, (double)param1, (double)param2, (PNMBrush::BrushEffect)param3);
                        if (return_value != (PNMBrush *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_PNMBrush,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeImage() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeImage(const PNMImage image, float xc, float yc)\n"
          "makeImage(const PNMImage image, float xc, float yc, int effect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMBrush_make_image_7_comment =
    "C++ Interface:\n"
    "makeImage(const PNMImage image, float xc, float yc)\n"
    "makeImage(const PNMImage image, float xc, float yc, int effect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMBrush::make_image\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a new brush that paints with the indicated\n"
    "//               image.  xc and yc indicate the pixel in the center of\n"
    "//               the brush.\n"
    "//\n"
    "//               The brush makes a copy of the image; it is safe to\n"
    "//               deallocate or modify the image after making this\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMBrush_make_image_7_comment = NULL;
#endif

int  Dtool_Init_PNMBrush(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PNMBrush)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PNMBrush(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMBrush)
    {
        printf("PNMBrush ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMBrush * local_this = (PNMBrush *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMBrush)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMBrush(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMBrush)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PNMBrush*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. pixel 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static int pixel::size(void)
 *******************************************************************/
static PyObject *Dtool_pixel_size_10(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int pixel::size(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list))
        {
            int return_value = pixel::size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_size_10_comment =
    "C++ Interface:\n"
    "size()\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_size_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [unsigned short int &pixel::operator [](int i)]
 * unsigned short int pixel::operator [](int i) const
 *******************************************************************/
static PyObject *Dtool_pixel_operator_11(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned short int pixel::operator [](int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const pixel*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            unsigned short int return_value = ((const pixel*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const Pixel this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_11_comment =
    "C++ Interface:\n"
    "__getitem__(const Pixel this, int i)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void pixel::__setitem__(int i, unsigned short int v)
 *******************************************************************/
static PyObject *Dtool_pixel_setitem_12(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void pixel::__setitem__(int i, unsigned short int v)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"i", (char *)"v", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:Setitem", key_word_list, &param1, &param2))
        {
             PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param2_uint == NULL)))
            {
                if (((int)param1) < 0 || ((int)param1) >= (local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                (local_this)->__setitem__((int)param1, PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Pixel.Setitem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const Pixel this, int i, unsigned int v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_setitem_12_comment =
    "C++ Interface:\n"
    "Setitem(non-const Pixel this, int i, unsigned int v)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_setitem_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * pixel pixel::operator +(pixel const &other) const
 *******************************************************************/
static PyObject *Dtool_pixel_operator_13(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-pixel pixel::operator +(pixel const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                pixel *param1_this = (pixel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_pixel, 1, "Pixel.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    pixel result = ((const pixel*)local_this)->operator +(*param1_this);
                    pixel *return_value = new pixel(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const Pixel this, const Pixel other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_13_comment =
    "C++ Interface:\n"
    "__add__(const Pixel this, const Pixel other)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * pixel pixel::operator -(pixel const &other) const
 *******************************************************************/
static PyObject *Dtool_pixel_operator_14(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-pixel pixel::operator -(pixel const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__sub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__sub__", &param1));
            if(!PyErr_Occurred())
            {
                pixel *param1_this = (pixel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_pixel, 1, "Pixel.__sub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    pixel result = ((const pixel*)local_this)->operator -(*param1_this);
                    pixel *return_value = new pixel(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__sub__(const Pixel this, const Pixel other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_14_comment =
    "C++ Interface:\n"
    "__sub__(const Pixel this, const Pixel other)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * pixel pixel::operator *(double const mult) const
 *******************************************************************/
static PyObject *Dtool_pixel_operator_15(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      // 1-pixel pixel::operator *(double const mult) const
        double param1;
        static char * key_word_list[] = {(char *)"mult", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:__mul__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:__mul__", &param1));
        if(!PyErr_Occurred())
        {
            pixel result = ((const pixel*)local_this)->operator *((double)param1);
            pixel *return_value = new pixel(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__mul__(const Pixel this, float mult)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_15_comment =
    "C++ Interface:\n"
    "__mul__(const Pixel this, float mult)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void pixel::operator +=(pixel const &other)
 *******************************************************************/
static PyObject *Dtool_pixel_operator_16(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void pixel::operator +=(pixel const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                pixel *param1_this = (pixel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_pixel, 1, "Pixel.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Pixel.__iadd__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const Pixel this, const Pixel other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_16_comment =
    "C++ Interface:\n"
    "__iadd__(non-const Pixel this, const Pixel other)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void pixel::operator -=(pixel const &other)
 *******************************************************************/
static PyObject *Dtool_pixel_operator_17(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void pixel::operator -=(pixel const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__isub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__isub__", &param1));
            if(!PyErr_Occurred())
            {
                pixel *param1_this = (pixel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_pixel, 1, "Pixel.__isub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator -=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Pixel.__isub__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__isub__(non-const Pixel this, const Pixel other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_17_comment =
    "C++ Interface:\n"
    "__isub__(non-const Pixel this, const Pixel other)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void pixel::operator *=(double const mult)
 *******************************************************************/
static PyObject *Dtool_pixel_operator_18(PyObject *self, PyObject *args,PyObject *kwds) {
    pixel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_pixel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void pixel::operator *=(double const mult)
        double param1;
        static char * key_word_list[] = {(char *)"mult", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:__imul__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:__imul__", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->operator *=((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              Py_INCREF(self);
              return self;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Pixel.__imul__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__imul__(non-const Pixel this, float mult)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_pixel_operator_18_comment =
    "C++ Interface:\n"
    "__imul__(non-const Pixel this, float mult)\n"
    "\n"
    "";
#else
static const char * Dtool_pixel_operator_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * pixel::pixel(void)
 * pixel::pixel(unsigned short int r, unsigned short int g, unsigned short int b)
 *******************************************************************/
int  Dtool_Init_pixel(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-pixel::pixel(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":pixel", key_word_list))
            {
                pixel *return_value = new pixel();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_pixel,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-pixel::pixel(unsigned short int r, unsigned short int g, unsigned short int b)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"r", (char *)"g", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:pixel", key_word_list, &param0, &param1, &param2))
            {
                 PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param0_uint == NULL)|| (param1_uint == NULL)|| (param2_uint == NULL)))
                {
                    pixel *return_value = new pixel(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param0_uint); Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_pixel,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "pixel() takes 0 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "pixel()\n"
          "pixel(unsigned int r, unsigned int g, unsigned int b)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_pixel(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_pixel)
    {
        printf("pixel ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    pixel * local_this = (pixel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_pixel)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_pixel(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_pixel)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMFileType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > PNMFileType::get_name(void) const = 0
 *******************************************************************/
static PyObject *Dtool_PNMFileType_get_name_32(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileType * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > PNMFileType::get_name(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PNMFileType*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const PNMFileType this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileType_get_name_32_comment =
    "C++ Interface:\n"
    "getName(const PNMFileType this)\n"
    "\n"
    "";
#else
static const char * Dtool_PNMFileType_get_name_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int PNMFileType::get_num_extensions(void) const
 *******************************************************************/
static PyObject *Dtool_PNMFileType_get_num_extensions_33(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileType * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int PNMFileType::get_num_extensions(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumExtensions", key_word_list));
        else
            (PyArg_Parse(args, ":getNumExtensions"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMFileType*)local_this)->get_num_extensions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumExtensions(const PNMFileType this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileType_get_num_extensions_33_comment =
    "C++ Interface:\n"
    "getNumExtensions(const PNMFileType this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileType::get_num_extensions\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the number of different possible filename\n"
    "//               extensions associated with this particular file type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileType_get_num_extensions_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > PNMFileType::get_extension(int n) const
 *******************************************************************/
static PyObject *Dtool_PNMFileType_get_extension_34(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileType * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > PNMFileType::get_extension(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getExtension", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getExtension", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PNMFileType*)local_this)->get_extension((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtension(const PNMFileType this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileType_get_extension_34_comment =
    "C++ Interface:\n"
    "getExtension(const PNMFileType this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileType::get_extension\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the nth possible filename extension\n"
    "//               associated with this particular file type, without a\n"
    "//               leading dot.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileType_get_extension_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > PNMFileType::get_suggested_extension(void) const
 *******************************************************************/
static PyObject *Dtool_PNMFileType_get_suggested_extension_35(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileType * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > PNMFileType::get_suggested_extension(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSuggestedExtension", key_word_list));
        else
            (PyArg_Parse(args, ":getSuggestedExtension"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PNMFileType*)local_this)->get_suggested_extension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuggestedExtension(const PNMFileType this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileType_get_suggested_extension_35_comment =
    "C++ Interface:\n"
    "getSuggestedExtension(const PNMFileType this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileType::get_suggested_extension\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns a suitable filename extension (without a\n"
    "//               leading dot) to suggest for files of this type, or\n"
    "//               empty string if no suggestions are available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileType_get_suggested_extension_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PNMFileType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PNMFileType_get_class_type_36(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PNMFileType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PNMFileType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileType_get_class_type_36_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PNMFileType_get_class_type_36_comment = NULL;
#endif

int  Dtool_Init_PNMFileType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PNMFileType)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PNMFileType_get_extensions(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumExtensions", "getExtension");
}
inline void  * Dtool_UpcastInterface_PNMFileType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMFileType)
    {
        printf("PNMFileType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMFileType * local_this = (PNMFileType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMFileType)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMFileType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMFileType)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PNMFileType*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PNMFileType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMFileTypeRegistry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int PNMFileTypeRegistry::get_num_types(void) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_num_types_39(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PNMFileTypeRegistry::get_num_types(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTypes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTypes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMFileTypeRegistry*)local_this)->get_num_types();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTypes(const PNMFileTypeRegistry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_num_types_39_comment =
    "C++ Interface:\n"
    "getNumTypes(const PNMFileTypeRegistry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_num_types\n"
    "//       Access: Published\n"
    "//  Description: Returns the total number of types registered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_num_types_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMFileType *PNMFileTypeRegistry::get_type(int n) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_type_40(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PNMFileType *PNMFileTypeRegistry::get_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getType", &param1));
        if(!PyErr_Occurred())
        {
            PNMFileType *return_value = ((const PNMFileTypeRegistry*)local_this)->get_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PNMFileType,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const PNMFileTypeRegistry this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_type_40_comment =
    "C++ Interface:\n"
    "getType(const PNMFileTypeRegistry this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth type registered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_type_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMFileType *PNMFileTypeRegistry::get_type_from_extension(basic_string< char > const &filename) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_extension_41(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_extension(basic_string< char > const &filename) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"filename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getTypeFromExtension", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getTypeFromExtension", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PNMFileType *return_value = ((const PNMFileTypeRegistry*)local_this)->get_type_from_extension(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PNMFileType,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeFromExtension(const PNMFileTypeRegistry this, string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_type_from_extension_41_comment =
    "C++ Interface:\n"
    "getTypeFromExtension(const PNMFileTypeRegistry this, string filename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_type_from_extension\n"
    "//       Access: Published\n"
    "//  Description: Tries to determine what the PNMFileType is likely to\n"
    "//               be for a particular image file based on its\n"
    "//               extension.  Returns a suitable PNMFileType pointer,\n"
    "//               or NULL if no type can be determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_type_from_extension_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(basic_string< char > const &magic_number) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_42(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(basic_string< char > const &magic_number) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"magic_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getTypeFromMagicNumber", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getTypeFromMagicNumber", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PNMFileType *return_value = ((const PNMFileTypeRegistry*)local_this)->get_type_from_magic_number(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PNMFileType,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeFromMagicNumber(const PNMFileTypeRegistry this, string magic_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_type_from_magic_number_42_comment =
    "C++ Interface:\n"
    "getTypeFromMagicNumber(const PNMFileTypeRegistry this, string magic_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_type_from_magic_number\n"
    "//       Access: Published\n"
    "//  Description: Tries to determine what the PNMFileType is likely to\n"
    "//               be for a particular image file based on its\n"
    "//               magic number, the first two bytes read from the\n"
    "//               file.  Returns a suitable PNMFileType pointer, or\n"
    "//               NULL if no type can be determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_type_from_magic_number_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_type_by_handle_43(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"handle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getTypeByHandle", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getTypeByHandle", &param1));
            if(!PyErr_Occurred())
            {
                TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PNMFileTypeRegistry.getTypeByHandle", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMFileType *return_value = ((const PNMFileTypeRegistry*)local_this)->get_type_by_handle(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PNMFileType,false, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypeByHandle(const PNMFileTypeRegistry this, const TypeHandle handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_type_by_handle_43_comment =
    "C++ Interface:\n"
    "getTypeByHandle(const PNMFileTypeRegistry this, const TypeHandle handle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_type_by_handle\n"
    "//       Access: Published\n"
    "//  Description: Returns the PNMFileType instance stored in the\n"
    "//               registry for the given TypeHandle, e.g. as retrieved\n"
    "//               by a previous call to get_type() on the type\n"
    "//               instance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_type_by_handle_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMFileTypeRegistry::write(ostream &out, int indent_level) const
 * void PNMFileTypeRegistry::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_write_44(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void PNMFileTypeRegistry::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMFileTypeRegistry.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PNMFileTypeRegistry*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void PNMFileTypeRegistry::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMFileTypeRegistry.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PNMFileTypeRegistry*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PNMFileTypeRegistry this, non-const Ostream out)\n"
          "write(const PNMFileTypeRegistry this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_write_44_comment =
    "C++ Interface:\n"
    "write(const PNMFileTypeRegistry this, non-const Ostream out)\n"
    "write(const PNMFileTypeRegistry this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a list of supported image file types to the\n"
    "//               indicated output stream, one per line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_write_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_PNMFileTypeRegistry_get_global_ptr_45(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            PNMFileTypeRegistry *return_value = PNMFileTypeRegistry::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMFileTypeRegistry,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMFileTypeRegistry_get_global_ptr_45_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMFileTypeRegistry::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the global PNMFileTypeRegistry\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMFileTypeRegistry_get_global_ptr_45_comment = NULL;
#endif

int  Dtool_Init_PNMFileTypeRegistry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PNMFileTypeRegistry)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PNMFileTypeRegistry_get_types(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumTypes", "getType");
}
inline void  * Dtool_UpcastInterface_PNMFileTypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMFileTypeRegistry)
    {
        printf("PNMFileTypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMFileTypeRegistry * local_this = (PNMFileTypeRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMFileTypeRegistry)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMFileTypeRegistry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMFileTypeRegistry)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMImageHeader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_operator_48(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader *param1_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader, 1, "PNMImageHeader.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PNMImageHeader *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImageHeader,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImageHeader.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PNMImageHeader this, const PNMImageHeader copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_operator_48_comment =
    "C++ Interface:\n"
    "assign(non-const PNMImageHeader this, const PNMImageHeader copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_operator_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_color_type_51(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorType", key_word_list));
        else
            (PyArg_Parse(args, ":getColorType"));
        if(!PyErr_Occurred())
        {
            PNMImageHeader::ColorType return_value = ((const PNMImageHeader*)local_this)->get_color_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorType(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_color_type_51_comment =
    "C++ Interface:\n"
    "getColorType(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_color_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the image type of the image, as an enumerated\n"
    "//               value.  This is really just the number of channels\n"
    "//               cast to the enumerated type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_color_type_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::get_num_channels(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_num_channels_52(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImageHeader::get_num_channels(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChannels", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChannels"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImageHeader*)local_this)->get_num_channels();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChannels(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_num_channels_52_comment =
    "C++ Interface:\n"
    "getNumChannels(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_num_channels\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of channels in the image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_num_channels_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::is_grayscale(void) const
 * static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_is_grayscale_53(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool PNMImageHeader::is_grayscale(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":isGrayscale", key_word_list));
            else
                (PyArg_Parse(args, ":isGrayscale"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const PNMImageHeader*)local_this)->is_grayscale();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
            int param0;
            static char * key_word_list[] = {(char *)"color_type", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:isGrayscale", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:isGrayscale", &param0));
            if(!PyErr_Occurred())
            {
                bool return_value = PNMImageHeader::is_grayscale((PNMImageHeader::ColorType)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isGrayscale() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isGrayscale(const PNMImageHeader this)\n"
          "isGrayscale(int color_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_is_grayscale_53_comment =
    "C++ Interface:\n"
    "isGrayscale(const PNMImageHeader this)\n"
    "isGrayscale(int color_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::is_grayscale\n"
    "//       Access: Published, Static\n"
    "//  Description: This static variant of is_grayscale() returns true if\n"
    "//               the indicated image type represents a grayscale\n"
    "//               image, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::is_grayscale\n"
    "//       Access: Published\n"
    "//  Description: Returns false if the image is a full-color image, and\n"
    "//               has red, green, and blue components; true if it is a\n"
    "//               grayscale image and has only a gray component.  (The\n"
    "//               gray color is actually stored in the blue channel,\n"
    "//               and the red and green channels are ignored.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_is_grayscale_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::has_alpha(void) const
 * static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_has_alpha_54(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool PNMImageHeader::has_alpha(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAlpha", key_word_list));
            else
                (PyArg_Parse(args, ":hasAlpha"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const PNMImageHeader*)local_this)->has_alpha();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
            int param0;
            static char * key_word_list[] = {(char *)"color_type", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasAlpha", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:hasAlpha", &param0));
            if(!PyErr_Occurred())
            {
                bool return_value = PNMImageHeader::has_alpha((PNMImageHeader::ColorType)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "hasAlpha() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "hasAlpha(const PNMImageHeader this)\n"
          "hasAlpha(int color_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_has_alpha_54_comment =
    "C++ Interface:\n"
    "hasAlpha(const PNMImageHeader this)\n"
    "hasAlpha(int color_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::has_alpha\n"
    "//       Access: Published, Static\n"
    "//  Description: This static variant of has_alpha() returns true if\n"
    "//               the indicated image type includes an alpha channel,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::has_alpha\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the image includes an alpha channel,\n"
    "//               false otherwise.  Unlike is_grayscale(), if this\n"
    "//               returns false it is an error to call any of the\n"
    "//               functions accessing the alpha channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_has_alpha_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::get_maxval(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_maxval_55(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::get_maxval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxval", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxval"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImageHeader*)local_this)->get_maxval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxval(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_maxval_55_comment =
    "C++ Interface:\n"
    "getMaxval(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_maxval\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum channel value allowable for any\n"
    "//               pixel in this image; for instance, 255 for a typical\n"
    "//               8-bit-per-channel image.  A pixel with this value is\n"
    "//               full on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_maxval_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::get_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_x_size_56(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImageHeader::get_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImageHeader*)local_this)->get_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXSize(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_x_size_56_comment =
    "C++ Interface:\n"
    "getXSize(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pixels in the X direction.\n"
    "//               This is one more than the largest allowable X\n"
    "//               coordinate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_x_size_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::get_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_y_size_57(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImageHeader::get_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImageHeader*)local_this)->get_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYSize(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_y_size_57_comment =
    "C++ Interface:\n"
    "getYSize(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pixels in the Y direction.\n"
    "//               This is one more than the largest allowable Y\n"
    "//               coordinate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_y_size_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > PNMImageHeader::get_comment(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_comment_58(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > PNMImageHeader::get_comment(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getComment", key_word_list));
        else
            (PyArg_Parse(args, ":getComment"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PNMImageHeader*)local_this)->get_comment();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getComment(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_comment_58_comment =
    "C++ Interface:\n"
    "getComment(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_comment\n"
    "//       Access: Published\n"
    "//  Description: Gets the user comment from the file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_comment_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::set_comment(basic_string< char > const &comment)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_set_comment_59(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImageHeader::set_comment(basic_string< char > const &comment)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"comment", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setComment", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setComment", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_comment(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImageHeader.setComment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setComment(non-const PNMImageHeader this, string comment)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_set_comment_59_comment =
    "C++ Interface:\n"
    "setComment(non-const PNMImageHeader this, string comment)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::set_comment\n"
    "//       Access: Published\n"
    "//  Description: Writes a user comment string to the image (header).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_set_comment_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::has_type(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_has_type_60(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMImageHeader::has_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasType", key_word_list));
        else
            (PyArg_Parse(args, ":hasType"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PNMImageHeader*)local_this)->has_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasType(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_has_type_60_comment =
    "C++ Interface:\n"
    "hasType(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::has_type\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the PNMImageHeader knows what type it\n"
    "//               is, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_has_type_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMFileType *PNMImageHeader::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_get_type_61(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMFileType *PNMImageHeader::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            PNMFileType *return_value = ((const PNMImageHeader*)local_this)->get_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PNMFileType,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const PNMImageHeader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_get_type_61_comment =
    "C++ Interface:\n"
    "getType(const PNMImageHeader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::get_type\n"
    "//       Access: Published\n"
    "//  Description: If the file type is known (e.g. has_type() returns\n"
    "//               true), returns its PNMFileType pointer; otherwise,\n"
    "//               returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_get_type_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::set_type(PNMFileType *type)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_set_type_62(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImageHeader::set_type(PNMFileType *type)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"type", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setType", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setType", &param1));
            if(!PyErr_Occurred())
            {
                PNMFileType *param1_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMFileType, 1, "PNMImageHeader.setType", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_type(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImageHeader.setType() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setType(non-const PNMImageHeader this, non-const PNMFileType type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_set_type_62_comment =
    "C++ Interface:\n"
    "setType(non-const PNMImageHeader this, non-const PNMFileType type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::set_type\n"
    "//       Access: Published\n"
    "//  Description: Sets the file type of this PNMImage.  This will be\n"
    "//               the default type used when an image is read, if the\n"
    "//               type cannot be determined by magic number or inferred\n"
    "//               by extension, or the type used when the image is\n"
    "//               written, if the type cannot be inferred from the\n"
    "//               filename extension.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_set_type_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type, bool report_unknown_type)
 * bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type, bool report_unknown_type = (1))
 * bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 * bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type)
 * bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type = (1))
 * bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 * bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_read_header_63(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:readHeader", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:readHeader", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImageHeader.readHeader", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:readHeader", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:readHeader", &param1));
                if(!PyErr_Occurred())
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type, bool report_unknown_type = (1))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:readHeader", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImageHeader.readHeader", 1, coerced_ptr, report_errors);
PNMFileType *param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMFileType, 2, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:readHeader", key_word_list, &param1, &param2_str, &param2_len))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type, bool report_unknown_type)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", (char *)"report_unknown_type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:readHeader", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImageHeader.readHeader", 1, coerced_ptr, report_errors);
PNMFileType *param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMFileType, 2, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this, param2_this, (PyObject_IsTrue(param3)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type = (1))
                PyObject *param1;
                char *param2_str; int param2_len;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#O:readHeader", key_word_list, &param1, &param2_str, &param2_len, &param3))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);
PNMFileType *param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMFileType, 3, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this, basic_string<char>(param2_str, param2_len), param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool PNMImageHeader::read_header(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type)
                PyObject *param1;
                char *param2_str; int param2_len;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", (char *)"type", (char *)"report_unknown_type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#OO:readHeader", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);
PNMFileType *param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMFileType, 3, "PNMImageHeader.readHeader", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read_header(*param1_this, basic_string<char>(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImageHeader.readHeader() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "readHeader() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "readHeader(non-const PNMImageHeader this, const Filename filename)\n"
          "readHeader(non-const PNMImageHeader this, non-const Istream data)\n"
          "readHeader(non-const PNMImageHeader this, const Filename filename, non-const PNMFileType type)\n"
          "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename)\n"
          "readHeader(non-const PNMImageHeader this, const Filename filename, non-const PNMFileType type, bool report_unknown_type)\n"
          "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename, non-const PNMFileType type)\n"
          "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename, non-const PNMFileType type, bool report_unknown_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_read_header_63_comment =
    "C++ Interface:\n"
    "readHeader(non-const PNMImageHeader this, const Filename filename)\n"
    "readHeader(non-const PNMImageHeader this, non-const Istream data)\n"
    "readHeader(non-const PNMImageHeader this, const Filename filename, non-const PNMFileType type)\n"
    "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename)\n"
    "readHeader(non-const PNMImageHeader this, const Filename filename, non-const PNMFileType type, bool report_unknown_type)\n"
    "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename, non-const PNMFileType type)\n"
    "readHeader(non-const PNMImageHeader this, non-const Istream data, string filename, non-const PNMFileType type, bool report_unknown_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::read_header\n"
    "//       Access: Published\n"
    "//  Description: Opens up the image file and tries to read its header\n"
    "//               information to determine its size, number of\n"
    "//               channels, etc.  If successful, updates the header\n"
    "//               information and returns true; otherwise, returns\n"
    "//               false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::read_header\n"
    "//       Access: Published\n"
    "//  Description: Reads the image header information only from the\n"
    "//               indicated stream.\n"
    "//\n"
    "//               The filename is advisory only, and may be used\n"
    "//               to suggest a type if it has a known extension.\n"
    "//\n"
    "//               If type is non-NULL, it is a suggestion for the type\n"
    "//               of file it is (and a non-NULL type will override any\n"
    "//               magic number test or filename extension lookup).\n"
    "//\n"
    "//               Returns true if successful, false on error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_read_header_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool PNMImageHeader::read_magic_number(istream *file, basic_string< char > &magic_number, int num_bytes)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_read_magic_number_66(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static bool PNMImageHeader::read_magic_number(istream *file, basic_string< char > &magic_number, int num_bytes)
            PyObject *param0;
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"file", (char *)"magic_number", (char *)"num_bytes", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:readMagicNumber", key_word_list, &param0, &param1, &param2))
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "PNMImageHeader.readMagicNumber", 0, coerced_ptr, report_errors);
basic_string< char > *param1_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_basic_string_char, 1, "PNMImageHeader.readMagicNumber", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    bool return_value = PNMImageHeader::read_magic_number(param0_this, *param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readMagicNumber(non-const Istream file, non-const BasicString magic_number, int num_bytes)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_read_magic_number_66_comment =
    "C++ Interface:\n"
    "readMagicNumber(non-const Istream file, non-const BasicString magic_number, int num_bytes)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::read_magic_number\n"
    "//       Access: Published, Static\n"
    "//  Description: Ensures that the first n bytes of the file are read\n"
    "//               into magic_number.  If magic_number is initially\n"
    "//               nonempty, assumes these represent the first few bytes\n"
    "//               already extracted.  Returns true if successful, false\n"
    "//               if an end of file or error occurred before num_bytes\n"
    "//               could be read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_read_magic_number_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImageHeader::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_output_67(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PNMImageHeader::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMImageHeader.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PNMImageHeader*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PNMImageHeader this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_output_67_comment =
    "C++ Interface:\n"
    "output(const PNMImageHeader this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_output_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImageHeader::PNMImageHeader(void)
 * inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
 *******************************************************************/
int  Dtool_Init_PNMImageHeader(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline PNMImageHeader::PNMImageHeader(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PNMImageHeader", key_word_list))
            {
                PNMImageHeader *return_value = new PNMImageHeader();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PNMImageHeader", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PNMImageHeader", &param0));
                if(!PyErr_Occurred())
                {
                    PNMImageHeader *param0_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImageHeader, 0, "PNMImageHeader.PNMImageHeader", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PNMImageHeader *return_value = new PNMImageHeader(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PNMImageHeader() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PNMImageHeader()\n"
          "PNMImageHeader(const PNMImageHeader copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMImageHeader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMImageHeader)
    {
        printf("PNMImageHeader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMImageHeader * local_this = (PNMImageHeader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMImageHeader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMImageHeader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMImageHeader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMImageHeader::PixelSpec 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::PixelSpec::operator =(PNMImageHeader::PixelSpec const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_70(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImageHeader::PixelSpec::operator =(PNMImageHeader::PixelSpec const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "PixelSpec.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PNMImageHeader::PixelSpec *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImageHeader_PixelSpec,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PixelSpec.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PixelSpec this, const PixelSpec copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_operator_70_comment =
    "C++ Interface:\n"
    "assign(non-const PixelSpec this, const PixelSpec copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_operator_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::PixelSpec::operator <(PNMImageHeader::PixelSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_71(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool PNMImageHeader::PixelSpec::operator <(PNMImageHeader::PixelSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "PixelSpec.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const PNMImageHeader::PixelSpec*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const PixelSpec this, const PixelSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_operator_71_comment =
    "C++ Interface:\n"
    "lessThan(const PixelSpec this, const PixelSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::operator <\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_operator_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::PixelSpec::operator ==(PNMImageHeader::PixelSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_72(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool PNMImageHeader::PixelSpec::operator ==(PNMImageHeader::PixelSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "PixelSpec.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const PNMImageHeader::PixelSpec*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const PixelSpec this, const PixelSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_operator_72_comment =
    "C++ Interface:\n"
    "eq(const PixelSpec this, const PixelSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::operator ==\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_operator_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImageHeader::PixelSpec::operator !=(PNMImageHeader::PixelSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_73(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool PNMImageHeader::PixelSpec::operator !=(PNMImageHeader::PixelSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ne", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ne", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "PixelSpec.ne", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const PNMImageHeader::PixelSpec*)local_this)->operator !=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ne(const PixelSpec this, const PixelSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_operator_73_comment =
    "C++ Interface:\n"
    "ne(const PixelSpec this, const PixelSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::operator !=\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_operator_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_compare_to_74(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "PixelSpec.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const PixelSpec this, const PixelSpec other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_compare_to_74_comment =
    "C++ Interface:\n"
    "compareTo(const PixelSpec this, const PixelSpec other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::compare_to\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_compare_to_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::PixelSpec::get_red(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_red_75(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::PixelSpec::get_red(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRed", key_word_list));
        else
            (PyArg_Parse(args, ":getRed"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->get_red();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRed(const PixelSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_get_red_75_comment =
    "C++ Interface:\n"
    "getRed(const PixelSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::get_red\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_get_red_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::PixelSpec::get_green(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_green_76(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::PixelSpec::get_green(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGreen", key_word_list));
        else
            (PyArg_Parse(args, ":getGreen"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->get_green();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGreen(const PixelSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_get_green_76_comment =
    "C++ Interface:\n"
    "getGreen(const PixelSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::get_green\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_get_green_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::PixelSpec::get_blue(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_blue_77(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::PixelSpec::get_blue(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlue", key_word_list));
        else
            (PyArg_Parse(args, ":getBlue"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->get_blue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlue(const PixelSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_get_blue_77_comment =
    "C++ Interface:\n"
    "getBlue(const PixelSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::get_blue\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_get_blue_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::PixelSpec::get_alpha(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_alpha_78(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::PixelSpec::get_alpha(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlpha", key_word_list));
        else
            (PyArg_Parse(args, ":getAlpha"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->get_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlpha(const PixelSpec this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_get_alpha_78_comment =
    "C++ Interface:\n"
    "getAlpha(const PixelSpec this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::get_alpha\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_get_alpha_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::PixelSpec::set_red(unsigned short int red)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_red_79(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImageHeader::PixelSpec::set_red(unsigned short int red)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"red", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRed", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_red(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PixelSpec.setRed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRed(non-const PixelSpec this, unsigned int red)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_set_red_79_comment =
    "C++ Interface:\n"
    "setRed(non-const PixelSpec this, unsigned int red)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::set_red\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_set_red_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::PixelSpec::set_green(unsigned short int green)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_green_80(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImageHeader::PixelSpec::set_green(unsigned short int green)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"green", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGreen", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setGreen", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_green(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PixelSpec.setGreen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGreen(non-const PixelSpec this, unsigned int green)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_set_green_80_comment =
    "C++ Interface:\n"
    "setGreen(non-const PixelSpec this, unsigned int green)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::set_green\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_set_green_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::PixelSpec::set_blue(unsigned short int blue)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_blue_81(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImageHeader::PixelSpec::set_blue(unsigned short int blue)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"blue", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBlue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setBlue", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_blue(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PixelSpec.setBlue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlue(non-const PixelSpec this, unsigned int blue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_set_blue_81_comment =
    "C++ Interface:\n"
    "setBlue(non-const PixelSpec this, unsigned int blue)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::set_blue\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_set_blue_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImageHeader::PixelSpec::set_alpha(unsigned short int alpha)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_alpha_82(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImageHeader::PixelSpec::set_alpha(unsigned short int alpha)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"alpha", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAlpha", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAlpha", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_alpha(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PixelSpec.setAlpha() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlpha(non-const PixelSpec this, unsigned int alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_set_alpha_82_comment =
    "C++ Interface:\n"
    "setAlpha(non-const PixelSpec this, unsigned int alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::set_alpha\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_set_alpha_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImageHeader::PixelSpec::operator [](int n) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_83(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImageHeader::PixelSpec::operator [](int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const PNMImageHeader::PixelSpec*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            unsigned short int return_value = ((const PNMImageHeader::PixelSpec*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const PixelSpec this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_operator_83_comment =
    "C++ Interface:\n"
    "__getitem__(const PixelSpec this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::operator []\n"
    "//       Access: Published\n"
    "//  Description: Indexes numerically into the components, in the order\n"
    "//               R, G, B, A.  This also makes the PixelSpec work like\n"
    "//               a tuple in Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_operator_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int PNMImageHeader::PixelSpec::size(void)
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_size_84(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int PNMImageHeader::PixelSpec::size(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list))
        {
            int return_value = PNMImageHeader::PixelSpec::size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_size_84_comment =
    "C++ Interface:\n"
    "size()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::size\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies the number of components in the PixelSpec;\n"
    "//               this is always 4, regardless of the type of image it\n"
    "//               was taken from.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_size_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImageHeader::PixelSpec::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_PixelSpec_output_85(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PNMImageHeader::PixelSpec::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PixelSpec.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PNMImageHeader::PixelSpec*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PixelSpec this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_PixelSpec_output_85_comment =
    "C++ Interface:\n"
    "output(const PixelSpec this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::PixelSpec::output\n"
    "//       Access: Public\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_PixelSpec_output_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &copy)
 * inline PNMImageHeader::PixelSpec::PixelSpec(pixel const &rgb)
 * inline PNMImageHeader::PixelSpec::PixelSpec(pixel const &rgb, unsigned short int alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int gray_value)
 * inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int gray_value, unsigned short int alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int red, unsigned short int green, unsigned short int blue)
 * inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int red, unsigned short int green, unsigned short int blue, unsigned short int alpha)
 *******************************************************************/
int  Dtool_Init_PNMImageHeader_PixelSpec(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PixelSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PixelSpec", &param0));
                if(!PyErr_Occurred())
                {
                    PNMImageHeader::PixelSpec *param0_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImageHeader_PixelSpec, 0, "PixelSpec.PixelSpec", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PNMImageHeader::PixelSpec::PixelSpec(pixel const &rgb)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"rgb", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PixelSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PixelSpec", &param0));
                if(!PyErr_Occurred())
                {
                    pixel *param0_this = (pixel *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_pixel, 0, "PixelSpec.PixelSpec", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int gray_value)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"gray_value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PixelSpec", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PixelSpec", &param0));
                if(!PyErr_Occurred())
                {
                     PyObject *param0_uint = PyNumber_Long(param0);
                    if (!((param0_uint == NULL)))
                    {
                        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(PyLong_AsUnsignedLong(param0_uint));
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline PNMImageHeader::PixelSpec::PixelSpec(pixel const &rgb, unsigned short int alpha)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"rgb", (char *)"alpha", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PixelSpec", key_word_list, &param0, &param1))
                {
                    pixel *param0_this = (pixel *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_pixel, 0, "PixelSpec.PixelSpec", 1, coerced_ptr, report_errors);
 PyObject *param1_uint = PyNumber_Long(param1);
                    if (!((param0_this == NULL)|| (param1_uint == NULL)))
                    {
                        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, PyLong_AsUnsignedLong(param1_uint));
                         Py_XDECREF(param1_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int gray_value, unsigned short int alpha)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"gray_value", (char *)"alpha", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PixelSpec", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1);
                    if (!((param0_uint == NULL)|| (param1_uint == NULL)))
                    {
                        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint));
                         Py_XDECREF(param0_uint); Py_XDECREF(param1_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int red, unsigned short int green, unsigned short int blue)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"red", (char *)"green", (char *)"blue", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:PixelSpec", key_word_list, &param0, &param1, &param2))
            {
                 PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param0_uint == NULL)|| (param1_uint == NULL)|| (param2_uint == NULL)))
                {
                    PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param0_uint); Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                    }
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline PNMImageHeader::PixelSpec::PixelSpec(unsigned short int red, unsigned short int green, unsigned short int blue, unsigned short int alpha)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"red", (char *)"green", (char *)"blue", (char *)"alpha", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:PixelSpec", key_word_list, &param0, &param1, &param2, &param3))
            {
                 PyObject *param0_uint = PyNumber_Long(param0); PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param0_uint == NULL)|| (param1_uint == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
                {
                    PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(PyLong_AsUnsignedLong(param0_uint), PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
                     Py_XDECREF(param0_uint); Py_XDECREF(param1_uint); Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_PixelSpec,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PixelSpec() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PixelSpec(const PixelSpec copy)\n"
          "PixelSpec(const Pixel rgb)\n"
          "PixelSpec(unsigned int gray_value)\n"
          "PixelSpec(const Pixel rgb, unsigned int alpha)\n"
          "PixelSpec(unsigned int gray_value, unsigned int alpha)\n"
          "PixelSpec(unsigned int red, unsigned int green, unsigned int blue)\n"
          "PixelSpec(unsigned int red, unsigned int green, unsigned int blue, unsigned int alpha)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMImageHeader_PixelSpec(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMImageHeader_PixelSpec)
    {
        printf("PNMImageHeader_PixelSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMImageHeader::PixelSpec * local_this = (PNMImageHeader::PixelSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMImageHeader_PixelSpec)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMImageHeader_PixelSpec(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMImageHeader_PixelSpec)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMImageHeader::PixelSpecCount 
//********************************************************************
int  Dtool_Init_PNMImageHeader_PixelSpecCount(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PNMImageHeader::PixelSpecCount)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PNMImageHeader_PixelSpecCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMImageHeader_PixelSpecCount)
    {
        printf("PNMImageHeader_PixelSpecCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMImageHeader::PixelSpecCount * local_this = (PNMImageHeader::PixelSpecCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMImageHeader_PixelSpecCount)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMImageHeader_PixelSpecCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMImageHeader_PixelSpecCount)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMImageHeader::Histogram 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::Histogram::get_num_pixels(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_Histogram_get_num_pixels_91(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::Histogram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_Histogram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImageHeader::Histogram::get_num_pixels(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPixels", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPixels"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImageHeader::Histogram*)local_this)->get_num_pixels();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPixels(const Histogram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_Histogram_get_num_pixels_91_comment =
    "C++ Interface:\n"
    "getNumPixels(const Histogram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Histogram::get_num_pixels\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of unique pixel colors in the\n"
    "//               histogram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_Histogram_get_num_pixels_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_Histogram_get_pixel_92(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::Histogram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_Histogram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPixel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPixel", &param1));
        if(!PyErr_Occurred())
        {
            PNMImageHeader::PixelSpec const *return_value = &(((const PNMImageHeader::Histogram*)local_this)->get_pixel((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImageHeader_PixelSpec,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixel(const Histogram this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_Histogram_get_pixel_92_comment =
    "C++ Interface:\n"
    "getPixel(const Histogram this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Histogram::get_pixel\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth unique pixel color in the histogram.\n"
    "//               These are ordered by default from most common to\n"
    "//               least common.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_Histogram_get_pixel_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
 * inline int PNMImageHeader::Histogram::get_count(int n) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_Histogram_get_count_93(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::Histogram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_Histogram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pixel", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getCount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getCount", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::PixelSpec *param1_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_PixelSpec, 1, "Histogram.getCount", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const PNMImageHeader::Histogram*)local_this)->get_count(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline int PNMImageHeader::Histogram::get_count(int n) const
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCount", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = ((const PNMImageHeader::Histogram*)local_this)->get_count((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCount(const Histogram this, const PixelSpec pixel)\n"
          "getCount(const Histogram this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_Histogram_get_count_93_comment =
    "C++ Interface:\n"
    "getCount(const Histogram this, const PixelSpec pixel)\n"
    "getCount(const Histogram this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Histogram::get_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of occurrences in the image of the\n"
    "//               nth unique pixel color in the histogram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Histogram::get_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of occurrences in the image of the\n"
    "//               indicated pixel color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_Histogram_get_count_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImageHeader::Histogram::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PNMImageHeader_Histogram_write_94(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImageHeader::Histogram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_Histogram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PNMImageHeader::Histogram::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Histogram.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PNMImageHeader::Histogram*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const Histogram this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImageHeader_Histogram_write_94_comment =
    "C++ Interface:\n"
    "write(const Histogram this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImageHeader::Histogram::write\n"
    "//       Access: Public\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImageHeader_Histogram_write_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImageHeader::Histogram::Histogram(void)
 *******************************************************************/
int  Dtool_Init_PNMImageHeader_Histogram(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline PNMImageHeader::Histogram::Histogram(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Histogram", key_word_list))
        {
            PNMImageHeader::Histogram *return_value = new PNMImageHeader::Histogram();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImageHeader_Histogram,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Histogram()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PNMImageHeader_Histogram_get_pixels(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPixels", "getPixel");
}
inline void  * Dtool_UpcastInterface_PNMImageHeader_Histogram(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMImageHeader_Histogram)
    {
        printf("PNMImageHeader_Histogram ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMImageHeader::Histogram * local_this = (PNMImageHeader::Histogram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMImageHeader_Histogram)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMImageHeader_Histogram(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMImageHeader_Histogram)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMImage 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::operator =(PNMImage const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_98(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::operator =(PNMImage const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PNMImage *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PNMImage this, const PNMImage copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_98_comment =
    "C++ Interface:\n"
    "assign(non-const PNMImage this, const PNMImage copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::Copy Assigment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::clamp_val(int input_value) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_clamp_val_100(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::clamp_val(int input_value) const
        int param1;
        static char * key_word_list[] = {(char *)"input_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clampVal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clampVal", &param1));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->clamp_val((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clampVal(const PNMImage this, int input_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_clamp_val_100_comment =
    "C++ Interface:\n"
    "clampVal(const PNMImage this, int input_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::clamp_val\n"
    "//       Access: Published\n"
    "//  Description: A handy function to clamp values to\n"
    "//               [0..get_maxval()].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_clamp_val_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::to_val(double input_value) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_to_val_101(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::to_val(double input_value) const
        double param1;
        static char * key_word_list[] = {(char *)"input_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:toVal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:toVal", &param1));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->to_val((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toVal(const PNMImage this, float input_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_to_val_101_comment =
    "C++ Interface:\n"
    "toVal(const PNMImage this, float input_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::to_val\n"
    "//       Access: Published\n"
    "//  Description: A handy function to scale values from [0..1] to\n"
    "//               [0..get_maxval()].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_to_val_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::from_val(unsigned short int input_value) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_from_val_102(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::from_val(unsigned short int input_value) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"input_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:fromVal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:fromVal", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                double return_value = ((const PNMImage*)local_this)->from_val(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fromVal(const PNMImage this, unsigned int input_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_from_val_102_comment =
    "C++ Interface:\n"
    "fromVal(const PNMImage this, unsigned int input_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::from_val\n"
    "//       Access: Published\n"
    "//  Description: A handy function to scale values from\n"
    "//               [0..get_maxval()] to [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_from_val_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::clear(void)
 * void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type)
 * void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type = ((void *)(0)))
 * void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
 * void PNMImage::clear(int x_size, int y_size, int num_channels = (3), unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_PNMImage_clear_103(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::clear(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
            else
                (PyArg_Parse(args, ":clear"));
            if(!PyErr_Occurred())
            {
                (local_this)->clear();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.clear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::clear(int x_size, int y_size, int num_channels = (3), unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:clear", key_word_list, &param1, &param2))
            {
                (local_this)->clear((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.clear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
            int param1;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:clear", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->clear((int)param1, (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.clear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type = ((void *)(0)))
            int param1;
            int param2;
            int param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", (char *)"maxval", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiO:clear", key_word_list, &param1, &param2, &param3, &param4))
            {
                 PyObject *param4_uint = PyNumber_Long(param4);
                if (!((param4_uint == NULL)))
                {
                    (local_this)->clear((int)param1, (int)param2, (int)param3, PyLong_AsUnsignedLong(param4_uint));
                     Py_XDECREF(param4_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.clear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::clear(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type)
                int param1;
                int param2;
                int param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", (char *)"maxval", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiOO:clear", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                     PyObject *param4_uint = PyNumber_Long(param4);PNMFileType *param5_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_PNMFileType, 5, "PNMImage.clear", 0, coerced_ptr, report_errors);

                    if (!((param4_uint == NULL)|| (param5_this == NULL)))
                    {
                        (local_this)->clear((int)param1, (int)param2, (int)param3, PyLong_AsUnsignedLong(param4_uint), param5_this);
                         Py_XDECREF(param4_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.clear() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "clear() takes 1, 3, 4, 5, or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "clear(non-const PNMImage this)\n"
          "clear(non-const PNMImage this, int x_size, int y_size)\n"
          "clear(non-const PNMImage this, int x_size, int y_size, int num_channels)\n"
          "clear(non-const PNMImage this, int x_size, int y_size, int num_channels, unsigned int maxval)\n"
          "clear(non-const PNMImage this, int x_size, int y_size, int num_channels, unsigned int maxval, non-const PNMFileType type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_clear_103_comment =
    "C++ Interface:\n"
    "clear(non-const PNMImage this)\n"
    "clear(non-const PNMImage this, int x_size, int y_size)\n"
    "clear(non-const PNMImage this, int x_size, int y_size, int num_channels)\n"
    "clear(non-const PNMImage this, int x_size, int y_size, int num_channels, unsigned int maxval)\n"
    "clear(non-const PNMImage this, int x_size, int y_size, int num_channels, unsigned int maxval, non-const PNMFileType type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::clear\n"
    "//       Access: Published\n"
    "//  Description: Frees all memory allocated for the image, and clears\n"
    "//               all its parameters (size, color, type, etc).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::clear\n"
    "//       Access: Published\n"
    "//  Description: This flavor of clear() reinitializes the image to an\n"
    "//               empty (black) image with the given dimensions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_clear_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::copy_from(PNMImage const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImage_copy_from_104(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::copy_from(PNMImage const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copyFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copyFrom", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->copy_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.copyFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyFrom(non-const PNMImage this, const PNMImage copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_copy_from_104_comment =
    "C++ Interface:\n"
    "copyFrom(non-const PNMImage this, const PNMImage copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::copy_from\n"
    "//       Access: Published\n"
    "//  Description: Makes this image become a copy of the other image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_copy_from_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size = (-1))
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size = (-1), int y_size = (-1))
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom = (0), int x_size = (-1), int y_size = (-1))
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom = (0), int cfrom = (0), int x_size = (-1), int y_size = (-1))
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = (0), int yfrom = (0), int cfrom = (0), int x_size = (-1), int y_size = (-1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_copy_channel_105(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"src_channel", (char *)"dest_channel", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:copyChannel", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = (0), int yfrom = (0), int cfrom = (0), int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom = (0), int cfrom = (0), int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", (char *)"xfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom = (0), int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", (char *)"xfrom", (char *)"yfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", (char *)"xfrom", (char *)"yfrom", (char *)"cfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                int param8;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", (char *)"xfrom", (char *)"yfrom", (char *)"cfrom", (char *)"x_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (int)param8);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(9):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                int param8;
                int param9;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"cto", (char *)"xfrom", (char *)"yfrom", (char *)"cfrom", (char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiiiii:copyChannel", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copyChannel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_channel(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (int)param8, (int)param9);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copyChannel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "copyChannel() takes 4, 5, 6, 7, 8, 9, or 10 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int src_channel, int dest_channel)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size)\n"
          "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_copy_channel_105_comment =
    "C++ Interface:\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int src_channel, int dest_channel)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size)\n"
    "copyChannel(non-const PNMImage this, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::copy_channel\n"
    "//       Access: Published\n"
    "//  Description: Copies a channel from one image into another.\n"
    "//               Images must be the same size\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::copy_channel\n"
    "//       Access: Published\n"
    "//  Description: Copies just a single channel from the source image\n"
    "//               into a single channel of this image, leaving the\n"
    "//               remaining channels alone.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_copy_channel_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::copy_header_from(PNMImageHeader const &header)
 *******************************************************************/
static PyObject *Dtool_PNMImage_copy_header_from_106(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::copy_header_from(PNMImageHeader const &header)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"header", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copyHeaderFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copyHeaderFrom", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader *param1_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader, 1, "PNMImage.copyHeaderFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->copy_header_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.copyHeaderFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyHeaderFrom(non-const PNMImage this, const PNMImageHeader header)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_copy_header_from_106_comment =
    "C++ Interface:\n"
    "copyHeaderFrom(non-const PNMImage this, const PNMImageHeader header)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::copy_header_from\n"
    "//       Access: Published\n"
    "//  Description: Copies just the header information into this image.\n"
    "//               This will blow away any image data stored in the\n"
    "//               image.  The new image data will be allocated, but\n"
    "//               left unitialized.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_copy_header_from_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::take_from(PNMImage &orig)
 *******************************************************************/
static PyObject *Dtool_PNMImage_take_from_107(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::take_from(PNMImage &orig)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"orig", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:takeFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:takeFrom", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.takeFrom", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->take_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.takeFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "takeFrom(non-const PNMImage this, non-const PNMImage orig)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_take_from_107_comment =
    "C++ Interface:\n"
    "takeFrom(non-const PNMImage this, non-const PNMImage orig)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::take_from\n"
    "//       Access: Published\n"
    "//  Description: Move the contents of the other image into this one,\n"
    "//               and empty the other image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_take_from_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::fill(double gray)
 * inline void PNMImage::fill(double gray = (0))
 * inline void PNMImage::fill(double red, double green, double blue)
 *******************************************************************/
static PyObject *Dtool_PNMImage_fill_108(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::fill(double gray = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":fill", key_word_list));
            else
                (PyArg_Parse(args, ":fill"));
            if(!PyErr_Occurred())
            {
                (local_this)->fill();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::fill(double gray)
            double param1;
            static char * key_word_list[] = {(char *)"gray", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:fill", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:fill", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->fill((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::fill(double red, double green, double blue)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"red", (char *)"green", (char *)"blue", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:fill", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->fill((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "fill() takes 1, 2, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "fill(non-const PNMImage this)\n"
          "fill(non-const PNMImage this, float gray)\n"
          "fill(non-const PNMImage this, float red, float green, float blue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_fill_108_comment =
    "C++ Interface:\n"
    "fill(non-const PNMImage this)\n"
    "fill(non-const PNMImage this, float gray)\n"
    "fill(non-const PNMImage this, float red, float green, float blue)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::fill\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire image (except the alpha channel) to\n"
    "//               the given color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::fill\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire image (except the alpha channel) to\n"
    "//               the given grayscale level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_fill_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::remix_channels(LMatrix4f const &conv)
 *******************************************************************/
static PyObject *Dtool_PNMImage_remix_channels_109(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::remix_channels(LMatrix4f const &conv)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"conv", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remixChannels", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remixChannels", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "PNMImage.remixChannels", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remix_channels(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.remixChannels() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remixChannels(non-const PNMImage this, const Mat4 conv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_remix_channels_109_comment =
    "C++ Interface:\n"
    "remixChannels(non-const PNMImage this, const Mat4 conv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::remix_channels\n"
    "//       Access: Published\n"
    "//  Description: Transforms every pixel using the operation\n"
    "//               (Ro,Go,Bo) = conv.xform_point(Ri,Gi,Bi);\n"
    "//               Input must be a color image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_remix_channels_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::fill_val(unsigned short int gray)
 * inline void PNMImage::fill_val(unsigned short int gray = (0))
 * void PNMImage::fill_val(unsigned short int red, unsigned short int green, unsigned short int blue)
 *******************************************************************/
static PyObject *Dtool_PNMImage_fill_val_110(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::fill_val(unsigned short int gray = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":fillVal", key_word_list));
            else
                (PyArg_Parse(args, ":fillVal"));
            if(!PyErr_Occurred())
            {
                (local_this)->fill_val();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fillVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::fill_val(unsigned short int gray)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"gray", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:fillVal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:fillVal", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->fill_val(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fillVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::fill_val(unsigned short int red, unsigned short int green, unsigned short int blue)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"red", (char *)"green", (char *)"blue", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:fillVal", key_word_list, &param1, &param2, &param3))
            {
                 PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param1_uint == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
                {
                    (local_this)->fill_val(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
                     Py_XDECREF(param1_uint); Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.fillVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "fillVal() takes 1, 2, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "fillVal(non-const PNMImage this)\n"
          "fillVal(non-const PNMImage this, unsigned int gray)\n"
          "fillVal(non-const PNMImage this, unsigned int red, unsigned int green, unsigned int blue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_fill_val_110_comment =
    "C++ Interface:\n"
    "fillVal(non-const PNMImage this)\n"
    "fillVal(non-const PNMImage this, unsigned int gray)\n"
    "fillVal(non-const PNMImage this, unsigned int red, unsigned int green, unsigned int blue)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::fill_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire image (except the alpha channel) to\n"
    "//               the given grayscale level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::fill_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire image (except the alpha channel) to\n"
    "//               the given color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_fill_val_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::alpha_fill(double alpha)
 * inline void PNMImage::alpha_fill(double alpha = (0))
 *******************************************************************/
static PyObject *Dtool_PNMImage_alpha_fill_111(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::alpha_fill(double alpha = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":alphaFill", key_word_list));
            else
                (PyArg_Parse(args, ":alphaFill"));
            if(!PyErr_Occurred())
            {
                (local_this)->alpha_fill();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.alphaFill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::alpha_fill(double alpha)
            double param1;
            static char * key_word_list[] = {(char *)"alpha", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:alphaFill", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:alphaFill", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->alpha_fill((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.alphaFill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "alphaFill() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "alphaFill(non-const PNMImage this)\n"
          "alphaFill(non-const PNMImage this, float alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_alpha_fill_111_comment =
    "C++ Interface:\n"
    "alphaFill(non-const PNMImage this)\n"
    "alphaFill(non-const PNMImage this, float alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::alpha_fill\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire alpha channel to the given level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_alpha_fill_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::alpha_fill_val(unsigned short int alpha)
 * void PNMImage::alpha_fill_val(unsigned short int alpha = (0))
 *******************************************************************/
static PyObject *Dtool_PNMImage_alpha_fill_val_112(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::alpha_fill_val(unsigned short int alpha = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":alphaFillVal", key_word_list));
            else
                (PyArg_Parse(args, ":alphaFillVal"));
            if(!PyErr_Occurred())
            {
                (local_this)->alpha_fill_val();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.alphaFillVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::alpha_fill_val(unsigned short int alpha)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"alpha", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:alphaFillVal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:alphaFillVal", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->alpha_fill_val(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.alphaFillVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "alphaFillVal() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "alphaFillVal(non-const PNMImage this)\n"
          "alphaFillVal(non-const PNMImage this, unsigned int alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_alpha_fill_val_112_comment =
    "C++ Interface:\n"
    "alphaFillVal(non-const PNMImage this)\n"
    "alphaFillVal(non-const PNMImage this, unsigned int alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::alpha_fill_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the entire alpha channel to the given level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_alpha_fill_val_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_read_size(int x_size, int y_size)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_read_size_113(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_read_size(int x_size, int y_size)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setReadSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_read_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setReadSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReadSize(non-const PNMImage this, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_read_size_113_comment =
    "C++ Interface:\n"
    "setReadSize(non-const PNMImage this, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_read_size\n"
    "//       Access: Published\n"
    "//  Description: Specifies the size to we'd like to scale the image\n"
    "//               upon reading it.  This will affect the next call to\n"
    "//               read().  This is usually used to reduce the image\n"
    "//               size, e.g. for a thumbnail.\n"
    "//\n"
    "//               If the file type reader supports it (e.g. JPEG), then\n"
    "//               this will scale the image during the read operation,\n"
    "//               consequently reducing memory and CPU utilization.  If\n"
    "//               the file type reader does not support it, this will\n"
    "//               load the image normally, and them perform a linear\n"
    "//               scale after it has been loaded.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_read_size_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::clear_read_size(void)
 *******************************************************************/
static PyObject *Dtool_PNMImage_clear_read_size_114(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::clear_read_size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearReadSize", key_word_list));
        else
            (PyArg_Parse(args, ":clearReadSize"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_read_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.clearReadSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearReadSize(non-const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_clear_read_size_114_comment =
    "C++ Interface:\n"
    "clearReadSize(non-const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::clear_read_size\n"
    "//       Access: Published\n"
    "//  Description: Undoes the effect of a previous call to\n"
    "//               set_read_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_clear_read_size_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImage::has_read_size(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_has_read_size_115(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMImage::has_read_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasReadSize", key_word_list));
        else
            (PyArg_Parse(args, ":hasReadSize"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PNMImage*)local_this)->has_read_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasReadSize(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_has_read_size_115_comment =
    "C++ Interface:\n"
    "hasReadSize(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::has_read_size\n"
    "//       Access: Published\n"
    "//  Description: Returns true if set_read_size() has been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_has_read_size_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImage::get_read_x_size(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_read_x_size_116(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImage::get_read_x_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReadXSize", key_word_list));
        else
            (PyArg_Parse(args, ":getReadXSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImage*)local_this)->get_read_x_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReadXSize(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_read_x_size_116_comment =
    "C++ Interface:\n"
    "getReadXSize(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_read_x_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the requested x_size of the image if\n"
    "//               set_read_size() has been called, or the image x_size\n"
    "//               otherwise (if it is known).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_read_x_size_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PNMImage::get_read_y_size(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_read_y_size_117(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PNMImage::get_read_y_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReadYSize", key_word_list));
        else
            (PyArg_Parse(args, ":getReadYSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PNMImage*)local_this)->get_read_y_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReadYSize(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_read_y_size_117_comment =
    "C++ Interface:\n"
    "getReadYSize(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_read_y_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the requested y_size of the image if\n"
    "//               set_read_size() has been called, or the image y_size\n"
    "//               otherwise (if it is known).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_read_y_size_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PNMImage::read(Filename const &filename, PNMFileType *type, bool report_unknown_type)
 * bool PNMImage::read(Filename const &filename, PNMFileType *type, bool report_unknown_type = (1))
 * bool PNMImage::read(Filename const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 * Rejected Remap [bool PNMImage::read(PNMReader *reader)]
 * bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type)
 * bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type = (1))
 * bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 * bool PNMImage::read(istream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_read_118(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(Filename const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImage.read", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(istream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(Filename const &filename, PNMFileType *type, bool report_unknown_type = (1))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:read", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImage.read", 1, coerced_ptr, report_errors);
PNMFileType *param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMFileType, 2, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0)), bool report_unknown_type = (1))
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:read", key_word_list, &param1, &param2_str, &param2_len))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(Filename const &filename, PNMFileType *type, bool report_unknown_type)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", (char *)"report_unknown_type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:read", key_word_list, &param1, &param2, &param3))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImage.read", 1, coerced_ptr, report_errors);
PNMFileType *param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMFileType, 2, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this, param2_this, (PyObject_IsTrue(param3)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type = (1))
                PyObject *param1;
                char *param2_str; int param2_len;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#O:read", key_word_list, &param1, &param2_str, &param2_len, &param3))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImage.read", 0, coerced_ptr, report_errors);
PNMFileType *param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMFileType, 3, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this, basic_string<char>(param2_str, param2_len), param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool PNMImage::read(istream &data, basic_string< char > const &filename, PNMFileType *type, bool report_unknown_type)
                PyObject *param1;
                char *param2_str; int param2_len;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", (char *)"type", (char *)"report_unknown_type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#OO:read", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "PNMImage.read", 0, coerced_ptr, report_errors);
PNMFileType *param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMFileType, 3, "PNMImage.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->read(*param1_this, basic_string<char>(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.read() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "read() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "read(non-const PNMImage this, const Filename filename)\n"
          "read(non-const PNMImage this, non-const Istream data)\n"
          "read(non-const PNMImage this, const Filename filename, non-const PNMFileType type)\n"
          "read(non-const PNMImage this, non-const Istream data, string filename)\n"
          "read(non-const PNMImage this, const Filename filename, non-const PNMFileType type, bool report_unknown_type)\n"
          "read(non-const PNMImage this, non-const Istream data, string filename, non-const PNMFileType type)\n"
          "read(non-const PNMImage this, non-const Istream data, string filename, non-const PNMFileType type, bool report_unknown_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_read_118_comment =
    "C++ Interface:\n"
    "read(non-const PNMImage this, const Filename filename)\n"
    "read(non-const PNMImage this, non-const Istream data)\n"
    "read(non-const PNMImage this, const Filename filename, non-const PNMFileType type)\n"
    "read(non-const PNMImage this, non-const Istream data, string filename)\n"
    "read(non-const PNMImage this, const Filename filename, non-const PNMFileType type, bool report_unknown_type)\n"
    "read(non-const PNMImage this, non-const Istream data, string filename, non-const PNMFileType type)\n"
    "read(non-const PNMImage this, non-const Istream data, string filename, non-const PNMFileType type, bool report_unknown_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::read\n"
    "//       Access: Published\n"
    "//  Description: Reads the indicated image filename.  If type is\n"
    "//               non-NULL, it is a suggestion for the type of file it\n"
    "//               is.  Returns true if successful, false on error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::read\n"
    "//       Access: Published\n"
    "//  Description: Reads the image data from the indicated stream.\n"
    "//\n"
    "//               The filename is advisory only, and may be used\n"
    "//               to suggest a type if it has a known extension.\n"
    "//\n"
    "//               If type is non-NULL, it is a suggestion for the type\n"
    "//               of file it is (and a non-NULL type will override any\n"
    "//               magic number test or filename extension lookup).\n"
    "//\n"
    "//               Returns true if successful, false on error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::read\n"
    "//       Access: Published\n"
    "//  Description: This flavor of read() uses an already-existing\n"
    "//               PNMReader to read the image file.  You can get a\n"
    "//               reader via the PNMImageHeader::make_reader() methods.\n"
    "//               This is a good way to examine the header of a file\n"
    "//               (for instance, to determine its size) before actually\n"
    "//               reading the entire image.\n"
    "//\n"
    "//               The PNMReader is always deleted upon completion,\n"
    "//               whether succesful or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_read_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PNMImage::write(Filename const &filename, PNMFileType *type) const
 * bool PNMImage::write(Filename const &filename, PNMFileType *type = ((void *)(0))) const
 * Rejected Remap [bool PNMImage::write(PNMWriter *writer) const]
 * bool PNMImage::write(ostream &data, basic_string< char > const &filename, PNMFileType *type) const
 * bool PNMImage::write(ostream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0))) const
 * bool PNMImage::write(ostream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0))) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_write_119(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool PNMImage::write(Filename const &filename, PNMFileType *type = ((void *)(0))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImage.write", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const PNMImage*)local_this)->write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool PNMImage::write(ostream &data, basic_string< char > const &filename = ((string())), PNMFileType *type = ((void *)(0))) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMImage.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const PNMImage*)local_this)->write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool PNMImage::write(Filename const &filename, PNMFileType *type) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "PNMImage.write", 1, coerced_ptr, report_errors);
PNMFileType *param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMFileType, 2, "PNMImage.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const PNMImage*)local_this)->write(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 bool PNMImage::write(ostream &data, basic_string< char > const &filename, PNMFileType *type = ((void *)(0))) const
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:write", key_word_list, &param1, &param2_str, &param2_len))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMImage.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const PNMImage*)local_this)->write(*param1_this, basic_string<char>(param2_str, param2_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool PNMImage::write(ostream &data, basic_string< char > const &filename, PNMFileType *type) const
                PyObject *param1;
                char *param2_str; int param2_len;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"data", (char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#O:write", key_word_list, &param1, &param2_str, &param2_len, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PNMImage.write", 0, coerced_ptr, report_errors);
PNMFileType *param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMFileType, 3, "PNMImage.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const PNMImage*)local_this)->write(*param1_this, basic_string<char>(param2_str, param2_len), param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PNMImage this, const Filename filename)\n"
          "write(const PNMImage this, non-const Ostream data)\n"
          "write(const PNMImage this, const Filename filename, non-const PNMFileType type)\n"
          "write(const PNMImage this, non-const Ostream data, string filename)\n"
          "write(const PNMImage this, non-const Ostream data, string filename, non-const PNMFileType type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_write_119_comment =
    "C++ Interface:\n"
    "write(const PNMImage this, const Filename filename)\n"
    "write(const PNMImage this, non-const Ostream data)\n"
    "write(const PNMImage this, const Filename filename, non-const PNMFileType type)\n"
    "write(const PNMImage this, non-const Ostream data, string filename)\n"
    "write(const PNMImage this, non-const Ostream data, string filename, non-const PNMFileType type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::write\n"
    "//       Access: Published\n"
    "//  Description: Writes the image to the indicated filename.  If type\n"
    "//               is non-NULL, it is a suggestion for the type of image\n"
    "//               file to write.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::write\n"
    "//       Access: Published\n"
    "//  Description: Writes the image to the indicated ostream.\n"
    "//\n"
    "//               The filename is advisory only, and may be used\n"
    "//               suggest a type if it has a known extension.\n"
    "//\n"
    "//               If type is non-NULL, it is a suggestion for the type\n"
    "//               of image file to write.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::write\n"
    "//       Access: Published\n"
    "//  Description: This flavor of write() uses an already-existing\n"
    "//               PNMWriter to write the image file.  You can get a\n"
    "//               writer via the PNMImageHeader::make_writer() methods.\n"
    "//\n"
    "//               The PNMWriter is always deleted upon completion,\n"
    "//               whether succesful or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_write_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PNMImage::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_is_valid_120(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PNMImage::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PNMImage*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_is_valid_120_comment =
    "C++ Interface:\n"
    "isValid(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::is_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the image has been read in or\n"
    "//               correctly initialized with a height and width.  If\n"
    "//               this returns false, virtually all member functions\n"
    "//               except clear() and read() are invalid function calls.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_is_valid_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_num_channels(int num_channels)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_num_channels_121(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_num_channels(int num_channels)
        int param1;
        static char * key_word_list[] = {(char *)"num_channels", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumChannels", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumChannels", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_channels((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setNumChannels() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumChannels(non-const PNMImage this, int num_channels)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_num_channels_121_comment =
    "C++ Interface:\n"
    "setNumChannels(non-const PNMImage this, int num_channels)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_num_channels\n"
    "//       Access: Published\n"
    "//  Description: Changes the number of channels associated with the\n"
    "//               image.  The new number of channels must be an integer\n"
    "//               in the range 1 through 4, inclusive.  This will\n"
    "//               allocate and/or deallocate memory as necessary to\n"
    "//               accomodate; see set_color_type().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_num_channels_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_color_type_122(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
        int param1;
        static char * key_word_list[] = {(char *)"color_type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setColorType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setColorType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_color_type((PNMImageHeader::ColorType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setColorType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorType(non-const PNMImage this, int color_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_color_type_122_comment =
    "C++ Interface:\n"
    "setColorType(non-const PNMImage this, int color_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_color_type\n"
    "//       Access: Published\n"
    "//  Description: Translates the image to or from grayscale, color, or\n"
    "//               four-color mode.  Grayscale images are converted to\n"
    "//               full-color images with R, G, B set to the original\n"
    "//               gray level; color images are converted to grayscale\n"
    "//               according to the value of Bright().  The alpha\n"
    "//               channel, if added, is initialized to zero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_color_type_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::add_alpha(void)
 *******************************************************************/
static PyObject *Dtool_PNMImage_add_alpha_123(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::add_alpha(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":addAlpha", key_word_list));
        else
            (PyArg_Parse(args, ":addAlpha"));
        if(!PyErr_Occurred())
        {
            (local_this)->add_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.addAlpha() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAlpha(non-const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_add_alpha_123_comment =
    "C++ Interface:\n"
    "addAlpha(non-const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::add_alpha\n"
    "//       Access: Published\n"
    "//  Description: Adds an alpha channel to the image, if it does not\n"
    "//               already have one.  The alpha channel is initialized\n"
    "//               to zeros.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_add_alpha_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::remove_alpha(void)
 *******************************************************************/
static PyObject *Dtool_PNMImage_remove_alpha_124(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::remove_alpha(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAlpha", key_word_list));
        else
            (PyArg_Parse(args, ":removeAlpha"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.removeAlpha() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAlpha(non-const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_remove_alpha_124_comment =
    "C++ Interface:\n"
    "removeAlpha(non-const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::remove_alpha\n"
    "//       Access: Published\n"
    "//  Description: Removes the image's alpha channel, if it exists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_remove_alpha_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::make_grayscale(void)
 * void PNMImage::make_grayscale(double rc, double gc, double bc)
 *******************************************************************/
static PyObject *Dtool_PNMImage_make_grayscale_125(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::make_grayscale(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeGrayscale", key_word_list));
            else
                (PyArg_Parse(args, ":makeGrayscale"));
            if(!PyErr_Occurred())
            {
                (local_this)->make_grayscale();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.makeGrayscale() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::make_grayscale(double rc, double gc, double bc)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"rc", (char *)"gc", (char *)"bc", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:makeGrayscale", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->make_grayscale((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.makeGrayscale() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeGrayscale() takes 1 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeGrayscale(non-const PNMImage this)\n"
          "makeGrayscale(non-const PNMImage this, float rc, float gc, float bc)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_make_grayscale_125_comment =
    "C++ Interface:\n"
    "makeGrayscale(non-const PNMImage this)\n"
    "makeGrayscale(non-const PNMImage this, float rc, float gc, float bc)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::make_grayscale\n"
    "//       Access: Published\n"
    "//  Description: Converts the image from RGB to grayscale.  Any alpha\n"
    "//               channel, if present, is left undisturbed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::make_grayscale\n"
    "//       Access: Published\n"
    "//  Description: Converts the image from RGB to grayscale.  Any alpha\n"
    "//               channel, if present, is left undisturbed.  The\n"
    "//               optional rc, gc, bc values represent the relative\n"
    "//               weights to apply to each channel to convert it to\n"
    "//               grayscale.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_make_grayscale_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::make_rgb(void)
 *******************************************************************/
static PyObject *Dtool_PNMImage_make_rgb_126(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::make_rgb(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeRgb", key_word_list));
        else
            (PyArg_Parse(args, ":makeRgb"));
        if(!PyErr_Occurred())
        {
            (local_this)->make_rgb();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.makeRgb() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeRgb(non-const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_make_rgb_126_comment =
    "C++ Interface:\n"
    "makeRgb(non-const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::make_rgb\n"
    "//       Access: Published\n"
    "//  Description: Converts the image from grayscale to RGB.  Any alpha\n"
    "//               channel, if present, is left undisturbed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_make_rgb_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::set_maxval(unsigned short int maxval)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_maxval_127(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PNMImage::set_maxval(unsigned short int maxval)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"maxval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMaxval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMaxval", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_maxval(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setMaxval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxval(non-const PNMImage this, unsigned int maxval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_maxval_127_comment =
    "C++ Interface:\n"
    "setMaxval(non-const PNMImage this, unsigned int maxval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_maxval\n"
    "//       Access: Published\n"
    "//  Description: Rescales the image to the indicated maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_maxval_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline pixel const &PNMImage::get_xel_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_xel_val_128(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline pixel const &PNMImage::get_xel_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getXelVal", key_word_list, &param1, &param2))
        {
            pixel const *return_value = &(((const PNMImage*)local_this)->get_xel_val((int)param1, (int)param2));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXelVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_xel_val_128_comment =
    "C++ Interface:\n"
    "getXelVal(const PNMImage this, int x, int y)\n"
    "\n"
    "// The *_val() functions return or set the color values in the range\n"
    "// [0..get_maxval()].  This range may be different for different\n"
    "// images!  Use the corresponding functions (without _val()) to work\n"
    "// in the normalized range [0..1].\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_xel_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the RGB color at the indicated pixel.  Each\n"
    "//               component is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_xel_val_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_xel_val(int x, int y, pixel const &value)
 * inline void PNMImage::set_xel_val(int x, int y, unsigned short int gray)
 * inline void PNMImage::set_xel_val(int x, int y, unsigned short int r, unsigned short int g, unsigned short int b)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_xel_val_129(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PNMImage::set_xel_val(int x, int y, pixel const &value)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"value", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setXelVal", key_word_list, &param1, &param2, &param3))
                {
                    pixel *param3_this = (pixel *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_pixel, 3, "PNMImage.setXelVal", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_xel_val((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PNMImage::set_xel_val(int x, int y, unsigned short int gray)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"gray", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setXelVal", key_word_list, &param1, &param2, &param3))
                {
                     PyObject *param3_uint = PyNumber_Long(param3);
                    if (!((param3_uint == NULL)))
                    {
                        (local_this)->set_xel_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                         Py_XDECREF(param3_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::set_xel_val(int x, int y, unsigned short int r, unsigned short int g, unsigned short int b)
            int param1;
            int param2;
            PyObject *param3;
            PyObject *param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", (char *)"g", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiOOO:setXelVal", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                 PyObject *param3_uint = PyNumber_Long(param3); PyObject *param4_uint = PyNumber_Long(param4); PyObject *param5_uint = PyNumber_Long(param5);
                if (!((param3_uint == NULL)|| (param4_uint == NULL)|| (param5_uint == NULL)))
                {
                    (local_this)->set_xel_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint), PyLong_AsUnsignedLong(param4_uint), PyLong_AsUnsignedLong(param5_uint));
                     Py_XDECREF(param3_uint); Py_XDECREF(param4_uint); Py_XDECREF(param5_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.setXelVal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setXelVal() takes 4 or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setXelVal(non-const PNMImage this, int x, int y, const Pixel value)\n"
          "setXelVal(non-const PNMImage this, int x, int y, unsigned int gray)\n"
          "setXelVal(non-const PNMImage this, int x, int y, unsigned int r, unsigned int g, unsigned int b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_xel_val_129_comment =
    "C++ Interface:\n"
    "setXelVal(non-const PNMImage this, int x, int y, const Pixel value)\n"
    "setXelVal(non-const PNMImage this, int x, int y, unsigned int gray)\n"
    "setXelVal(non-const PNMImage this, int x, int y, unsigned int r, unsigned int g, unsigned int b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel_val\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGB color at the indicated pixel.  Each\n"
    "//               component is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel_val\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGB color at the indicated pixel.  Each\n"
    "//               component is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel_val\n"
    "//       Access: Published\n"
    "//  Description: Changes all three color components at the indicated\n"
    "//               pixel to the same value.  The value is in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_xel_val_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::get_red_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_red_val_130(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::get_red_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getRedVal", key_word_list, &param1, &param2))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_red_val((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRedVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_red_val_130_comment =
    "C++ Interface:\n"
    "getRedVal(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_red_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the red component color at the indicated\n"
    "//               pixel.  The value returned is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_red_val_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::get_green_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_green_val_131(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::get_green_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getGreenVal", key_word_list, &param1, &param2))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_green_val((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGreenVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_green_val_131_comment =
    "C++ Interface:\n"
    "getGreenVal(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_green_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the green component color at the indicated\n"
    "//               pixel.  The value returned is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_green_val_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::get_blue_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_blue_val_132(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::get_blue_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getBlueVal", key_word_list, &param1, &param2))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_blue_val((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlueVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_blue_val_132_comment =
    "C++ Interface:\n"
    "getBlueVal(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_blue_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the blue component color at the indicated\n"
    "//               pixel.  The value returned is in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_blue_val_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::get_gray_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_gray_val_133(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::get_gray_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getGrayVal", key_word_list, &param1, &param2))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_gray_val((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGrayVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_gray_val_133_comment =
    "C++ Interface:\n"
    "getGrayVal(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_gray_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the gray component color at the indicated\n"
    "//               pixel.  This only has a meaningful value for\n"
    "//               grayscale images; for other image types, this returns\n"
    "//               the value of the blue channel only.  However, also\n"
    "//               see the get_bright() function.  The value returned is\n"
    "//               in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_gray_val_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int PNMImage::get_alpha_val(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_alpha_val_134(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int PNMImage::get_alpha_val(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getAlphaVal", key_word_list, &param1, &param2))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_alpha_val((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaVal(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_alpha_val_134_comment =
    "C++ Interface:\n"
    "getAlphaVal(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_alpha_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the alpha component color at the indicated\n"
    "//               pixel.  It is an error to call this unless\n"
    "//               has_alpha() is true.  The value returned is in the\n"
    "//               range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_alpha_val_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_red_val(int x, int y, unsigned short int r)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_red_val_135(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_red_val(int x, int y, unsigned short int r)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setRedVal", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param3_uint == NULL)))
            {
                (local_this)->set_red_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setRedVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRedVal(non-const PNMImage this, int x, int y, unsigned int r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_red_val_135_comment =
    "C++ Interface:\n"
    "setRedVal(non-const PNMImage this, int x, int y, unsigned int r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_red_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the red component color only at the indicated\n"
    "//               pixel.  The value given should be in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_red_val_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_green_val(int x, int y, unsigned short int g)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_green_val_136(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_green_val(int x, int y, unsigned short int g)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"g", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setGreenVal", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param3_uint == NULL)))
            {
                (local_this)->set_green_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setGreenVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGreenVal(non-const PNMImage this, int x, int y, unsigned int g)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_green_val_136_comment =
    "C++ Interface:\n"
    "setGreenVal(non-const PNMImage this, int x, int y, unsigned int g)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_green_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the green component color only at the indicated\n"
    "//               pixel.  The value given should be in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_green_val_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_blue_val(int x, int y, unsigned short int b)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_blue_val_137(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_blue_val(int x, int y, unsigned short int b)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"b", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setBlueVal", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param3_uint == NULL)))
            {
                (local_this)->set_blue_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setBlueVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlueVal(non-const PNMImage this, int x, int y, unsigned int b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_blue_val_137_comment =
    "C++ Interface:\n"
    "setBlueVal(non-const PNMImage this, int x, int y, unsigned int b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_blue_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the blue component color only at the indicated\n"
    "//               pixel.  The value given should be in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_blue_val_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_gray_val(int x, int y, unsigned short int gray)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_gray_val_138(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_gray_val(int x, int y, unsigned short int gray)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"gray", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setGrayVal", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param3_uint == NULL)))
            {
                (local_this)->set_gray_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setGrayVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGrayVal(non-const PNMImage this, int x, int y, unsigned int gray)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_gray_val_138_comment =
    "C++ Interface:\n"
    "setGrayVal(non-const PNMImage this, int x, int y, unsigned int gray)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_gray_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the gray component color at the indicated\n"
    "//               pixel.  This is only meaningful for grayscale images;\n"
    "//               for other image types, this simply sets the blue\n"
    "//               component color.  However, also see set_xel_val(),\n"
    "//               which can set all the component colors to the same\n"
    "//               grayscale level, and hence works correctly both for\n"
    "//               grayscale and color images.  The value given should\n"
    "//               be in the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_gray_val_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_alpha_val(int x, int y, unsigned short int a)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_alpha_val_139(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_alpha_val(int x, int y, unsigned short int a)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"a", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setAlphaVal", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param3_uint == NULL)))
            {
                (local_this)->set_alpha_val((int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setAlphaVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlphaVal(non-const PNMImage this, int x, int y, unsigned int a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_alpha_val_139_comment =
    "C++ Interface:\n"
    "setAlphaVal(non-const PNMImage this, int x, int y, unsigned int a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_alpha_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the alpha component color only at the indicated\n"
    "//               pixel.  It is an error to call this unless\n"
    "//               has_alpha() is true.  The value given should be in\n"
    "//               the range 0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_alpha_val_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned short int PNMImage::get_channel_val(int x, int y, int channel) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_channel_val_140(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned short int PNMImage::get_channel_val(int x, int y, int channel) const
        int param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"channel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:getChannelVal", key_word_list, &param1, &param2, &param3))
        {
            unsigned short int return_value = ((const PNMImage*)local_this)->get_channel_val((int)param1, (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChannelVal(const PNMImage this, int x, int y, int channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_channel_val_140_comment =
    "C++ Interface:\n"
    "getChannelVal(const PNMImage this, int x, int y, int channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_channel_val\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth component color at the indicated\n"
    "//               pixel.  The channel index should be in the range\n"
    "//               0..(get_num_channels()-1).  The channels are ordered B,\n"
    "//               G, R, A.  This is slightly less optimal than\n"
    "//               accessing the component values directly by named\n"
    "//               methods.  The value returned is in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_channel_val_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::set_channel_val(int x, int y, int channel, unsigned short int value)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_channel_val_141(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PNMImage::set_channel_val(int x, int y, int channel, unsigned short int value)
        int param1;
        int param2;
        int param3;
        PyObject *param4;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"channel", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiO:setChannelVal", key_word_list, &param1, &param2, &param3, &param4))
        {
             PyObject *param4_uint = PyNumber_Long(param4);
            if (!((param4_uint == NULL)))
            {
                (local_this)->set_channel_val((int)param1, (int)param2, (int)param3, PyLong_AsUnsignedLong(param4_uint));
                 Py_XDECREF(param4_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setChannelVal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChannelVal(non-const PNMImage this, int x, int y, int channel, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_channel_val_141_comment =
    "C++ Interface:\n"
    "setChannelVal(non-const PNMImage this, int x, int y, int channel, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_channel_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth component color at the indicated\n"
    "//               pixel.  The channel index should be in the range\n"
    "//               0..(get_num_channels()-1).  The channels are ordered B,\n"
    "//               G, R, A.  This is slightly less optimal than\n"
    "//               setting the component values directly by named\n"
    "//               methods.  The value given should be in the range\n"
    "//               0..maxval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_channel_val_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_pixel_142(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getPixel", key_word_list, &param1, &param2))
        {
            PNMImageHeader::PixelSpec result = ((const PNMImage*)local_this)->get_pixel((int)param1, (int)param2);
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImageHeader_PixelSpec,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPixel(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_pixel_142_comment =
    "C++ Interface:\n"
    "getPixel(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_pixel\n"
    "//       Access: Published\n"
    "//  Description: Returns the (r, g, b, a) pixel value at the indicated\n"
    "//               pixel, using a PixelSpec object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_pixel_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_pixel_143(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
            int param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"pixel", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setPixel", key_word_list, &param1, &param2, &param3))
            {
                PNMImageHeader::PixelSpec *param3_this = (PNMImageHeader::PixelSpec *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PNMImageHeader_PixelSpec, 3, "PNMImage.setPixel", 1, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    (local_this)->set_pixel((int)param1, (int)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.setPixel() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPixel(non-const PNMImage this, int x, int y, const PixelSpec pixel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_pixel_143_comment =
    "C++ Interface:\n"
    "setPixel(non-const PNMImage this, int x, int y, const PixelSpec pixel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_pixel\n"
    "//       Access: Published\n"
    "//  Description: Sets the (r, g, b, a) pixel value at the indicated\n"
    "//               pixel, using a PixelSpec object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_pixel_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3d PNMImage::get_xel(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_xel_144(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3d PNMImage::get_xel(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getXel", key_word_list, &param1, &param2))
        {
            LVecBase3d result = ((const PNMImage*)local_this)->get_xel((int)param1, (int)param2);
            LVecBase3d *return_value = new LVecBase3d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXel(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_xel_144_comment =
    "C++ Interface:\n"
    "getXel(const PNMImage this, int x, int y)\n"
    "\n"
    "// The corresponding get_xel(), set_xel(), get_red(), etc. functions\n"
    "// automatically scale their values by get_maxval() into the range\n"
    "// [0..1].\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_xel\n"
    "//       Access: Published\n"
    "//  Description: Returns the RGB color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_xel_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_xel(int x, int y, LVecBase3d const &value)
 * inline void PNMImage::set_xel(int x, int y, double gray)
 * inline void PNMImage::set_xel(int x, int y, double r, double g, double b)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_xel_145(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PNMImage::set_xel(int x, int y, LVecBase3d const &value)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"value", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setXel", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3d, 3, "PNMImage.setXel", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_xel((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PNMImage::set_xel(int x, int y, double gray)
                int param1;
                int param2;
                double param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"gray", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setXel", key_word_list, &param1, &param2, &param3))
                {
                    (local_this)->set_xel((int)param1, (int)param2, (double)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::set_xel(int x, int y, double r, double g, double b)
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", (char *)"g", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddd:setXel", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                (local_this)->set_xel((int)param1, (int)param2, (double)param3, (double)param4, (double)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.setXel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setXel() takes 4 or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setXel(non-const PNMImage this, int x, int y, const VBase3D value)\n"
          "setXel(non-const PNMImage this, int x, int y, float gray)\n"
          "setXel(non-const PNMImage this, int x, int y, float r, float g, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_xel_145_comment =
    "C++ Interface:\n"
    "setXel(non-const PNMImage this, int x, int y, const VBase3D value)\n"
    "setXel(non-const PNMImage this, int x, int y, float gray)\n"
    "setXel(non-const PNMImage this, int x, int y, float r, float g, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGB color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGB color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel\n"
    "//       Access: Published\n"
    "//  Description: Changes all three color components at the indicated\n"
    "//               pixel to the same value.  The value is a double in\n"
    "//               the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_xel_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4d PNMImage::get_xel_a(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_xel_a_146(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4d PNMImage::get_xel_a(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getXelA", key_word_list, &param1, &param2))
        {
            LVecBase4d result = ((const PNMImage*)local_this)->get_xel_a((int)param1, (int)param2);
            LVecBase4d *return_value = new LVecBase4d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXelA(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_xel_a_146_comment =
    "C++ Interface:\n"
    "getXelA(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_xel_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the RGBA color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_xel_a_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_xel_a(int x, int y, LVecBase4d const &value)
 * inline void PNMImage::set_xel_a(int x, int y, double r, double g, double b, double a)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_xel_a_147(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PNMImage::set_xel_a(int x, int y, LVecBase4d const &value)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"value", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setXelA", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4d *param3_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4d, 3, "PNMImage.setXelA", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_xel_a((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.setXelA() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::set_xel_a(int x, int y, double r, double g, double b, double a)
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iidddd:setXelA", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->set_xel_a((int)param1, (int)param2, (double)param3, (double)param4, (double)param5, (double)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.setXelA() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setXelA() takes 4 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setXelA(non-const PNMImage this, int x, int y, const VBase4D value)\n"
          "setXelA(non-const PNMImage this, int x, int y, float r, float g, float b, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_xel_a_147_comment =
    "C++ Interface:\n"
    "setXelA(non-const PNMImage this, int x, int y, const VBase4D value)\n"
    "setXelA(non-const PNMImage this, int x, int y, float r, float g, float b, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel_a\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGBA color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_xel_a\n"
    "//       Access: Published\n"
    "//  Description: Changes the RGBA color at the indicated pixel.  Each\n"
    "//               component is a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_xel_a_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_red(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_red_148(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_red(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getRed", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMImage*)local_this)->get_red((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRed(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_red_148_comment =
    "C++ Interface:\n"
    "getRed(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_red\n"
    "//       Access: Published\n"
    "//  Description: Returns the red component color at the indicated\n"
    "//               pixel.  The value returned is a double in the range\n"
    "//               0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_red_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_green(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_green_149(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_green(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getGreen", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMImage*)local_this)->get_green((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGreen(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_green_149_comment =
    "C++ Interface:\n"
    "getGreen(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_green\n"
    "//       Access: Published\n"
    "//  Description: Returns the green component color at the indicated\n"
    "//               pixel.  The value returned is a double in the range\n"
    "//               0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_green_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_blue(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_blue_150(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_blue(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getBlue", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMImage*)local_this)->get_blue((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlue(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_blue_150_comment =
    "C++ Interface:\n"
    "getBlue(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_blue\n"
    "//       Access: Published\n"
    "//  Description: Returns the blue component color at the indicated\n"
    "//               pixel.  The value returned is a double in the range\n"
    "//               0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_blue_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_gray(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_gray_151(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_gray(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getGray", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMImage*)local_this)->get_gray((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGray(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_gray_151_comment =
    "C++ Interface:\n"
    "getGray(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_gray\n"
    "//       Access: Published\n"
    "//  Description: Returns the gray component color at the indicated\n"
    "//               pixel.  This only has a meaningful value for\n"
    "//               grayscale images; for other image types, this returns\n"
    "//               the value of the blue channel only.  However, also\n"
    "//               see the get_bright() function.  The value returned is\n"
    "//               a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_gray_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_alpha(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_alpha_152(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_alpha(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getAlpha", key_word_list, &param1, &param2))
        {
            double return_value = ((const PNMImage*)local_this)->get_alpha((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlpha(const PNMImage this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_alpha_152_comment =
    "C++ Interface:\n"
    "getAlpha(const PNMImage this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_alpha\n"
    "//       Access: Published\n"
    "//  Description: Returns the alpha component color at the indicated\n"
    "//               pixel.  It is an error to call this unless\n"
    "//               has_alpha() is true.  The value returned is a double\n"
    "//               in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_alpha_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_red(int x, int y, double r)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_red_153(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_red(int x, int y, double r)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setRed", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_red((int)param1, (int)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setRed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRed(non-const PNMImage this, int x, int y, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_red_153_comment =
    "C++ Interface:\n"
    "setRed(non-const PNMImage this, int x, int y, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_red\n"
    "//       Access: Published\n"
    "//  Description: Sets the red component color only at the indicated\n"
    "//               pixel.  The value given should be a double in the\n"
    "//               range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_red_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_green(int x, int y, double g)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_green_154(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_green(int x, int y, double g)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"g", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setGreen", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_green((int)param1, (int)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setGreen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGreen(non-const PNMImage this, int x, int y, float g)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_green_154_comment =
    "C++ Interface:\n"
    "setGreen(non-const PNMImage this, int x, int y, float g)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_green\n"
    "//       Access: Published\n"
    "//  Description: Sets the green component color only at the indicated\n"
    "//               pixel.  The value given should be a double in the\n"
    "//               range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_green_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_blue(int x, int y, double b)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_blue_155(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_blue(int x, int y, double b)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"b", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setBlue", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_blue((int)param1, (int)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setBlue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlue(non-const PNMImage this, int x, int y, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_blue_155_comment =
    "C++ Interface:\n"
    "setBlue(non-const PNMImage this, int x, int y, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_blue\n"
    "//       Access: Published\n"
    "//  Description: Sets the blue component color only at the indicated\n"
    "//               pixel.  The value given should be a double in the\n"
    "//               range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_blue_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_gray(int x, int y, double gray)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_gray_156(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_gray(int x, int y, double gray)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"gray", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setGray", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_gray((int)param1, (int)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setGray() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGray(non-const PNMImage this, int x, int y, float gray)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_gray_156_comment =
    "C++ Interface:\n"
    "setGray(non-const PNMImage this, int x, int y, float gray)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_gray\n"
    "//       Access: Published\n"
    "//  Description: Sets the gray component color at the indicated\n"
    "//               pixel.  This is only meaningful for grayscale images;\n"
    "//               for other image types, this simply sets the blue\n"
    "//               component color.  However, also see set_xel(), which\n"
    "//               can set all the component colors to the same\n"
    "//               grayscale level, and hence works correctly both for\n"
    "//               grayscale and color images.  The value given should\n"
    "//               be a double in the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_gray_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_alpha(int x, int y, double a)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_alpha_157(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_alpha(int x, int y, double a)
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"a", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:setAlpha", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_alpha((int)param1, (int)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setAlpha() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlpha(non-const PNMImage this, int x, int y, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_alpha_157_comment =
    "C++ Interface:\n"
    "setAlpha(non-const PNMImage this, int x, int y, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_alpha\n"
    "//       Access: Published\n"
    "//  Description: Sets the alpha component color only at the indicated\n"
    "//               pixel.  It is an error to call this unless\n"
    "//               has_alpha() is true.  The value given should be in\n"
    "//               the range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_alpha_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_channel(int x, int y, int channel) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_channel_158(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PNMImage::get_channel(int x, int y, int channel) const
        int param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"channel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:getChannel", key_word_list, &param1, &param2, &param3))
        {
            double return_value = ((const PNMImage*)local_this)->get_channel((int)param1, (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChannel(const PNMImage this, int x, int y, int channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_channel_158_comment =
    "C++ Interface:\n"
    "getChannel(const PNMImage this, int x, int y, int channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_channel\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth component color at the indicated\n"
    "//               pixel.  The channel index should be in the range\n"
    "//               0..(get_num_channels()-1).  The channels are ordered B,\n"
    "//               G, R, A.  This is slightly less optimal than\n"
    "//               accessing the component values directly by named\n"
    "//               methods.  The value returned is a double in the range\n"
    "//               0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_channel_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::set_channel(int x, int y, int channel, double value)
 *******************************************************************/
static PyObject *Dtool_PNMImage_set_channel_159(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMImage::set_channel(int x, int y, int channel, double value)
        int param1;
        int param2;
        int param3;
        double param4;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"channel", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiid:setChannel", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_channel((int)param1, (int)param2, (int)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMImage.setChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChannel(non-const PNMImage this, int x, int y, int channel, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_set_channel_159_comment =
    "C++ Interface:\n"
    "setChannel(non-const PNMImage this, int x, int y, int channel, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::set_channel_val\n"
    "//       Access: Published\n"
    "//  Description: Sets the nth component color at the indicated\n"
    "//               pixel.  The channel index should be in the range\n"
    "//               0..(get_num_channels()-1).  The channels are ordered B,\n"
    "//               G, R, A.  This is slightly less optimal than\n"
    "//               setting the component values directly by named\n"
    "//               methods.  The value given should be a double in the\n"
    "//               range 0..1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_set_channel_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PNMImage::get_bright(int x, int y) const
 * inline double PNMImage::get_bright(int x, int y, double rc, double gc, double bc) const
 * inline double PNMImage::get_bright(int x, int y, double rc, double gc, double bc, double ac) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_bright_160(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-inline double PNMImage::get_bright(int x, int y) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getBright", key_word_list, &param1, &param2))
            {
                double return_value = ((const PNMImage*)local_this)->get_bright((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-inline double PNMImage::get_bright(int x, int y, double rc, double gc, double bc) const
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"rc", (char *)"gc", (char *)"bc", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddd:getBright", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                double return_value = ((const PNMImage*)local_this)->get_bright((int)param1, (int)param2, (double)param3, (double)param4, (double)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    case(6):
        {
        {
          // 1-inline double PNMImage::get_bright(int x, int y, double rc, double gc, double bc, double ac) const
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"rc", (char *)"gc", (char *)"bc", (char *)"ac", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iidddd:getBright", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                double return_value = ((const PNMImage*)local_this)->get_bright((int)param1, (int)param2, (double)param3, (double)param4, (double)param5, (double)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getBright() takes 3, 6, or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getBright(const PNMImage this, int x, int y)\n"
          "getBright(const PNMImage this, int x, int y, float rc, float gc, float bc)\n"
          "getBright(const PNMImage this, int x, int y, float rc, float gc, float bc, float ac)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_bright_160_comment =
    "C++ Interface:\n"
    "getBright(const PNMImage this, int x, int y)\n"
    "getBright(const PNMImage this, int x, int y, float rc, float gc, float bc)\n"
    "getBright(const PNMImage this, int x, int y, float rc, float gc, float bc, float ac)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_bright\n"
    "//       Access: Published\n"
    "//  Description: Returns the linear brightness of the given xel, as a\n"
    "//               double in the range 0..1.  This flavor of\n"
    "//               get_bright() returns the correct grayscale brightness\n"
    "//               level for both full-color and grayscale images.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_bright\n"
    "//       Access: Published\n"
    "//  Description: This flavor of get_bright() works correctly only for\n"
    "//               color images.  It returns a single brightness value\n"
    "//               for the RGB color at the indicated pixel, based on\n"
    "//               the supplied weights for each component.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_bright\n"
    "//       Access: Published\n"
    "//  Description: This flavor of get_bright() works correctly only for\n"
    "//               four-channel images.  It returns a single brightness\n"
    "//               value for the RGBA color at the indicated pixel,\n"
    "//               based on the supplied weights for each component.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_bright_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::blend(int x, int y, LVecBase3d const &val, double alpha)
 * void PNMImage::blend(int x, int y, double r, double g, double b, double alpha)
 *******************************************************************/
static PyObject *Dtool_PNMImage_blend_161(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PNMImage::blend(int x, int y, LVecBase3d const &val, double alpha)
                int param1;
                int param2;
                PyObject *param3;
                double param4;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"val", (char *)"alpha", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiOd:blend", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3d, 3, "PNMImage.blend", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->blend((int)param1, (int)param2, *param3_this, (double)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blend() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::blend(int x, int y, double r, double g, double b, double alpha)
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"r", (char *)"g", (char *)"b", (char *)"alpha", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iidddd:blend", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->blend((int)param1, (int)param2, (double)param3, (double)param4, (double)param5, (double)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.blend() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "blend() takes 5 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "blend(non-const PNMImage this, int x, int y, const VBase3D val, float alpha)\n"
          "blend(non-const PNMImage this, int x, int y, float r, float g, float b, float alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_blend_161_comment =
    "C++ Interface:\n"
    "blend(non-const PNMImage this, int x, int y, const VBase3D val, float alpha)\n"
    "blend(non-const PNMImage this, int x, int y, float r, float g, float b, float alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::blend\n"
    "//       Access: Published\n"
    "//  Description: Smoothly blends the indicated pixel value in with\n"
    "//               whatever was already in the image, based on the given\n"
    "//               alpha value.  An alpha of 1.0 is fully opaque and\n"
    "//               completely replaces whatever was there previously;\n"
    "//               alpha of 0.0 is fully transparent and does nothing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::blend\n"
    "//       Access: Published\n"
    "//  Description: Smoothly blends the indicated pixel value in with\n"
    "//               whatever was already in the image, based on the given\n"
    "//               alpha value.  An alpha of 1.0 is fully opaque and\n"
    "//               completely replaces whatever was there previously;\n"
    "//               alpha of 0.0 is fully transparent and does nothing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_blend_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline pixel *PNMImage::operator [](int y)
 * inline pixel const *PNMImage::operator [](int y) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_162(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 inline pixel const *PNMImage::operator [](int y) const
        int param1;
        static char * key_word_list[] = {(char *)"y", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            pixel const *return_value = ((const PNMImage*)local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline pixel *PNMImage::operator [](int y)
        int param1;
        static char * key_word_list[] = {(char *)"y", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            pixel *return_value = (local_this)->operator []((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_pixel,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const PNMImage this, int y)\n"
          "__getitem__(non-const PNMImage this, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_162_comment =
    "C++ Interface:\n"
    "__getitem__(const PNMImage this, int y)\n"
    "__getitem__(non-const PNMImage this, int y)\n"
    "\n"
    "// If you're used to the NetPBM library and like working with a 2-d\n"
    "// array of xels, and using the PNM macros to access their components,\n"
    "// you may treat the PNMImage as such directly.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::Array Operator\n"
    "//       Access: Published\n"
    "//  Description: Allows the PNMImage to appear to be a 2-d array of\n"
    "//               xels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::Array Operator\n"
    "//       Access: Published\n"
    "//  Description: Allows the PNMImage to appear to be a 2-d array of\n"
    "//               xels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1))
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1))
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1))
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_copy_sub_image_163(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:copySubImage", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copySubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_sub_image(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copySubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:copySubImage", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copySubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copySubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiii:copySubImage", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copySubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copySubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiii:copySubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copySubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copySubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiii:copySubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.copySubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->copy_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.copySubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "copySubImage() takes 4, 5, 6, 7, or 8 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
          "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
          "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
          "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
          "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_copy_sub_image_163_comment =
    "C++ Interface:\n"
    "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
    "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
    "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
    "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
    "copySubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::copy_sub_image\n"
    "//       Access: Published\n"
    "//  Description: Copies a rectangular area of another image into a\n"
    "//               rectangular area of this image.  Both images must\n"
    "//               already have been initialized.  The upper-left corner\n"
    "//               of the region in both images is specified, and the\n"
    "//               size of the area; if the size is omitted, it defaults\n"
    "//               to the entire other image, or the largest piece that\n"
    "//               will fit.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_copy_sub_image_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_blend_sub_image_164(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:blendSubImage", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:blendSubImage", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiii:blendSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiii:blendSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiii:blendSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                double param8;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", (char *)"pixel_scale", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiiid:blendSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.blendSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->blend_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (double)param8);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.blendSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "blendSubImage() takes 4, 5, 6, 7, 8, or 9 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
          "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_blend_sub_image_164_comment =
    "C++ Interface:\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
    "blendSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::blend_sub_image\n"
    "//       Access: Published\n"
    "//  Description: Behaves like copy_sub_image(), except the alpha\n"
    "//               channel of the copy is used to blend the copy into\n"
    "//               the destination image, instead of overwriting pixels\n"
    "//               unconditionally.\n"
    "//\n"
    "//               If pixel_scale is not 1.0, it specifies an amount to\n"
    "//               scale each *alpha* value of the source image before\n"
    "//               applying it to the target image.\n"
    "//\n"
    "//               If pixel_scale is 1.0 and the copy has no alpha\n"
    "//               channel, this degenerates into copy_sub_image().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_blend_sub_image_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_darken_sub_image_165(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:darkenSubImage", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:darkenSubImage", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiii:darkenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiii:darkenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiii:darkenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                double param8;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", (char *)"pixel_scale", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiiid:darkenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.darkenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->darken_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (double)param8);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.darkenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "darkenSubImage() takes 4, 5, 6, 7, 8, or 9 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
          "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_darken_sub_image_165_comment =
    "C++ Interface:\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
    "darkenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::darken_sub_image\n"
    "//       Access: Published\n"
    "//  Description: Behaves like copy_sub_image(), but the resulting\n"
    "//               color will be the darker of the source and\n"
    "//               destination colors at each pixel (and at each R, G,\n"
    "//               B, A component value).\n"
    "//\n"
    "//               If pixel_scale is not 1.0, it specifies an amount to\n"
    "//               scale each pixel value of the source image before\n"
    "//               applying it to the target image.  The scale is\n"
    "//               applied with the center at 1.0: scaling the pixel\n"
    "//               value smaller brings it closer to 1.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_darken_sub_image_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_lighten_sub_image_166(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = (0), int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:lightenSubImage", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom = (0), int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:lightenSubImage", key_word_list, &param1, &param2, &param3, &param4))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size = (-1), int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiii:lightenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size = (-1), double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiii:lightenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale = (1))
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiii:lightenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, double pixel_scale)
                PyObject *param1;
                int param2;
                int param3;
                int param4;
                int param5;
                int param6;
                int param7;
                double param8;
                static char * key_word_list[] = {(char *)"copy", (char *)"xto", (char *)"yto", (char *)"xfrom", (char *)"yfrom", (char *)"x_size", (char *)"y_size", (char *)"pixel_scale", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiiiiid:lightenSubImage", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.lightenSubImage", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->lighten_sub_image(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (double)param8);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.lightenSubImage() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "lightenSubImage() takes 4, 5, 6, 7, 8, or 9 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
          "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_lighten_sub_image_166_comment =
    "C++ Interface:\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto)\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom)\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom)\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size)\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
    "lightenSubImage(non-const PNMImage this, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::lighten_sub_image\n"
    "//       Access: Published\n"
    "//  Description: Behaves like copy_sub_image(), but the resulting\n"
    "//               color will be the lighter of the source and\n"
    "//               destination colors at each pixel (and at each R, G,\n"
    "//               B, A component value).\n"
    "//\n"
    "//               If pixel_scale is not 1.0, it specifies an amount to\n"
    "//               scale each pixel value of the source image before\n"
    "//               applying it to the target image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_lighten_sub_image_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::threshold(PNMImage const &select_image, int channel, double threshold, PNMImage const &lt, PNMImage const &ge)
 *******************************************************************/
static PyObject *Dtool_PNMImage_threshold_167(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::threshold(PNMImage const &select_image, int channel, double threshold, PNMImage const &lt, PNMImage const &ge)
            PyObject *param1;
            int param2;
            double param3;
            PyObject *param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"select_image", (char *)"channel", (char *)"threshold", (char *)"lt", (char *)"ge", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OidOO:threshold", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.threshold", 1, coerced_ptr, report_errors);
PNMImage *param4_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_PNMImage, 4, "PNMImage.threshold", 1, coerced_ptr, report_errors);
PNMImage *param5_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_PNMImage, 5, "PNMImage.threshold", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)))
                {
                    (local_this)->threshold(*param1_this, (int)param2, (double)param3, *param4_this, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.threshold() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "threshold(non-const PNMImage this, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_threshold_167_comment =
    "C++ Interface:\n"
    "threshold(non-const PNMImage this, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::threshold\n"
    "//       Access: Published\n"
    "//  Description: Selectively copies each pixel from either one source\n"
    "//               or another source, depending on the pixel value of\n"
    "//               the indicated channel of select_image.\n"
    "//\n"
    "//               For each pixel (x, y):\n"
    "//\n"
    "//               s = select_image.get_channel(x, y). Set this image's\n"
    "//               (x, y) to:\n"
    "//\n"
    "//               lt.get_xel(x, y) if s <= threshold, or\n"
    "//\n"
    "//               ge.get_xel(x, y) if s > threshold\n"
    "//\n"
    "//               Any of select_image, lt, or ge may be the same\n"
    "//               PNMImge object as this image, or the same as each\n"
    "//               other; or they may all be different. All images must\n"
    "//               be the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_threshold_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::render_spot(LVecBase4d const &fg, LVecBase4d const &bg, double min_radius, double max_radius)
 *******************************************************************/
static PyObject *Dtool_PNMImage_render_spot_168(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::render_spot(LVecBase4d const &fg, LVecBase4d const &bg, double min_radius, double max_radius)
            PyObject *param1;
            PyObject *param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"fg", (char *)"bg", (char *)"min_radius", (char *)"max_radius", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOdd:renderSpot", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVecBase4d *param1_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4d, 1, "PNMImage.renderSpot", 1, coerced_ptr, report_errors);
LVecBase4d *param2_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4d, 2, "PNMImage.renderSpot", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->render_spot(*param1_this, *param2_this, (double)param3, (double)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.renderSpot() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "renderSpot(non-const PNMImage this, const VBase4D fg, const VBase4D bg, float min_radius, float max_radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_render_spot_168_comment =
    "C++ Interface:\n"
    "renderSpot(non-const PNMImage this, const VBase4D fg, const VBase4D bg, float min_radius, float max_radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::render_spot\n"
    "//       Access: Published\n"
    "//  Description: Renders a solid-color circle, with a fuzzy edge, into\n"
    "//               the center of the PNMImage.  If the PNMImage is\n"
    "//               non-square, this actually renders an ellipse.\n"
    "//\n"
    "//               The min_radius and max_radius are in the scale 0..1,\n"
    "//               where 1.0 means the full width of the image.  If\n"
    "//               min_radius == max_radius, the edge is sharp (but\n"
    "//               still antialiased); otherwise, the pixels between\n"
    "//               min_radius and max_radius are smoothly blended\n"
    "//               between fg and bg colors.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_render_spot_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::expand_border(int left, int right, int bottom, int top, LVecBase4d const &color)
 *******************************************************************/
static PyObject *Dtool_PNMImage_expand_border_169(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::expand_border(int left, int right, int bottom, int top, LVecBase4d const &color)
            int param1;
            int param2;
            int param3;
            int param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiiO:expandBorder", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                LVecBase4d *param5_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase4d, 5, "PNMImage.expandBorder", 1, coerced_ptr, report_errors);

                if (!((param5_this == NULL)))
                {
                    (local_this)->expand_border((int)param1, (int)param2, (int)param3, (int)param4, *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.expandBorder() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "expandBorder(non-const PNMImage this, int left, int right, int bottom, int top, const VBase4D color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_expand_border_169_comment =
    "C++ Interface:\n"
    "expandBorder(non-const PNMImage this, int left, int right, int bottom, int top, const VBase4D color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::expand_border\n"
    "//       Access: Published\n"
    "//  Description: Expands the image by the indicated number of pixels\n"
    "//               on each edge.  The new pixels are set to the\n"
    "//               indicated color.\n"
    "//\n"
    "//               If any of the values is negative, this actually crops\n"
    "//               the image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_expand_border_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::box_filter(double radius)
 * inline void PNMImage::box_filter(double radius = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_box_filter_170(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::box_filter(double radius = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":boxFilter", key_word_list));
            else
                (PyArg_Parse(args, ":boxFilter"));
            if(!PyErr_Occurred())
            {
                (local_this)->box_filter();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.boxFilter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::box_filter(double radius)
            double param1;
            static char * key_word_list[] = {(char *)"radius", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:boxFilter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:boxFilter", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->box_filter((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.boxFilter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "boxFilter() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "boxFilter(non-const PNMImage this)\n"
          "boxFilter(non-const PNMImage this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_box_filter_170_comment =
    "C++ Interface:\n"
    "boxFilter(non-const PNMImage this)\n"
    "boxFilter(non-const PNMImage this, float radius)\n"
    "\n"
    "// The bodies for the non-inline *_filter() functions can be found\n"
    "// in the file pnm-image-filter.cxx.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::box_filter\n"
    "//       Access: Published\n"
    "//  Description: This flavor of box_filter() will apply the filter\n"
    "//               over the entire image without resizing or copying;\n"
    "//               the effect is that of a blur operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_box_filter_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMImage::gaussian_filter(double radius)
 * inline void PNMImage::gaussian_filter(double radius = (1))
 *******************************************************************/
static PyObject *Dtool_PNMImage_gaussian_filter_171(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::gaussian_filter(double radius = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":gaussianFilter", key_word_list));
            else
                (PyArg_Parse(args, ":gaussianFilter"));
            if(!PyErr_Occurred())
            {
                (local_this)->gaussian_filter();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.gaussianFilter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMImage::gaussian_filter(double radius)
            double param1;
            static char * key_word_list[] = {(char *)"radius", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:gaussianFilter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:gaussianFilter", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->gaussian_filter((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.gaussianFilter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "gaussianFilter() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "gaussianFilter(non-const PNMImage this)\n"
          "gaussianFilter(non-const PNMImage this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_gaussian_filter_171_comment =
    "C++ Interface:\n"
    "gaussianFilter(non-const PNMImage this)\n"
    "gaussianFilter(non-const PNMImage this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::gaussian_filter\n"
    "//       Access: Published\n"
    "//  Description: This flavor of gaussian_filter() will apply the filter\n"
    "//               over the entire image without resizing or copying;\n"
    "//               the effect is that of a blur operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_gaussian_filter_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::box_filter_from(double radius, PNMImage const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImage_box_filter_from_172(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::box_filter_from(double radius, PNMImage const &copy)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"radius", (char *)"copy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:boxFilterFrom", key_word_list, &param1, &param2))
            {
                PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMImage, 2, "PNMImage.boxFilterFrom", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->box_filter_from((double)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.boxFilterFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "boxFilterFrom(non-const PNMImage this, float radius, const PNMImage copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_box_filter_from_172_comment =
    "C++ Interface:\n"
    "boxFilterFrom(non-const PNMImage this, float radius, const PNMImage copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::box_filter_from\n"
    "//       Access: Public\n"
    "//  Description: Makes a resized copy of the indicated image into this\n"
    "//               one using the indicated filter.  The image to be\n"
    "//               copied is squashed and stretched to match the\n"
    "//               dimensions of the current image, applying the\n"
    "//               appropriate filter to perform the stretching.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_box_filter_from_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::gaussian_filter_from(double radius, PNMImage const &copy)
 *******************************************************************/
static PyObject *Dtool_PNMImage_gaussian_filter_from_173(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::gaussian_filter_from(double radius, PNMImage const &copy)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"radius", (char *)"copy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:gaussianFilterFrom", key_word_list, &param1, &param2))
            {
                PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PNMImage, 2, "PNMImage.gaussianFilterFrom", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->gaussian_filter_from((double)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.gaussianFilterFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "gaussianFilterFrom(non-const PNMImage this, float radius, const PNMImage copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_gaussian_filter_from_173_comment =
    "C++ Interface:\n"
    "gaussianFilterFrom(non-const PNMImage this, float radius, const PNMImage copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::gaussian_filter_from\n"
    "//       Access: Public\n"
    "//  Description: Makes a resized copy of the indicated image into this\n"
    "//               one using the indicated filter.  The image to be\n"
    "//               copied is squashed and stretched to match the\n"
    "//               dimensions of the current image, applying the\n"
    "//               appropriate filter to perform the stretching.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_gaussian_filter_from_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::quick_filter_from(PNMImage const &copy, int xborder, int yborder)
 * void PNMImage::quick_filter_from(PNMImage const &copy, int xborder, int yborder = (0))
 * void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = (0), int yborder = (0))
 *******************************************************************/
static PyObject *Dtool_PNMImage_quick_filter_from_174(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = (0), int yborder = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:quickFilterFrom", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:quickFilterFrom", &param1));
                if(!PyErr_Occurred())
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.quickFilterFrom", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->quick_filter_from(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.quickFilterFrom() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::quick_filter_from(PNMImage const &copy, int xborder, int yborder = (0))
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"copy", (char *)"xborder", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:quickFilterFrom", key_word_list, &param1, &param2))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.quickFilterFrom", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->quick_filter_from(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.quickFilterFrom() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::quick_filter_from(PNMImage const &copy, int xborder, int yborder)
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"copy", (char *)"xborder", (char *)"yborder", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:quickFilterFrom", key_word_list, &param1, &param2, &param3))
                {
                    PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.quickFilterFrom", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->quick_filter_from(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.quickFilterFrom() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "quickFilterFrom() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "quickFilterFrom(non-const PNMImage this, const PNMImage copy)\n"
          "quickFilterFrom(non-const PNMImage this, const PNMImage copy, int xborder)\n"
          "quickFilterFrom(non-const PNMImage this, const PNMImage copy, int xborder, int yborder)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_quick_filter_from_174_comment =
    "C++ Interface:\n"
    "quickFilterFrom(non-const PNMImage this, const PNMImage copy)\n"
    "quickFilterFrom(non-const PNMImage this, const PNMImage copy, int xborder)\n"
    "quickFilterFrom(non-const PNMImage this, const PNMImage copy, int xborder, int yborder)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::quick_filter_from\n"
    "//       Access: Public\n"
    "//  Description: Resizes from the given image, with a fixed radius of\n"
    "//               0.5. This is a very specialized and simple algorithm\n"
    "//               that doesn't handle dropping below the Nyquist rate\n"
    "//               very well, but is quite a bit faster than the more\n"
    "//               general box_filter(), above.  If borders are\n"
    "//               specified, they will further restrict the size of the\n"
    "//               resulting image. There's no point in using\n"
    "//               quick_box_filter() on a single image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_quick_filter_from_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
 *******************************************************************/
static PyObject *Dtool_PNMImage_make_histogram_175(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hist", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:makeHistogram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:makeHistogram", &param1));
            if(!PyErr_Occurred())
            {
                PNMImageHeader::Histogram *param1_this = (PNMImageHeader::Histogram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImageHeader_Histogram, 1, "PNMImage.makeHistogram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->make_histogram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.makeHistogram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeHistogram(non-const PNMImage this, non-const Histogram hist)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_make_histogram_175_comment =
    "C++ Interface:\n"
    "makeHistogram(non-const PNMImage this, non-const Histogram hist)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::make_histogram\n"
    "//       Access: Published\n"
    "//  Description: Computes a histogram of the colors used in the\n"
    "//               image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_make_histogram_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
 * void PNMImage::perlin_noise_fill(double sx, double sy, int table_size, unsigned long int seed)
 * void PNMImage::perlin_noise_fill(double sx, double sy, int table_size, unsigned long int seed = (0))
 * void PNMImage::perlin_noise_fill(double sx, double sy, int table_size = (256), unsigned long int seed = (0))
 *******************************************************************/
static PyObject *Dtool_PNMImage_perlin_noise_fill_176(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"perlin", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:perlinNoiseFill", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:perlinNoiseFill", &param1));
                if(!PyErr_Occurred())
                {
                    StackedPerlinNoise2 *param1_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StackedPerlinNoise2, 1, "PNMImage.perlinNoiseFill", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->perlin_noise_fill(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PNMImage.perlinNoiseFill() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::perlin_noise_fill(double sx, double sy, int table_size = (256), unsigned long int seed = (0))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:perlinNoiseFill", key_word_list, &param1, &param2))
            {
                (local_this)->perlin_noise_fill((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.perlinNoiseFill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::perlin_noise_fill(double sx, double sy, int table_size, unsigned long int seed = (0))
            double param1;
            double param2;
            int param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"table_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddi:perlinNoiseFill", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->perlin_noise_fill((double)param1, (double)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.perlinNoiseFill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PNMImage::perlin_noise_fill(double sx, double sy, int table_size, unsigned long int seed)
            double param1;
            double param2;
            int param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"table_size", (char *)"seed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddiO:perlinNoiseFill", key_word_list, &param1, &param2, &param3, &param4))
            {
                 PyObject *param4_uint = PyNumber_Long(param4);
                if (!((param4_uint == NULL)))
                {
                    (local_this)->perlin_noise_fill((double)param1, (double)param2, (int)param3, PyLong_AsUnsignedLong(param4_uint));
                     Py_XDECREF(param4_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMImage.perlinNoiseFill() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "perlinNoiseFill() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "perlinNoiseFill(non-const PNMImage this, non-const StackedPerlinNoise2 perlin)\n"
          "perlinNoiseFill(non-const PNMImage this, float sx, float sy)\n"
          "perlinNoiseFill(non-const PNMImage this, float sx, float sy, int table_size)\n"
          "perlinNoiseFill(non-const PNMImage this, float sx, float sy, int table_size, unsigned int seed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_perlin_noise_fill_176_comment =
    "C++ Interface:\n"
    "perlinNoiseFill(non-const PNMImage this, non-const StackedPerlinNoise2 perlin)\n"
    "perlinNoiseFill(non-const PNMImage this, float sx, float sy)\n"
    "perlinNoiseFill(non-const PNMImage this, float sx, float sy, int table_size)\n"
    "perlinNoiseFill(non-const PNMImage this, float sx, float sy, int table_size, unsigned int seed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::perlin_noise_fill\n"
    "//       Access: Published\n"
    "//  Description: Fills the image with a grayscale perlin noise\n"
    "//               pattern based on the indicated parameters.\n"
    "//               Uses set_xel to set the grayscale values.\n"
    "//               The sx and sy parameters are in multiples\n"
    "//               of the size of this image.\n"
    "//               See also the PerlinNoise2 class in mathutil.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::perlin_noise_fill\n"
    "//       Access: Published\n"
    "//  Description: Variant of perlin_noise_fill that uses an\n"
    "//               existing StackedPerlinNoise2 object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_perlin_noise_fill_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3d PNMImage::get_average_xel(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_average_xel_177(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase3d PNMImage::get_average_xel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageXel", key_word_list));
        else
            (PyArg_Parse(args, ":getAverageXel"));
        if(!PyErr_Occurred())
        {
            LVecBase3d result = ((const PNMImage*)local_this)->get_average_xel();
            LVecBase3d *return_value = new LVecBase3d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAverageXel(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_average_xel_177_comment =
    "C++ Interface:\n"
    "getAverageXel(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_average_xel\n"
    "//       Access: Published\n"
    "//  Description: Returns the average color of all of the pixels\n"
    "//               in the image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_average_xel_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4d PNMImage::get_average_xel_a(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_average_xel_a_178(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4d PNMImage::get_average_xel_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageXelA", key_word_list));
        else
            (PyArg_Parse(args, ":getAverageXelA"));
        if(!PyErr_Occurred())
        {
            LVecBase4d result = ((const PNMImage*)local_this)->get_average_xel_a();
            LVecBase4d *return_value = new LVecBase4d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAverageXelA(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_average_xel_a_178_comment =
    "C++ Interface:\n"
    "getAverageXelA(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_average_xel_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the average color of all of the pixels\n"
    "//               in the image, including the alpha channel.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_average_xel_a_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double PNMImage::get_average_gray(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_get_average_gray_179(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double PNMImage::get_average_gray(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageGray", key_word_list));
        else
            (PyArg_Parse(args, ":getAverageGray"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PNMImage*)local_this)->get_average_gray();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAverageGray(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_get_average_gray_179_comment =
    "C++ Interface:\n"
    "getAverageGray(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::get_average_gray\n"
    "//       Access: Published\n"
    "//  Description: Returns the average grayscale component of all of\n"
    "//               the pixels in the image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_get_average_gray_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMImage PNMImage::operator ~(void) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_180(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PNMImage PNMImage::operator ~(void) const
        {
            PNMImage result = ((const PNMImage*)local_this)->operator ~();
            PNMImage *return_value = new PNMImage(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__invert__(const PNMImage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_180_comment =
    "C++ Interface:\n"
    "__invert__(const PNMImage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator ~\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage that is the\n"
    "//               complement of the current PNMImage.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImage PNMImage::operator +(LVecBase4d const &other) const
 * inline PNMImage PNMImage::operator +(PNMImage const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_181(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline PNMImage PNMImage::operator +(PNMImage const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMImage result = ((const PNMImage*)local_this)->operator +(*param1_this);
                    PNMImage *return_value = new PNMImage(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline PNMImage PNMImage::operator +(LVecBase4d const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4d *param1_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4d, 1, "PNMImage.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMImage result = ((const PNMImage*)local_this)->operator +(*param1_this);
                    PNMImage *return_value = new PNMImage(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const PNMImage this, const PNMImage other)\n"
          "__add__(const PNMImage this, const VBase4D other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_181_comment =
    "C++ Interface:\n"
    "__add__(const PNMImage this, const PNMImage other)\n"
    "__add__(const PNMImage this, const VBase4D other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               is the sum of the corresponding pixel values\n"
    "//               in the two given images.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which the provided color\n"
    "//               is added to each pixel in the provided image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImage PNMImage::operator -(LVecBase4d const &other) const
 * inline PNMImage PNMImage::operator -(PNMImage const &other) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_182(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline PNMImage PNMImage::operator -(PNMImage const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__sub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__sub__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__sub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMImage result = ((const PNMImage*)local_this)->operator -(*param1_this);
                    PNMImage *return_value = new PNMImage(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline PNMImage PNMImage::operator -(LVecBase4d const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__sub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__sub__", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4d *param1_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4d, 1, "PNMImage.__sub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMImage result = ((const PNMImage*)local_this)->operator -(*param1_this);
                    PNMImage *return_value = new PNMImage(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__sub__(const PNMImage this, const PNMImage other)\n"
          "__sub__(const PNMImage this, const VBase4D other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_182_comment =
    "C++ Interface:\n"
    "__sub__(const PNMImage this, const PNMImage other)\n"
    "__sub__(const PNMImage this, const VBase4D other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator -\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               from the right image is subtracted from each\n"
    "//               pixel value from the left image.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator -\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which the provided color\n"
    "//               is subtracted from each pixel in the provided image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImage PNMImage::operator *(PNMImage const &other) const
 * inline PNMImage PNMImage::operator *(double multiplier) const
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_183(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline PNMImage PNMImage::operator *(PNMImage const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__mul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PNMImage result = ((const PNMImage*)local_this)->operator *(*param1_this);
                    PNMImage *return_value = new PNMImage(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline PNMImage PNMImage::operator *(double multiplier) const
            double param1;
            static char * key_word_list[] = {(char *)"multiplier", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage result = ((const PNMImage*)local_this)->operator *((double)param1);
                PNMImage *return_value = new PNMImage(result);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_PNMImage,true, false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__mul__(const PNMImage this, const PNMImage other)\n"
          "__mul__(const PNMImage this, float multiplier)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_183_comment =
    "C++ Interface:\n"
    "__mul__(const PNMImage this, const PNMImage other)\n"
    "__mul__(const PNMImage this, float multiplier)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator *\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               from the left image is multiplied by each\n"
    "//               pixel value from the right image. Note that the\n"
    "//               floating-point values in the 0..1 range are\n"
    "//               multiplied, not in the 0..maxval range.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator *\n"
    "//       Access: Published\n"
    "//  Description: Multiplies every pixel value in the image by\n"
    "//               a constant floating-point multiplier value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::operator +=(LVecBase4d const &other)
 * void PNMImage::operator +=(PNMImage const &other)
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_184(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator +=(PNMImage const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator +=(LVecBase4d const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4d *param1_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4d, 1, "PNMImage.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const PNMImage this, const PNMImage other)\n"
          "__iadd__(non-const PNMImage this, const VBase4D other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_184_comment =
    "C++ Interface:\n"
    "__iadd__(non-const PNMImage this, const PNMImage other)\n"
    "__iadd__(non-const PNMImage this, const VBase4D other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               is the sum of the corresponding pixel values\n"
    "//               in the two given images.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which the provided color\n"
    "//               is added to each pixel in the provided image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::operator -=(LVecBase4d const &other)
 * void PNMImage::operator -=(PNMImage const &other)
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_185(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator -=(PNMImage const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__isub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__isub__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__isub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator -=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator -=(LVecBase4d const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__isub__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__isub__", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4d *param1_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4d, 1, "PNMImage.__isub__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator -=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__isub__(non-const PNMImage this, const PNMImage other)\n"
          "__isub__(non-const PNMImage this, const VBase4D other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_185_comment =
    "C++ Interface:\n"
    "__isub__(non-const PNMImage this, const PNMImage other)\n"
    "__isub__(non-const PNMImage this, const VBase4D other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator -=\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               from the right image is subtracted from each\n"
    "//               pixel value from the left image.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator -=\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which the provided color\n"
    "//               is subtracted from each pixel in the provided image.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMImage::operator *=(PNMImage const &other)
 * void PNMImage::operator *=(double multiplier)
 *******************************************************************/
static PyObject *Dtool_PNMImage_operator_186(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMImage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator *=(PNMImage const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__imul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__imul__", &param1));
            if(!PyErr_Occurred())
            {
                PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMImage, 1, "PNMImage.__imul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator *=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PNMImage::operator *=(double multiplier)
            double param1;
            static char * key_word_list[] = {(char *)"multiplier", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:__imul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:__imul__", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->operator *=((double)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  Py_INCREF(self);
                  return self;
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__imul__(non-const PNMImage this, const PNMImage other)\n"
          "__imul__(non-const PNMImage this, float multiplier)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMImage_operator_186_comment =
    "C++ Interface:\n"
    "__imul__(non-const PNMImage this, const PNMImage other)\n"
    "__imul__(non-const PNMImage this, float multiplier)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator *=\n"
    "//       Access: Published\n"
    "//  Description: Returns a new PNMImage in which each pixel value\n"
    "//               from the left image is multiplied by each\n"
    "//               pixel value from the right image. Note that the\n"
    "//               floating-point values in the 0..1 range are\n"
    "//               multiplied, not in the 0..maxval range.\n"
    "//               Only valid when both images have the same size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMImage::operator *=\n"
    "//       Access: Published\n"
    "//  Description: Multiplies every pixel value in the image by\n"
    "//               a constant floating-point multiplier value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMImage_operator_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMImage::PNMImage(void)
 * PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
 * PNMImage::PNMImage(Filename const &filename, PNMFileType *type = ((void *)(0)))
 * inline PNMImage::PNMImage(PNMImage const &copy)
 * inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type)
 * inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type = ((void *)(0)))
 * inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
 * inline PNMImage::PNMImage(int x_size, int y_size, int num_channels = (3), unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_PNMImage(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline PNMImage::PNMImage(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PNMImage", key_word_list))
            {
                PNMImage *return_value = new PNMImage();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline PNMImage::PNMImage(PNMImage const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PNMImage", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PNMImage", &param0));
                if(!PyErr_Occurred())
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMImage.PNMImage", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PNMImage *return_value = new PNMImage(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 PNMImage::PNMImage(Filename const &filename, PNMFileType *type = ((void *)(0)))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PNMImage", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PNMImage", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "PNMImage.PNMImage", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMImage *return_value = new PNMImage(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PNMImage", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "PNMImage.PNMImage", 1, coerced_ptr, report_errors);
PNMFileType *param1_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMFileType, 1, "PNMImage.PNMImage", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        PNMImage *return_value = new PNMImage(*param0_this, param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PNMImage::PNMImage(int x_size, int y_size, int num_channels = (3), unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
                int param0;
                int param1;
                static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:PNMImage", key_word_list, &param0, &param1))
                {
                    PNMImage *return_value = new PNMImage((int)param0, (int)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval = (255), PNMFileType *type = ((void *)(0)))
            int param0;
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:PNMImage", key_word_list, &param0, &param1, &param2))
            {
                PNMImage *return_value = new PNMImage((int)param0, (int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type = ((void *)(0)))
            int param0;
            int param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", (char *)"maxval", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiO:PNMImage", key_word_list, &param0, &param1, &param2, &param3))
            {
                 PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param3_uint == NULL)))
                {
                    PNMImage *return_value = new PNMImage((int)param0, (int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                     Py_XDECREF(param3_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                    }
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PNMImage::PNMImage(int x_size, int y_size, int num_channels, unsigned short int maxval, PNMFileType *type)
                int param0;
                int param1;
                int param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"x_size", (char *)"y_size", (char *)"num_channels", (char *)"maxval", (char *)"type", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiiOO:PNMImage", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                     PyObject *param3_uint = PyNumber_Long(param3);PNMFileType *param4_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_PNMFileType, 4, "PNMImage.PNMImage", 0, coerced_ptr, report_errors);

                    if (!((param3_uint == NULL)|| (param4_this == NULL)))
                    {
                        PNMImage *return_value = new PNMImage((int)param0, (int)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint), param4_this);
                         Py_XDECREF(param3_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMImage,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PNMImage() takes 0, 1, 2, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PNMImage()\n"
          "PNMImage(const PNMImage copy)\n"
          "PNMImage(const Filename filename)\n"
          "PNMImage(const Filename filename, non-const PNMFileType type)\n"
          "PNMImage(int x_size, int y_size)\n"
          "PNMImage(int x_size, int y_size, int num_channels)\n"
          "PNMImage(int x_size, int y_size, int num_channels, unsigned int maxval)\n"
          "PNMImage(int x_size, int y_size, int num_channels, unsigned int maxval, non-const PNMFileType type)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMImage(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMImage)
    {
        printf("PNMImage ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMImage * local_this = (PNMImage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMImage)
        return local_this;
    if(requested_type == &Dtool_PNMImageHeader)
        return ( PNMImageHeader *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMImage(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMImage)
        return from_this;
    if(from_type == &Dtool_PNMImageHeader)
    {
          PNMImageHeader* other_this = (PNMImageHeader*)from_this;
          return (PNMImage*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PNMPainter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PNMPainter::set_pen(PNMBrush *pen)
 *******************************************************************/
static PyObject *Dtool_PNMPainter_set_pen_190(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMPainter::set_pen(PNMBrush *pen)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pen", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPen", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPen", &param1));
            if(!PyErr_Occurred())
            {
                PNMBrush *param1_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMBrush, 1, "PNMPainter.setPen", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pen(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMPainter.setPen() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPen(non-const PNMPainter this, non-const PNMBrush pen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_set_pen_190_comment =
    "C++ Interface:\n"
    "setPen(non-const PNMPainter this, non-const PNMBrush pen)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::set_pen\n"
    "//       Access: Published\n"
    "//  Description: Specifies a PNMBrush that will be used for drawing\n"
    "//               lines and edges.  If the brush is a bitmap brush, its\n"
    "//               image will be smeared pixelwise along the line.\n"
    "//\n"
    "//               Unlike the PNMImage passed to the constructor, the\n"
    "//               PNMPainter will take ownership of the pen.  It is not\n"
    "//               necessary to keep a separate pointer to it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_set_pen_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMBrush *PNMPainter::get_pen(void) const
 *******************************************************************/
static PyObject *Dtool_PNMPainter_get_pen_191(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMBrush *PNMPainter::get_pen(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPen", key_word_list));
        else
            (PyArg_Parse(args, ":getPen"));
        if(!PyErr_Occurred())
        {
            PNMBrush *return_value = ((const PNMPainter*)local_this)->get_pen();
            if (return_value != (PNMBrush *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMBrush,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPen(const PNMPainter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_get_pen_191_comment =
    "C++ Interface:\n"
    "getPen(const PNMPainter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::get_pen\n"
    "//       Access: Published\n"
    "//  Description: Returns the current pen.  See set_pen().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_get_pen_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMPainter::set_fill(PNMBrush *fill)
 *******************************************************************/
static PyObject *Dtool_PNMPainter_set_fill_192(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PNMPainter::set_fill(PNMBrush *fill)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"fill", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFill", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFill", &param1));
            if(!PyErr_Occurred())
            {
                PNMBrush *param1_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PNMBrush, 1, "PNMPainter.setFill", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_fill(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PNMPainter.setFill() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFill(non-const PNMPainter this, non-const PNMBrush fill)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_set_fill_192_comment =
    "C++ Interface:\n"
    "setFill(non-const PNMPainter this, non-const PNMBrush fill)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::set_fill\n"
    "//       Access: Published\n"
    "//  Description: Specifies a PNMBrush that will be used for filling\n"
    "//               in the interiors of objects.  If the brush is a\n"
    "//               bitmap brush, its image will be tiled throughout the\n"
    "//               space.\n"
    "//\n"
    "//               Unlike the PNMImage passed to the constructor, the\n"
    "//               PNMPainter will take ownership of the fill brush.  It\n"
    "//               is not necessary to keep a separate pointer to it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_set_fill_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PNMBrush *PNMPainter::get_fill(void) const
 *******************************************************************/
static PyObject *Dtool_PNMPainter_get_fill_193(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PNMBrush *PNMPainter::get_fill(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFill", key_word_list));
        else
            (PyArg_Parse(args, ":getFill"));
        if(!PyErr_Occurred())
        {
            PNMBrush *return_value = ((const PNMPainter*)local_this)->get_fill();
            if (return_value != (PNMBrush *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PNMBrush,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFill(const PNMPainter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_get_fill_193_comment =
    "C++ Interface:\n"
    "getFill(const PNMPainter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::get_fill\n"
    "//       Access: Published\n"
    "//  Description: Returns the current fill brush.  See set_fill().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_get_fill_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PNMPainter::draw_point(double x, double y)
 *******************************************************************/
static PyObject *Dtool_PNMPainter_draw_point_194(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PNMPainter::draw_point(double x, double y)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:drawPoint", key_word_list, &param1, &param2))
        {
            (local_this)->draw_point((double)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMPainter.drawPoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "drawPoint(non-const PNMPainter this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_draw_point_194_comment =
    "C++ Interface:\n"
    "drawPoint(non-const PNMPainter this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::draw_point\n"
    "//       Access: Published\n"
    "//  Description: Draws an antialiased point on the PNMImage, using the\n"
    "//               current pen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_draw_point_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMPainter::draw_line(double xa, double ya, double xb, double yb)
 *******************************************************************/
static PyObject *Dtool_PNMPainter_draw_line_195(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PNMPainter::draw_line(double xa, double ya, double xb, double yb)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xa", (char *)"ya", (char *)"xb", (char *)"yb", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:drawLine", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->draw_line((double)param1, (double)param2, (double)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMPainter.drawLine() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "drawLine(non-const PNMPainter this, float xa, float ya, float xb, float yb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_draw_line_195_comment =
    "C++ Interface:\n"
    "drawLine(non-const PNMPainter this, float xa, float ya, float xb, float yb)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::draw_line\n"
    "//       Access: Published\n"
    "//  Description: Draws an antialiased line on the PNMImage, using the\n"
    "//               current pen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_draw_line_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PNMPainter::draw_rectangle(double xa, double ya, double xb, double yb)
 *******************************************************************/
static PyObject *Dtool_PNMPainter_draw_rectangle_196(PyObject *self, PyObject *args,PyObject *kwds) {
    PNMPainter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMPainter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PNMPainter::draw_rectangle(double xa, double ya, double xb, double yb)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xa", (char *)"ya", (char *)"xb", (char *)"yb", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:drawRectangle", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->draw_rectangle((double)param1, (double)param2, (double)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PNMPainter.drawRectangle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "drawRectangle(non-const PNMPainter this, float xa, float ya, float xb, float yb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PNMPainter_draw_rectangle_196_comment =
    "C++ Interface:\n"
    "drawRectangle(non-const PNMPainter this, float xa, float ya, float xb, float yb)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PNMPainter::draw_rectangle\n"
    "//       Access: Published\n"
    "//  Description: Draws a filled rectangule on the PNMImage, using the\n"
    "//               current pen for the outline, and the current fill\n"
    "//               brush for the interior.\n"
    "//\n"
    "//               The two coordinates specify any two diagonally\n"
    "//               opposite corners.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PNMPainter_draw_rectangle_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PNMPainter::PNMPainter(PNMImage &image, int xo, int yo)
 * PNMPainter::PNMPainter(PNMImage &image, int xo, int yo = (0))
 * PNMPainter::PNMPainter(PNMImage &image, int xo = (0), int yo = (0))
 *******************************************************************/
int  Dtool_Init_PNMPainter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PNMPainter::PNMPainter(PNMImage &image, int xo = (0), int yo = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"image", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PNMPainter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PNMPainter", &param0));
                if(!PyErr_Occurred())
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMPainter.PNMPainter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMPainter *return_value = new PNMPainter(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMPainter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo = (0))
                PyObject *param0;
                int param1;
                static char * key_word_list[] = {(char *)"image", (char *)"xo", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:PNMPainter", key_word_list, &param0, &param1))
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMPainter.PNMPainter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMPainter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PNMPainter::PNMPainter(PNMImage &image, int xo, int yo)
                PyObject *param0;
                int param1;
                int param2;
                static char * key_word_list[] = {(char *)"image", (char *)"xo", (char *)"yo", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:PNMPainter", key_word_list, &param0, &param1, &param2))
                {
                    PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PNMImage, 0, "PNMPainter.PNMPainter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PNMPainter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PNMPainter() takes 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PNMPainter(non-const PNMImage image)\n"
          "PNMPainter(non-const PNMImage image, int xo)\n"
          "PNMPainter(non-const PNMImage image, int xo, int yo)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PNMPainter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PNMPainter)
    {
        printf("PNMPainter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PNMPainter * local_this = (PNMPainter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PNMPainter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PNMPainter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PNMPainter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PNMBrush | PNMBrush
//********************************************************************
PyMethodDef Dtool_Methods_PNMBrush[]= {
  { "makeTransparent",(PyCFunction ) &Dtool_PNMBrush_make_transparent_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMBrush_make_transparent_4_comment},
  { "makePixel",(PyCFunction ) &Dtool_PNMBrush_make_pixel_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMBrush_make_pixel_5_comment},
  { "makeSpot",(PyCFunction ) &Dtool_PNMBrush_make_spot_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMBrush_make_spot_6_comment},
  { "makeImage",(PyCFunction ) &Dtool_PNMBrush_make_image_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMBrush_make_image_7_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMBrush(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMBrush.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMBrush\n"
          "// Description : This class is used to control the shape and color of\n"
          "//               the drawing operations performed by a PNMPainter\n"
          "//               object.\n"
          "//\n"
          "//               Normally, you don't create a PNMBrush directly;\n"
          "//               instead, use one of the static PNMBrush::make_*()\n"
          "//               methods provided here.\n"
          "//\n"
          "//               A PNMBrush is used to draw the border of a polygon or\n"
          "//               rectangle, as well as for filling its interior.  When\n"
          "//               it is used to draw a border, the brush is \"smeared\"\n"
          "//               over the border; when it is used to fill the\n"
          "//               interior, it is tiled through the interior.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_PNMBrush.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_PNMBrush.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMBrush.As_PyTypeObject().tp_dict);
        // Enum  PNMBrush::BrushEffect;
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"BESet",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"BEBlend",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"BEDarken",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"BELighten",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_PNMBrush.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMBrush)");
             printf(" Error In PyType_ReadyPNMBrush");
             return;
        }
        Py_INCREF(&Dtool_PNMBrush.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"PNMBrush",&Dtool_PNMBrush.As_PyObject());
        //  Static Method makeTransparent
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"makeTransparent",PyCFunction_New(&Dtool_Methods_PNMBrush[0],&Dtool_PNMBrush.As_PyObject()));
        //  Static Method makePixel
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"makePixel",PyCFunction_New(&Dtool_Methods_PNMBrush[1],&Dtool_PNMBrush.As_PyObject()));
        //  Static Method makeSpot
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"makeSpot",PyCFunction_New(&Dtool_Methods_PNMBrush[2],&Dtool_PNMBrush.As_PyObject()));
        //  Static Method makeImage
        PyDict_SetItemString(Dtool_PNMBrush.As_PyTypeObject().tp_dict,"makeImage",PyCFunction_New(&Dtool_Methods_PNMBrush[3],&Dtool_PNMBrush.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PNMBrush,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMBrush.As_PyTypeObject());
        PyModule_AddObject(module, "PNMBrush",(PyObject *)&Dtool_PNMBrush.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. pixel | Xel
//********************************************************************
PyMethodDef Dtool_Methods_pixel[]= {
  { "size",(PyCFunction ) &Dtool_pixel_size_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_size_10_comment},
  { "__getitem__",(PyCFunction ) &Dtool_pixel_operator_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_11_comment},
  { "Setitem",(PyCFunction ) &Dtool_pixel_setitem_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_setitem_12_comment},
  { "__add__",(PyCFunction ) &Dtool_pixel_operator_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_13_comment},
  { "__sub__",(PyCFunction ) &Dtool_pixel_operator_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_14_comment},
  { "__mul__",(PyCFunction ) &Dtool_pixel_operator_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_15_comment},
  { "__iadd__",(PyCFunction ) &Dtool_pixel_operator_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_16_comment},
  { "__isub__",(PyCFunction ) &Dtool_pixel_operator_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_17_comment},
  { "__imul__",(PyCFunction ) &Dtool_pixel_operator_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_pixel_operator_18_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_subtract = __sub__
//////////////////
static PyObject *Dtool_pixel_operator_14__sub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_14(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_pixel_operator_16__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_16(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_multiply = __mul__
//////////////////
static PyObject *Dtool_pixel_operator_15__mul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_15(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_inplace_subtract = __isub__
//////////////////
static PyObject *Dtool_pixel_operator_17__isub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_17(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_inplace_multiply = __imul__
//////////////////
static PyObject *Dtool_pixel_operator_18__imul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_18(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_pixel_setitem_12Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_pixel_setitem_12(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_pixel_operator_13__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_pixel_operator_13(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_pixel_size_10size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_pixel_size_10(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     pixel ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_pixel_operator_11__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_pixel_operator_11(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_pixel(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_pixel.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_pixel.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_pixel.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_pixel.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_subtract = __sub__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_subtract = &Dtool_pixel_operator_14__sub__;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_pixel_operator_16__iadd__;
        // tp_as_number->nb_multiply = __mul__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_multiply = &Dtool_pixel_operator_15__mul__;
        // tp_as_number->nb_inplace_subtract = __isub__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_inplace_subtract = &Dtool_pixel_operator_17__isub__;
        // tp_as_number->nb_inplace_multiply = __imul__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_inplace_multiply = &Dtool_pixel_operator_18__imul__;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_pixel.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_pixel_setitem_12Setitem;
        // tp_as_number->nb_add = __add__
        Dtool_pixel.As_PyTypeObject().tp_as_number->nb_add = &Dtool_pixel_operator_13__add__;
        // tp_as_sequence->sq_length = size
        Dtool_pixel.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_pixel_size_10size;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_pixel.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_pixel_operator_11__getitem__;
        if(PyType_Ready(&Dtool_pixel.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(pixel)");
             printf(" Error In PyType_Readypixel");
             return;
        }
        Py_INCREF(&Dtool_pixel.As_PyTypeObject());
        PyDict_SetItemString(Dtool_pixel.As_PyTypeObject().tp_dict,"Xel",&Dtool_pixel.As_PyObject());
        //  Static Method size
        PyDict_SetItemString(Dtool_pixel.As_PyTypeObject().tp_dict,"size",PyCFunction_New(&Dtool_Methods_pixel[0],&Dtool_pixel.As_PyObject()));
        RegisterRuntimeClass(&Dtool_pixel,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_pixel.As_PyTypeObject());
        PyModule_AddObject(module, "Xel",(PyObject *)&Dtool_pixel.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMFileType | PNMFileType
//********************************************************************
PyMethodDef Dtool_Methods_PNMFileType[]= {
  { "getName",(PyCFunction ) &Dtool_PNMFileType_get_name_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileType_get_name_32_comment},
  { "getNumExtensions",(PyCFunction ) &Dtool_PNMFileType_get_num_extensions_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileType_get_num_extensions_33_comment},
  { "getExtension",(PyCFunction ) &Dtool_PNMFileType_get_extension_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileType_get_extension_34_comment},
  { "getSuggestedExtension",(PyCFunction ) &Dtool_PNMFileType_get_suggested_extension_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileType_get_suggested_extension_35_comment},
  { "getClassType",(PyCFunction ) &Dtool_PNMFileType_get_class_type_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileType_get_class_type_36_comment},
  { "getExtensions",(PyCFunction) &MakeSeq_PNMFileType_get_extensions, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMFileType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMFileType.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMFileType\n"
          "// Description : This is the base class of a family of classes that\n"
          "//               represent particular image file types that PNMImage\n"
          "//               supports.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritable._Dtool_ClassInit(NULL);
        Dtool_PNMFileType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritable.As_PyTypeObject());
        Dtool_PNMFileType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMFileType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMFileType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PNMFileType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMFileType)");
             printf(" Error In PyType_ReadyPNMFileType");
             return;
        }
        Py_INCREF(&Dtool_PNMFileType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMFileType.As_PyTypeObject().tp_dict,"PNMFileType",&Dtool_PNMFileType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PNMFileType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PNMFileType[4],&Dtool_PNMFileType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PNMFileType,PNMFileType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMFileType.As_PyTypeObject());
        PyModule_AddObject(module, "PNMFileType",(PyObject *)&Dtool_PNMFileType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMFileTypeRegistry | PNMFileTypeRegistry
//********************************************************************
PyMethodDef Dtool_Methods_PNMFileTypeRegistry[]= {
  { "getNumTypes",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_num_types_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_num_types_39_comment},
  { "getType",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_type_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_type_40_comment},
  { "getTypeFromExtension",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_type_from_extension_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_type_from_extension_41_comment},
  { "getTypeFromMagicNumber",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_type_from_magic_number_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_type_from_magic_number_42_comment},
  { "getTypeByHandle",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_type_by_handle_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_type_by_handle_43_comment},
  { "write",(PyCFunction ) &Dtool_PNMFileTypeRegistry_write_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_write_44_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_PNMFileTypeRegistry_get_global_ptr_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMFileTypeRegistry_get_global_ptr_45_comment},
  { "getTypes",(PyCFunction) &MakeSeq_PNMFileTypeRegistry_get_types, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     PNMFileTypeRegistry
//////////////////
static PyObject *  Dtool_Str_PNMFileTypeRegistry(PyObject * self)
{
    PNMFileTypeRegistry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMFileTypeRegistry,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PNMFileTypeRegistry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMFileTypeRegistry\n"
          "// Description : This class maintains the set of all known\n"
          "//               PNMFileTypes in the universe.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_str = & Dtool_Str_PNMFileTypeRegistry;
        if(PyType_Ready(&Dtool_PNMFileTypeRegistry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMFileTypeRegistry)");
             printf(" Error In PyType_ReadyPNMFileTypeRegistry");
             return;
        }
        Py_INCREF(&Dtool_PNMFileTypeRegistry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_dict,"PNMFileTypeRegistry",&Dtool_PNMFileTypeRegistry.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_PNMFileTypeRegistry.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_PNMFileTypeRegistry[6],&Dtool_PNMFileTypeRegistry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PNMFileTypeRegistry,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMFileTypeRegistry.As_PyTypeObject());
        PyModule_AddObject(module, "PNMFileTypeRegistry",(PyObject *)&Dtool_PNMFileTypeRegistry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMImageHeader_PixelSpec | PixelSpec
//********************************************************************
PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpec[]= {
  { "assign",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_operator_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_operator_70_comment},
  { "lessThan",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_operator_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_operator_71_comment},
  { "eq",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_operator_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_operator_72_comment},
  { "ne",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_operator_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_operator_73_comment},
  { "compareTo",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_compare_to_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_compare_to_74_comment},
  { "getRed",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_get_red_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_get_red_75_comment},
  { "getGreen",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_get_green_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_get_green_76_comment},
  { "getBlue",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_get_blue_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_get_blue_77_comment},
  { "getAlpha",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_get_alpha_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_get_alpha_78_comment},
  { "setRed",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_set_red_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_set_red_79_comment},
  { "setGreen",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_set_green_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_set_green_80_comment},
  { "setBlue",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_set_blue_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_set_blue_81_comment},
  { "setAlpha",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_set_alpha_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_set_alpha_82_comment},
  { "__getitem__",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_operator_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_operator_83_comment},
  { "size",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_size_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_size_84_comment},
  { "output",(PyCFunction ) &Dtool_PNMImageHeader_PixelSpec_output_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_PixelSpec_output_85_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImageHeader_PixelSpec ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_PNMImageHeader_PixelSpec_operator_83__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PNMImageHeader_PixelSpec_operator_83(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImageHeader_PixelSpec ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PNMImageHeader_PixelSpec_size_84size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PNMImageHeader_PixelSpec_size_84(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A __repr__ Function
//     PNMImageHeader_PixelSpec
//////////////////
static PyObject *  Dtool_Repr_PNMImageHeader_PixelSpec(PyObject * self)
{
    PNMImageHeader::PixelSpec * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_PixelSpec,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_doc =
          "// Contains a single pixel specification used in compute_histogram()\n"
          "// and make_histogram().  Note that pixels are stored by integer\n"
          "// value, not by floating-point scaled value.";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = __getitem__
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PNMImageHeader_PixelSpec_operator_83__getitem__;
        // tp_as_sequence->sq_length = size
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PNMImageHeader_PixelSpec_size_84size;
        // __repr__
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_repr = & Dtool_Repr_PNMImageHeader_PixelSpec;
        // __str__ Repr Proxy
        Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_str = & Dtool_Repr_PNMImageHeader_PixelSpec;
        if(PyType_Ready(&Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMImageHeader_PixelSpec)");
             printf(" Error In PyType_ReadyPNMImageHeader_PixelSpec");
             return;
        }
        Py_INCREF(&Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_dict,"PixelSpec",&Dtool_PNMImageHeader_PixelSpec.As_PyObject());
        //  Static Method size
        PyDict_SetItemString(Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject().tp_dict,"size",PyCFunction_New(&Dtool_Methods_PNMImageHeader_PixelSpec[14],&Dtool_PNMImageHeader_PixelSpec.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PNMImageHeader_PixelSpec,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject());
        PyModule_AddObject(module, "PixelSpec",(PyObject *)&Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMImageHeader_PixelSpecCount | PixelSpecCount
//********************************************************************
PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpecCount[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_doc =
          "// Associates a pixel specification with an appearance count, for\n"
          "// use in Histogram, below.";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMImageHeader_PixelSpecCount)");
             printf(" Error In PyType_ReadyPNMImageHeader_PixelSpecCount");
             return;
        }
        Py_INCREF(&Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject().tp_dict,"PixelSpecCount",&Dtool_PNMImageHeader_PixelSpecCount.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMImageHeader_PixelSpecCount,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject());
        PyModule_AddObject(module, "PixelSpecCount",(PyObject *)&Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMImageHeader_Histogram | Histogram
//********************************************************************
PyMethodDef Dtool_Methods_PNMImageHeader_Histogram[]= {
  { "getNumPixels",(PyCFunction ) &Dtool_PNMImageHeader_Histogram_get_num_pixels_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_Histogram_get_num_pixels_91_comment},
  { "getPixel",(PyCFunction ) &Dtool_PNMImageHeader_Histogram_get_pixel_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_Histogram_get_pixel_92_comment},
  { "getCount",(PyCFunction ) &Dtool_PNMImageHeader_Histogram_get_count_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_Histogram_get_count_93_comment},
  { "write",(PyCFunction ) &Dtool_PNMImageHeader_Histogram_write_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_Histogram_write_94_comment},
  { "getPixels",(PyCFunction) &MakeSeq_PNMImageHeader_Histogram_get_pixels, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     PNMImageHeader_Histogram
//////////////////
static PyObject *  Dtool_Str_PNMImageHeader_Histogram(PyObject * self)
{
    PNMImageHeader::Histogram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader_Histogram,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PNMImageHeader_Histogram(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_doc =
          "// Used to return a pixel histogram in PNMImage::get_histogram().";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_str = & Dtool_Str_PNMImageHeader_Histogram;
        if(PyType_Ready(&Dtool_PNMImageHeader_Histogram.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMImageHeader_Histogram)");
             printf(" Error In PyType_ReadyPNMImageHeader_Histogram");
             return;
        }
        Py_INCREF(&Dtool_PNMImageHeader_Histogram.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMImageHeader_Histogram.As_PyTypeObject().tp_dict,"Histogram",&Dtool_PNMImageHeader_Histogram.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMImageHeader_Histogram,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMImageHeader_Histogram.As_PyTypeObject());
        PyModule_AddObject(module, "Histogram",(PyObject *)&Dtool_PNMImageHeader_Histogram.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMImageHeader | PNMImageHeader
//********************************************************************
PyMethodDef Dtool_Methods_PNMImageHeader[]= {
  { "assign",(PyCFunction ) &Dtool_PNMImageHeader_operator_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_operator_48_comment},
  { "getColorType",(PyCFunction ) &Dtool_PNMImageHeader_get_color_type_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_color_type_51_comment},
  { "getNumChannels",(PyCFunction ) &Dtool_PNMImageHeader_get_num_channels_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_num_channels_52_comment},
  { "isGrayscale",(PyCFunction ) &Dtool_PNMImageHeader_is_grayscale_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_is_grayscale_53_comment},
  { "hasAlpha",(PyCFunction ) &Dtool_PNMImageHeader_has_alpha_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_has_alpha_54_comment},
  { "getMaxval",(PyCFunction ) &Dtool_PNMImageHeader_get_maxval_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_maxval_55_comment},
  { "getXSize",(PyCFunction ) &Dtool_PNMImageHeader_get_x_size_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_x_size_56_comment},
  { "getYSize",(PyCFunction ) &Dtool_PNMImageHeader_get_y_size_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_y_size_57_comment},
  { "getComment",(PyCFunction ) &Dtool_PNMImageHeader_get_comment_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_comment_58_comment},
  { "setComment",(PyCFunction ) &Dtool_PNMImageHeader_set_comment_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_set_comment_59_comment},
  { "hasType",(PyCFunction ) &Dtool_PNMImageHeader_has_type_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_has_type_60_comment},
  { "getType",(PyCFunction ) &Dtool_PNMImageHeader_get_type_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_get_type_61_comment},
  { "setType",(PyCFunction ) &Dtool_PNMImageHeader_set_type_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_set_type_62_comment},
  { "readHeader",(PyCFunction ) &Dtool_PNMImageHeader_read_header_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_read_header_63_comment},
  { "readMagicNumber",(PyCFunction ) &Dtool_PNMImageHeader_read_magic_number_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_read_magic_number_66_comment},
  { "output",(PyCFunction ) &Dtool_PNMImageHeader_output_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImageHeader_output_67_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PNMImageHeader
//////////////////
static PyObject *  Dtool_Repr_PNMImageHeader(PyObject * self)
{
    PNMImageHeader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PNMImageHeader,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PNMImageHeader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMImageHeader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMImageHeader\n"
          "// Description : This is the base class of PNMImage, PNMReader, and\n"
          "//               PNMWriter.  It encapsulates all the information\n"
          "//               associated with an image that describes its size,\n"
          "//               number of channels, etc; that is, all the information\n"
          "//               about the image except the image data itself.  It's\n"
          "//               the sort of information you typically read from the\n"
          "//               image file's header.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMImageHeader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMImageHeader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMImageHeader.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PNMImageHeader.As_PyTypeObject().tp_repr = & Dtool_Repr_PNMImageHeader;
        // __str__ Repr Proxy
        Dtool_PNMImageHeader.As_PyTypeObject().tp_str = & Dtool_Repr_PNMImageHeader;
        // Enum  PNMImageHeader::ColorType;
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"CTInvalid",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"CTGrayscale",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"CTTwoChannel",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"CTColor",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"CTFourChannel",PyInt_FromLong(4));
        // Nested Object   PNMImageHeader_PixelSpec;
        Dtool_PNMImageHeader_PixelSpec._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"PixelSpec",(PyObject *)&Dtool_PNMImageHeader_PixelSpec.As_PyTypeObject());
        // Nested Object   PNMImageHeader_PixelSpecCount;
        Dtool_PNMImageHeader_PixelSpecCount._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"PixelSpecCount",(PyObject *)&Dtool_PNMImageHeader_PixelSpecCount.As_PyTypeObject());
        // Nested Object   PNMImageHeader_Histogram;
        Dtool_PNMImageHeader_Histogram._Dtool_ClassInit(NULL);
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"Histogram",(PyObject *)&Dtool_PNMImageHeader_Histogram.As_PyTypeObject());
        if(PyType_Ready(&Dtool_PNMImageHeader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMImageHeader)");
             printf(" Error In PyType_ReadyPNMImageHeader");
             return;
        }
        Py_INCREF(&Dtool_PNMImageHeader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"PNMImageHeader",&Dtool_PNMImageHeader.As_PyObject());
        //  Static Method readMagicNumber
        PyDict_SetItemString(Dtool_PNMImageHeader.As_PyTypeObject().tp_dict,"readMagicNumber",PyCFunction_New(&Dtool_Methods_PNMImageHeader[14],&Dtool_PNMImageHeader.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PNMImageHeader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMImageHeader.As_PyTypeObject());
        PyModule_AddObject(module, "PNMImageHeader",(PyObject *)&Dtool_PNMImageHeader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMImage | PNMImage
//********************************************************************
PyMethodDef Dtool_Methods_PNMImage[]= {
  { "assign",(PyCFunction ) &Dtool_PNMImage_operator_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_98_comment},
  { "clampVal",(PyCFunction ) &Dtool_PNMImage_clamp_val_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_clamp_val_100_comment},
  { "toVal",(PyCFunction ) &Dtool_PNMImage_to_val_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_to_val_101_comment},
  { "fromVal",(PyCFunction ) &Dtool_PNMImage_from_val_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_from_val_102_comment},
  { "clear",(PyCFunction ) &Dtool_PNMImage_clear_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_clear_103_comment},
  { "copyFrom",(PyCFunction ) &Dtool_PNMImage_copy_from_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_copy_from_104_comment},
  { "copyChannel",(PyCFunction ) &Dtool_PNMImage_copy_channel_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_copy_channel_105_comment},
  { "copyHeaderFrom",(PyCFunction ) &Dtool_PNMImage_copy_header_from_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_copy_header_from_106_comment},
  { "takeFrom",(PyCFunction ) &Dtool_PNMImage_take_from_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_take_from_107_comment},
  { "fill",(PyCFunction ) &Dtool_PNMImage_fill_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_fill_108_comment},
  { "remixChannels",(PyCFunction ) &Dtool_PNMImage_remix_channels_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_remix_channels_109_comment},
  { "fillVal",(PyCFunction ) &Dtool_PNMImage_fill_val_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_fill_val_110_comment},
  { "alphaFill",(PyCFunction ) &Dtool_PNMImage_alpha_fill_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_alpha_fill_111_comment},
  { "alphaFillVal",(PyCFunction ) &Dtool_PNMImage_alpha_fill_val_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_alpha_fill_val_112_comment},
  { "setReadSize",(PyCFunction ) &Dtool_PNMImage_set_read_size_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_read_size_113_comment},
  { "clearReadSize",(PyCFunction ) &Dtool_PNMImage_clear_read_size_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_clear_read_size_114_comment},
  { "hasReadSize",(PyCFunction ) &Dtool_PNMImage_has_read_size_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_has_read_size_115_comment},
  { "getReadXSize",(PyCFunction ) &Dtool_PNMImage_get_read_x_size_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_read_x_size_116_comment},
  { "getReadYSize",(PyCFunction ) &Dtool_PNMImage_get_read_y_size_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_read_y_size_117_comment},
  { "read",(PyCFunction ) &Dtool_PNMImage_read_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_read_118_comment},
  { "write",(PyCFunction ) &Dtool_PNMImage_write_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_write_119_comment},
  { "isValid",(PyCFunction ) &Dtool_PNMImage_is_valid_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_is_valid_120_comment},
  { "setNumChannels",(PyCFunction ) &Dtool_PNMImage_set_num_channels_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_num_channels_121_comment},
  { "setColorType",(PyCFunction ) &Dtool_PNMImage_set_color_type_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_color_type_122_comment},
  { "addAlpha",(PyCFunction ) &Dtool_PNMImage_add_alpha_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_add_alpha_123_comment},
  { "removeAlpha",(PyCFunction ) &Dtool_PNMImage_remove_alpha_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_remove_alpha_124_comment},
  { "makeGrayscale",(PyCFunction ) &Dtool_PNMImage_make_grayscale_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_make_grayscale_125_comment},
  { "makeRgb",(PyCFunction ) &Dtool_PNMImage_make_rgb_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_make_rgb_126_comment},
  { "setMaxval",(PyCFunction ) &Dtool_PNMImage_set_maxval_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_maxval_127_comment},
  { "getXelVal",(PyCFunction ) &Dtool_PNMImage_get_xel_val_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_xel_val_128_comment},
  { "setXelVal",(PyCFunction ) &Dtool_PNMImage_set_xel_val_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_xel_val_129_comment},
  { "getRedVal",(PyCFunction ) &Dtool_PNMImage_get_red_val_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_red_val_130_comment},
  { "getGreenVal",(PyCFunction ) &Dtool_PNMImage_get_green_val_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_green_val_131_comment},
  { "getBlueVal",(PyCFunction ) &Dtool_PNMImage_get_blue_val_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_blue_val_132_comment},
  { "getGrayVal",(PyCFunction ) &Dtool_PNMImage_get_gray_val_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_gray_val_133_comment},
  { "getAlphaVal",(PyCFunction ) &Dtool_PNMImage_get_alpha_val_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_alpha_val_134_comment},
  { "setRedVal",(PyCFunction ) &Dtool_PNMImage_set_red_val_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_red_val_135_comment},
  { "setGreenVal",(PyCFunction ) &Dtool_PNMImage_set_green_val_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_green_val_136_comment},
  { "setBlueVal",(PyCFunction ) &Dtool_PNMImage_set_blue_val_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_blue_val_137_comment},
  { "setGrayVal",(PyCFunction ) &Dtool_PNMImage_set_gray_val_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_gray_val_138_comment},
  { "setAlphaVal",(PyCFunction ) &Dtool_PNMImage_set_alpha_val_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_alpha_val_139_comment},
  { "getChannelVal",(PyCFunction ) &Dtool_PNMImage_get_channel_val_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_channel_val_140_comment},
  { "setChannelVal",(PyCFunction ) &Dtool_PNMImage_set_channel_val_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_channel_val_141_comment},
  { "getPixel",(PyCFunction ) &Dtool_PNMImage_get_pixel_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_pixel_142_comment},
  { "setPixel",(PyCFunction ) &Dtool_PNMImage_set_pixel_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_pixel_143_comment},
  { "getXel",(PyCFunction ) &Dtool_PNMImage_get_xel_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_xel_144_comment},
  { "setXel",(PyCFunction ) &Dtool_PNMImage_set_xel_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_xel_145_comment},
  { "getXelA",(PyCFunction ) &Dtool_PNMImage_get_xel_a_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_xel_a_146_comment},
  { "setXelA",(PyCFunction ) &Dtool_PNMImage_set_xel_a_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_xel_a_147_comment},
  { "getRed",(PyCFunction ) &Dtool_PNMImage_get_red_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_red_148_comment},
  { "getGreen",(PyCFunction ) &Dtool_PNMImage_get_green_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_green_149_comment},
  { "getBlue",(PyCFunction ) &Dtool_PNMImage_get_blue_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_blue_150_comment},
  { "getGray",(PyCFunction ) &Dtool_PNMImage_get_gray_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_gray_151_comment},
  { "getAlpha",(PyCFunction ) &Dtool_PNMImage_get_alpha_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_alpha_152_comment},
  { "setRed",(PyCFunction ) &Dtool_PNMImage_set_red_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_red_153_comment},
  { "setGreen",(PyCFunction ) &Dtool_PNMImage_set_green_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_green_154_comment},
  { "setBlue",(PyCFunction ) &Dtool_PNMImage_set_blue_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_blue_155_comment},
  { "setGray",(PyCFunction ) &Dtool_PNMImage_set_gray_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_gray_156_comment},
  { "setAlpha",(PyCFunction ) &Dtool_PNMImage_set_alpha_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_alpha_157_comment},
  { "getChannel",(PyCFunction ) &Dtool_PNMImage_get_channel_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_channel_158_comment},
  { "setChannel",(PyCFunction ) &Dtool_PNMImage_set_channel_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_set_channel_159_comment},
  { "getBright",(PyCFunction ) &Dtool_PNMImage_get_bright_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_bright_160_comment},
  { "blend",(PyCFunction ) &Dtool_PNMImage_blend_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_blend_161_comment},
  { "__getitem__",(PyCFunction ) &Dtool_PNMImage_operator_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_162_comment},
  { "copySubImage",(PyCFunction ) &Dtool_PNMImage_copy_sub_image_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_copy_sub_image_163_comment},
  { "blendSubImage",(PyCFunction ) &Dtool_PNMImage_blend_sub_image_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_blend_sub_image_164_comment},
  { "darkenSubImage",(PyCFunction ) &Dtool_PNMImage_darken_sub_image_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_darken_sub_image_165_comment},
  { "lightenSubImage",(PyCFunction ) &Dtool_PNMImage_lighten_sub_image_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_lighten_sub_image_166_comment},
  { "threshold",(PyCFunction ) &Dtool_PNMImage_threshold_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_threshold_167_comment},
  { "renderSpot",(PyCFunction ) &Dtool_PNMImage_render_spot_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_render_spot_168_comment},
  { "expandBorder",(PyCFunction ) &Dtool_PNMImage_expand_border_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_expand_border_169_comment},
  { "boxFilter",(PyCFunction ) &Dtool_PNMImage_box_filter_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_box_filter_170_comment},
  { "gaussianFilter",(PyCFunction ) &Dtool_PNMImage_gaussian_filter_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_gaussian_filter_171_comment},
  { "boxFilterFrom",(PyCFunction ) &Dtool_PNMImage_box_filter_from_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_box_filter_from_172_comment},
  { "gaussianFilterFrom",(PyCFunction ) &Dtool_PNMImage_gaussian_filter_from_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_gaussian_filter_from_173_comment},
  { "quickFilterFrom",(PyCFunction ) &Dtool_PNMImage_quick_filter_from_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_quick_filter_from_174_comment},
  { "makeHistogram",(PyCFunction ) &Dtool_PNMImage_make_histogram_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_make_histogram_175_comment},
  { "perlinNoiseFill",(PyCFunction ) &Dtool_PNMImage_perlin_noise_fill_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_perlin_noise_fill_176_comment},
  { "getAverageXel",(PyCFunction ) &Dtool_PNMImage_get_average_xel_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_average_xel_177_comment},
  { "getAverageXelA",(PyCFunction ) &Dtool_PNMImage_get_average_xel_a_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_average_xel_a_178_comment},
  { "getAverageGray",(PyCFunction ) &Dtool_PNMImage_get_average_gray_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_get_average_gray_179_comment},
  { "__invert__",(PyCFunction ) &Dtool_PNMImage_operator_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_180_comment},
  { "__add__",(PyCFunction ) &Dtool_PNMImage_operator_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_181_comment},
  { "__sub__",(PyCFunction ) &Dtool_PNMImage_operator_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_182_comment},
  { "__mul__",(PyCFunction ) &Dtool_PNMImage_operator_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_183_comment},
  { "__iadd__",(PyCFunction ) &Dtool_PNMImage_operator_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_184_comment},
  { "__isub__",(PyCFunction ) &Dtool_PNMImage_operator_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_185_comment},
  { "__imul__",(PyCFunction ) &Dtool_PNMImage_operator_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMImage_operator_186_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_PNMImage_operator_162__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_162(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_invert = __invert__
//////////////////
static PyObject * Dtool_PNMImage_operator_180__invert__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PNMImage_operator_180(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_subtract = __sub__
//////////////////
static PyObject *Dtool_PNMImage_operator_182__sub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_182(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_PNMImage_operator_184__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_184(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_multiply = __mul__
//////////////////
static PyObject *Dtool_PNMImage_operator_183__mul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_183(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_inplace_subtract = __isub__
//////////////////
static PyObject *Dtool_PNMImage_operator_185__isub__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_185(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_inplace_multiply = __imul__
//////////////////
static PyObject *Dtool_PNMImage_operator_186__imul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_186(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PNMImage ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_PNMImage_operator_181__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PNMImage_operator_181(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_PNMImage(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMImage.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMImage\n"
          "// Description : The name of this class derives from the fact that we\n"
          "//               originally implemented it as a layer on top of the\n"
          "//               \"pnm library\", based on netpbm, which was built to\n"
          "//               implement pbm, pgm, and pbm files, and is the\n"
          "//               underlying support of a number of public-domain image\n"
          "//               file converters.  Nowadays we are no longer derived\n"
          "//               directly from the pnm library, mainly to allow\n"
          "//               support of C++ iostreams instead of the C stdio FILE\n"
          "//               interface.\n"
          "//\n"
          "//               Conceptually, a PNMImage is a two-dimensional array\n"
          "//               of xels, which are the PNM-defined generic pixel\n"
          "//               type.  Each xel may have a red, green, and blue\n"
          "//               component, or (if the image is grayscale) a gray\n"
          "//               component.  The image may be read in, the individual\n"
          "//               xels manipulated, and written out again, or a black\n"
          "//               image may be constructed from scratch.\n"
          "//\n"
          "//               The image is of size XSize() by YSize() xels,\n"
          "//               numbered from top to bottom, left to right, beginning\n"
          "//               at zero.\n"
          "//\n"
          "//               Files can be specified by filename, or by an iostream\n"
          "//               pointer.  The filename \"-\" refers to stdin or stdout.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PNMImageHeader._Dtool_ClassInit(NULL);
        Dtool_PNMImage.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PNMImageHeader.As_PyTypeObject());
        Dtool_PNMImage.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMImage.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMImage.As_PyTypeObject().tp_dict);
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_PNMImage.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_PNMImage_operator_162__getitem__;
        // tp_as_number->nb_invert = __invert__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_invert = &Dtool_PNMImage_operator_180__invert__;
        // tp_as_number->nb_subtract = __sub__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_subtract = &Dtool_PNMImage_operator_182__sub__;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_PNMImage_operator_184__iadd__;
        // tp_as_number->nb_multiply = __mul__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_multiply = &Dtool_PNMImage_operator_183__mul__;
        // tp_as_number->nb_inplace_subtract = __isub__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_inplace_subtract = &Dtool_PNMImage_operator_185__isub__;
        // tp_as_number->nb_inplace_multiply = __imul__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_inplace_multiply = &Dtool_PNMImage_operator_186__imul__;
        // tp_as_number->nb_add = __add__
        Dtool_PNMImage.As_PyTypeObject().tp_as_number->nb_add = &Dtool_PNMImage_operator_181__add__;
        if(PyType_Ready(&Dtool_PNMImage.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMImage)");
             printf(" Error In PyType_ReadyPNMImage");
             return;
        }
        Py_INCREF(&Dtool_PNMImage.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMImage.As_PyTypeObject().tp_dict,"PNMImage",&Dtool_PNMImage.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMImage,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMImage.As_PyTypeObject());
        PyModule_AddObject(module, "PNMImage",(PyObject *)&Dtool_PNMImage.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PNMPainter | PNMPainter
//********************************************************************
PyMethodDef Dtool_Methods_PNMPainter[]= {
  { "setPen",(PyCFunction ) &Dtool_PNMPainter_set_pen_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_set_pen_190_comment},
  { "getPen",(PyCFunction ) &Dtool_PNMPainter_get_pen_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_get_pen_191_comment},
  { "setFill",(PyCFunction ) &Dtool_PNMPainter_set_fill_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_set_fill_192_comment},
  { "getFill",(PyCFunction ) &Dtool_PNMPainter_get_fill_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_get_fill_193_comment},
  { "drawPoint",(PyCFunction ) &Dtool_PNMPainter_draw_point_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_draw_point_194_comment},
  { "drawLine",(PyCFunction ) &Dtool_PNMPainter_draw_line_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_draw_line_195_comment},
  { "drawRectangle",(PyCFunction ) &Dtool_PNMPainter_draw_rectangle_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PNMPainter_draw_rectangle_196_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PNMPainter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PNMPainter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PNMPainter\n"
          "// Description : This class provides a number of convenient methods\n"
          "//               for painting drawings directly into a PNMImage.\n"
          "//\n"
          "//               It stores a pointer to the PNMImage you pass it, but\n"
          "//               it does not take ownership of the object; you are\n"
          "//               responsible for ensuring that the PNMImage does not\n"
          "//               destruct during the lifetime of the PNMPainter\n"
          "//               object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PNMPainter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PNMPainter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PNMPainter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PNMPainter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PNMPainter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PNMPainter)");
             printf(" Error In PyType_ReadyPNMPainter");
             return;
        }
        Py_INCREF(&Dtool_PNMPainter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PNMPainter.As_PyTypeObject().tp_dict,"PNMPainter",&Dtool_PNMPainter.As_PyObject());
        RegisterRuntimeClass(&Dtool_PNMPainter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PNMPainter.As_PyTypeObject());
        PyModule_AddObject(module, "PNMPainter",(PyObject *)&Dtool_PNMPainter.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PNMBrush
//********************************************************************
   Dtool_PyModuleClassInit_PNMBrush(module);
//********************************************************************
//*** Module Init Updcall ..pixel
//********************************************************************
   Dtool_PyModuleClassInit_pixel(module);
//********************************************************************
//*** Module Init Updcall ..PNMFileType
//********************************************************************
   Dtool_PyModuleClassInit_PNMFileType(module);
//********************************************************************
//*** Module Init Updcall ..PNMFileTypeRegistry
//********************************************************************
   Dtool_PyModuleClassInit_PNMFileTypeRegistry(module);
//********************************************************************
//*** Module Init Updcall ..PNMImageHeader
//********************************************************************
   Dtool_PyModuleClassInit_PNMImageHeader(module);
//********************************************************************
//*** Module Init Updcall ..PNMImage
//********************************************************************
   Dtool_PyModuleClassInit_PNMImage(module);
//********************************************************************
//*** Module Init Updcall ..PNMPainter
//********************************************************************
   Dtool_PyModuleClassInit_PNMPainter(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpnmimage_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212827,  /* file_identifier */
  "libpnmimage",  /* library_name */
  "5U4k",  /* library_hash_name */
  "panda",  /* module_name */
  "libpnmimage.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  546  /* next_index */
};

Configure(_in_configure_libpnmimage);
ConfigureFn(_in_configure_libpnmimage) {
  interrogate_request_module(&_in_module_def);
}

