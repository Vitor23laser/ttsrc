/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/nativenet -Ipanda/src/nativenet -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libnativenet_igate.cxx -od built_Rocket/pandac/input/libnativenet.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/nativenet -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/openssl/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libnativenet buffered_datagramconnection.h buffered_datagramreader.h buffered_datagramwriter.h config_nativenet.h membuffer.h ringbuffer.h socket_address.h socket_base.h socket_fdset.h socket_ip.h socket_portable.h socket_selector.h socket_tcp.h socket_tcp_listen.h socket_tcp_ssl.h socket_udp.h socket_udp_incoming.h socket_udp_outgoing.h time_accumulator.h time_base.h time_clock.h time_general.h time_out.h time_span.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libnativenet
#include "py_panda.h"  

#include "buffered_datagramconnection.h"
#include "buffered_datagramreader.h"
#include "buffered_datagramwriter.h"
#include "config_nativenet.h"
#include "datagram.h"
#include "membuffer.h"
#include "numeric_types.h"
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include "pandabase.h"
#include "pvector.h"
#include "ringbuffer.h"
#include "socket_address.h"
#include "socket_base.h"
#include "socket_fdset.h"
#include "socket_ip.h"
#include "socket_portable.h"
#include "socket_selector.h"
#include "socket_tcp.h"
#include "socket_tcp_listen.h"
#include "socket_tcp_ssl.h"
#include "socket_udp.h"
#include "socket_udp_incoming.h"
#include "socket_udp_outgoing.h"
#include "time_accumulator.h"
#include "time_base.h"
#include "time_clock.h"
#include "time_general.h"
#include "time_out.h"
#include "time_span.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. Socket_Address
//********************************************************************
typedef  Socket_Address  Socket_Address_localtype;
Define_Module_Class(panda,Socket_Address,Socket_Address_localtype,SocketAddress);
//********************************************************************
//*** prototypes for .. Socket_IP
//********************************************************************
typedef  Socket_IP  Socket_IP_localtype;
Define_Module_Class(panda,Socket_IP,Socket_IP_localtype,SocketIP);
//********************************************************************
//*** prototypes for .. Socket_TCP
//********************************************************************
typedef  Socket_TCP  Socket_TCP_localtype;
Define_Module_Class(panda,Socket_TCP,Socket_TCP_localtype,SocketTCP);
//********************************************************************
//*** prototypes for .. Socket_TCP_Listen
//********************************************************************
typedef  Socket_TCP_Listen  Socket_TCP_Listen_localtype;
Define_Module_Class(panda,Socket_TCP_Listen,Socket_TCP_Listen_localtype,SocketTCPListen);
//********************************************************************
//*** prototypes for .. Socket_UDP_Incoming
//********************************************************************
typedef  Socket_UDP_Incoming  Socket_UDP_Incoming_localtype;
Define_Module_Class(panda,Socket_UDP_Incoming,Socket_UDP_Incoming_localtype,SocketUDPIncoming);
//********************************************************************
//*** prototypes for .. Socket_UDP_Outgoing
//********************************************************************
typedef  Socket_UDP_Outgoing  Socket_UDP_Outgoing_localtype;
Define_Module_Class(panda,Socket_UDP_Outgoing,Socket_UDP_Outgoing_localtype,SocketUDPOutgoing);
//********************************************************************
//*** prototypes for .. Socket_fdset
//********************************************************************
typedef  Socket_fdset  Socket_fdset_localtype;
Define_Module_Class(panda,Socket_fdset,Socket_fdset_localtype,SocketFdset);
//********************************************************************
//*** prototypes for .. Buffered_DatagramConnection
//********************************************************************
typedef  Buffered_DatagramConnection  Buffered_DatagramConnection_localtype;
Define_Module_Class(panda,Buffered_DatagramConnection,Buffered_DatagramConnection_localtype,BufferedDatagramConnection);
//********************************************************************
//*** prototypes for .. Socket_UDP
//********************************************************************
typedef  Socket_UDP  Socket_UDP_localtype;
Define_Module_Class(panda,Socket_UDP,Socket_UDP_localtype,SocketUDP);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. Socket_Address 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::set_any_IP(int port)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_set_any_IP_4(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_Address::set_any_IP(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAnyIP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAnyIP", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_any_IP((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketAddress.setAnyIP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnyIP(non-const SocketAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_set_any_IP_4_comment =
    "C++ Interface:\n"
    "setAnyIP(non-const SocketAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : set_any_IP\n"
    "// Description   : Set to any address and a specified port\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_set_any_IP_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::set_port(int port)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_set_port_5(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_Address::set_port(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPort", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_port((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketAddress.setPort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPort(non-const SocketAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_set_port_5_comment =
    "C++ Interface:\n"
    "setPort(non-const SocketAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : set_port\n"
    "// Description   : Set to a specified port\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_set_port_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::set_broadcast(int port)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_set_broadcast_6(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_Address::set_broadcast(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBroadcast", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBroadcast", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_broadcast((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketAddress.setBroadcast() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBroadcast(non-const SocketAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_set_broadcast_6_comment =
    "C++ Interface:\n"
    "setBroadcast(non-const SocketAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : set_broadcast\n"
    "// Description   : Set to the broadcast address and a specified port\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_set_broadcast_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::set_host(basic_string< char > const &hostname)
 * inline bool Socket_Address::set_host(basic_string< char > const &hostname, int port)
 * inline bool Socket_Address::set_host(unsigned int ip4adr, int port)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_set_host_7(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_Address::set_host(basic_string< char > const &hostname)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"hostname", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setHost", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setHost", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->set_host(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketAddress.setHost() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool Socket_Address::set_host(basic_string< char > const &hostname, int port)
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"hostname", (char *)"port", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setHost", key_word_list, &param1_str, &param1_len, &param2))
            {
                bool return_value = (local_this)->set_host(basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool Socket_Address::set_host(unsigned int ip4adr, int port)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"ip4adr", (char *)"port", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setHost", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    bool return_value = (local_this)->set_host(PyLong_AsUnsignedLong(param1_uint), (int)param2);
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setHost() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setHost(non-const SocketAddress this, string hostname)\n"
          "setHost(non-const SocketAddress this, string hostname, int port)\n"
          "setHost(non-const SocketAddress this, unsigned int ip4adr, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_set_host_7_comment =
    "C++ Interface:\n"
    "setHost(non-const SocketAddress this, string hostname)\n"
    "setHost(non-const SocketAddress this, string hostname, int port)\n"
    "setHost(non-const SocketAddress this, unsigned int ip4adr, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : set_host\n"
    "// Description   : this function will take a port and string-based tcp address and initialize\n"
    "//      the address with the information\n"
    "//\n"
    "// Return type  : bool (address is undefined after an error)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_Address::set_host\n"
    "// Description   :\n"
    "//////////////////////////////////////////////////////////////\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_Address::set_host\n"
    "// Description   :\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_set_host_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Socket_Address::clear(void)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_clear_8(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Socket_Address::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketAddress.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_clear_8_comment =
    "C++ Interface:\n"
    "clear(non-const SocketAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : clear\n"
    "// Description   : Set the internal values to a suitable known value\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_clear_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned short int Socket_Address::get_port(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_get_port_9(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned short int Socket_Address::get_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPort", key_word_list));
        else
            (PyArg_Parse(args, ":getPort"));
        if(!PyErr_Occurred())
        {
            unsigned short int return_value = ((const Socket_Address*)local_this)->get_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPort(const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_get_port_9_comment =
    "C++ Interface:\n"
    "getPort(const SocketAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : get_port\n"
    "// Description   : Get the port portion as an integer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_get_port_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Socket_Address::get_ip(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_get_ip_10(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Socket_Address::get_ip(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIp", key_word_list));
        else
            (PyArg_Parse(args, ":getIp"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Socket_Address*)local_this)->get_ip();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIp(const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_get_ip_10_comment =
    "C++ Interface:\n"
    "getIp(const SocketAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : get_ip\n"
    "// Description   : Return the ip address portion in dot notation string\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_get_ip_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Socket_Address::get_ip_port(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_get_ip_port_11(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Socket_Address::get_ip_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIpPort", key_word_list));
        else
            (PyArg_Parse(args, ":getIpPort"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Socket_Address*)local_this)->get_ip_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIpPort(const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_get_ip_port_11_comment =
    "C++ Interface:\n"
    "getIpPort(const SocketAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : get_ip_port\n"
    "// Description   : Return the ip address/port in dot notation string\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_get_ip_port_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned long int Socket_Address::GetIPAddressRaw(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_GetIPAddressRaw_12(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned long int Socket_Address::GetIPAddressRaw(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetIPAddressRaw", key_word_list));
        else
            (PyArg_Parse(args, ":GetIPAddressRaw"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = ((const Socket_Address*)local_this)->GetIPAddressRaw();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetIPAddressRaw(const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_GetIPAddressRaw_12_comment =
    "C++ Interface:\n"
    "GetIPAddressRaw(const SocketAddress this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_Address::GetIPAdddressRaw\n"
    "// Description   : Return a RAW sockaddr_in\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_GetIPAddressRaw_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::operator ==(Socket_Address const &in) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_operator_13(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Socket_Address::operator ==(Socket_Address const &in) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketAddress.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Socket_Address*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const SocketAddress this, const SocketAddress in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_operator_13_comment =
    "C++ Interface:\n"
    "eq(const SocketAddress this, const SocketAddress in)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_Address::operator==\n"
    "// Description   : Allow for normal == operation on a address item..\n"
    "//      Will simplify the use in sorted containers..\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_operator_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::operator <(Socket_Address const &in) const
 *******************************************************************/
static PyObject *Dtool_Socket_Address_operator_14(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Socket_Address::operator <(Socket_Address const &in) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketAddress.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Socket_Address*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const SocketAddress this, const SocketAddress in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_operator_14_comment =
    "C++ Interface:\n"
    "lessThan(const SocketAddress this, const SocketAddress in)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : <\n"
    "// Description   :\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_operator_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_Address::isMcastRange(void)
 *******************************************************************/
static PyObject *Dtool_Socket_Address_isMcastRange_15(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_Address * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_Address,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_Address::isMcastRange(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isMcastRange", key_word_list));
        else
            (PyArg_Parse(args, ":isMcastRange"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->isMcastRange();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketAddress.isMcastRange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isMcastRange(non-const SocketAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_Address_isMcastRange_15_comment =
    "C++ Interface:\n"
    "isMcastRange(non-const SocketAddress this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : isMcastRange\n"
    "// Description   : return true if the address is in the mcast range.\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_Address_isMcastRange_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
 * inline Socket_Address::Socket_Address(short int port)
 * inline Socket_Address::Socket_Address(short int port = (0))
 *******************************************************************/
int  Dtool_Init_Socket_Address(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Socket_Address::Socket_Address(short int port = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketAddress", key_word_list))
            {
                Socket_Address *return_value = new Socket_Address();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_Address,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"inaddr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SocketAddress", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SocketAddress", &param0));
                if(!PyErr_Occurred())
                {
                    Socket_Address *param0_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Socket_Address, 0, "SocketAddress.SocketAddress", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Socket_Address *return_value = new Socket_Address(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_Address,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline Socket_Address::Socket_Address(short int port)
                int param0;
                static char * key_word_list[] = {(char *)"port", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:SocketAddress", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:SocketAddress", &param0));
                if(!PyErr_Occurred())
                {
                    Socket_Address *return_value = new Socket_Address((short int)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_Address,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SocketAddress() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SocketAddress()\n"
          "SocketAddress(const SocketAddress inaddr)\n"
          "SocketAddress(int port)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_Address(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_Address)
    {
        printf("Socket_Address ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_Address * local_this = (Socket_Address *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_Address)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_Address(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_Address)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_IP 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Socket_IP::Close(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_Close_19(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Socket_IP::Close(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Close", key_word_list));
        else
            (PyArg_Parse(args, ":Close"));
        if(!PyErr_Occurred())
        {
            (local_this)->Close();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.Close() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Close(non-const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_Close_19_comment =
    "C++ Interface:\n"
    "Close(non-const SocketIP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::Close\n"
    "// Description   : closes a socket if it is open (allocated)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_Close_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int Socket_IP::GetLastError(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_GetLastError_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int Socket_IP::GetLastError(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":GetLastError", key_word_list))
        {
            int return_value = Socket_IP::GetLastError();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetLastError()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_GetLastError_20_comment =
    "C++ Interface:\n"
    "GetLastError()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::GetLastError\n"
    "// Description   : gets the last errcode from a socket operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_GetLastError_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_IP::SetNonBlocking(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_SetNonBlocking_21(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_IP::SetNonBlocking(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetNonBlocking", key_word_list));
        else
            (PyArg_Parse(args, ":SetNonBlocking"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->SetNonBlocking();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.SetNonBlocking() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetNonBlocking(non-const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_SetNonBlocking_21_comment =
    "C++ Interface:\n"
    "SetNonBlocking(non-const SocketIP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : SetNonBlocking\n"
    "// Description   : this function will throw a socket into non-blocking mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_SetNonBlocking_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_IP::SetBlocking(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_SetBlocking_22(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_IP::SetBlocking(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetBlocking", key_word_list));
        else
            (PyArg_Parse(args, ":SetBlocking"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->SetBlocking();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.SetBlocking() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetBlocking(non-const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_SetBlocking_22_comment =
    "C++ Interface:\n"
    "SetBlocking(non-const SocketIP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::SetBlocking\n"
    "// Description   : Set the socket to block on subsequent calls to\n"
    "//      socket functions that address this socket\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_SetBlocking_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_IP::SetReuseAddress(bool flag)
 * inline bool Socket_IP::SetReuseAddress(bool flag = (1))
 *******************************************************************/
static PyObject *Dtool_Socket_IP_SetReuseAddress_23(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_IP::SetReuseAddress(bool flag = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":SetReuseAddress", key_word_list));
            else
                (PyArg_Parse(args, ":SetReuseAddress"));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->SetReuseAddress();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketIP.SetReuseAddress() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_IP::SetReuseAddress(bool flag)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"flag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:SetReuseAddress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:SetReuseAddress", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->SetReuseAddress((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketIP.SetReuseAddress() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SetReuseAddress() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SetReuseAddress(non-const SocketIP this)\n"
          "SetReuseAddress(non-const SocketIP this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_SetReuseAddress_23_comment =
    "C++ Interface:\n"
    "SetReuseAddress(non-const SocketIP this)\n"
    "SetReuseAddress(non-const SocketIP this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name :  SetReuseAddress\n"
    "// Description     :  Informs a socket to reuse IP address as needed\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_SetReuseAddress_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_IP::Active(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_Active_24(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_IP::Active(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Active", key_word_list));
        else
            (PyArg_Parse(args, ":Active"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->Active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.Active() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Active(non-const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_Active_24_comment =
    "C++ Interface:\n"
    "Active(non-const SocketIP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::Active\n"
    "// Description   : Ask if the socket is open (allocated)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_Active_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_IP::SetRecvBufferSize(int size)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_SetRecvBufferSize_25(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_IP::SetRecvBufferSize(int size)
        int param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetRecvBufferSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:SetRecvBufferSize", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->SetRecvBufferSize((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.SetRecvBufferSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetRecvBufferSize(non-const SocketIP this, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_SetRecvBufferSize_25_comment =
    "C++ Interface:\n"
    "SetRecvBufferSize(non-const SocketIP this, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::SetRecvBufferSize\n"
    "// Description   : Ok it sets the recv buffer size for both tcp and UDP\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_SetRecvBufferSize_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Socket_IP::SetSocket(int ins)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_SetSocket_26(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Socket_IP::SetSocket(int ins)
        int param1;
        static char * key_word_list[] = {(char *)"ins", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetSocket", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:SetSocket", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetSocket((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketIP.SetSocket() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetSocket(non-const SocketIP this, int ins)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_SetSocket_26_comment =
    "C++ Interface:\n"
    "SetSocket(non-const SocketIP this, int ins)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::SetSocket\n"
    "// Description   : Assigns an existing socket to this class\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_SetSocket_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_IP::GetSocket(void)
 * inline int Socket_IP::GetSocket(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_IP_GetSocket_27(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline int Socket_IP::GetSocket(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetSocket", key_word_list));
        else
            (PyArg_Parse(args, ":GetSocket"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->GetSocket();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 inline int Socket_IP::GetSocket(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetSocket", key_word_list));
        else
            (PyArg_Parse(args, ":GetSocket"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Socket_IP*)local_this)->GetSocket();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetSocket(non-const SocketIP this)\n"
          "GetSocket(const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_GetSocket_27_comment =
    "C++ Interface:\n"
    "GetSocket(non-const SocketIP this)\n"
    "GetSocket(const SocketIP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::GetSocket\n"
    "// Description   : Gets the base socket type\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::GetSocket\n"
    "// Description   : Get The RAW file id of the socket\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_GetSocket_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_Address Socket_IP::GetPeerName(void) const
 *******************************************************************/
static PyObject *Dtool_Socket_IP_GetPeerName_28(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_IP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_IP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Socket_Address Socket_IP::GetPeerName(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetPeerName", key_word_list));
        else
            (PyArg_Parse(args, ":GetPeerName"));
        if(!PyErr_Occurred())
        {
            Socket_Address result = ((const Socket_IP*)local_this)->GetPeerName();
            Socket_Address *return_value = new Socket_Address(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Socket_Address,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetPeerName(const SocketIP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_GetPeerName_28_comment =
    "C++ Interface:\n"
    "GetPeerName(const SocketIP this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_IP::GetPeerName\n"
    "// Description   : Wrapper on berkly getpeername...\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_IP_GetPeerName_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int Socket_IP::InitNetworkDriver(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_InitNetworkDriver_29(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int Socket_IP::InitNetworkDriver(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":InitNetworkDriver", key_word_list))
        {
            int return_value = Socket_IP::InitNetworkDriver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitNetworkDriver()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_InitNetworkDriver_29_comment =
    "C++ Interface:\n"
    "InitNetworkDriver()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_IP_InitNetworkDriver_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_IP::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_IP_get_class_type_30(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_IP::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_IP::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_IP_get_class_type_30_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_IP_get_class_type_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_IP::Socket_IP(void)
 * inline Socket_IP::Socket_IP(int in)
 *******************************************************************/
int  Dtool_Init_Socket_IP(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Socket_IP::Socket_IP(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketIP", key_word_list))
            {
                Socket_IP *return_value = new Socket_IP();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_IP,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline Socket_IP::Socket_IP(int in)
            int param0;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:SocketIP", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:SocketIP", &param0));
            if(!PyErr_Occurred())
            {
                Socket_IP *return_value = new Socket_IP((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_IP,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SocketIP() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SocketIP()\n"
          "SocketIP(int in)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_IP(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_IP)
    {
        printf("Socket_IP ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_IP * local_this = (Socket_IP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_IP)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_IP(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_IP)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_IP*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_TCP 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int Socket_TCP::SetNoDelay(bool flag)
 * inline int Socket_TCP::SetNoDelay(bool flag = (1))
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_SetNoDelay_33(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_TCP::SetNoDelay(bool flag = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":SetNoDelay", key_word_list));
            else
                (PyArg_Parse(args, ":SetNoDelay"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->SetNoDelay();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.SetNoDelay() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_TCP::SetNoDelay(bool flag)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"flag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:SetNoDelay", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:SetNoDelay", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->SetNoDelay((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.SetNoDelay() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SetNoDelay() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SetNoDelay(non-const SocketTCP this)\n"
          "SetNoDelay(non-const SocketTCP this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_SetNoDelay_33_comment =
    "C++ Interface:\n"
    "SetNoDelay(non-const SocketTCP this)\n"
    "SetNoDelay(non-const SocketTCP this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : SetNoDelay\n"
    "// Description   : Disable Nagle algorithm. Don't delay send to coalesce packets\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_SetNoDelay_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_TCP::SetLinger(int interval_seconds)
 * inline int Socket_TCP::SetLinger(int interval_seconds = (0))
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_SetLinger_34(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_TCP::SetLinger(int interval_seconds = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":SetLinger", key_word_list));
            else
                (PyArg_Parse(args, ":SetLinger"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->SetLinger();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.SetLinger() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_TCP::SetLinger(int interval_seconds)
            int param1;
            static char * key_word_list[] = {(char *)"interval_seconds", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetLinger", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:SetLinger", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->SetLinger((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.SetLinger() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SetLinger() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SetLinger(non-const SocketTCP this)\n"
          "SetLinger(non-const SocketTCP this, int interval_seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_SetLinger_34_comment =
    "C++ Interface:\n"
    "SetLinger(non-const SocketTCP this)\n"
    "SetLinger(non-const SocketTCP this, int interval_seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : SetLinger\n"
    "// Description   : will control the behavior of SO_LINGER for a TCP socket\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_SetLinger_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_TCP::DontLinger(void)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_DontLinger_35(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_TCP::DontLinger(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":DontLinger", key_word_list));
        else
            (PyArg_Parse(args, ":DontLinger"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->DontLinger();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.DontLinger() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DontLinger(non-const SocketTCP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_DontLinger_35_comment =
    "C++ Interface:\n"
    "DontLinger(non-const SocketTCP this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_TCP::DontLinger\n"
    "// Description   : Turn off the linger flag. The socket will quickly release\n"
    "//        buffered items and free up OS resources. You may lose\n"
    "//        a stream if you use this flag and do not negotiate the close\n"
    "//        at the application layer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_DontLinger_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_TCP::SetSendBufferSize(int insize)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_SetSendBufferSize_36(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_TCP::SetSendBufferSize(int insize)
        int param1;
        static char * key_word_list[] = {(char *)"insize", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetSendBufferSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:SetSendBufferSize", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->SetSendBufferSize((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.SetSendBufferSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetSendBufferSize(non-const SocketTCP this, int insize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_SetSendBufferSize_36_comment =
    "C++ Interface:\n"
    "SetSendBufferSize(non-const SocketTCP this, int insize)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : SetSendBufferSize\n"
    "// Description   : Just like it sounds. Sets a buffered socket recv buffer size.\n"
    "//      This function does not refuse ranges outside hard-coded OS\n"
    "//      limits\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_SetSendBufferSize_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_ActiveOpen_37(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"theaddress", (char *)"setdelay", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:ActiveOpen", key_word_list, &param1, &param2))
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketTCP.ActiveOpen", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->ActiveOpen(*param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.ActiveOpen() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ActiveOpen(non-const SocketTCP this, const SocketAddress theaddress, bool setdelay)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_ActiveOpen_37_comment =
    "C++ Interface:\n"
    "ActiveOpen(non-const SocketTCP this, const SocketAddress theaddress, bool setdelay)\n"
    "\n"
    "//inline bool ActiveOpen(const Socket_Address & theaddress);\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : ActiveOpen\n"
    "// Description   : This function will try and set the socket up for active open to a specified\n"
    "//       address and port provided by the input parameter\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_ActiveOpen_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_ActiveOpenNonBlocking_38(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"theaddress", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ActiveOpenNonBlocking", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:ActiveOpenNonBlocking", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketTCP.ActiveOpenNonBlocking", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->ActiveOpenNonBlocking(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCP.ActiveOpenNonBlocking() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ActiveOpenNonBlocking(non-const SocketTCP this, const SocketAddress theaddress)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_ActiveOpenNonBlocking_38_comment =
    "C++ Interface:\n"
    "ActiveOpenNonBlocking(non-const SocketTCP this, const SocketAddress theaddress)\n"
    "\n"
    "//inline bool ActiveOpen(const Socket_Address & theaddress);\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : ActiveOpenNonBlocking\n"
    "// Description   : This function will try and set the socket up for active open to a specified\n"
    "//       address and port provided by the input parameter (non-blocking version)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_ActiveOpenNonBlocking_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_ErrorIs_WouldBlocking_39(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
        int param1;
        static char * key_word_list[] = {(char *)"err", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:ErrorIsWouldBlocking", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:ErrorIsWouldBlocking", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->ErrorIs_WouldBlocking((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.ErrorIsWouldBlocking() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ErrorIsWouldBlocking(non-const SocketTCP this, int err)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_ErrorIs_WouldBlocking_39_comment =
    "C++ Interface:\n"
    "ErrorIsWouldBlocking(non-const SocketTCP this, int err)\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_TCP_ErrorIs_WouldBlocking_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP::ShutdownSend(void)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_ShutdownSend_40(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_TCP::ShutdownSend(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ShutdownSend", key_word_list));
        else
            (PyArg_Parse(args, ":ShutdownSend"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->ShutdownSend();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.ShutdownSend() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ShutdownSend(non-const SocketTCP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_ShutdownSend_40_comment =
    "C++ Interface:\n"
    "ShutdownSend(non-const SocketTCP this)\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_TCP_ShutdownSend_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_TCP::SendData(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_SendData_41(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Socket_TCP::SendData(basic_string< char > const &str)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"str", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SendData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:SendData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->SendData(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.SendData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendData(non-const SocketTCP this, string str)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_SendData_41_comment =
    "C++ Interface:\n"
    "SendData(non-const SocketTCP this, string str)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_TCP::SendData\n"
    "// Description   : Ok Lets Send the Data\n"
    "//\n"
    "// Return type  : int\n"
    "//      - if error\n"
    "//      0 if socket closed for write or lengh is 0\n"
    "//      + bytes writen ( May be smaller than requested)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_SendData_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Socket_TCP::RecvData(int max_len)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_RecvData_42(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Socket_TCP::RecvData(int max_len)
        int param1;
        static char * key_word_list[] = {(char *)"max_len", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:RecvData", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:RecvData", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->RecvData((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketTCP.RecvData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RecvData(non-const SocketTCP this, int max_len)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_RecvData_42_comment =
    "C++ Interface:\n"
    "RecvData(non-const SocketTCP this, int max_len)\n"
    "\n"
    "//    inline int RecvData( std::string &str, int max_len);\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_TCP::RecvData\n"
    "// Description   : Read the data from the connection\n"
    "//\n"
    "// Return type  : int\n"
    "//      - if error\n"
    "//      0 if socket closed for read or length is 0\n"
    "//      + bytes read ( May be smaller than requested)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_TCP::RecvData\n"
    "// Description   : Read the data from the connection\n"
    "//\n"
    "// Return type  : int\n"
    "//      - if error\n"
    "//      0 if socket closed for read or length is 0\n"
    "//      + bytes read ( May be smaller than requested)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_RecvData_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_TCP::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_get_class_type_43(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_TCP::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_TCP::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_get_class_type_43_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_TCP_get_class_type_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_TCP::Socket_TCP(void)
 * inline Socket_TCP::Socket_TCP(int )
 *******************************************************************/
int  Dtool_Init_Socket_TCP(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Socket_TCP::Socket_TCP(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketTCP", key_word_list))
            {
                Socket_TCP *return_value = new Socket_TCP();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_TCP,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline Socket_TCP::Socket_TCP(int )
            int param0;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:SocketTCP", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:SocketTCP", &param0));
            if(!PyErr_Occurred())
            {
                Socket_TCP *return_value = new Socket_TCP((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_TCP,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SocketTCP() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SocketTCP()\n"
          "SocketTCP(int)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_TCP(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_TCP)
    {
        printf("Socket_TCP ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_TCP * local_this = (Socket_TCP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_TCP)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_TCP(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_TCP)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Socket_TCP*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_TCP*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_TCP_Listen 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &Inaddess, int backlog_size)
 * inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &Inaddess, int backlog_size = (1024))
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_Listen_OpenForListen_47(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP_Listen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP_Listen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &Inaddess, int backlog_size = (1024))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"Inaddess", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OpenForListen", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:OpenForListen", &param1));
                if(!PyErr_Occurred())
                {
                    Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketTCPListen.OpenForListen", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->OpenForListen(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SocketTCPListen.OpenForListen() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &Inaddess, int backlog_size)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"Inaddess", (char *)"backlog_size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:OpenForListen", key_word_list, &param1, &param2))
                {
                    Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketTCPListen.OpenForListen", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->OpenForListen(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SocketTCPListen.OpenForListen() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OpenForListen() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OpenForListen(non-const SocketTCPListen this, const SocketAddress Inaddess)\n"
          "OpenForListen(non-const SocketTCPListen this, const SocketAddress Inaddess, int backlog_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_Listen_OpenForListen_47_comment =
    "C++ Interface:\n"
    "OpenForListen(non-const SocketTCPListen this, const SocketAddress Inaddess)\n"
    "OpenForListen(non-const SocketTCPListen this, const SocketAddress Inaddess, int backlog_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : OpenForListen\n"
    "// Description   : This function will initialize a listening Socket\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_Listen_OpenForListen_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_Listen_GetIncomingConnection_48(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_TCP_Listen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_TCP_Listen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"newsession", (char *)"address", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:GetIncomingConnection", key_word_list, &param1, &param2))
            {
                Socket_TCP *param1_this = (Socket_TCP *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_TCP, 1, "SocketTCPListen.GetIncomingConnection", 0, coerced_ptr, report_errors);
Socket_Address *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Socket_Address, 2, "SocketTCPListen.GetIncomingConnection", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->GetIncomingConnection(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketTCPListen.GetIncomingConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetIncomingConnection(non-const SocketTCPListen this, non-const SocketTCP newsession, non-const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_Listen_GetIncomingConnection_48_comment =
    "C++ Interface:\n"
    "GetIncomingConnection(non-const SocketTCPListen this, non-const SocketTCP newsession, non-const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : GetIncomingConnection\n"
    "// Description   : This function is used to accept new connections\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_TCP_Listen_GetIncomingConnection_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_TCP_Listen::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_TCP_Listen_get_class_type_49(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_TCP_Listen::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_TCP_Listen::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_TCP_Listen_get_class_type_49_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_TCP_Listen_get_class_type_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Socket_TCP_Listen::Socket_TCP_Listen(void)
 *******************************************************************/
int  Dtool_Init_Socket_TCP_Listen(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Socket_TCP_Listen::Socket_TCP_Listen(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketTCPListen", key_word_list))
        {
            Socket_TCP_Listen *return_value = new Socket_TCP_Listen();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_TCP_Listen,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SocketTCPListen()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_TCP_Listen(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_TCP_Listen)
    {
        printf("Socket_TCP_Listen ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_TCP_Listen * local_this = (Socket_TCP_Listen *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_TCP_Listen)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_TCP_Listen(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_TCP_Listen)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Socket_TCP_Listen*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_TCP_Listen*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_UDP_Incoming 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInput_52(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Incoming * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Incoming,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"address", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:OpenForInput", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:OpenForInput", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketUDPIncoming.OpenForInput", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->OpenForInput(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDPIncoming.OpenForInput() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OpenForInput(non-const SocketUDPIncoming this, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_OpenForInput_52_comment =
    "C++ Interface:\n"
    "OpenForInput(non-const SocketUDPIncoming this, const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Incoming::OpenForInput\n"
    "// Description     : Starts a UDP socket listening on a port\n"
    "//\n"
    "// Return type  : bool\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_OpenForInput_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInputMCast_53(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Incoming * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Incoming,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"address", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:OpenForInputMCast", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:OpenForInputMCast", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketUDPIncoming.OpenForInputMCast", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->OpenForInputMCast(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDPIncoming.OpenForInputMCast() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OpenForInputMCast(non-const SocketUDPIncoming this, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_OpenForInputMCast_53_comment =
    "C++ Interface:\n"
    "OpenForInputMCast(non-const SocketUDPIncoming this, const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Incoming::OpenForInput\n"
    "// Description     : Starts a UDP socket listening on a port\n"
    "//\n"
    "// Return type  : bool\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_OpenForInputMCast_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_SendTo_55(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Incoming * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Incoming,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
            char *param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"data", (char *)"len", (char *)"address", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "siO:SendTo", key_word_list, &param1, &param2, &param3))
            {
                Socket_Address *param3_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Socket_Address, 3, "SocketUDPIncoming.SendTo", 1, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    bool return_value = (local_this)->SendTo((char const *)param1, (int)param2, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDPIncoming.SendTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendTo(non-const SocketUDPIncoming this, string data, int len, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_SendTo_55_comment =
    "C++ Interface:\n"
    "SendTo(non-const SocketUDPIncoming this, string data, int len, const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : SocketUDP_Outgoing::SendTo\n"
    "// Description     : Send data to specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : char * data\n"
    "// Argument         : int len\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_SendTo_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Incoming::InitNoAddress(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_InitNoAddress_56(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Incoming * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Incoming,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP_Incoming::InitNoAddress(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":InitNoAddress", key_word_list));
        else
            (PyArg_Parse(args, ":InitNoAddress"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->InitNoAddress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDPIncoming.InitNoAddress() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitNoAddress(non-const SocketUDPIncoming this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_InitNoAddress_56_comment =
    "C++ Interface:\n"
    "InitNoAddress(non-const SocketUDPIncoming this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Incoming::InitNoAddress\n"
    "// Description     : Set this socket to work with out a bound external address..\n"
    "// Return type  : inline bool\n"
    "// Argument         : void\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_InitNoAddress_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Incoming::SetToBroadCast(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_SetToBroadCast_57(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Incoming * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Incoming,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP_Incoming::SetToBroadCast(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetToBroadCast", key_word_list));
        else
            (PyArg_Parse(args, ":SetToBroadCast"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->SetToBroadCast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDPIncoming.SetToBroadCast() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetToBroadCast(non-const SocketUDPIncoming this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_SetToBroadCast_57_comment =
    "C++ Interface:\n"
    "SetToBroadCast(non-const SocketUDPIncoming this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Incoming::tToBroadCast\n"
    "// Description     : Flips the OS bits that allow for brodcast\n"
    "//      packets to com in on this port\n"
    "//\n"
    "// Return type  : bool\n"
    "// Argument         : void\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_SetToBroadCast_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_UDP_Incoming::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Incoming_get_class_type_58(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_UDP_Incoming::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_UDP_Incoming::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Incoming_get_class_type_58_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_UDP_Incoming_get_class_type_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
 *******************************************************************/
int  Dtool_Init_Socket_UDP_Incoming(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketUDPIncoming", key_word_list))
        {
            Socket_UDP_Incoming *return_value = new Socket_UDP_Incoming();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_UDP_Incoming,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SocketUDPIncoming()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_UDP_Incoming(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_UDP_Incoming)
    {
        printf("Socket_UDP_Incoming ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_UDP_Incoming * local_this = (Socket_UDP_Incoming *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_UDP_Incoming)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_UDP_Incoming(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_UDP_Incoming)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Socket_UDP_Incoming*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_UDP_Incoming*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_UDP_Outgoing 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_InitToAddress_62(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Outgoing * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Outgoing,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"address", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:InitToAddress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:InitToAddress", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketUDPOutgoing.InitToAddress", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->InitToAddress(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDPOutgoing.InitToAddress() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitToAddress(non-const SocketUDPOutgoing this, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_InitToAddress_62_comment =
    "C++ Interface:\n"
    "InitToAddress(non-const SocketUDPOutgoing this, const SocketAddress address)\n"
    "\n"
    "// use this interface for a tagreted UDP connection\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::InitToAddress\n"
    "// Description     : Connects the Socket to a Specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_InitToAddress_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Outgoing::Send(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_Send_63(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Outgoing * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Outgoing,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP_Outgoing::Send(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Send", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:Send", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->Send(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDPOutgoing.Send() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Send(non-const SocketUDPOutgoing this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_Send_63_comment =
    "C++ Interface:\n"
    "Send(non-const SocketUDPOutgoing this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::Send\n"
    "// Description     : Send data to connected address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : char * data\n"
    "// Argument         : int len\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::Send\n"
    "// Description     : Send data to connected address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : const string &data\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_Send_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Outgoing::InitNoAddress(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_InitNoAddress_64(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Outgoing * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Outgoing,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP_Outgoing::InitNoAddress(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":InitNoAddress", key_word_list));
        else
            (PyArg_Parse(args, ":InitNoAddress"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->InitNoAddress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDPOutgoing.InitNoAddress() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitNoAddress(non-const SocketUDPOutgoing this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_InitNoAddress_64_comment =
    "C++ Interface:\n"
    "InitNoAddress(non-const SocketUDPOutgoing this)\n"
    "\n"
    "// use this interface for a none tagreted UDP connection\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::InitNoAddress\n"
    "// Description     : This will set a udp up for targeted sends..\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : void\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_InitNoAddress_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Outgoing::SendTo(basic_string< char > const &data, Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_SendTo_65(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Outgoing * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Outgoing,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP_Outgoing::SendTo(basic_string< char > const &data, Socket_Address const &address)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"data", (char *)"address", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:SendTo", key_word_list, &param1_str, &param1_len, &param2))
            {
                Socket_Address *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Socket_Address, 2, "SocketUDPOutgoing.SendTo", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->SendTo(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDPOutgoing.SendTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendTo(non-const SocketUDPOutgoing this, string data, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_SendTo_65_comment =
    "C++ Interface:\n"
    "SendTo(non-const SocketUDPOutgoing this, string data, const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::SendTo\n"
    "// Description     : Send data to specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : char * data\n"
    "// Argument         : int len\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing::SendTo\n"
    "// Description     : Send data to specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : const string &data\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_SendTo_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_SetToBroadCast_66(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP_Outgoing * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP_Outgoing,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetToBroadCast", key_word_list));
        else
            (PyArg_Parse(args, ":SetToBroadCast"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->SetToBroadCast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDPOutgoing.SetToBroadCast() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetToBroadCast(non-const SocketUDPOutgoing this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_SetToBroadCast_66_comment =
    "C++ Interface:\n"
    "SetToBroadCast(non-const SocketUDPOutgoing this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP_Outgoing:SetToBroadCast\n"
    "// Description     : Ask the OS to let us receive BROADCASt packets on  this port..\n"
    "// Return type  : bool\n"
    "// Argument         : void\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_SetToBroadCast_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Outgoing_get_class_type_67(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_UDP_Outgoing::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Outgoing_get_class_type_67_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_UDP_Outgoing_get_class_type_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
 *******************************************************************/
int  Dtool_Init_Socket_UDP_Outgoing(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketUDPOutgoing", key_word_list))
        {
            Socket_UDP_Outgoing *return_value = new Socket_UDP_Outgoing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_UDP_Outgoing,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SocketUDPOutgoing()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_UDP_Outgoing(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_UDP_Outgoing)
    {
        printf("Socket_UDP_Outgoing ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_UDP_Outgoing * local_this = (Socket_UDP_Outgoing *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_UDP_Outgoing)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_UDP_Outgoing(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_UDP_Outgoing)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Socket_UDP_Outgoing*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_UDP_Outgoing*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_fdset 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Socket_fdset::setForSocket(Socket_IP const &incon)
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_setForSocket_71(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Socket_fdset::setForSocket(Socket_IP const &incon)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"incon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForSocket", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setForSocket", &param1));
            if(!PyErr_Occurred())
            {
                Socket_IP *param1_this = (Socket_IP *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_IP, 1, "SocketFdset.setForSocket", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->setForSocket(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.setForSocket() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForSocket(non-const SocketFdset this, const SocketIP incon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_setForSocket_71_comment =
    "C++ Interface:\n"
    "setForSocket(non-const SocketFdset this, const SocketIP incon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_fdset::setForSocket\n"
    "// Description   :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_setForSocket_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_IsSetFor_72(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"incon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:IsSetFor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:IsSetFor", &param1));
            if(!PyErr_Occurred())
            {
                Socket_IP *param1_this = (Socket_IP *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_IP, 1, "SocketFdset.IsSetFor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const Socket_fdset*)local_this)->IsSetFor(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "IsSetFor(const SocketFdset this, const SocketIP incon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_IsSetFor_72_comment =
    "C++ Interface:\n"
    "IsSetFor(const SocketFdset this, const SocketIP incon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_fdset::IsSetFor\n"
    "// Description   : check to see if a socket object has been marked for reading\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_IsSetFor_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [inline int Socket_fdset::WaitForRead(bool zeroFds, Time_Span const &timeout)]
 * inline int Socket_fdset::WaitForRead(bool zeroFds, unsigned int sleep_time)
 * inline int Socket_fdset::WaitForRead(bool zeroFds, unsigned int sleep_time = (2147483647))
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_WaitForRead_73(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForRead(bool zeroFds, unsigned int sleep_time = (2147483647))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"zeroFds", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:WaitForRead", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:WaitForRead", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->WaitForRead((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForRead() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForRead(bool zeroFds, unsigned int sleep_time)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"zeroFds", (char *)"sleep_time", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:WaitForRead", key_word_list, &param1, &param2))
            {
                 PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param2_uint == NULL)))
                {
                    int return_value = (local_this)->WaitForRead((PyObject_IsTrue(param1)!=0), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForRead() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "WaitForRead() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "WaitForRead(non-const SocketFdset this, bool zeroFds)\n"
          "WaitForRead(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_WaitForRead_73_comment =
    "C++ Interface:\n"
    "WaitForRead(non-const SocketFdset this, bool zeroFds)\n"
    "WaitForRead(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : WaitForRead\n"
    "// Description   :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name :  Socket_fdset::WaitForRead\n"
    "// Description   :\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_WaitForRead_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_fdset::WaitForWrite(bool zeroFds, unsigned int sleep_time)
 * inline int Socket_fdset::WaitForWrite(bool zeroFds, unsigned int sleep_time = (2147483647))
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_WaitForWrite_74(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForWrite(bool zeroFds, unsigned int sleep_time = (2147483647))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"zeroFds", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:WaitForWrite", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:WaitForWrite", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->WaitForWrite((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForWrite() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForWrite(bool zeroFds, unsigned int sleep_time)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"zeroFds", (char *)"sleep_time", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:WaitForWrite", key_word_list, &param1, &param2))
            {
                 PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param2_uint == NULL)))
                {
                    int return_value = (local_this)->WaitForWrite((PyObject_IsTrue(param1)!=0), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForWrite() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "WaitForWrite() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "WaitForWrite(non-const SocketFdset this, bool zeroFds)\n"
          "WaitForWrite(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_WaitForWrite_74_comment =
    "C++ Interface:\n"
    "WaitForWrite(non-const SocketFdset this, bool zeroFds)\n"
    "WaitForWrite(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
    "\n"
    "////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_fdset::WaitForWrite\n"
    "// Description   : This is the function that will wait till\n"
    "//      one of the sockets is ready for writing\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_WaitForWrite_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Socket_fdset::WaitForError(bool zeroFds, unsigned int sleep_time)
 * inline int Socket_fdset::WaitForError(bool zeroFds, unsigned int sleep_time = (2147483647))
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_WaitForError_75(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForError(bool zeroFds, unsigned int sleep_time = (2147483647))
            PyObject *param1;
            static char * key_word_list[] = {(char *)"zeroFds", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:WaitForError", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:WaitForError", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->WaitForError((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForError() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Socket_fdset::WaitForError(bool zeroFds, unsigned int sleep_time)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"zeroFds", (char *)"sleep_time", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:WaitForError", key_word_list, &param1, &param2))
            {
                 PyObject *param2_uint = PyNumber_Long(param2);
                if (!((param2_uint == NULL)))
                {
                    int return_value = (local_this)->WaitForError((PyObject_IsTrue(param1)!=0), PyLong_AsUnsignedLong(param2_uint));
                     Py_XDECREF(param2_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketFdset.WaitForError() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "WaitForError() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "WaitForError(non-const SocketFdset this, bool zeroFds)\n"
          "WaitForError(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_WaitForError_75_comment =
    "C++ Interface:\n"
    "WaitForError(non-const SocketFdset this, bool zeroFds)\n"
    "WaitForError(non-const SocketFdset this, bool zeroFds, unsigned int sleep_time)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_fdset::WaitForError\n"
    "// Description   : This is the function that will wait till\n"
    "//      one of the sockets is in error state\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_WaitForError_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Socket_fdset::clear(void)
 *******************************************************************/
static PyObject *Dtool_Socket_fdset_clear_76(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_fdset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_fdset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Socket_fdset::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketFdset.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const SocketFdset this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_fdset_clear_76_comment =
    "C++ Interface:\n"
    "clear(non-const SocketFdset this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name :  Socket_fdset::zeroOut\n"
    "// Description   :  Marks the content as empty\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_fdset_clear_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_fdset::Socket_fdset(void)
 *******************************************************************/
int  Dtool_Init_Socket_fdset(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Socket_fdset::Socket_fdset(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketFdset", key_word_list))
        {
            Socket_fdset *return_value = new Socket_fdset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_fdset,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SocketFdset()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_fdset(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_fdset)
    {
        printf("Socket_fdset ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_fdset * local_this = (Socket_fdset *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_fdset)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_fdset(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_fdset)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Buffered_DatagramConnection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_GetMessage_79(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"val", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:GetMessage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:GetMessage", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "BufferedDatagramConnection.GetMessage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->GetMessage(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BufferedDatagramConnection.GetMessage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetMessage(non-const BufferedDatagramConnection this, non-const Datagram val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_GetMessage_79_comment =
    "C++ Interface:\n"
    "GetMessage(non-const BufferedDatagramConnection this, non-const Datagram val)\n"
    "\n"
    "// do not use this .. this is a way for the the COnnecting UPcall to drop messages in queue first..\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name    : Buffered_DatagramConnection::GetMessage\n"
    "// Description      :  read a message\n"
    "//  \n"
    "//  false means something bad happened..\n"
    "//\n"
    "//\n"
    "// Return type      : inline bool \n"
    "// Argument         : Datagram &val\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_GetMessage_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Buffered_DatagramConnection::DoConnect(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_DoConnect_80(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Buffered_DatagramConnection::DoConnect(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":DoConnect", key_word_list));
        else
            (PyArg_Parse(args, ":DoConnect"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->DoConnect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.DoConnect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DoConnect(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_DoConnect_80_comment =
    "C++ Interface:\n"
    "DoConnect(non-const BufferedDatagramConnection this)\n"
    "\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_DoConnect_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Buffered_DatagramConnection::IsConnected(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_IsConnected_81(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Buffered_DatagramConnection::IsConnected(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":IsConnected", key_word_list));
        else
            (PyArg_Parse(args, ":IsConnected"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->IsConnected();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.IsConnected() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "IsConnected(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_IsConnected_81_comment =
    "C++ Interface:\n"
    "IsConnected(non-const BufferedDatagramConnection this)\n"
    "\n"
    "// all the real state magic is in here\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_IsConnected_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_SendMessage_83(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"msg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:SendMessage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:SendMessage", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "BufferedDatagramConnection.SendMessage", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->SendMessage(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BufferedDatagramConnection.SendMessage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendMessage(non-const BufferedDatagramConnection this, const Datagram msg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_SendMessage_83_comment =
    "C++ Interface:\n"
    "SendMessage(non-const BufferedDatagramConnection this, const Datagram msg)\n"
    "\n"
    "// the reason thsi all exists\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name    :  Buffered_DatagramConnection::SendMessage\n"
    "// Description      : send the message \n"
    "//  \n"
    "// Return type      : inline bool \n"
    "// Argument         : DataGram &msg\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_SendMessage_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Buffered_DatagramConnection::Flush(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_Flush_84(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Buffered_DatagramConnection::Flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Flush", key_word_list));
        else
            (PyArg_Parse(args, ":Flush"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->Flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.Flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Flush(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_Flush_84_comment =
    "C++ Interface:\n"
    "Flush(non-const BufferedDatagramConnection this)\n"
    "\n"
    "// the reason thsi all exists\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name    : Buffered_DatagramConnection::Flush\n"
    "// Description      : flush all wrightes\n"
    "//  \n"
    "// Return type      : bool \n"
    "// Argument         : void\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_Flush_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Buffered_DatagramConnection::Reset(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_Reset_85(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Buffered_DatagramConnection::Reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Reset", key_word_list));
        else
            (PyArg_Parse(args, ":Reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->Reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.Reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Reset(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_Reset_85_comment =
    "C++ Interface:\n"
    "Reset(non-const BufferedDatagramConnection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name    : Buffered_DatagramConnection::Reset\n"
    "// Description      : Reset \n"
    "//  \n"
    "// Return type      : void \n"
    "// Argument         : void\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_Reset_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(float MaxTime)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_86(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(float MaxTime)
        double param1;
        static char * key_word_list[] = {(char *)"MaxTime", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:WaitForNetworkReadEvent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:WaitForNetworkReadEvent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->WaitForNetworkReadEvent((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.WaitForNetworkReadEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "WaitForNetworkReadEvent(non-const BufferedDatagramConnection this, float MaxTime)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_86_comment =
    "C++ Interface:\n"
    "WaitForNetworkReadEvent(non-const BufferedDatagramConnection this, float MaxTime)\n"
    "\n"
    "//  int WaitFor_Read_Error(const Socket_fdset & fd, const Time_Span & timeout);\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int Buffered_DatagramConnection::AddressQueueSize(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_AddressQueueSize_87(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int Buffered_DatagramConnection::AddressQueueSize(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":AddressQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":AddressQueueSize"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->AddressQueueSize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.AddressQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AddressQueueSize(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_AddressQueueSize_87_comment =
    "C++ Interface:\n"
    "AddressQueueSize(non-const BufferedDatagramConnection this)\n"
    "\n"
    "// address queue stuff\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_AddressQueueSize_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_AddAddress_88(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"inadr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:AddAddress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:AddAddress", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "BufferedDatagramConnection.AddAddress", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->AddAddress(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BufferedDatagramConnection.AddAddress() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AddAddress(non-const BufferedDatagramConnection this, non-const SocketAddress inadr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_AddAddress_88_comment =
    "C++ Interface:\n"
    "AddAddress(non-const BufferedDatagramConnection this, non-const SocketAddress inadr)\n"
    "\n"
    "// address queue stuff\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name    : Buffered_DatagramConnection::Init\n"
    "// Description      :  must be called to set value to the server\n"
    "//  \n"
    "// Return type      : inline void \n"
    "// Argument         : Socket_Address &inadr\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_AddAddress_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Buffered_DatagramConnection::ClearAddresses(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_ClearAddresses_89(PyObject *self, PyObject *args,PyObject *kwds) {
    Buffered_DatagramConnection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Buffered_DatagramConnection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Buffered_DatagramConnection::ClearAddresses(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ClearAddresses", key_word_list));
        else
            (PyArg_Parse(args, ":ClearAddresses"));
        if(!PyErr_Occurred())
        {
            (local_this)->ClearAddresses();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BufferedDatagramConnection.ClearAddresses() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ClearAddresses(non-const BufferedDatagramConnection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_ClearAddresses_89_comment =
    "C++ Interface:\n"
    "ClearAddresses(non-const BufferedDatagramConnection this)\n"
    "\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_ClearAddresses_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Buffered_DatagramConnection::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Buffered_DatagramConnection_get_class_type_90(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Buffered_DatagramConnection::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Buffered_DatagramConnection::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Buffered_DatagramConnection_get_class_type_90_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Buffered_DatagramConnection_get_class_type_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
 *******************************************************************/
int  Dtool_Init_Buffered_DatagramConnection(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
        int param0;
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"rbufsize", (char *)"wbufsize", (char *)"write_flush_point", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:BufferedDatagramConnection", key_word_list, &param0, &param1, &param2))
        {
            Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection((int)param0, (int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Buffered_DatagramConnection,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "BufferedDatagramConnection(int rbufsize, int wbufsize, int write_flush_point)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Buffered_DatagramConnection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Buffered_DatagramConnection)
    {
        printf("Buffered_DatagramConnection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Buffered_DatagramConnection * local_this = (Buffered_DatagramConnection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Buffered_DatagramConnection)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *)( Socket_TCP *) local_this;
    if(requested_type == &Dtool_Socket_TCP)
        return ( Socket_TCP *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *)( Socket_TCP *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Buffered_DatagramConnection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Buffered_DatagramConnection)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Buffered_DatagramConnection*)other_this;
    }
    if(from_type == &Dtool_Socket_TCP)
    {
          Socket_TCP* other_this = (Socket_TCP*)from_this;
          return (Buffered_DatagramConnection*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Buffered_DatagramConnection*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Socket_UDP 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_InitToAddress_93(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"address", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:InitToAddress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:InitToAddress", &param1));
            if(!PyErr_Occurred())
            {
                Socket_Address *param1_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_Address, 1, "SocketUDP.InitToAddress", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->InitToAddress(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDP.InitToAddress() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitToAddress(non-const SocketUDP this, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_InitToAddress_93_comment =
    "C++ Interface:\n"
    "InitToAddress(non-const SocketUDP this, const SocketAddress address)\n"
    "\n"
    "// use this interface for a tagreted UDP connection\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::InitToAddress\n"
    "// Description     : Connects the Socket to a Specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_InitToAddress_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP::Send(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_Send_94(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP::Send(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Send", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:Send", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->Send(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDP.Send() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Send(non-const SocketUDP this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_Send_94_comment =
    "C++ Interface:\n"
    "Send(non-const SocketUDP this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::Send\n"
    "// Description     : Send data to connected address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : char * data\n"
    "// Argument         : int len\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::Send\n"
    "// Description     : Send data to connected address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : const string &data\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_Send_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP::InitNoAddress(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_InitNoAddress_95(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP::InitNoAddress(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":InitNoAddress", key_word_list));
        else
            (PyArg_Parse(args, ":InitNoAddress"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->InitNoAddress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDP.InitNoAddress() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InitNoAddress(non-const SocketUDP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_InitNoAddress_95_comment =
    "C++ Interface:\n"
    "InitNoAddress(non-const SocketUDP this)\n"
    "\n"
    "// use this interface for a none tagreted UDP connection\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::InitNoAddress\n"
    "// Description     : This will set a udp up for targeted sends..\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : void\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_InitNoAddress_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP::SendTo(basic_string< char > const &data, Socket_Address const &address)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_SendTo_96(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool Socket_UDP::SendTo(basic_string< char > const &data, Socket_Address const &address)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"data", (char *)"address", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:SendTo", key_word_list, &param1_str, &param1_len, &param2))
            {
                Socket_Address *param2_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Socket_Address, 2, "SocketUDP.SendTo", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->SendTo(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SocketUDP.SendTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendTo(non-const SocketUDP this, string data, const SocketAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_SendTo_96_comment =
    "C++ Interface:\n"
    "SendTo(non-const SocketUDP this, string data, const SocketAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::SendTo\n"
    "// Description     : Send data to specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : char * data\n"
    "// Argument         : int len\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP::SendTo\n"
    "// Description     : Send data to specified address\n"
    "//\n"
    "// Return type  : inline bool\n"
    "// Argument         : const string &data\n"
    "// Argument         : NetAddress & address\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_SendTo_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Socket_UDP::SetToBroadCast(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_SetToBroadCast_97(PyObject *self, PyObject *args,PyObject *kwds) {
    Socket_UDP * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Socket_UDP,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Socket_UDP::SetToBroadCast(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetToBroadCast", key_word_list));
        else
            (PyArg_Parse(args, ":SetToBroadCast"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->SetToBroadCast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SocketUDP.SetToBroadCast() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetToBroadCast(non-const SocketUDP this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_SetToBroadCast_97_comment =
    "C++ Interface:\n"
    "SetToBroadCast(non-const SocketUDP this)\n"
    "\n"
    "//////////////////////////////////////////////////////////////\n"
    "// Function name : Socket_UDP:SetToBroadCast\n"
    "// Description     : Ask the OS to let us receive BROADCASt packets on  this port..\n"
    "// Return type  : bool\n"
    "// Argument         : void\n"
    "//////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Socket_UDP_SetToBroadCast_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Socket_UDP::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Socket_UDP_get_class_type_98(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Socket_UDP::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Socket_UDP::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Socket_UDP_get_class_type_98_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Socket_UDP_get_class_type_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Socket_UDP::Socket_UDP(void)
 *******************************************************************/
int  Dtool_Init_Socket_UDP(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Socket_UDP::Socket_UDP(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SocketUDP", key_word_list))
        {
            Socket_UDP *return_value = new Socket_UDP();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Socket_UDP,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SocketUDP()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Socket_UDP(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Socket_UDP)
    {
        printf("Socket_UDP ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Socket_UDP * local_this = (Socket_UDP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Socket_UDP)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *)( Socket_UDP_Incoming *) local_this;
    if(requested_type == &Dtool_Socket_UDP_Incoming)
        return ( Socket_UDP_Incoming *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *)( Socket_UDP_Incoming *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Socket_UDP(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Socket_UDP)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Socket_UDP*)other_this;
    }
    if(from_type == &Dtool_Socket_UDP_Incoming)
    {
          Socket_UDP_Incoming* other_this = (Socket_UDP_Incoming*)from_this;
          return (Socket_UDP*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Socket_UDP*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. Socket_Address | SocketAddress
//********************************************************************
PyMethodDef Dtool_Methods_Socket_Address[]= {
  { "setAnyIP",(PyCFunction ) &Dtool_Socket_Address_set_any_IP_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_set_any_IP_4_comment},
  { "setPort",(PyCFunction ) &Dtool_Socket_Address_set_port_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_set_port_5_comment},
  { "setBroadcast",(PyCFunction ) &Dtool_Socket_Address_set_broadcast_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_set_broadcast_6_comment},
  { "setHost",(PyCFunction ) &Dtool_Socket_Address_set_host_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_set_host_7_comment},
  { "clear",(PyCFunction ) &Dtool_Socket_Address_clear_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_clear_8_comment},
  { "getPort",(PyCFunction ) &Dtool_Socket_Address_get_port_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_get_port_9_comment},
  { "getIp",(PyCFunction ) &Dtool_Socket_Address_get_ip_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_get_ip_10_comment},
  { "getIpPort",(PyCFunction ) &Dtool_Socket_Address_get_ip_port_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_get_ip_port_11_comment},
  { "GetIPAddressRaw",(PyCFunction ) &Dtool_Socket_Address_GetIPAddressRaw_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_GetIPAddressRaw_12_comment},
  { "eq",(PyCFunction ) &Dtool_Socket_Address_operator_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_operator_13_comment},
  { "lessThan",(PyCFunction ) &Dtool_Socket_Address_operator_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_operator_14_comment},
  { "isMcastRange",(PyCFunction ) &Dtool_Socket_Address_isMcastRange_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_Address_isMcastRange_15_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_Address(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_Address.As_PyTypeObject().tp_doc =
          "///////////////////////////////////\n"
          "// Class : Socket_Address\n"
          "//\n"
          "// Description: A simple place to store and munipulate tcp and port address for\n"
          "//    communication layer\n"
          "//\n"
          "//////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Socket_Address.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Socket_Address.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_Address.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_Address.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_Address.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_Address)");
             printf(" Error In PyType_ReadySocket_Address");
             return;
        }
        Py_INCREF(&Dtool_Socket_Address.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_Address.As_PyTypeObject().tp_dict,"SocketAddress",&Dtool_Socket_Address.As_PyObject());
        RegisterRuntimeClass(&Dtool_Socket_Address,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_Address.As_PyTypeObject());
        PyModule_AddObject(module, "SocketAddress",(PyObject *)&Dtool_Socket_Address.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_IP | SocketIP
//********************************************************************
PyMethodDef Dtool_Methods_Socket_IP[]= {
  { "Close",(PyCFunction ) &Dtool_Socket_IP_Close_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_Close_19_comment},
  { "GetLastError",(PyCFunction ) &Dtool_Socket_IP_GetLastError_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_GetLastError_20_comment},
  { "SetNonBlocking",(PyCFunction ) &Dtool_Socket_IP_SetNonBlocking_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_SetNonBlocking_21_comment},
  { "SetBlocking",(PyCFunction ) &Dtool_Socket_IP_SetBlocking_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_SetBlocking_22_comment},
  { "SetReuseAddress",(PyCFunction ) &Dtool_Socket_IP_SetReuseAddress_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_SetReuseAddress_23_comment},
  { "Active",(PyCFunction ) &Dtool_Socket_IP_Active_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_Active_24_comment},
  { "SetRecvBufferSize",(PyCFunction ) &Dtool_Socket_IP_SetRecvBufferSize_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_SetRecvBufferSize_25_comment},
  { "SetSocket",(PyCFunction ) &Dtool_Socket_IP_SetSocket_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_SetSocket_26_comment},
  { "GetSocket",(PyCFunction ) &Dtool_Socket_IP_GetSocket_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_GetSocket_27_comment},
  { "GetPeerName",(PyCFunction ) &Dtool_Socket_IP_GetPeerName_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_GetPeerName_28_comment},
  { "InitNetworkDriver",(PyCFunction ) &Dtool_Socket_IP_InitNetworkDriver_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_InitNetworkDriver_29_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_IP_get_class_type_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_IP_get_class_type_30_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_IP(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_IP.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_IP\n"
          "//\n"
          "// Description : Base functionality for a INET domain Socket\n"
          "//     this call should be the starting point for all other\n"
          "//     unix domain sockets\n"
          "//\n"
          "//\n"
          "//                                       SocketIP\n"
          "//                                          |\n"
          "//       -------------------------------------------------------------------\n"
          "//       |             |                       |                           |\n"
          "//     SocketTCP     SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound\n"
          "//\n"
          "//\n"
          "//\n"
          "// socket_fdset\n"
          "//\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_Socket_IP.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_Socket_IP.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_IP.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_IP.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_IP.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_IP)");
             printf(" Error In PyType_ReadySocket_IP");
             return;
        }
        Py_INCREF(&Dtool_Socket_IP.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_IP.As_PyTypeObject().tp_dict,"SocketIP",&Dtool_Socket_IP.As_PyObject());
        //  Static Method GetLastError
        PyDict_SetItemString(Dtool_Socket_IP.As_PyTypeObject().tp_dict,"GetLastError",PyCFunction_New(&Dtool_Methods_Socket_IP[1],&Dtool_Socket_IP.As_PyObject()));
        //  Static Method InitNetworkDriver
        PyDict_SetItemString(Dtool_Socket_IP.As_PyTypeObject().tp_dict,"InitNetworkDriver",PyCFunction_New(&Dtool_Methods_Socket_IP[10],&Dtool_Socket_IP.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_IP.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_IP[11],&Dtool_Socket_IP.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_IP,Socket_IP::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_IP.As_PyTypeObject());
        PyModule_AddObject(module, "SocketIP",(PyObject *)&Dtool_Socket_IP.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_TCP | SocketTCP
//********************************************************************
PyMethodDef Dtool_Methods_Socket_TCP[]= {
  { "SetNoDelay",(PyCFunction ) &Dtool_Socket_TCP_SetNoDelay_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_SetNoDelay_33_comment},
  { "SetLinger",(PyCFunction ) &Dtool_Socket_TCP_SetLinger_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_SetLinger_34_comment},
  { "DontLinger",(PyCFunction ) &Dtool_Socket_TCP_DontLinger_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_DontLinger_35_comment},
  { "SetSendBufferSize",(PyCFunction ) &Dtool_Socket_TCP_SetSendBufferSize_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_SetSendBufferSize_36_comment},
  { "ActiveOpen",(PyCFunction ) &Dtool_Socket_TCP_ActiveOpen_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_ActiveOpen_37_comment},
  { "ActiveOpenNonBlocking",(PyCFunction ) &Dtool_Socket_TCP_ActiveOpenNonBlocking_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_ActiveOpenNonBlocking_38_comment},
  { "ErrorIsWouldBlocking",(PyCFunction ) &Dtool_Socket_TCP_ErrorIs_WouldBlocking_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_ErrorIs_WouldBlocking_39_comment},
  { "ShutdownSend",(PyCFunction ) &Dtool_Socket_TCP_ShutdownSend_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_ShutdownSend_40_comment},
  { "SendData",(PyCFunction ) &Dtool_Socket_TCP_SendData_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_SendData_41_comment},
  { "RecvData",(PyCFunction ) &Dtool_Socket_TCP_RecvData_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_RecvData_42_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_TCP_get_class_type_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_get_class_type_43_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_TCP(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_TCP.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_TCP\n"
          "//\n"
          "// Description : Base functionality for a TCP connected socket\n"
          "//               This class is pretty useless by itself but it does hide some of the\n"
          "//               platform differences from machine to machine\n"
          "//\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_IP._Dtool_ClassInit(NULL);
        Dtool_Socket_TCP.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_IP.As_PyTypeObject());
        Dtool_Socket_TCP.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_TCP.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_TCP.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_TCP.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_TCP)");
             printf(" Error In PyType_ReadySocket_TCP");
             return;
        }
        Py_INCREF(&Dtool_Socket_TCP.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_TCP.As_PyTypeObject().tp_dict,"SocketTCP",&Dtool_Socket_TCP.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_TCP.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_TCP[10],&Dtool_Socket_TCP.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_TCP,Socket_TCP::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_TCP.As_PyTypeObject());
        PyModule_AddObject(module, "SocketTCP",(PyObject *)&Dtool_Socket_TCP.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_TCP_Listen | SocketTCPListen
//********************************************************************
PyMethodDef Dtool_Methods_Socket_TCP_Listen[]= {
  { "OpenForListen",(PyCFunction ) &Dtool_Socket_TCP_Listen_OpenForListen_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_Listen_OpenForListen_47_comment},
  { "GetIncomingConnection",(PyCFunction ) &Dtool_Socket_TCP_Listen_GetIncomingConnection_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_Listen_GetIncomingConnection_48_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_TCP_Listen_get_class_type_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_TCP_Listen_get_class_type_49_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_TCP_Listen(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_TCP_Listen\n"
          "// Description : Base functionality for a TCP rendezvous socket\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_IP._Dtool_ClassInit(NULL);
        Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_IP.As_PyTypeObject());
        Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_TCP_Listen.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_TCP_Listen)");
             printf(" Error In PyType_ReadySocket_TCP_Listen");
             return;
        }
        Py_INCREF(&Dtool_Socket_TCP_Listen.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_dict,"SocketTCPListen",&Dtool_Socket_TCP_Listen.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_TCP_Listen.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_TCP_Listen[2],&Dtool_Socket_TCP_Listen.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_TCP_Listen,Socket_TCP_Listen::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_TCP_Listen.As_PyTypeObject());
        PyModule_AddObject(module, "SocketTCPListen",(PyObject *)&Dtool_Socket_TCP_Listen.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_UDP_Incoming | SocketUDPIncoming
//********************************************************************
PyMethodDef Dtool_Methods_Socket_UDP_Incoming[]= {
  { "OpenForInput",(PyCFunction ) &Dtool_Socket_UDP_Incoming_OpenForInput_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_OpenForInput_52_comment},
  { "OpenForInputMCast",(PyCFunction ) &Dtool_Socket_UDP_Incoming_OpenForInputMCast_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_OpenForInputMCast_53_comment},
  { "SendTo",(PyCFunction ) &Dtool_Socket_UDP_Incoming_SendTo_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_SendTo_55_comment},
  { "InitNoAddress",(PyCFunction ) &Dtool_Socket_UDP_Incoming_InitNoAddress_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_InitNoAddress_56_comment},
  { "SetToBroadCast",(PyCFunction ) &Dtool_Socket_UDP_Incoming_SetToBroadCast_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_SetToBroadCast_57_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_UDP_Incoming_get_class_type_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Incoming_get_class_type_58_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_UDP_Incoming(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_UDP_Incoming\n"
          "//\n"
          "// Description : Base functionality for a UDP Reader\n"
          "//\n"
          "//\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_IP._Dtool_ClassInit(NULL);
        Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_IP.As_PyTypeObject());
        Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_UDP_Incoming.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_UDP_Incoming)");
             printf(" Error In PyType_ReadySocket_UDP_Incoming");
             return;
        }
        Py_INCREF(&Dtool_Socket_UDP_Incoming.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_dict,"SocketUDPIncoming",&Dtool_Socket_UDP_Incoming.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_UDP_Incoming.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_UDP_Incoming[5],&Dtool_Socket_UDP_Incoming.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_UDP_Incoming,Socket_UDP_Incoming::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_UDP_Incoming.As_PyTypeObject());
        PyModule_AddObject(module, "SocketUDPIncoming",(PyObject *)&Dtool_Socket_UDP_Incoming.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_UDP_Outgoing | SocketUDPOutgoing
//********************************************************************
PyMethodDef Dtool_Methods_Socket_UDP_Outgoing[]= {
  { "InitToAddress",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_InitToAddress_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_InitToAddress_62_comment},
  { "Send",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_Send_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_Send_63_comment},
  { "InitNoAddress",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_InitNoAddress_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_InitNoAddress_64_comment},
  { "SendTo",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_SendTo_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_SendTo_65_comment},
  { "SetToBroadCast",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_SetToBroadCast_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_SetToBroadCast_66_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_UDP_Outgoing_get_class_type_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Outgoing_get_class_type_67_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_UDP_Outgoing(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_UDP_Outgoing\n"
          "//\n"
          "// Description : Base functionality for a UDP Sending Socket\n"
          "//\n"
          "//\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_IP._Dtool_ClassInit(NULL);
        Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_IP.As_PyTypeObject());
        Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_UDP_Outgoing.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_UDP_Outgoing)");
             printf(" Error In PyType_ReadySocket_UDP_Outgoing");
             return;
        }
        Py_INCREF(&Dtool_Socket_UDP_Outgoing.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_dict,"SocketUDPOutgoing",&Dtool_Socket_UDP_Outgoing.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_UDP_Outgoing.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_UDP_Outgoing[5],&Dtool_Socket_UDP_Outgoing.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_UDP_Outgoing,Socket_UDP_Outgoing::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_UDP_Outgoing.As_PyTypeObject());
        PyModule_AddObject(module, "SocketUDPOutgoing",(PyObject *)&Dtool_Socket_UDP_Outgoing.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_fdset | SocketFdset
//********************************************************************
PyMethodDef Dtool_Methods_Socket_fdset[]= {
  { "setForSocket",(PyCFunction ) &Dtool_Socket_fdset_setForSocket_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_setForSocket_71_comment},
  { "IsSetFor",(PyCFunction ) &Dtool_Socket_fdset_IsSetFor_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_IsSetFor_72_comment},
  { "WaitForRead",(PyCFunction ) &Dtool_Socket_fdset_WaitForRead_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_WaitForRead_73_comment},
  { "WaitForWrite",(PyCFunction ) &Dtool_Socket_fdset_WaitForWrite_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_WaitForWrite_74_comment},
  { "WaitForError",(PyCFunction ) &Dtool_Socket_fdset_WaitForError_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_WaitForError_75_comment},
  { "clear",(PyCFunction ) &Dtool_Socket_fdset_clear_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_fdset_clear_76_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_fdset(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Socket_fdset.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Socket_fdset.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_fdset.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_fdset.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_fdset.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_fdset)");
             printf(" Error In PyType_ReadySocket_fdset");
             return;
        }
        Py_INCREF(&Dtool_Socket_fdset.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_fdset.As_PyTypeObject().tp_dict,"SocketFdset",&Dtool_Socket_fdset.As_PyObject());
        RegisterRuntimeClass(&Dtool_Socket_fdset,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_fdset.As_PyTypeObject());
        PyModule_AddObject(module, "SocketFdset",(PyObject *)&Dtool_Socket_fdset.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Buffered_DatagramConnection | BufferedDatagramConnection
//********************************************************************
PyMethodDef Dtool_Methods_Buffered_DatagramConnection[]= {
  { "GetMessage",(PyCFunction ) &Dtool_Buffered_DatagramConnection_GetMessage_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_GetMessage_79_comment},
  { "DoConnect",(PyCFunction ) &Dtool_Buffered_DatagramConnection_DoConnect_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_DoConnect_80_comment},
  { "IsConnected",(PyCFunction ) &Dtool_Buffered_DatagramConnection_IsConnected_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_IsConnected_81_comment},
  { "SendMessage",(PyCFunction ) &Dtool_Buffered_DatagramConnection_SendMessage_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_SendMessage_83_comment},
  { "Flush",(PyCFunction ) &Dtool_Buffered_DatagramConnection_Flush_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_Flush_84_comment},
  { "Reset",(PyCFunction ) &Dtool_Buffered_DatagramConnection_Reset_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_Reset_85_comment},
  { "WaitForNetworkReadEvent",(PyCFunction ) &Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_86_comment},
  { "AddressQueueSize",(PyCFunction ) &Dtool_Buffered_DatagramConnection_AddressQueueSize_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_AddressQueueSize_87_comment},
  { "AddAddress",(PyCFunction ) &Dtool_Buffered_DatagramConnection_AddAddress_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_AddAddress_88_comment},
  { "ClearAddresses",(PyCFunction ) &Dtool_Buffered_DatagramConnection_ClearAddresses_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_ClearAddresses_89_comment},
  { "getClassType",(PyCFunction ) &Dtool_Buffered_DatagramConnection_get_class_type_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Buffered_DatagramConnection_get_class_type_90_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Buffered_DatagramConnection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////\n"
          "// there are 3 states   \n"
          "//\n"
          "//      1. Socket not even assigned,,,,\n"
          "//      2. Socket Assigned and trying to get a active connect open\n"
          "//      3. Socket is open and  writable.. ( Fully powered up )...\n"
          "//\n"
          "///////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_TCP._Dtool_ClassInit(NULL);
        Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_TCP.As_PyTypeObject());
        Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Buffered_DatagramConnection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Buffered_DatagramConnection)");
             printf(" Error In PyType_ReadyBuffered_DatagramConnection");
             return;
        }
        Py_INCREF(&Dtool_Buffered_DatagramConnection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_dict,"BufferedDatagramConnection",&Dtool_Buffered_DatagramConnection.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Buffered_DatagramConnection.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Buffered_DatagramConnection[10],&Dtool_Buffered_DatagramConnection.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Buffered_DatagramConnection,Buffered_DatagramConnection::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Buffered_DatagramConnection.As_PyTypeObject());
        PyModule_AddObject(module, "BufferedDatagramConnection",(PyObject *)&Dtool_Buffered_DatagramConnection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Socket_UDP | SocketUDP
//********************************************************************
PyMethodDef Dtool_Methods_Socket_UDP[]= {
  { "InitToAddress",(PyCFunction ) &Dtool_Socket_UDP_InitToAddress_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_InitToAddress_93_comment},
  { "Send",(PyCFunction ) &Dtool_Socket_UDP_Send_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_Send_94_comment},
  { "InitNoAddress",(PyCFunction ) &Dtool_Socket_UDP_InitNoAddress_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_InitNoAddress_95_comment},
  { "SendTo",(PyCFunction ) &Dtool_Socket_UDP_SendTo_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_SendTo_96_comment},
  { "SetToBroadCast",(PyCFunction ) &Dtool_Socket_UDP_SetToBroadCast_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_SetToBroadCast_97_comment},
  { "getClassType",(PyCFunction ) &Dtool_Socket_UDP_get_class_type_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Socket_UDP_get_class_type_98_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Socket_UDP(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Socket_UDP.As_PyTypeObject().tp_doc =
          "/////////////////////////////////////////////////////////////////////\n"
          "// Class : Socket_UDP\n"
          "//\n"
          "// Description : Base functionality for a combination UDP Reader and\n"
          "//               Writer.  This duplicates code from\n"
          "//               Socket_UDP_Outgoing, to avoid the problems of\n"
          "//               multiple inheritance.\n"
          "/////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Socket_UDP_Incoming._Dtool_ClassInit(NULL);
        Dtool_Socket_UDP.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Socket_UDP_Incoming.As_PyTypeObject());
        Dtool_Socket_UDP.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Socket_UDP.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Socket_UDP.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Socket_UDP.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Socket_UDP)");
             printf(" Error In PyType_ReadySocket_UDP");
             return;
        }
        Py_INCREF(&Dtool_Socket_UDP.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Socket_UDP.As_PyTypeObject().tp_dict,"SocketUDP",&Dtool_Socket_UDP.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Socket_UDP.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Socket_UDP[5],&Dtool_Socket_UDP.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Socket_UDP,Socket_UDP::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Socket_UDP.As_PyTypeObject());
        PyModule_AddObject(module, "SocketUDP",(PyObject *)&Dtool_Socket_UDP.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..Socket_Address
//********************************************************************
   Dtool_PyModuleClassInit_Socket_Address(module);
//********************************************************************
//*** Module Init Updcall ..Socket_IP
//********************************************************************
   Dtool_PyModuleClassInit_Socket_IP(module);
//********************************************************************
//*** Module Init Updcall ..Socket_TCP
//********************************************************************
   Dtool_PyModuleClassInit_Socket_TCP(module);
//********************************************************************
//*** Module Init Updcall ..Socket_TCP_Listen
//********************************************************************
   Dtool_PyModuleClassInit_Socket_TCP_Listen(module);
//********************************************************************
//*** Module Init Updcall ..Socket_UDP_Incoming
//********************************************************************
   Dtool_PyModuleClassInit_Socket_UDP_Incoming(module);
//********************************************************************
//*** Module Init Updcall ..Socket_UDP_Outgoing
//********************************************************************
   Dtool_PyModuleClassInit_Socket_UDP_Outgoing(module);
//********************************************************************
//*** Module Init Updcall ..Socket_fdset
//********************************************************************
   Dtool_PyModuleClassInit_Socket_fdset(module);
//********************************************************************
//*** Module Init Updcall ..Buffered_DatagramConnection
//********************************************************************
   Dtool_PyModuleClassInit_Buffered_DatagramConnection(module);
//********************************************************************
//*** Module Init Updcall ..Socket_UDP
//********************************************************************
   Dtool_PyModuleClassInit_Socket_UDP(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libnativenet_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212829,  /* file_identifier */
  "libnativenet",  /* library_name */
  "XxDh",  /* library_hash_name */
  "panda",  /* module_name */
  "libnativenet.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  231  /* next_index */
};

Configure(_in_configure_libnativenet);
ConfigureFn(_in_configure_libnativenet) {
  interrogate_request_module(&_in_module_def);
}

