/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/char -Ipanda/src/char -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libchar_igate.cxx -od built_Rocket/pandac/input/libchar.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/char -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libchar char_composite.cxx character.h characterJoint.h characterJointBundle.h characterJointEffect.h characterSlider.h characterVertexSlider.h config_char.h jointVertexTransform.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libchar
#include "py_panda.h"  

#include "character.h"
#include "characterJoint.h"
#include "characterJointBundle.h"
#include "characterJointEffect.h"
#include "characterSlider.h"
#include "characterVertexSlider.h"
#include "config_char.h"
#include "jointVertexTransform.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CharacterJoint
//********************************************************************
typedef  CharacterJoint  CharacterJoint_localtype;
Define_Module_ClassRef(panda,CharacterJoint,CharacterJoint_localtype,CharacterJoint);
//********************************************************************
//*** prototypes for .. CharacterSlider
//********************************************************************
typedef  CharacterSlider  CharacterSlider_localtype;
Define_Module_ClassRef(panda,CharacterSlider,CharacterSlider_localtype,CharacterSlider);
//********************************************************************
//*** prototypes for .. CharacterVertexSlider
//********************************************************************
typedef  CharacterVertexSlider  CharacterVertexSlider_localtype;
Define_Module_ClassRef(panda,CharacterVertexSlider,CharacterVertexSlider_localtype,CharacterVertexSlider);
//********************************************************************
//*** prototypes for .. JointVertexTransform
//********************************************************************
typedef  JointVertexTransform  JointVertexTransform_localtype;
Define_Module_ClassRef(panda,JointVertexTransform,JointVertexTransform_localtype,JointVertexTransform);
//********************************************************************
//*** prototypes for .. Character
//********************************************************************
typedef  Character  Character_localtype;
Define_Module_ClassRef(panda,Character,Character_localtype,Character);
//********************************************************************
//*** prototypes for .. CharacterJointBundle
//********************************************************************
typedef  CharacterJointBundle  CharacterJointBundle_localtype;
Define_Module_ClassRef(panda,CharacterJointBundle,CharacterJointBundle_localtype,CharacterJointBundle);
//********************************************************************
//*** prototypes for .. CharacterJointEffect
//********************************************************************
typedef  CharacterJointEffect  CharacterJointEffect_localtype;
Define_Module_ClassRef(panda,CharacterJointEffect,CharacterJointEffect_localtype,CharacterJointEffect);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovingPartBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovingPartMatrix;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovingPartScalar;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovingPart_ACMatrixSwitchType;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovingPart_ACScalarSwitchType;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePathCollection;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PartBundle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PartBundleHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PartBundleNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PartGroup;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_RenderEffect;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Thread;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VertexSlider;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_VertexTransform;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CharacterJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::add_net_transform(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_add_net_transform_4(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CharacterJoint::add_net_transform(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addNetTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addNetTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.addNetTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_net_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CharacterJoint.addNetTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addNetTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_add_net_transform_4_comment =
    "C++ Interface:\n"
    "addNetTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::add_net_transform\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated node to the list of nodes that will\n"
    "//               be updated each frame with the joint's net transform\n"
    "//               from the root.  Returns true if the node is\n"
    "//               successfully added, false if it had already been\n"
    "//               added.\n"
    "//\n"
    "//               A CharacterJointEffect for this joint's Character\n"
    "//               will automatically be added to the specified node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_add_net_transform_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::remove_net_transform(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_remove_net_transform_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CharacterJoint::remove_net_transform(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeNetTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeNetTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.removeNetTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_net_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CharacterJoint.removeNetTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeNetTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_remove_net_transform_5_comment =
    "C++ Interface:\n"
    "removeNetTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::remove_net_transform\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated node from the list of nodes that\n"
    "//               will be updated each frame with the joint's net\n"
    "//               transform from the root.  Returns true if the node is\n"
    "//               successfully removed, false if it was not on the\n"
    "//               list.\n"
    "//\n"
    "//               If the node has a CharacterJointEffect that matches\n"
    "//               this joint's Character, it will be cleared.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_remove_net_transform_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::has_net_transform(PandaNode *node) const
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_has_net_transform_6(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CharacterJoint::has_net_transform(PandaNode *node) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasNetTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasNetTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.hasNetTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const CharacterJoint*)local_this)->has_net_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasNetTransform(const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_has_net_transform_6_comment =
    "C++ Interface:\n"
    "hasNetTransform(const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::has_net_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the node is on the list of nodes that\n"
    "//               will be updated each frame with the joint's net\n"
    "//               transform from the root, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_has_net_transform_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CharacterJoint::clear_net_transforms(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_clear_net_transforms_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CharacterJoint::clear_net_transforms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearNetTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":clearNetTransforms"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_net_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CharacterJoint.clearNetTransforms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearNetTransforms(non-const CharacterJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_clear_net_transforms_7_comment =
    "C++ Interface:\n"
    "clearNetTransforms(non-const CharacterJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::clear_net_transforms\n"
    "//       Access: Published\n"
    "//  Description: Removes all nodes from the list of nodes that will be\n"
    "//               updated each frame with the joint's net transform\n"
    "//               from the root.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_clear_net_transforms_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePathCollection CharacterJoint::get_net_transforms(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_net_transforms_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePathCollection CharacterJoint::get_net_transforms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNetTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":getNetTransforms"));
        if(!PyErr_Occurred())
        {
            NodePathCollection result = (local_this)->get_net_transforms();
            NodePathCollection *return_value = new NodePathCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePathCollection,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CharacterJoint.getNetTransforms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNetTransforms(non-const CharacterJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_net_transforms_8_comment =
    "C++ Interface:\n"
    "getNetTransforms(non-const CharacterJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::get_net_transforms\n"
    "//       Access: Published\n"
    "//  Description: Returns a list of the net transforms set for this\n"
    "//               node.  Note that this returns a list of NodePaths,\n"
    "//               even though the net transforms are actually a list of\n"
    "//               PandaNodes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_net_transforms_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::add_local_transform(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_add_local_transform_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CharacterJoint::add_local_transform(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLocalTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addLocalTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.addLocalTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_local_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CharacterJoint.addLocalTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLocalTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_add_local_transform_9_comment =
    "C++ Interface:\n"
    "addLocalTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::add_local_transform\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated node to the list of nodes that will\n"
    "//               be updated each frame with the joint's local\n"
    "//               transform from its parent.  Returns true if the node\n"
    "//               is successfully added, false if it had already been\n"
    "//               added.\n"
    "//\n"
    "//               The Character pointer should be the Character object\n"
    "//               that owns this joint; this will be used to create a\n"
    "//               CharacterJointEffect for this node.  If it is NULL,\n"
    "//               no such effect will be created.\n"
    "//\n"
    "//               A CharacterJointEffect for this joint's Character\n"
    "//               will automatically be added to the specified node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_add_local_transform_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::remove_local_transform(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_remove_local_transform_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CharacterJoint::remove_local_transform(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeLocalTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeLocalTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.removeLocalTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_local_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CharacterJoint.removeLocalTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeLocalTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_remove_local_transform_10_comment =
    "C++ Interface:\n"
    "removeLocalTransform(non-const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::remove_local_transform\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated node from the list of nodes that\n"
    "//               will be updated each frame with the joint's local\n"
    "//               transform from its parent.  Returns true if the node\n"
    "//               is successfully removed, false if it was not on the\n"
    "//               list.\n"
    "//\n"
    "//               If the node has a CharacterJointEffect that matches\n"
    "//               this joint's Character, it will be cleared.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_remove_local_transform_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CharacterJoint::has_local_transform(PandaNode *node) const
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_has_local_transform_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CharacterJoint::has_local_transform(PandaNode *node) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasLocalTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasLocalTransform", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "CharacterJoint.hasLocalTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const CharacterJoint*)local_this)->has_local_transform(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasLocalTransform(const CharacterJoint this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_has_local_transform_11_comment =
    "C++ Interface:\n"
    "hasLocalTransform(const CharacterJoint this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::has_local_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the node is on the list of nodes that\n"
    "//               will be updated each frame with the joint's local\n"
    "//               transform from its parent, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_has_local_transform_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CharacterJoint::clear_local_transforms(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_clear_local_transforms_12(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CharacterJoint::clear_local_transforms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLocalTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":clearLocalTransforms"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_local_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CharacterJoint.clearLocalTransforms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLocalTransforms(non-const CharacterJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_clear_local_transforms_12_comment =
    "C++ Interface:\n"
    "clearLocalTransforms(non-const CharacterJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::clear_local_transforms\n"
    "//       Access: Published\n"
    "//  Description: Removes all nodes from the list of nodes that will be\n"
    "//               updated each frame with the joint's local transform\n"
    "//               from its parent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_clear_local_transforms_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePathCollection CharacterJoint::get_local_transforms(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_local_transforms_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-NodePathCollection CharacterJoint::get_local_transforms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":getLocalTransforms"));
        if(!PyErr_Occurred())
        {
            NodePathCollection result = (local_this)->get_local_transforms();
            NodePathCollection *return_value = new NodePathCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePathCollection,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CharacterJoint.getLocalTransforms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalTransforms(non-const CharacterJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_local_transforms_13_comment =
    "C++ Interface:\n"
    "getLocalTransforms(non-const CharacterJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::get_local_transforms\n"
    "//       Access: Published\n"
    "//  Description: Returns a list of the local transforms set for this\n"
    "//               node.  Note that this returns a list of NodePaths,\n"
    "//               even though the local transforms are actually a list of\n"
    "//               PandaNodes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_local_transforms_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CharacterJoint::get_transform(LMatrix4f &transform) const
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_transform_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CharacterJoint::get_transform(LMatrix4f &transform) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getTransform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "CharacterJoint.getTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CharacterJoint*)local_this)->get_transform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTransform(const CharacterJoint this, non-const Mat4 transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_transform_14_comment =
    "C++ Interface:\n"
    "getTransform(const CharacterJoint this, non-const Mat4 transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::get_transform\n"
    "//       Access: Published\n"
    "//  Description: Copies the joint's current transform into the\n"
    "//               indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_transform_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CharacterJoint::get_net_transform(LMatrix4f &transform) const
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_net_transform_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CharacterJoint::get_net_transform(LMatrix4f &transform) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNetTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getNetTransform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "CharacterJoint.getNetTransform", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CharacterJoint*)local_this)->get_net_transform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNetTransform(const CharacterJoint this, non-const Mat4 transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_net_transform_15_comment =
    "C++ Interface:\n"
    "getNetTransform(const CharacterJoint this, non-const Mat4 transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::get_net_transform\n"
    "//       Access: Published\n"
    "//  Description: Copies the joint's current net transform (composed\n"
    "//               from the root of the character joint hierarchy) into\n"
    "//               the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_net_transform_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Character *CharacterJoint::get_character(void) const
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_character_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Character *CharacterJoint::get_character(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCharacter", key_word_list));
        else
            (PyArg_Parse(args, ":getCharacter"));
        if(!PyErr_Occurred())
        {
            Character *return_value = ((const CharacterJoint*)local_this)->get_character();
            if (return_value != (Character *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Character,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCharacter(const CharacterJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_character_16_comment =
    "C++ Interface:\n"
    "getCharacter(const CharacterJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJoint::get_character\n"
    "//       Access: Published\n"
    "//  Description: Returns the Character that owns this joint.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_character_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CharacterJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJoint_get_class_type_17(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CharacterJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CharacterJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJoint_get_class_type_17_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CharacterJoint_get_class_type_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, basic_string< char > const &name, LMatrix4f const &default_value)
 *******************************************************************/
int  Dtool_Init_CharacterJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, basic_string< char > const &name, LMatrix4f const &default_value)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            char *param3_str; int param3_len;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"character", (char *)"root", (char *)"parent", (char *)"name", (char *)"default_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOs#O:CharacterJoint", key_word_list, &param0, &param1, &param2, &param3_str, &param3_len, &param4))
            {
                Character *param0_this = (Character *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Character, 0, "CharacterJoint.CharacterJoint", 0, coerced_ptr, report_errors);
PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "CharacterJoint.CharacterJoint", 0, coerced_ptr, report_errors);
PartGroup *param2_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PartGroup, 2, "CharacterJoint.CharacterJoint", 0, coerced_ptr, report_errors);
LMatrix4f *param4_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LMatrix4f, 4, "CharacterJoint.CharacterJoint", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    CharacterJoint *return_value = new CharacterJoint(param0_this, param1_this, param2_this, basic_string<char>(param3_str, param3_len), *param4_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CharacterJoint,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CharacterJoint(non-const Character character, non-const PartBundle root, non-const PartGroup parent, string name, const Mat4 default_value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CharacterJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CharacterJoint)
    {
        printf("CharacterJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CharacterJoint * local_this = (CharacterJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CharacterJoint)
        return local_this;
    if(requested_type == &Dtool_MovingPart_ACMatrixSwitchType)
        return ( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_MovingPartMatrix)
        return ( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *)( MovingPartMatrix *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CharacterJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CharacterJoint)
        return from_this;
    if(from_type == &Dtool_MovingPart_ACMatrixSwitchType)
    {
          MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_MovingPartMatrix)
    {
          MovingPartMatrix* other_this = (MovingPartMatrix*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CharacterJoint*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CharacterJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CharacterSlider 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool CharacterSlider::update_internals(PartBundle *root, PartGroup *parent, bool self_changed, bool parent_changed, Thread *current_thread)
 *******************************************************************/
static PyObject *Dtool_CharacterSlider_update_internals_21(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterSlider * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterSlider,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool CharacterSlider::update_internals(PartBundle *root, PartGroup *parent, bool self_changed, bool parent_changed, Thread *current_thread)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"root", (char *)"parent", (char *)"self_changed", (char *)"parent_changed", (char *)"current_thread", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOO:updateInternals", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "CharacterSlider.updateInternals", 0, coerced_ptr, report_errors);
PartGroup *param2_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PartGroup, 2, "CharacterSlider.updateInternals", 0, coerced_ptr, report_errors);
Thread *param5_this = (Thread *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_Thread, 5, "CharacterSlider.updateInternals", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param5_this == NULL)))
                {
                    bool return_value = (local_this)->update_internals(param1_this, param2_this, (PyObject_IsTrue(param3)!=0), (PyObject_IsTrue(param4)!=0), param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CharacterSlider.updateInternals() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateInternals(non-const CharacterSlider this, non-const PartBundle root, non-const PartGroup parent, bool self_changed, bool parent_changed, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterSlider_update_internals_21_comment =
    "C++ Interface:\n"
    "updateInternals(non-const CharacterSlider this, non-const PartBundle root, non-const PartGroup parent, bool self_changed, bool parent_changed, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterSlider::update_internals\n"
    "//       Access: Public, Virtual\n"
    "//  Description: This is called by do_update() whenever the part or\n"
    "//               some ancestor has changed values.  It is a hook for\n"
    "//               derived classes to update whatever cache they may\n"
    "//               have that depends on these.\n"
    "//\n"
    "//               The return value is true if the part has changed as a\n"
    "//               result of the update, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterSlider_update_internals_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CharacterSlider::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CharacterSlider_get_class_type_22(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CharacterSlider::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CharacterSlider::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterSlider_get_class_type_22_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CharacterSlider_get_class_type_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterSlider::CharacterSlider(PartGroup *parent, basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_CharacterSlider(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CharacterSlider::CharacterSlider(PartGroup *parent, basic_string< char > const &name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"parent", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:CharacterSlider", key_word_list, &param0, &param1_str, &param1_len))
            {
                PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PartGroup, 0, "CharacterSlider.CharacterSlider", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    CharacterSlider *return_value = new CharacterSlider(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CharacterSlider,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CharacterSlider(non-const PartGroup parent, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CharacterSlider(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CharacterSlider)
    {
        printf("CharacterSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CharacterSlider * local_this = (CharacterSlider *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CharacterSlider)
        return local_this;
    if(requested_type == &Dtool_MovingPart_ACScalarSwitchType)
        return ( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_MovingPartScalar)
        return ( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *)( MovingPartScalar *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CharacterSlider(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CharacterSlider)
        return from_this;
    if(from_type == &Dtool_MovingPart_ACScalarSwitchType)
    {
          MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_MovingPartScalar)
    {
          MovingPartScalar* other_this = (MovingPartScalar*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CharacterSlider*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CharacterSlider*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CharacterVertexSlider 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
 *******************************************************************/
static PyObject *Dtool_CharacterVertexSlider_get_char_slider_26(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterVertexSlider * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterVertexSlider,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCharSlider", key_word_list));
        else
            (PyArg_Parse(args, ":getCharSlider"));
        if(!PyErr_Occurred())
        {
            CharacterSlider const *return_value = ((const CharacterVertexSlider*)local_this)->get_char_slider();
            if (return_value != (CharacterSlider const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CharacterSlider,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCharSlider(const CharacterVertexSlider this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterVertexSlider_get_char_slider_26_comment =
    "C++ Interface:\n"
    "getCharSlider(const CharacterVertexSlider this)\n"
    "\n"
    "// Filename: characterVertexSlider.I\n"
    "// Created by:  drose (28Mar05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterVertexSlider::get_char_slider\n"
    "//       Access: Published\n"
    "//  Description: Returns the CharacterSlider object for which this\n"
    "//               object returns the slider value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterVertexSlider_get_char_slider_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CharacterVertexSlider::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CharacterVertexSlider_get_class_type_27(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CharacterVertexSlider::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CharacterVertexSlider::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterVertexSlider_get_class_type_27_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CharacterVertexSlider_get_class_type_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
 *******************************************************************/
int  Dtool_Init_CharacterVertexSlider(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"char_slider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:CharacterVertexSlider", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:CharacterVertexSlider", &param0));
            if(!PyErr_Occurred())
            {
                CharacterSlider *param0_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    CharacterVertexSlider *return_value = new CharacterVertexSlider(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CharacterVertexSlider,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CharacterVertexSlider(non-const CharacterSlider char_slider)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CharacterVertexSlider(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CharacterVertexSlider)
    {
        printf("CharacterVertexSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CharacterVertexSlider * local_this = (CharacterVertexSlider *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CharacterVertexSlider)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( VertexSlider *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( VertexSlider *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( VertexSlider *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( VertexSlider *) local_this;
    if(requested_type == &Dtool_VertexSlider)
        return ( VertexSlider *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CharacterVertexSlider(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CharacterVertexSlider)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CharacterVertexSlider*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CharacterVertexSlider*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CharacterVertexSlider*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CharacterVertexSlider*)other_this;
    }
    if(from_type == &Dtool_VertexSlider)
    {
          VertexSlider* other_this = (VertexSlider*)from_this;
          return (CharacterVertexSlider*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. JointVertexTransform 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CharacterJoint const *JointVertexTransform::get_joint(void) const
 *******************************************************************/
static PyObject *Dtool_JointVertexTransform_get_joint_31(PyObject *self, PyObject *args,PyObject *kwds) {
    JointVertexTransform * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_JointVertexTransform,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CharacterJoint const *JointVertexTransform::get_joint(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getJoint", key_word_list));
        else
            (PyArg_Parse(args, ":getJoint"));
        if(!PyErr_Occurred())
        {
            CharacterJoint const *return_value = ((const JointVertexTransform*)local_this)->get_joint();
            if (return_value != (CharacterJoint const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CharacterJoint,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getJoint(const JointVertexTransform this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_JointVertexTransform_get_joint_31_comment =
    "C++ Interface:\n"
    "getJoint(const JointVertexTransform this)\n"
    "\n"
    "// Filename: jointVertexTransform.I\n"
    "// Created by:  drose (24Mar05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: JointVertexTransform::get_joint\n"
    "//       Access: Published\n"
    "//  Description: Returns the joint for which this object returns the\n"
    "//               transform.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_JointVertexTransform_get_joint_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle JointVertexTransform::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_JointVertexTransform_get_class_type_32(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle JointVertexTransform::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = JointVertexTransform::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_JointVertexTransform_get_class_type_32_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_JointVertexTransform_get_class_type_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
 *******************************************************************/
int  Dtool_Init_JointVertexTransform(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"joint", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:JointVertexTransform", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:JointVertexTransform", &param0));
            if(!PyErr_Occurred())
            {
                CharacterJoint *param0_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    JointVertexTransform *return_value = new JointVertexTransform(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_JointVertexTransform,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "JointVertexTransform(non-const CharacterJoint joint)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_JointVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_JointVertexTransform)
    {
        printf("JointVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    JointVertexTransform * local_this = (JointVertexTransform *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_JointVertexTransform)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( VertexTransform *) local_this;
    if(requested_type == &Dtool_VertexTransform)
        return ( VertexTransform *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_JointVertexTransform(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_JointVertexTransform)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (JointVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (JointVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (JointVertexTransform*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (JointVertexTransform*)other_this;
    }
    if(from_type == &Dtool_VertexTransform)
    {
          VertexTransform* other_this = (VertexTransform*)from_this;
          return (JointVertexTransform*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Character 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CharacterJointBundle *Character::get_bundle(int i) const
 *******************************************************************/
static PyObject *Dtool_Character_get_bundle_36(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CharacterJointBundle *Character::get_bundle(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBundle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBundle", &param1));
        if(!PyErr_Occurred())
        {
            CharacterJointBundle *return_value = ((const Character*)local_this)->get_bundle((int)param1);
            if (return_value != (CharacterJointBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CharacterJointBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBundle(const Character this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_get_bundle_36_comment =
    "C++ Interface:\n"
    "getBundle(const Character this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::get_bundle\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_get_bundle_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle)
 * void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
 *******************************************************************/
static PyObject *Dtool_Character_merge_bundles_37(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"old_bundle_handle", (char *)"other_bundle_handle", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:mergeBundles", key_word_list, &param1, &param2))
            {
                PartBundleHandle *param1_this = (PartBundleHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundleHandle, 1, "Character.mergeBundles", 0, coerced_ptr, report_errors);
PartBundleHandle *param2_this = (PartBundleHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PartBundleHandle, 2, "Character.mergeBundles", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->merge_bundles(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"old_bundle", (char *)"other_bundle", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:mergeBundles", key_word_list, &param1, &param2))
            {
                PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "Character.mergeBundles", 0, coerced_ptr, report_errors);
PartBundle *param2_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PartBundle, 2, "Character.mergeBundles", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->merge_bundles(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mergeBundles(non-const Character this, non-const PartBundleHandle old_bundle_handle, non-const PartBundleHandle other_bundle_handle)\n"
          "mergeBundles(non-const Character this, non-const PartBundle old_bundle, non-const PartBundle other_bundle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_merge_bundles_37_comment =
    "C++ Interface:\n"
    "mergeBundles(non-const Character this, non-const PartBundleHandle old_bundle_handle, non-const PartBundleHandle other_bundle_handle)\n"
    "mergeBundles(non-const Character this, non-const PartBundle old_bundle, non-const PartBundle other_bundle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::merge_bundles\n"
    "//       Access: Published\n"
    "//  Description: Merges old_bundle with new_bundle.  old_bundle\n"
    "//               must be one of the PartBundles within this node.  At\n"
    "//               the end of this call, the old_bundle pointer within\n"
    "//               this node will be replaced with the new_bundle\n"
    "//               pointer, and all geometry within this node will be\n"
    "//               updated to reference new_bundle.\n"
    "//\n"
    "//               This method is deprecated.  Use the newer version of\n"
    "//               this method, below.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::merge_bundles\n"
    "//       Access: Published\n"
    "//  Description: Merges old_bundle_handle->get_bundle() with\n"
    "//               new_bundle.  old_bundle_handle must be one of the\n"
    "//               PartBundleHandle within this node.  At the end of\n"
    "//               this call, the bundle pointer within the\n"
    "//               old_bundle_handle will be replaced with that within\n"
    "//               the new_bundle_handle pointer, and all geometry\n"
    "//               within this node will be updated to reference\n"
    "//               new_bundle.\n"
    "//\n"
    "//               Normally, this is called when the two bundles have\n"
    "//               the same, or nearly the same, hierarchies.  In this\n"
    "//               case, new_bundle will simply be assigned over the\n"
    "//               old_bundle position.  However, if any joints are\n"
    "//               present in one bundle or the other, new_bundle will\n"
    "//               be modified to contain the union of all joints.\n"
    "//               \n"
    "//               The geometry below this node is also updated to\n"
    "//               reference new_bundle, instead of the original\n"
    "//               old_bundle.\n"
    "//\n"
    "//               This method is intended to unify two different models\n"
    "//               that share a common skeleton, for instance, different\n"
    "//               LOD's of the same model.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_merge_bundles_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::set_lod_animation(LPoint3f const &center, float far_distance, float near_distance, float delay_factor)
 *******************************************************************/
static PyObject *Dtool_Character_set_lod_animation_38(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Character::set_lod_animation(LPoint3f const &center, float far_distance, float near_distance, float delay_factor)
            PyObject *param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"center", (char *)"far_distance", (char *)"near_distance", (char *)"delay_factor", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddd:setLodAnimation", key_word_list, &param1, &param2, &param3, &param4))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Character.setLodAnimation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_lod_animation(*param1_this, (float)param2, (float)param3, (float)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Character.setLodAnimation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLodAnimation(non-const Character this, const Point3 center, float far_distance, float near_distance, float delay_factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_set_lod_animation_38_comment =
    "C++ Interface:\n"
    "setLodAnimation(non-const Character this, const Point3 center, float far_distance, float near_distance, float delay_factor)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::set_lod_animation\n"
    "//       Access: Published\n"
    "//  Description: Activates a special mode in which the character\n"
    "//               animates less frequently as it gets further from the\n"
    "//               camera.  This is intended as a simple optimization to\n"
    "//               minimize the effort of computing animation for lots\n"
    "//               of characters that may not necessarily be very\n"
    "//               important to animate every frame.\n"
    "//\n"
    "//               If the character is closer to the camera than\n"
    "//               near_distance, then it is animated its normal rate,\n"
    "//               every frame.  If the character is exactly\n"
    "//               far_distance away, it is animated only every\n"
    "//               delay_factor seconds (which should be a number\n"
    "//               greater than 0).  If the character is between\n"
    "//               near_distance and far_distance, its animation rate is\n"
    "//               linearly interpolated according to its distance\n"
    "//               between the two.  The interpolation function\n"
    "//               continues beyond far_distance, so that the character\n"
    "//               is animated increasingly less frequently as it gets\n"
    "//               farther away.\n"
    "//\n"
    "//               The distance calculations are made from center, which\n"
    "//               is a fixed point relative to the character node, to\n"
    "//               the camera's lod center or cull center node (or to\n"
    "//               the camera node itself).\n"
    "//\n"
    "//               If multiple cameras are viewing the character in any\n"
    "//               given frame, the closest one counts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_set_lod_animation_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::clear_lod_animation(void)
 *******************************************************************/
static PyObject *Dtool_Character_clear_lod_animation_39(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Character::clear_lod_animation(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLodAnimation", key_word_list));
        else
            (PyArg_Parse(args, ":clearLodAnimation"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_lod_animation();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Character.clearLodAnimation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLodAnimation(non-const Character this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_clear_lod_animation_39_comment =
    "C++ Interface:\n"
    "clearLodAnimation(non-const Character this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::clear_lod_animation\n"
    "//       Access: Published\n"
    "//  Description: Undoes the effect of a recent call to\n"
    "//               set_lod_animation().  Henceforth, the character will\n"
    "//               animate every frame, regardless of its distance from\n"
    "//               the camera.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_clear_lod_animation_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterJoint *Character::find_joint(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_Character_find_joint_40(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-CharacterJoint *Character::find_joint(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findJoint", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findJoint", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            CharacterJoint *return_value = ((const Character*)local_this)->find_joint(basic_string<char>(param1_str, param1_len));
            if (return_value != (CharacterJoint *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CharacterJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findJoint(const Character this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_find_joint_40_comment =
    "C++ Interface:\n"
    "findJoint(const Character this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::find_joint\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the joint with the given name,\n"
    "//               if there is such a joint, or NULL if there is no such\n"
    "//               joint.  This will not return a pointer to a slider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_find_joint_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterSlider *Character::find_slider(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_Character_find_slider_41(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-CharacterSlider *Character::find_slider(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findSlider", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findSlider", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            CharacterSlider *return_value = ((const Character*)local_this)->find_slider(basic_string<char>(param1_str, param1_len));
            if (return_value != (CharacterSlider *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CharacterSlider,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findSlider(const Character this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_find_slider_41_comment =
    "C++ Interface:\n"
    "findSlider(const Character this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::find_slider\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the slider with the given name,\n"
    "//               if there is such a slider, or NULL if there is no such\n"
    "//               slider.  This will not return a pointer to a joint.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_find_slider_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::write_parts(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Character_write_parts_42(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Character::write_parts(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeParts", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeParts", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Character.writeParts", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Character*)local_this)->write_parts(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeParts(const Character this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_write_parts_42_comment =
    "C++ Interface:\n"
    "writeParts(const Character this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::write_parts\n"
    "//       Access: Published\n"
    "//  Description: Writes a list of the Character's joints and sliders,\n"
    "//               in their hierchical structure, to the indicated\n"
    "//               output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_write_parts_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::write_part_values(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Character_write_part_values_43(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Character::write_part_values(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePartValues", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writePartValues", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Character.writePartValues", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Character*)local_this)->write_part_values(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writePartValues(const Character this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_write_part_values_43_comment =
    "C++ Interface:\n"
    "writePartValues(const Character this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::write_part_values\n"
    "//       Access: Published\n"
    "//  Description: Writes a list of the Character's joints and sliders,\n"
    "//               along with each current position, in their hierchical\n"
    "//               structure, to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_write_part_values_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::update_to_now(void)
 *******************************************************************/
static PyObject *Dtool_Character_update_to_now_44(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Character::update_to_now(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":updateToNow", key_word_list));
        else
            (PyArg_Parse(args, ":updateToNow"));
        if(!PyErr_Occurred())
        {
            (local_this)->update_to_now();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Character.updateToNow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateToNow(non-const Character this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_update_to_now_44_comment =
    "C++ Interface:\n"
    "updateToNow(non-const Character this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::update_to_now\n"
    "//       Access: Published\n"
    "//  Description: Advances the character's frame to the current time,\n"
    "//               and then calls update().  This can be used by show\n"
    "//               code to force an update of the character's position\n"
    "//               to the current frame, regardless of whether the\n"
    "//               character is currently onscreen and animating.\n"
    "//\n"
    "//               This method is deprecated.  Call update() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_update_to_now_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::update(void)
 *******************************************************************/
static PyObject *Dtool_Character_update_45(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Character::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Character.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const Character this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_update_45_comment =
    "C++ Interface:\n"
    "update(non-const Character this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::update\n"
    "//       Access: Published\n"
    "//  Description: Recalculates the Character's joints and vertices for\n"
    "//               the current frame.  Normally this is performed\n"
    "//               automatically during the render and need not be\n"
    "//               called explicitly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_update_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Character::force_update(void)
 *******************************************************************/
static PyObject *Dtool_Character_force_update_46(PyObject *self, PyObject *args,PyObject *kwds) {
    Character * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Character,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Character::force_update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":forceUpdate", key_word_list));
        else
            (PyArg_Parse(args, ":forceUpdate"));
        if(!PyErr_Occurred())
        {
            (local_this)->force_update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Character.forceUpdate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceUpdate(non-const Character this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_force_update_46_comment =
    "C++ Interface:\n"
    "forceUpdate(non-const Character this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Character::force_update\n"
    "//       Access: Published\n"
    "//  Description: Recalculates the character even if we think it\n"
    "//               doesn't need it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Character_force_update_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Character::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Character_get_class_type_47(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Character::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Character::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Character_get_class_type_47_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Character_get_class_type_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Character::Character(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_Character(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Character::Character(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Character", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:Character", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Character *return_value = new Character(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Character,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Character(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Character(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Character)
    {
        printf("Character ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Character * local_this = (Character *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Character)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PartBundleNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PartBundleNode *) local_this;
    if(requested_type == &Dtool_PartBundleNode)
        return ( PartBundleNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PartBundleNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PartBundleNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PartBundleNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Character(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Character)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Character*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Character*)other_this;
    }
    if(from_type == &Dtool_PartBundleNode)
    {
          PartBundleNode* other_this = (PartBundleNode*)from_this;
          return (Character*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Character*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Character*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CharacterJointBundle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Character *CharacterJointBundle::get_node(int n) const
 *******************************************************************/
static PyObject *Dtool_CharacterJointBundle_get_node_51(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJointBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJointBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Character *CharacterJointBundle::get_node(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNode", &param1));
        if(!PyErr_Occurred())
        {
            Character *return_value = ((const CharacterJointBundle*)local_this)->get_node((int)param1);
            if (return_value != (Character *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Character,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CharacterJointBundle this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJointBundle_get_node_51_comment =
    "C++ Interface:\n"
    "getNode(const CharacterJointBundle this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJointBundle::get_node\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth Character associated with\n"
    "//               this PartBundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJointBundle_get_node_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CharacterJointBundle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJointBundle_get_class_type_52(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CharacterJointBundle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CharacterJointBundle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJointBundle_get_class_type_52_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CharacterJointBundle_get_class_type_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CharacterJointBundle::CharacterJointBundle(basic_string< char > const &name)
 * CharacterJointBundle::CharacterJointBundle(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_CharacterJointBundle(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-CharacterJointBundle::CharacterJointBundle(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CharacterJointBundle", key_word_list))
            {
                CharacterJointBundle *return_value = new CharacterJointBundle();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CharacterJointBundle,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-CharacterJointBundle::CharacterJointBundle(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CharacterJointBundle", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:CharacterJointBundle", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                CharacterJointBundle *return_value = new CharacterJointBundle(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CharacterJointBundle,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CharacterJointBundle() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CharacterJointBundle()\n"
          "CharacterJointBundle(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CharacterJointBundle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CharacterJointBundle)
    {
        printf("CharacterJointBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CharacterJointBundle * local_this = (CharacterJointBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CharacterJointBundle)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( PartBundle *) local_this;
    if(requested_type == &Dtool_PartBundle)
        return ( PartBundle *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( PartBundle *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( PartBundle *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( PartBundle *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( PartBundle *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( PartBundle *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CharacterJointBundle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CharacterJointBundle)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_PartBundle)
    {
          PartBundle* other_this = (PartBundle*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CharacterJointBundle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CharacterJointEffect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
 *******************************************************************/
static PyObject *Dtool_CharacterJointEffect_make_55(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"character", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:make", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:make", &param0));
            if(!PyErr_Occurred())
            {
                Character *param0_this = (Character *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Character, 0, "CharacterJointEffect.make", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerTo< RenderEffect > return_value = CharacterJointEffect::make(param0_this);
                    if (return_value != (RenderEffect const *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_RenderEffect,true, true, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "make(non-const Character character)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJointEffect_make_55_comment =
    "C++ Interface:\n"
    "make(non-const Character character)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJointEffect::make\n"
    "//       Access: Published, Static\n"
    "//  Description: Constructs a new CharacterJointEffect object that\n"
    "//               references the indicated character.  When a relative\n"
    "//               get_transform() is called on the node that contains\n"
    "//               the CharacterJointEffect, it will implicitly call\n"
    "//               character->update() first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJointEffect_make_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Character *CharacterJointEffect::get_character(void) const
 *******************************************************************/
static PyObject *Dtool_CharacterJointEffect_get_character_56(PyObject *self, PyObject *args,PyObject *kwds) {
    CharacterJointEffect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CharacterJointEffect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Character *CharacterJointEffect::get_character(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCharacter", key_word_list));
        else
            (PyArg_Parse(args, ":getCharacter"));
        if(!PyErr_Occurred())
        {
            Character *return_value = ((const CharacterJointEffect*)local_this)->get_character();
            if (return_value != (Character *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Character,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCharacter(const CharacterJointEffect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJointEffect_get_character_56_comment =
    "C++ Interface:\n"
    "getCharacter(const CharacterJointEffect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CharacterJointEffect::get_character\n"
    "//       Access: Published\n"
    "//  Description: Returns the Character that will get update() called\n"
    "//               on it when this node's relative transform is queried,\n"
    "//               or NULL if there is no such character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CharacterJointEffect_get_character_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CharacterJointEffect::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CharacterJointEffect_get_class_type_57(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CharacterJointEffect::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CharacterJointEffect::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CharacterJointEffect_get_class_type_57_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CharacterJointEffect_get_class_type_57_comment = NULL;
#endif

int  Dtool_Init_CharacterJointEffect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CharacterJointEffect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CharacterJointEffect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CharacterJointEffect)
    {
        printf("CharacterJointEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CharacterJointEffect * local_this = (CharacterJointEffect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CharacterJointEffect)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( RenderEffect *) local_this;
    if(requested_type == &Dtool_RenderEffect)
        return ( RenderEffect *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( RenderEffect *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( RenderEffect *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( RenderEffect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CharacterJointEffect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CharacterJointEffect)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CharacterJointEffect*)other_this;
    }
    if(from_type == &Dtool_RenderEffect)
    {
          RenderEffect* other_this = (RenderEffect*)from_this;
          return (CharacterJointEffect*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CharacterJointEffect*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CharacterJointEffect*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CharacterJointEffect*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CharacterJoint | CharacterJoint
//********************************************************************
PyMethodDef Dtool_Methods_CharacterJoint[]= {
  { "addNetTransform",(PyCFunction ) &Dtool_CharacterJoint_add_net_transform_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_add_net_transform_4_comment},
  { "removeNetTransform",(PyCFunction ) &Dtool_CharacterJoint_remove_net_transform_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_remove_net_transform_5_comment},
  { "hasNetTransform",(PyCFunction ) &Dtool_CharacterJoint_has_net_transform_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_has_net_transform_6_comment},
  { "clearNetTransforms",(PyCFunction ) &Dtool_CharacterJoint_clear_net_transforms_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_clear_net_transforms_7_comment},
  { "getNetTransforms",(PyCFunction ) &Dtool_CharacterJoint_get_net_transforms_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_net_transforms_8_comment},
  { "addLocalTransform",(PyCFunction ) &Dtool_CharacterJoint_add_local_transform_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_add_local_transform_9_comment},
  { "removeLocalTransform",(PyCFunction ) &Dtool_CharacterJoint_remove_local_transform_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_remove_local_transform_10_comment},
  { "hasLocalTransform",(PyCFunction ) &Dtool_CharacterJoint_has_local_transform_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_has_local_transform_11_comment},
  { "clearLocalTransforms",(PyCFunction ) &Dtool_CharacterJoint_clear_local_transforms_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_clear_local_transforms_12_comment},
  { "getLocalTransforms",(PyCFunction ) &Dtool_CharacterJoint_get_local_transforms_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_local_transforms_13_comment},
  { "getTransform",(PyCFunction ) &Dtool_CharacterJoint_get_transform_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_transform_14_comment},
  { "getNetTransform",(PyCFunction ) &Dtool_CharacterJoint_get_net_transform_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_net_transform_15_comment},
  { "getCharacter",(PyCFunction ) &Dtool_CharacterJoint_get_character_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_character_16_comment},
  { "getClassType",(PyCFunction ) &Dtool_CharacterJoint_get_class_type_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJoint_get_class_type_17_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CharacterJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CharacterJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CharacterJoint\n"
          "// Description : This represents one joint of the character's\n"
          "//               animation, containing an animating transform matrix.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovingPartMatrix._Dtool_ClassInit(NULL);
        Dtool_CharacterJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPartMatrix.As_PyTypeObject());
        Dtool_CharacterJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CharacterJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CharacterJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CharacterJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CharacterJoint)");
             printf(" Error In PyType_ReadyCharacterJoint");
             return;
        }
        Py_INCREF(&Dtool_CharacterJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CharacterJoint.As_PyTypeObject().tp_dict,"CharacterJoint",&Dtool_CharacterJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CharacterJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CharacterJoint[13],&Dtool_CharacterJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CharacterJoint,CharacterJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CharacterJoint.As_PyTypeObject());
        PyModule_AddObject(module, "CharacterJoint",(PyObject *)&Dtool_CharacterJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CharacterSlider | CharacterSlider
//********************************************************************
PyMethodDef Dtool_Methods_CharacterSlider[]= {
  { "updateInternals",(PyCFunction ) &Dtool_CharacterSlider_update_internals_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterSlider_update_internals_21_comment},
  { "getClassType",(PyCFunction ) &Dtool_CharacterSlider_get_class_type_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterSlider_get_class_type_22_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CharacterSlider(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CharacterSlider.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CharacterSlider\n"
          "// Description : This is a morph slider within the character.  It's\n"
          "//               simply a single floating-point value that animates\n"
          "//               generally between 0 and 1, that controls the effects\n"
          "//               of one or more morphs within the character.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovingPartScalar._Dtool_ClassInit(NULL);
        Dtool_CharacterSlider.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPartScalar.As_PyTypeObject());
        Dtool_CharacterSlider.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CharacterSlider.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CharacterSlider.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CharacterSlider.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CharacterSlider)");
             printf(" Error In PyType_ReadyCharacterSlider");
             return;
        }
        Py_INCREF(&Dtool_CharacterSlider.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CharacterSlider.As_PyTypeObject().tp_dict,"CharacterSlider",&Dtool_CharacterSlider.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CharacterSlider.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CharacterSlider[1],&Dtool_CharacterSlider.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CharacterSlider,CharacterSlider::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CharacterSlider.As_PyTypeObject());
        PyModule_AddObject(module, "CharacterSlider",(PyObject *)&Dtool_CharacterSlider.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CharacterVertexSlider | CharacterVertexSlider
//********************************************************************
PyMethodDef Dtool_Methods_CharacterVertexSlider[]= {
  { "getCharSlider",(PyCFunction ) &Dtool_CharacterVertexSlider_get_char_slider_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterVertexSlider_get_char_slider_26_comment},
  { "getClassType",(PyCFunction ) &Dtool_CharacterVertexSlider_get_class_type_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterVertexSlider_get_class_type_27_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CharacterVertexSlider(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CharacterVertexSlider.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CharacterVertexSlider\n"
          "// Description : This is a specialization on VertexSlider that\n"
          "//               returns the slider value associated with a particular\n"
          "//               CharacterSlider object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VertexSlider._Dtool_ClassInit(NULL);
        Dtool_CharacterVertexSlider.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VertexSlider.As_PyTypeObject());
        Dtool_CharacterVertexSlider.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CharacterVertexSlider.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CharacterVertexSlider.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CharacterVertexSlider.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CharacterVertexSlider)");
             printf(" Error In PyType_ReadyCharacterVertexSlider");
             return;
        }
        Py_INCREF(&Dtool_CharacterVertexSlider.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CharacterVertexSlider.As_PyTypeObject().tp_dict,"CharacterVertexSlider",&Dtool_CharacterVertexSlider.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CharacterVertexSlider.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CharacterVertexSlider[1],&Dtool_CharacterVertexSlider.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CharacterVertexSlider,CharacterVertexSlider::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CharacterVertexSlider.As_PyTypeObject());
        PyModule_AddObject(module, "CharacterVertexSlider",(PyObject *)&Dtool_CharacterVertexSlider.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. JointVertexTransform | JointVertexTransform
//********************************************************************
PyMethodDef Dtool_Methods_JointVertexTransform[]= {
  { "getJoint",(PyCFunction ) &Dtool_JointVertexTransform_get_joint_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_JointVertexTransform_get_joint_31_comment},
  { "getClassType",(PyCFunction ) &Dtool_JointVertexTransform_get_class_type_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_JointVertexTransform_get_class_type_32_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_JointVertexTransform(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_JointVertexTransform.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : JointVertexTransform\n"
          "// Description : This is a specialization on VertexTransform that\n"
          "//               returns the transform necessary to move vertices as\n"
          "//               if they were assigned to the indicated joint.  The\n"
          "//               geometry itself should be parented to the scene graph\n"
          "//               at the level of the character's root joint; that is,\n"
          "//               it should not be parented under a node directly\n"
          "//               animated by any joints.\n"
          "//\n"
          "//               Multiple combinations of these with different weights\n"
          "//               are used to implement soft-skinned vertices for an\n"
          "//               animated character.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_VertexTransform._Dtool_ClassInit(NULL);
        Dtool_JointVertexTransform.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_VertexTransform.As_PyTypeObject());
        Dtool_JointVertexTransform.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_JointVertexTransform.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_JointVertexTransform.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_JointVertexTransform.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(JointVertexTransform)");
             printf(" Error In PyType_ReadyJointVertexTransform");
             return;
        }
        Py_INCREF(&Dtool_JointVertexTransform.As_PyTypeObject());
        PyDict_SetItemString(Dtool_JointVertexTransform.As_PyTypeObject().tp_dict,"JointVertexTransform",&Dtool_JointVertexTransform.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_JointVertexTransform.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_JointVertexTransform[1],&Dtool_JointVertexTransform.As_PyObject()));
        RegisterRuntimeClass(&Dtool_JointVertexTransform,JointVertexTransform::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_JointVertexTransform.As_PyTypeObject());
        PyModule_AddObject(module, "JointVertexTransform",(PyObject *)&Dtool_JointVertexTransform.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Character | Character
//********************************************************************
PyMethodDef Dtool_Methods_Character[]= {
  { "getBundle",(PyCFunction ) &Dtool_Character_get_bundle_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_get_bundle_36_comment},
  { "mergeBundles",(PyCFunction ) &Dtool_Character_merge_bundles_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_merge_bundles_37_comment},
  { "setLodAnimation",(PyCFunction ) &Dtool_Character_set_lod_animation_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_set_lod_animation_38_comment},
  { "clearLodAnimation",(PyCFunction ) &Dtool_Character_clear_lod_animation_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_clear_lod_animation_39_comment},
  { "findJoint",(PyCFunction ) &Dtool_Character_find_joint_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_find_joint_40_comment},
  { "findSlider",(PyCFunction ) &Dtool_Character_find_slider_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_find_slider_41_comment},
  { "writeParts",(PyCFunction ) &Dtool_Character_write_parts_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_write_parts_42_comment},
  { "writePartValues",(PyCFunction ) &Dtool_Character_write_part_values_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_write_part_values_43_comment},
  { "updateToNow",(PyCFunction ) &Dtool_Character_update_to_now_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_update_to_now_44_comment},
  { "update",(PyCFunction ) &Dtool_Character_update_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_update_45_comment},
  { "forceUpdate",(PyCFunction ) &Dtool_Character_force_update_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_force_update_46_comment},
  { "getClassType",(PyCFunction ) &Dtool_Character_get_class_type_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Character_get_class_type_47_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Character(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Character.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Character\n"
          "// Description : An animated character, with skeleton-morph animation\n"
          "//               and either soft-skinned or hard-skinned vertices.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PartBundleNode._Dtool_ClassInit(NULL);
        Dtool_Character.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PartBundleNode.As_PyTypeObject());
        Dtool_Character.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Character.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Character.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Character.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Character)");
             printf(" Error In PyType_ReadyCharacter");
             return;
        }
        Py_INCREF(&Dtool_Character.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Character.As_PyTypeObject().tp_dict,"Character",&Dtool_Character.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Character.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Character[11],&Dtool_Character.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Character,Character::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Character.As_PyTypeObject());
        PyModule_AddObject(module, "Character",(PyObject *)&Dtool_Character.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CharacterJointBundle | CharacterJointBundle
//********************************************************************
PyMethodDef Dtool_Methods_CharacterJointBundle[]= {
  { "getNode",(PyCFunction ) &Dtool_CharacterJointBundle_get_node_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJointBundle_get_node_51_comment},
  { "getClassType",(PyCFunction ) &Dtool_CharacterJointBundle_get_class_type_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJointBundle_get_class_type_52_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CharacterJointBundle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CharacterJointBundle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CharacterJointBundle\n"
          "// Description : The collection of all the joints and sliders in the\n"
          "//               character.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PartBundle._Dtool_ClassInit(NULL);
        Dtool_CharacterJointBundle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PartBundle.As_PyTypeObject());
        Dtool_CharacterJointBundle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CharacterJointBundle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CharacterJointBundle.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CharacterJointBundle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CharacterJointBundle)");
             printf(" Error In PyType_ReadyCharacterJointBundle");
             return;
        }
        Py_INCREF(&Dtool_CharacterJointBundle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CharacterJointBundle.As_PyTypeObject().tp_dict,"CharacterJointBundle",&Dtool_CharacterJointBundle.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CharacterJointBundle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CharacterJointBundle[1],&Dtool_CharacterJointBundle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CharacterJointBundle,CharacterJointBundle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CharacterJointBundle.As_PyTypeObject());
        PyModule_AddObject(module, "CharacterJointBundle",(PyObject *)&Dtool_CharacterJointBundle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CharacterJointEffect | CharacterJointEffect
//********************************************************************
PyMethodDef Dtool_Methods_CharacterJointEffect[]= {
  { "make",(PyCFunction ) &Dtool_CharacterJointEffect_make_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJointEffect_make_55_comment},
  { "getCharacter",(PyCFunction ) &Dtool_CharacterJointEffect_get_character_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJointEffect_get_character_56_comment},
  { "getClassType",(PyCFunction ) &Dtool_CharacterJointEffect_get_class_type_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CharacterJointEffect_get_class_type_57_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CharacterJointEffect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CharacterJointEffect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CharacterJointEffect\n"
          "// Description : This effect will be added automatically to a node by\n"
          "//               CharacterJoint::add_net_transform() and\n"
          "//               CharacterJoint::add_local_transform().\n"
          "//\n"
          "//               The effect binds the node back to the character, so\n"
          "//               that querying the relative transform of the affected\n"
          "//               node will automatically force the indicated character\n"
          "//               to be updated first.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_RenderEffect._Dtool_ClassInit(NULL);
        Dtool_CharacterJointEffect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_RenderEffect.As_PyTypeObject());
        Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CharacterJointEffect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CharacterJointEffect)");
             printf(" Error In PyType_ReadyCharacterJointEffect");
             return;
        }
        Py_INCREF(&Dtool_CharacterJointEffect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict,"CharacterJointEffect",&Dtool_CharacterJointEffect.As_PyObject());
        //  Static Method make
        PyDict_SetItemString(Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict,"make",PyCFunction_New(&Dtool_Methods_CharacterJointEffect[0],&Dtool_CharacterJointEffect.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CharacterJointEffect.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CharacterJointEffect[2],&Dtool_CharacterJointEffect.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CharacterJointEffect,CharacterJointEffect::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CharacterJointEffect.As_PyTypeObject());
        PyModule_AddObject(module, "CharacterJointEffect",(PyObject *)&Dtool_CharacterJointEffect.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CharacterJoint
//********************************************************************
   Dtool_PyModuleClassInit_CharacterJoint(module);
//********************************************************************
//*** Module Init Updcall ..CharacterSlider
//********************************************************************
   Dtool_PyModuleClassInit_CharacterSlider(module);
//********************************************************************
//*** Module Init Updcall ..CharacterVertexSlider
//********************************************************************
   Dtool_PyModuleClassInit_CharacterVertexSlider(module);
//********************************************************************
//*** Module Init Updcall ..JointVertexTransform
//********************************************************************
   Dtool_PyModuleClassInit_JointVertexTransform(module);
//********************************************************************
//*** Module Init Updcall ..Character
//********************************************************************
   Dtool_PyModuleClassInit_Character(module);
//********************************************************************
//*** Module Init Updcall ..CharacterJointBundle
//********************************************************************
   Dtool_PyModuleClassInit_CharacterJointBundle(module);
//********************************************************************
//*** Module Init Updcall ..CharacterJointEffect
//********************************************************************
   Dtool_PyModuleClassInit_CharacterJointEffect(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libchar_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212864,  /* file_identifier */
  "libchar",  /* library_name */
  "nRYR",  /* library_hash_name */
  "panda",  /* module_name */
  "libchar.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  161  /* next_index */
};

Configure(_in_configure_libchar);
ConfigureFn(_in_configure_libchar) {
  interrogate_request_module(&_in_module_def);
}

