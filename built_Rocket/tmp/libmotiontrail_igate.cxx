/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/motiontrail -Idirect/src/motiontrail -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libmotiontrail_igate.cxx -od built_Rocket/pandac/input/libmotiontrail.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/motiontrail -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libmotiontrail cMotionTrail.cxx cMotionTrail.h config_motiontrail.cxx config_motiontrail.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libmotiontrail
#include "py_panda.h"  

#include "cMotionTrail.h"
#include "colorAttrib.h"
#include "config_motiontrail.h"
#include "dconfig.h"
#include "directbase.h"
#include "renderState.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CMotionTrail
//********************************************************************
typedef  CMotionTrail  CMotionTrail_localtype;
Define_Module_ClassRef(p3direct,CMotionTrail,CMotionTrail_localtype,CMotionTrail);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CMotionTrail 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::reset(void)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_reset_4(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMotionTrail::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMotionTrail.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const CMotionTrail this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_reset_4_comment =
    "C++ Interface:\n"
    "reset(non-const CMotionTrail this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::reset\n"
    "//       Access: Published\n"
    "//  Description: Reset the frame sample history.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_reset_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::reset_vertex_list(void)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_reset_vertex_list_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMotionTrail::reset_vertex_list(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetVertexList", key_word_list));
        else
            (PyArg_Parse(args, ":resetVertexList"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_vertex_list();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMotionTrail.resetVertexList() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetVertexList(non-const CMotionTrail this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_reset_vertex_list_5_comment =
    "C++ Interface:\n"
    "resetVertexList(non-const CMotionTrail this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::reset_vertex_list\n"
    "//       Access: Published\n"
    "//  Description: Reset the vertex list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_reset_vertex_list_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::enable(bool enable)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_enable_6(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMotionTrail::enable(bool enable)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"enable", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:enable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:enable", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->enable((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMotionTrail.enable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enable(non-const CMotionTrail this, bool enable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_enable_6_comment =
    "C++ Interface:\n"
    "enable(non-const CMotionTrail this, bool enable)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::enable\n"
    "//       Access: Published\n"
    "//  Description: Enable/disable the motion trail.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_enable_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::set_geom_node(PointerTo< GeomNode > geom_node)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_set_geom_node_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMotionTrail::set_geom_node(PointerTo< GeomNode > geom_node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom_node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGeomNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setGeomNode", &param1));
            if(!PyErr_Occurred())
            {
                GeomNode *param1_this = (GeomNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GeomNode, 1, "CMotionTrail.setGeomNode", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_geom_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMotionTrail.setGeomNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGeomNode(non-const CMotionTrail this, const GeomNode geom_node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_set_geom_node_7_comment =
    "C++ Interface:\n"
    "setGeomNode(non-const CMotionTrail this, const GeomNode geom_node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::set_geom_node\n"
    "//       Access: Published\n"
    "//  Description: Set the GeomNode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_set_geom_node_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::add_vertex(LVector4f *vertex, LVector4f *start_color, LVector4f *end_color, float v)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_add_vertex_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMotionTrail::add_vertex(LVector4f *vertex, LVector4f *start_color, LVector4f *end_color, float v)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            double param4;
            static char * key_word_list[] = {(char *)"vertex", (char *)"start_color", (char *)"end_color", (char *)"v", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOd:addVertex", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVector4f *param1_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector4f, 1, "CMotionTrail.addVertex", 0, coerced_ptr, report_errors);
LVector4f *param2_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector4f, 2, "CMotionTrail.addVertex", 0, coerced_ptr, report_errors);
LVector4f *param3_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector4f, 3, "CMotionTrail.addVertex", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    (local_this)->add_vertex(param1_this, param2_this, param3_this, (float)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMotionTrail.addVertex() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addVertex(non-const CMotionTrail this, non-const Vec4 vertex, non-const Vec4 start_color, non-const Vec4 end_color, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_add_vertex_8_comment =
    "C++ Interface:\n"
    "addVertex(non-const CMotionTrail this, non-const Vec4 vertex, non-const Vec4 start_color, non-const Vec4 end_color, float v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::add_vertex\n"
    "//       Access: Published\n"
    "//  Description: Add a vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_add_vertex_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::set_parameters(float sampling_time, float time_window, bool use_texture, bool calculate_relative_matrix, bool use_nurbs, float resolution_distance)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_set_parameters_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMotionTrail::set_parameters(float sampling_time, float time_window, bool use_texture, bool calculate_relative_matrix, bool use_nurbs, float resolution_distance)
        double param1;
        double param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        double param6;
        static char * key_word_list[] = {(char *)"sampling_time", (char *)"time_window", (char *)"use_texture", (char *)"calculate_relative_matrix", (char *)"use_nurbs", (char *)"resolution_distance", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOOd:setParameters", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
        {
            (local_this)->set_parameters((float)param1, (float)param2, (PyObject_IsTrue(param3)!=0), (PyObject_IsTrue(param4)!=0), (PyObject_IsTrue(param5)!=0), (float)param6);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMotionTrail.setParameters() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParameters(non-const CMotionTrail this, float sampling_time, float time_window, bool use_texture, bool calculate_relative_matrix, bool use_nurbs, float resolution_distance)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_set_parameters_9_comment =
    "C++ Interface:\n"
    "setParameters(non-const CMotionTrail this, float sampling_time, float time_window, bool use_texture, bool calculate_relative_matrix, bool use_nurbs, float resolution_distance)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::set_parameters\n"
    "//       Access: Published\n"
    "//  Description: Set motion trail parameters.\n"
    "//\n"
    "//               sampling_time = Can be used to specify a lower \n"
    "//               sampling rate than the frame rate. Use 0.0 with \n"
    "//               nurbs. \n"
    "//\n"
    "//               time_window = a component for the \"length\" of the \n"
    "//               motion trail.  The motion trail length = \n"
    "//               time_window * velocity of the object.\n"
    "//\n"
    "//               use_texture = texture option on/off.\n"
    "//\n"
    "//               calculate_relative_matrix = calculate relative \n"
    "//               matrix on/off.\n"
    "//\n"
    "//               use_nurbs = nurbs option on/off\n"
    "//\n"
    "//               resolution_distance = the distance used to \n"
    "//               determine the number of geometry samples. \n"
    "//               samples = motion trail length / resolution_distance.\n"
    "//               Applicable only if nurbs is on.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_set_parameters_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CMotionTrail::check_for_update(float current_time)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_check_for_update_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CMotionTrail::check_for_update(float current_time)
        double param1;
        static char * key_word_list[] = {(char *)"current_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:checkForUpdate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:checkForUpdate", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->check_for_update((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMotionTrail.checkForUpdate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkForUpdate(non-const CMotionTrail this, float current_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_check_for_update_10_comment =
    "C++ Interface:\n"
    "checkForUpdate(non-const CMotionTrail this, float current_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::check_for_update\n"
    "//       Access: Published\n"
    "//  Description: Check if a sample can be submitted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_check_for_update_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMotionTrail::update_motion_trail(float current_time, LMatrix4f *transform)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_update_motion_trail_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CMotionTrail * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMotionTrail,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMotionTrail::update_motion_trail(float current_time, LMatrix4f *transform)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"current_time", (char *)"transform", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:updateMotionTrail", key_word_list, &param1, &param2))
            {
                LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "CMotionTrail.updateMotionTrail", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->update_motion_trail((float)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMotionTrail.updateMotionTrail() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateMotionTrail(non-const CMotionTrail this, float current_time, non-const Mat4 transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_update_motion_trail_11_comment =
    "C++ Interface:\n"
    "updateMotionTrail(non-const CMotionTrail this, float current_time, non-const Mat4 transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMotionTrail::update_motion_trail\n"
    "//       Access: Published\n"
    "//  Description: See class header comments.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMotionTrail_update_motion_trail_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CMotionTrail::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CMotionTrail_get_class_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CMotionTrail::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CMotionTrail::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMotionTrail_get_class_type_12_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CMotionTrail_get_class_type_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CMotionTrail::CMotionTrail(void)
 *******************************************************************/
int  Dtool_Init_CMotionTrail(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CMotionTrail::CMotionTrail(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CMotionTrail", key_word_list))
        {
            CMotionTrail *return_value = new CMotionTrail();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CMotionTrail,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CMotionTrail()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CMotionTrail(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CMotionTrail)
    {
        printf("CMotionTrail ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CMotionTrail * local_this = (CMotionTrail *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CMotionTrail)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CMotionTrail(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CMotionTrail)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CMotionTrail*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CMotionTrail*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CMotionTrail*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CMotionTrail | CMotionTrail
//********************************************************************
PyMethodDef Dtool_Methods_CMotionTrail[]= {
  { "reset",(PyCFunction ) &Dtool_CMotionTrail_reset_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_reset_4_comment},
  { "resetVertexList",(PyCFunction ) &Dtool_CMotionTrail_reset_vertex_list_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_reset_vertex_list_5_comment},
  { "enable",(PyCFunction ) &Dtool_CMotionTrail_enable_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_enable_6_comment},
  { "setGeomNode",(PyCFunction ) &Dtool_CMotionTrail_set_geom_node_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_set_geom_node_7_comment},
  { "addVertex",(PyCFunction ) &Dtool_CMotionTrail_add_vertex_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_add_vertex_8_comment},
  { "setParameters",(PyCFunction ) &Dtool_CMotionTrail_set_parameters_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_set_parameters_9_comment},
  { "checkForUpdate",(PyCFunction ) &Dtool_CMotionTrail_check_for_update_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_check_for_update_10_comment},
  { "updateMotionTrail",(PyCFunction ) &Dtool_CMotionTrail_update_motion_trail_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_update_motion_trail_11_comment},
  { "getClassType",(PyCFunction ) &Dtool_CMotionTrail_get_class_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMotionTrail_get_class_type_12_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CMotionTrail(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CMotionTrail.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CMotionTrail\n"
          "// Description : The method used in creating the motion trail is \n"
          "//               based on taking samples of time and transformations \n"
          "//               (the position and orientation matrix) in real-time.\n"
          "//               The method also requires a number of vertices \n"
          "//               (positions) that determines \"shape\" of the motion \n"
          "//               trail (i.e. the edge of a blade).  A start color \n"
          "//               and end color is also required for each vertex. \n"
          "//               The color is interpolated as function of time.\n"
          "//               The colors are typically used to fade the motion\n"
          "//               trail so the end color is typically black.\n"
          "//\n"
          "//               The vertices are submitted via the \"add_vertex\" \n"
          "//               function.  For each frame, a sample is submited via \n"
          "//               the \"update_motion_trail\" function.  During the \n"
          "//               \"update_motion_trail\" function, the motion trail \n"
          "//               geometry is created dynamically from the sample \n"
          "//               history and the vertices.  \n"
          "//\n"
          "//               The user must specifiy a GeomNode via \n"
          "//               \"set_geom_node\".\n"
          "//\n"
          "//               The duration of the sample history is specified by \n"
          "//               a time window. A larger time window creates longer \n"
          "//               motion trails (given constant speed).  Samples that \n"
          "//               are no longer within the time window are \n"
          "//               automatically discarded.\n"
          "//\n"
          "//               The nurbs option can be used to create smooth \n"
          "//               interpolated curves from the samples.  The nurbs \n"
          "//               option is useful for animations that lack sampling \n"
          "//               to begin with, animations that move very quickly, \n"
          "//               or low frame rates.\n"
          "//\n"
          "//               The texture option be used to create variation to \n"
          "//               the motion trail.  The u coordinate of the texture \n"
          "//               corresponds to time and the v coordinate \n"
          "//               corresponds to the \"shape\" of the motion trail.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CMotionTrail.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CMotionTrail.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CMotionTrail.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CMotionTrail.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CMotionTrail.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CMotionTrail)");
             printf(" Error In PyType_ReadyCMotionTrail");
             return;
        }
        Py_INCREF(&Dtool_CMotionTrail.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CMotionTrail.As_PyTypeObject().tp_dict,"CMotionTrail",&Dtool_CMotionTrail.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CMotionTrail.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CMotionTrail[8],&Dtool_CMotionTrail.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CMotionTrail,CMotionTrail::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CMotionTrail.As_PyTypeObject());
        PyModule_AddObject(module, "CMotionTrail",(PyObject *)&Dtool_CMotionTrail.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CMotionTrail
//********************************************************************
   Dtool_PyModuleClassInit_CMotionTrail(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libmotiontrail_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213786,  /* file_identifier */
  "libmotiontrail",  /* library_name */
  "Cer8",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libmotiontrail.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  41  /* next_index */
};

Configure(_in_configure_libmotiontrail);
ConfigureFn(_in_configure_libmotiontrail) {
  interrogate_request_module(&_in_module_def);
}

