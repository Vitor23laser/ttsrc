/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir otp/secure -Iotp/secure -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libsecure_igate.cxx -od built_Rocket/pandac/input/libsecure.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Iotp/secure -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/zlib/include -Sthirdparty/win-libs-vc9/openssl/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_OTP -module otp -library libsecure loadClientCertificate.cxx loadClientCertificate.h get_fingerprint.h get_fingerprint.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libsecure
#include "py_panda.h"  

#include <Iphlpapi.h>
#include "get_fingerprint.h"
#include "httpClient.h"
#include "loadClientCertificate.h"
#include "otpbase.h"
#include "pnotify.h"
#include "zStream.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_HTTPClient;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void prepare_avatar(HTTPClient *http)
 *******************************************************************/
static PyObject *Dtool_prepare_avatar_1(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void prepare_avatar(HTTPClient *http)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"http", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:prepareAvatar", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:prepareAvatar", &param0));
            if(!PyErr_Occurred())
            {
                HTTPClient *param0_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_HTTPClient, 0, "prepareAvatar", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    prepare_avatar(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prepareAvatar(non-const HTTPClient http)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_prepare_avatar_1_comment =
    "C++ Interface:\n"
    "prepareAvatar(non-const HTTPClient http)\n"
    "\n"
    "// This function loads the (encrypted) client certificate into the\n"
    "// indicated HTTPClient.  It should be called something like\n"
    "// load_client_certificate(), but that name would then be visible to a\n"
    "// hacker scanning the Python code, so we call it something\n"
    "// misleading just to make it a teeny bit harder to find.\n"
    "";
#else
static const char * Dtool_prepare_avatar_1_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > preload_cache(void)
 *******************************************************************/
static PyObject *Dtool_preload_cache_2(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-basic_string< char > preload_cache(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":preloadCache", key_word_list))
        {
            basic_string< char > return_value = preload_cache();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "preloadCache()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_preload_cache_2_comment =
    "C++ Interface:\n"
    "preloadCache()\n"
    "\n"
    "// This function returns a string that should be unique to each\n"
    "// computer (currently, it returns the MAC address).  As with\n"
    "// loadClientCertificate, it should be named get_fingerprint(), but we\n"
    "// call it something misleading instead to distract curious\n"
    "// code-browsers.\n"
    "";
#else
static const char * Dtool_preload_cache_2_comment = NULL;
#endif


//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "prepareAvatar", (PyCFunction) &Dtool_prepare_avatar_1, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_prepare_avatar_1_comment},
  { "preloadCache", (PyCFunction) &Dtool_preload_cache_2, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_preload_cache_2_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libsecure_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213946,  /* file_identifier */
  "libsecure",  /* library_name */
  "w_HE",  /* library_hash_name */
  "otp",  /* module_name */
  "libsecure.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  9  /* next_index */
};

Configure(_in_configure_libsecure);
ConfigureFn(_in_configure_libsecure) {
  interrogate_request_module(&_in_module_def);
}

