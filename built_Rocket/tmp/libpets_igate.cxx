/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir toontown/pets -Itoontown/pets -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpets_igate.cxx -od built_Rocket/pandac/input/libpets.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Itoontown/pets -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_TOONTOWN -module toontown -library libpets cPetBrain.cxx cPetBrain.h cPetChase.cxx cPetChase.h cPetFlee.cxx cPetFlee.h config_pets.cxx config_pets.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpets
#include "py_panda.h"  

#include "cMover.h"
#include "cPetBrain.h"
#include "cPetChase.h"
#include "cPetFlee.h"
#include "config_pets.h"
#include "dconfig.h"
#include "luse.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CPetBrain
//********************************************************************
typedef  CPetBrain  CPetBrain_localtype;
Define_Module_Class(toontown,CPetBrain,CPetBrain_localtype,CPetBrain);
//********************************************************************
//*** prototypes for .. CPetChase
//********************************************************************
typedef  CPetChase  CPetChase_localtype;
Define_Module_ClassRef(toontown,CPetChase,CPetChase_localtype,CPetChase);
//********************************************************************
//*** prototypes for .. CPetFlee
//********************************************************************
typedef  CPetFlee  CPetFlee_localtype;
Define_Module_ClassRef(toontown,CPetFlee,CPetFlee_localtype,CPetFlee);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CImpulse;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CPetBrain 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool CPetBrain::is_attending_us(NodePath &us, NodePath &them)
 *******************************************************************/
static PyObject *Dtool_CPetBrain_is_attending_us_3(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetBrain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetBrain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CPetBrain::is_attending_us(NodePath &us, NodePath &them)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"us", (char *)"them", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:isAttendingUs", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CPetBrain.isAttendingUs", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CPetBrain.isAttendingUs", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->is_attending_us(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CPetBrain.isAttendingUs() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAttendingUs(non-const CPetBrain this, non-const NodePath us, non-const NodePath them)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetBrain_is_attending_us_3_comment =
    "C++ Interface:\n"
    "isAttendingUs(non-const CPetBrain this, non-const NodePath us, non-const NodePath them)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetBrain::is_attending_us\n"
    "//       Access: Published\n"
    "//  Description: Calculates whether another avatar is paying\n"
    "//               attention to us\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetBrain_is_attending_us_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CPetBrain::CPetBrain(void)
 *******************************************************************/
int  Dtool_Init_CPetBrain(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CPetBrain::CPetBrain(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CPetBrain", key_word_list))
        {
            CPetBrain *return_value = new CPetBrain();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetBrain,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CPetBrain()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CPetBrain(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CPetBrain)
    {
        printf("CPetBrain ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CPetBrain * local_this = (CPetBrain *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CPetBrain)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CPetBrain(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CPetBrain)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CPetChase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CPetChase::set_target(NodePath const &target)
 *******************************************************************/
static PyObject *Dtool_CPetChase_set_target_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetChase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetChase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CPetChase::set_target(NodePath const &target)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"target", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTarget", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTarget", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CPetChase.setTarget", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_target(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CPetChase.setTarget() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTarget(non-const CPetChase this, const NodePath target)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetChase_set_target_8_comment =
    "C++ Interface:\n"
    "setTarget(non-const CPetChase this, const NodePath target)\n"
    "\n"
    "// Filename: cPetChase.I\n"
    "// Created by:  dcranall (15Jul04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetChase::set_target\n"
    "//       Access: Published\n"
    "//  Description: Sets the NodePath that this pet should chase\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetChase_set_target_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath CPetChase::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_CPetChase_get_target_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetChase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetChase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath CPetChase::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CPetChase*)local_this)->get_target();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const CPetChase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetChase_get_target_9_comment =
    "C++ Interface:\n"
    "getTarget(const CPetChase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetChase::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath that this pet is chasing\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetChase_get_target_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CPetChase::set_min_dist(float min_dist)
 *******************************************************************/
static PyObject *Dtool_CPetChase_set_min_dist_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetChase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetChase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CPetChase::set_min_dist(float min_dist)
        double param1;
        static char * key_word_list[] = {(char *)"min_dist", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMinDist", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMinDist", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_min_dist((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CPetChase.setMinDist() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinDist(non-const CPetChase this, float min_dist)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetChase_set_min_dist_10_comment =
    "C++ Interface:\n"
    "setMinDist(non-const CPetChase this, float min_dist)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetChase::set_min_dist\n"
    "//       Access: Published\n"
    "//  Description: Sets the minimum distance for which the pet should\n"
    "//               approach the target it is chasing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetChase_set_min_dist_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CPetChase::get_min_dist(void) const
 *******************************************************************/
static PyObject *Dtool_CPetChase_get_min_dist_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetChase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetChase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CPetChase::get_min_dist(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinDist", key_word_list));
        else
            (PyArg_Parse(args, ":getMinDist"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CPetChase*)local_this)->get_min_dist();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinDist(const CPetChase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetChase_get_min_dist_11_comment =
    "C++ Interface:\n"
    "getMinDist(const CPetChase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetChase::get_min_dist\n"
    "//       Access: Published\n"
    "//  Description: returns the minimum distance for which the pet should\n"
    "//               approach the target it is chasing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetChase_get_min_dist_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CPetChase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CPetChase_get_class_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CPetChase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CPetChase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetChase_get_class_type_12_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CPetChase_get_class_type_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CPetChase::CPetChase(NodePath *target, float min_dist, float move_angle)
 * CPetChase::CPetChase(NodePath *target, float min_dist, float move_angle = (20))
 * CPetChase::CPetChase(NodePath *target, float min_dist = (5), float move_angle = (20))
 * CPetChase::CPetChase(NodePath *target = (0), float min_dist = (5), float move_angle = (20))
 *******************************************************************/
int  Dtool_Init_CPetChase(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-CPetChase::CPetChase(NodePath *target = (0), float min_dist = (5), float move_angle = (20))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CPetChase", key_word_list))
            {
                CPetChase *return_value = new CPetChase();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetChase,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetChase::CPetChase(NodePath *target, float min_dist = (5), float move_angle = (20))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"target", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:CPetChase", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:CPetChase", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetChase.CPetChase", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetChase *return_value = new CPetChase(param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetChase,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetChase::CPetChase(NodePath *target, float min_dist, float move_angle = (20))
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"target", (char *)"min_dist", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:CPetChase", key_word_list, &param0, &param1))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetChase.CPetChase", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetChase *return_value = new CPetChase(param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetChase,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetChase::CPetChase(NodePath *target, float min_dist, float move_angle)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"target", (char *)"min_dist", (char *)"move_angle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:CPetChase", key_word_list, &param0, &param1, &param2))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetChase.CPetChase", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetChase *return_value = new CPetChase(param0_this, (float)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetChase,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CPetChase() takes 0, 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CPetChase()\n"
          "CPetChase(non-const NodePath target)\n"
          "CPetChase(non-const NodePath target, float min_dist)\n"
          "CPetChase(non-const NodePath target, float min_dist, float move_angle)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CPetChase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CPetChase)
    {
        printf("CPetChase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CPetChase * local_this = (CPetChase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CPetChase)
        return local_this;
    if(requested_type == &Dtool_CImpulse)
        return ( CImpulse *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CImpulse *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CImpulse *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CImpulse *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CPetChase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CPetChase)
        return from_this;
    if(from_type == &Dtool_CImpulse)
    {
          CImpulse* other_this = (CImpulse*)from_this;
          return (CPetChase*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CPetChase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CPetChase*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CPetChase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CPetFlee 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CPetFlee::set_chaser(NodePath &chaser)
 *******************************************************************/
static PyObject *Dtool_CPetFlee_set_chaser_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CPetFlee * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CPetFlee,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CPetFlee::set_chaser(NodePath &chaser)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"chaser", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setChaser", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setChaser", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CPetFlee.setChaser", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_chaser(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CPetFlee.setChaser() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChaser(non-const CPetFlee this, non-const NodePath chaser)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetFlee_set_chaser_15_comment =
    "C++ Interface:\n"
    "setChaser(non-const CPetFlee this, non-const NodePath chaser)\n"
    "\n"
    "// Filename: cPetFlee.I\n"
    "// Created by:  dcranall (15Jul04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CPetFlee::set_chaser\n"
    "//       Access: Published\n"
    "//  Description: Sets the NodePath that this pet should flee from\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CPetFlee_set_chaser_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CPetFlee::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CPetFlee_get_class_type_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CPetFlee::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CPetFlee::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CPetFlee_get_class_type_16_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CPetFlee_get_class_type_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CPetFlee::CPetFlee(NodePath *chaser, float max_dist, float move_angle)
 * CPetFlee::CPetFlee(NodePath *chaser, float max_dist, float move_angle = (20))
 * CPetFlee::CPetFlee(NodePath *chaser, float max_dist = (50), float move_angle = (20))
 * CPetFlee::CPetFlee(NodePath *chaser = (0), float max_dist = (50), float move_angle = (20))
 *******************************************************************/
int  Dtool_Init_CPetFlee(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-CPetFlee::CPetFlee(NodePath *chaser = (0), float max_dist = (50), float move_angle = (20))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CPetFlee", key_word_list))
            {
                CPetFlee *return_value = new CPetFlee();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetFlee,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetFlee::CPetFlee(NodePath *chaser, float max_dist = (50), float move_angle = (20))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"chaser", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:CPetFlee", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:CPetFlee", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetFlee.CPetFlee", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetFlee *return_value = new CPetFlee(param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetFlee,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetFlee::CPetFlee(NodePath *chaser, float max_dist, float move_angle = (20))
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"chaser", (char *)"max_dist", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:CPetFlee", key_word_list, &param0, &param1))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetFlee.CPetFlee", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetFlee *return_value = new CPetFlee(param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetFlee,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CPetFlee::CPetFlee(NodePath *chaser, float max_dist, float move_angle)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"chaser", (char *)"max_dist", (char *)"move_angle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:CPetFlee", key_word_list, &param0, &param1, &param2))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CPetFlee.CPetFlee", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CPetFlee *return_value = new CPetFlee(param0_this, (float)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CPetFlee,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CPetFlee() takes 0, 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CPetFlee()\n"
          "CPetFlee(non-const NodePath chaser)\n"
          "CPetFlee(non-const NodePath chaser, float max_dist)\n"
          "CPetFlee(non-const NodePath chaser, float max_dist, float move_angle)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CPetFlee(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CPetFlee)
    {
        printf("CPetFlee ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CPetFlee * local_this = (CPetFlee *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CPetFlee)
        return local_this;
    if(requested_type == &Dtool_CImpulse)
        return ( CImpulse *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CImpulse *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CImpulse *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CImpulse *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CPetFlee(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CPetFlee)
        return from_this;
    if(from_type == &Dtool_CImpulse)
    {
          CImpulse* other_this = (CImpulse*)from_this;
          return (CPetFlee*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CPetFlee*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CPetFlee*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CPetFlee*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CPetBrain | CPetBrain
//********************************************************************
PyMethodDef Dtool_Methods_CPetBrain[]= {
  { "isAttendingUs",(PyCFunction ) &Dtool_CPetBrain_is_attending_us_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetBrain_is_attending_us_3_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CPetBrain(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_CPetBrain.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_CPetBrain.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CPetBrain.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CPetBrain.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CPetBrain.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CPetBrain)");
             printf(" Error In PyType_ReadyCPetBrain");
             return;
        }
        Py_INCREF(&Dtool_CPetBrain.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CPetBrain.As_PyTypeObject().tp_dict,"CPetBrain",&Dtool_CPetBrain.As_PyObject());
        RegisterRuntimeClass(&Dtool_CPetBrain,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CPetBrain.As_PyTypeObject());
        PyModule_AddObject(module, "CPetBrain",(PyObject *)&Dtool_CPetBrain.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CPetChase | CPetChase
//********************************************************************
PyMethodDef Dtool_Methods_CPetChase[]= {
  { "setTarget",(PyCFunction ) &Dtool_CPetChase_set_target_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetChase_set_target_8_comment},
  { "getTarget",(PyCFunction ) &Dtool_CPetChase_get_target_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetChase_get_target_9_comment},
  { "setMinDist",(PyCFunction ) &Dtool_CPetChase_set_min_dist_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetChase_set_min_dist_10_comment},
  { "getMinDist",(PyCFunction ) &Dtool_CPetChase_get_min_dist_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetChase_get_min_dist_11_comment},
  { "getClassType",(PyCFunction ) &Dtool_CPetChase_get_class_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetChase_get_class_type_12_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CPetChase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_CImpulse._Dtool_ClassInit(NULL);
        Dtool_CPetChase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CImpulse.As_PyTypeObject());
        Dtool_CPetChase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CPetChase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CPetChase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CPetChase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CPetChase)");
             printf(" Error In PyType_ReadyCPetChase");
             return;
        }
        Py_INCREF(&Dtool_CPetChase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CPetChase.As_PyTypeObject().tp_dict,"CPetChase",&Dtool_CPetChase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CPetChase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CPetChase[4],&Dtool_CPetChase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CPetChase,CPetChase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CPetChase.As_PyTypeObject());
        PyModule_AddObject(module, "CPetChase",(PyObject *)&Dtool_CPetChase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CPetFlee | CPetFlee
//********************************************************************
PyMethodDef Dtool_Methods_CPetFlee[]= {
  { "setChaser",(PyCFunction ) &Dtool_CPetFlee_set_chaser_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetFlee_set_chaser_15_comment},
  { "getClassType",(PyCFunction ) &Dtool_CPetFlee_get_class_type_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CPetFlee_get_class_type_16_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CPetFlee(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_CImpulse._Dtool_ClassInit(NULL);
        Dtool_CPetFlee.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CImpulse.As_PyTypeObject());
        Dtool_CPetFlee.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CPetFlee.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CPetFlee.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CPetFlee.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CPetFlee)");
             printf(" Error In PyType_ReadyCPetFlee");
             return;
        }
        Py_INCREF(&Dtool_CPetFlee.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CPetFlee.As_PyTypeObject().tp_dict,"CPetFlee",&Dtool_CPetFlee.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CPetFlee.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CPetFlee[1],&Dtool_CPetFlee.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CPetFlee,CPetFlee::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CPetFlee.As_PyTypeObject());
        PyModule_AddObject(module, "CPetFlee",(PyObject *)&Dtool_CPetFlee.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CPetBrain
//********************************************************************
   Dtool_PyModuleClassInit_CPetBrain(module);
//********************************************************************
//*** Module Init Updcall ..CPetChase
//********************************************************************
   Dtool_PyModuleClassInit_CPetChase(module);
//********************************************************************
//*** Module Init Updcall ..CPetFlee
//********************************************************************
   Dtool_PyModuleClassInit_CPetFlee(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpets_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687214005,  /* file_identifier */
  "libpets",  /* library_name */
  "Wst6",  /* library_hash_name */
  "toontown",  /* module_name */
  "libpets.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  50  /* next_index */
};

Configure(_in_configure_libpets);
ConfigureFn(_in_configure_libpets) {
  interrogate_request_module(&_in_module_def);
}

