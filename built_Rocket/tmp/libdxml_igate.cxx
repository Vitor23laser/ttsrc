/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/dxml -Ipanda/src/dxml -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdxml_igate.cxx -od built_Rocket/pandac/input/libdxml.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/dxml -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DTIXML_USE_STL= -DBUILDING_PANDA -module panda -library libdxml config_dxml.h dxml_composite1.cxx tinyxml.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdxml
#include "py_panda.h"  

#include "config_dxml.h"
#include "dconfig.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "tinyxml.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. TiXmlBase
//********************************************************************
typedef  TiXmlBase  TiXmlBase_localtype;
Define_Module_Class(panda,TiXmlBase,TiXmlBase_localtype,TiXmlBase);
//********************************************************************
//*** prototypes for .. TiXmlDeclaration
//********************************************************************
typedef  TiXmlDeclaration  TiXmlDeclaration_localtype;
Define_Module_Class(panda,TiXmlDeclaration,TiXmlDeclaration_localtype,TiXmlDeclaration);
//********************************************************************
//*** prototypes for .. TiXmlNode
//********************************************************************
typedef  TiXmlNode  TiXmlNode_localtype;
Define_Module_Class(panda,TiXmlNode,TiXmlNode_localtype,TiXmlNode);
//********************************************************************
//*** prototypes for .. TiXmlDocument
//********************************************************************
typedef  TiXmlDocument  TiXmlDocument_localtype;
Define_Module_Class(panda,TiXmlDocument,TiXmlDocument_localtype,TiXmlDocument);
//********************************************************************
//*** prototypes for .. TiXmlElement
//********************************************************************
typedef  TiXmlElement  TiXmlElement_localtype;
Define_Module_Class(panda,TiXmlElement,TiXmlElement_localtype,TiXmlElement);
//********************************************************************
//*** prototypes for .. TiXmlCursor
//********************************************************************
typedef  TiXmlCursor  TiXmlCursor_localtype;
Define_Module_Class(panda,TiXmlCursor,TiXmlCursor_localtype,TiXmlCursor);
//********************************************************************
//*** prototypes for .. TiXmlVisitor
//********************************************************************
typedef  TiXmlVisitor  TiXmlVisitor_localtype;
Define_Module_Class(panda,TiXmlVisitor,TiXmlVisitor_localtype,TiXmlVisitor);
//********************************************************************
//*** prototypes for .. TiXmlAttribute
//********************************************************************
typedef  TiXmlAttribute  TiXmlAttribute_localtype;
Define_Module_Class(panda,TiXmlAttribute,TiXmlAttribute_localtype,TiXmlAttribute);
//********************************************************************
//*** prototypes for .. TiXmlAttributeSet
//********************************************************************
typedef  TiXmlAttributeSet  TiXmlAttributeSet_localtype;
Define_Module_Class(panda,TiXmlAttributeSet,TiXmlAttributeSet_localtype,TiXmlAttributeSet);
//********************************************************************
//*** prototypes for .. TiXmlComment
//********************************************************************
typedef  TiXmlComment  TiXmlComment_localtype;
Define_Module_Class(panda,TiXmlComment,TiXmlComment_localtype,TiXmlComment);
//********************************************************************
//*** prototypes for .. TiXmlText
//********************************************************************
typedef  TiXmlText  TiXmlText_localtype;
Define_Module_Class(panda,TiXmlText,TiXmlText_localtype,TiXmlText);
//********************************************************************
//*** prototypes for .. TiXmlUnknown
//********************************************************************
typedef  TiXmlUnknown  TiXmlUnknown_localtype;
Define_Module_Class(panda,TiXmlUnknown,TiXmlUnknown_localtype,TiXmlUnknown);
//********************************************************************
//*** prototypes for .. TiXmlHandle
//********************************************************************
typedef  TiXmlHandle  TiXmlHandle_localtype;
Define_Module_Class(panda,TiXmlHandle,TiXmlHandle_localtype,TiXmlHandle);
//********************************************************************
//*** prototypes for .. TiXmlPrinter
//********************************************************************
typedef  TiXmlPrinter  TiXmlPrinter_localtype;
Define_Module_Class(panda,TiXmlPrinter,TiXmlPrinter_localtype,TiXmlPrinter);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_basic_string_char;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_istream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * TiXmlDocument *read_xml_stream(istream &in)
 *******************************************************************/
static PyObject *Dtool_read_xml_stream_81(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-TiXmlDocument *read_xml_stream(istream &in)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:readXmlStream", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:readXmlStream", &param0));
            if(!PyErr_Occurred())
            {
                istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_istream, 0, "readXmlStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    TiXmlDocument *return_value = read_xml_stream(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readXmlStream(non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_read_xml_stream_81_comment =
    "C++ Interface:\n"
    "readXmlStream(non-const Istream in)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: read_xml_stream\n"
    "//  Description: Reads an XML document from the indicated stream.\n"
    "//               Returns the document, or NULL on error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_read_xml_stream_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void write_xml_stream(ostream &out, TiXmlDocument *doc)
 *******************************************************************/
static PyObject *Dtool_write_xml_stream_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void write_xml_stream(ostream &out, TiXmlDocument *doc)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", (char *)"doc", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeXmlStream", key_word_list, &param0, &param1))
            {
                ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "writeXmlStream", 0, coerced_ptr, report_errors);
TiXmlDocument *param1_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDocument, 1, "writeXmlStream", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    write_xml_stream(*param0_this, param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeXmlStream(non-const Ostream out, non-const TiXmlDocument doc)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_write_xml_stream_82_comment =
    "C++ Interface:\n"
    "writeXmlStream(non-const Ostream out, non-const TiXmlDocument doc)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: write_xml_stream\n"
    "//  Description: Writes an XML document to the indicated stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_write_xml_stream_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int get_TIXML_MAJOR_VERSION(void)
 *******************************************************************/
static PyObject *Dtool_get_TIXML_MAJOR_VERSION_84(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-int get_TIXML_MAJOR_VERSION(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTIXMLMAJORVERSION", key_word_list))
        {
            int return_value = TIXML_MAJOR_VERSION;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTIXMLMAJORVERSION()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_TIXML_MAJOR_VERSION_84_comment =
    "C++ Interface:\n"
    "getTIXMLMAJORVERSION()\n"
    "\n"
    "getter for int const TIXML_MAJOR_VERSION;\n"
    "";
#else
static const char * Dtool_get_TIXML_MAJOR_VERSION_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int get_TIXML_MINOR_VERSION(void)
 *******************************************************************/
static PyObject *Dtool_get_TIXML_MINOR_VERSION_86(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-int get_TIXML_MINOR_VERSION(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTIXMLMINORVERSION", key_word_list))
        {
            int return_value = TIXML_MINOR_VERSION;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTIXMLMINORVERSION()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_TIXML_MINOR_VERSION_86_comment =
    "C++ Interface:\n"
    "getTIXMLMINORVERSION()\n"
    "\n"
    "getter for int const TIXML_MINOR_VERSION;\n"
    "";
#else
static const char * Dtool_get_TIXML_MINOR_VERSION_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int get_TIXML_PATCH_VERSION(void)
 *******************************************************************/
static PyObject *Dtool_get_TIXML_PATCH_VERSION_88(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-int get_TIXML_PATCH_VERSION(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTIXMLPATCHVERSION", key_word_list))
        {
            int return_value = TIXML_PATCH_VERSION;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTIXMLPATCHVERSION()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_TIXML_PATCH_VERSION_88_comment =
    "C++ Interface:\n"
    "getTIXMLPATCHVERSION()\n"
    "\n"
    "getter for int const TIXML_PATCH_VERSION;\n"
    "";
#else
static const char * Dtool_get_TIXML_PATCH_VERSION_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void)
 *******************************************************************/
static PyObject *Dtool_get_TIXML_DEFAULT_ENCODING_98(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getTIXMLDEFAULTENCODING", key_word_list))
        {
            TiXmlEncoding return_value = TIXML_DEFAULT_ENCODING;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTIXMLDEFAULTENCODING()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_TIXML_DEFAULT_ENCODING_98_comment =
    "C++ Interface:\n"
    "getTIXMLDEFAULTENCODING()\n"
    "\n"
    "getter for TiXmlEncoding const TIXML_DEFAULT_ENCODING;\n"
    "";
#else
static const char * Dtool_get_TIXML_DEFAULT_ENCODING_98_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. TiXmlBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static void TiXmlBase::SetCondenseWhiteSpace(bool condense)
 *******************************************************************/
static PyObject *Dtool_TiXmlBase_SetCondenseWhiteSpace_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void TiXmlBase::SetCondenseWhiteSpace(bool condense)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"condense", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:SetCondenseWhiteSpace", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:SetCondenseWhiteSpace", &param0));
        if(!PyErr_Occurred())
        {
            TiXmlBase::SetCondenseWhiteSpace((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetCondenseWhiteSpace(bool condense)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment =
    "C++ Interface:\n"
    "SetCondenseWhiteSpace(bool condense)\n"
    "\n"
    "/**\011The world does not agree on whether white space should be kept or\n"
    "\011\011not. In order to make everyone happy, these global, static functions\n"
    "\011\011are provided to set whether or not TinyXml will condense all white space\n"
    "\011\011into a single space or not. The default is to condense. Note changing this\n"
    "\011\011value is not thread safe.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool TiXmlBase::IsWhiteSpaceCondensed(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlBase_IsWhiteSpaceCondensed_5(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static bool TiXmlBase::IsWhiteSpaceCondensed(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":IsWhiteSpaceCondensed", key_word_list))
        {
            bool return_value = TiXmlBase::IsWhiteSpaceCondensed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "IsWhiteSpaceCondensed()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment =
    "C++ Interface:\n"
    "IsWhiteSpaceCondensed()\n"
    "\n"
    "/// Return the current white space setting.\n"
    "";
#else
static const char * Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlBase::Row(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlBase_Row_6(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlBase::Row(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Row", key_word_list));
        else
            (PyArg_Parse(args, ":Row"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlBase*)local_this)->Row();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Row(const TiXmlBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlBase_Row_6_comment =
    "C++ Interface:\n"
    "Row(const TiXmlBase this)\n"
    "\n"
    "/** Return the position, in the original source file, of this node or attribute.\n"
    "\011\011The row and column are 1-based. (That is the first row and first column is\n"
    "\011\0111,1). If the returns values are 0 or less, then the parser does not have\n"
    "\011\011a row and column value.\n"
    "\n"
    "\011\011Generally, the row and column value will be set when the TiXmlDocument::Load(),\n"
    "\011\011TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set\n"
    "\011\011when the DOM was created from operator>>.\n"
    "\n"
    "\011\011The values reflect the initial load. Once the DOM is modified programmatically\n"
    "\011\011(by adding or changing nodes and attributes) the new values will NOT update to\n"
    "\011\011reflect changes in the document.\n"
    "\n"
    "\011\011There is a minor performance cost to computing the row and column. Computation\n"
    "\011\011can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.\n"
    "\n"
    "\011\011@sa TiXmlDocument::SetTabSize()\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlBase_Row_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlBase::Column(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlBase_Column_7(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlBase::Column(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Column", key_word_list));
        else
            (PyArg_Parse(args, ":Column"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlBase*)local_this)->Column();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Column(const TiXmlBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlBase_Column_7_comment =
    "C++ Interface:\n"
    "Column(const TiXmlBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlBase_Column_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void TiXmlBase::EncodeString(basic_string< char > const &str, basic_string< char > *out)
 *******************************************************************/
static PyObject *Dtool_TiXmlBase_EncodeString_11(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void TiXmlBase::EncodeString(basic_string< char > const &str, basic_string< char > *out)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"str", (char *)"out", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:EncodeString", key_word_list, &param0_str, &param0_len, &param1))
            {
                basic_string< char > *param1_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_basic_string_char, 1, "TiXmlBase.EncodeString", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    TiXmlBase::EncodeString(basic_string<char>(param0_str, param0_len), param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EncodeString(string str, non-const BasicString out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlBase_EncodeString_11_comment =
    "C++ Interface:\n"
    "EncodeString(string str, non-const BasicString out)\n"
    "\n"
    "/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, \n"
    "\011\011or they will be transformed into entities!\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlBase_EncodeString_11_comment = NULL;
#endif

int  Dtool_Init_TiXmlBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TiXmlBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TiXmlBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlBase)
    {
        printf("TiXmlBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlBase * local_this = (TiXmlBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlBase)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlBase)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlDeclaration 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy)
 *******************************************************************/
static PyObject *Dtool_TiXmlDeclaration_operator_45(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlDeclaration *param1_this = (TiXmlDeclaration *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDeclaration, 1, "TiXmlDeclaration.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlDeclaration *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDeclaration,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlDeclaration.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlDeclaration this, const TiXmlDeclaration copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDeclaration_operator_45_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlDeclaration this, const TiXmlDeclaration copy)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlDeclaration_operator_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlDeclaration::Version(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDeclaration_Version_46(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlDeclaration::Version(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Version", key_word_list));
        else
            (PyArg_Parse(args, ":Version"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlDeclaration*)local_this)->Version();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Version(const TiXmlDeclaration this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDeclaration_Version_46_comment =
    "C++ Interface:\n"
    "Version(const TiXmlDeclaration this)\n"
    "\n"
    "/// Version. Will return an empty string if none was found.\n"
    "";
#else
static const char * Dtool_TiXmlDeclaration_Version_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlDeclaration::Encoding(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDeclaration_Encoding_47(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlDeclaration::Encoding(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Encoding", key_word_list));
        else
            (PyArg_Parse(args, ":Encoding"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlDeclaration*)local_this)->Encoding();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Encoding(const TiXmlDeclaration this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDeclaration_Encoding_47_comment =
    "C++ Interface:\n"
    "Encoding(const TiXmlDeclaration this)\n"
    "\n"
    "/// Encoding. Will return an empty string if none was found.\n"
    "";
#else
static const char * Dtool_TiXmlDeclaration_Encoding_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlDeclaration::Standalone(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDeclaration_Standalone_48(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlDeclaration::Standalone(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Standalone", key_word_list));
        else
            (PyArg_Parse(args, ":Standalone"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlDeclaration*)local_this)->Standalone();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Standalone(const TiXmlDeclaration this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDeclaration_Standalone_48_comment =
    "C++ Interface:\n"
    "Standalone(const TiXmlDeclaration this)\n"
    "\n"
    "/// Is this a standalone document?\n"
    "";
#else
static const char * Dtool_TiXmlDeclaration_Standalone_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlDeclaration::TiXmlDeclaration(void)
 * TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy)
 * TiXmlDeclaration::TiXmlDeclaration(basic_string< char > const &_version, basic_string< char > const &_encoding, basic_string< char > const &_standalone)
 * TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
 *******************************************************************/
int  Dtool_Init_TiXmlDeclaration(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlDeclaration::TiXmlDeclaration(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlDeclaration", key_word_list))
            {
                TiXmlDeclaration *return_value = new TiXmlDeclaration();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDeclaration,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlDeclaration", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TiXmlDeclaration", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlDeclaration *param0_this = (TiXmlDeclaration *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlDeclaration, 0, "TiXmlDeclaration.TiXmlDeclaration", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TiXmlDeclaration *return_value = new TiXmlDeclaration(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDeclaration,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // -2 TiXmlDeclaration::TiXmlDeclaration(basic_string< char > const &_version, basic_string< char > const &_encoding, basic_string< char > const &_standalone)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"_version", (char *)"_encoding", (char *)"_standalone", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#s#:TiXmlDeclaration", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                TiXmlDeclaration *return_value = new TiXmlDeclaration(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDeclaration,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
            char *param0;
            char *param1;
            char *param2;
            static char * key_word_list[] = {(char *)"_version", (char *)"_encoding", (char *)"_standalone", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "sss:TiXmlDeclaration", key_word_list, &param0, &param1, &param2))
            {
                TiXmlDeclaration *return_value = new TiXmlDeclaration((char const *)param0, (char const *)param1, (char const *)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDeclaration,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TiXmlDeclaration() takes 0, 1, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TiXmlDeclaration()\n"
          "TiXmlDeclaration(const TiXmlDeclaration copy)\n"
          "TiXmlDeclaration(string _version, string _encoding, string _standalone)\n"
          "TiXmlDeclaration(string _version, string _encoding, string _standalone)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlDeclaration)
    {
        printf("TiXmlDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlDeclaration * local_this = (TiXmlDeclaration *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlDeclaration)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlDeclaration(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlDeclaration)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlDeclaration*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlDeclaration*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlNode::Value(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Value_15(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlNode::Value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Value", key_word_list));
        else
            (PyArg_Parse(args, ":Value"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlNode*)local_this)->Value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Value(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Value_15_comment =
    "C++ Interface:\n"
    "Value(const TiXmlNode this)\n"
    "\n"
    "/** The meaning of 'value' changes for the specific type of\n"
    "\011\011TiXmlNode.\n"
    "\011\011@verbatim\n"
    "\011\011Document:\011filename of the xml file\n"
    "\011\011Element:\011name of the element\n"
    "\011\011Comment:\011the comment text\n"
    "\011\011Unknown:\011the tag contents\n"
    "\011\011Text:\011\011the text string\n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011The subclasses will wrap this function.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_Value_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &TiXmlNode::ValueStr(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ValueStr_16(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &TiXmlNode::ValueStr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ValueStr", key_word_list));
        else
            (PyArg_Parse(args, ":ValueStr"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const TiXmlNode*)local_this)->ValueStr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ValueStr(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ValueStr_16_comment =
    "C++ Interface:\n"
    "ValueStr(const TiXmlNode this)\n"
    "\n"
    "/** Return Value() as a std::string. If you only use STL,\n"
    "\011    this is more efficient than calling Value().\n"
    "\011\011Only available in STL mode.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_ValueStr_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &TiXmlNode::ValueTStr(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ValueTStr_17(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &TiXmlNode::ValueTStr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ValueTStr", key_word_list));
        else
            (PyArg_Parse(args, ":ValueTStr"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const TiXmlNode*)local_this)->ValueTStr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ValueTStr(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ValueTStr_17_comment =
    "C++ Interface:\n"
    "ValueTStr(const TiXmlNode this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlNode_ValueTStr_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlNode::SetValue(basic_string< char > const &_value)
 * void TiXmlNode::SetValue(char const *_value)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_SetValue_18(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlNode::SetValue(basic_string< char > const &_value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SetValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:SetValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->SetValue(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlNode::SetValue(char const *_value)
        char *param1;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:SetValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:SetValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetValue((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetValue(non-const TiXmlNode this, string _value)\n"
          "SetValue(non-const TiXmlNode this, string _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_SetValue_18_comment =
    "C++ Interface:\n"
    "SetValue(non-const TiXmlNode this, string _value)\n"
    "SetValue(non-const TiXmlNode this, string _value)\n"
    "\n"
    "/** Changes the value of the node. Defined as:\n"
    "\011\011@verbatim\n"
    "\011\011Document:\011filename of the xml file\n"
    "\011\011Element:\011name of the element\n"
    "\011\011Comment:\011the comment text\n"
    "\011\011Unknown:\011the tag contents\n"
    "\011\011Text:\011\011the text string\n"
    "\011\011@endverbatim\n"
    "\011*/\n"
    "\n"
    "/// STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_SetValue_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlNode::Clear(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Clear_19(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlNode::Clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Clear", key_word_list));
        else
            (PyArg_Parse(args, ":Clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->Clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlNode.Clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Clear(non-const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Clear_19_comment =
    "C++ Interface:\n"
    "Clear(non-const TiXmlNode this)\n"
    "\n"
    "/// Delete all the children of this node. Does not affect 'this'.\n"
    "";
#else
static const char * Dtool_TiXmlNode_Clear_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::Parent(void)
 * TiXmlNode const *TiXmlNode::Parent(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Parent_20(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlNode *TiXmlNode::Parent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Parent", key_word_list));
        else
            (PyArg_Parse(args, ":Parent"));
        if(!PyErr_Occurred())
        {
            TiXmlNode *return_value = (local_this)->Parent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlNode const *TiXmlNode::Parent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Parent", key_word_list));
        else
            (PyArg_Parse(args, ":Parent"));
        if(!PyErr_Occurred())
        {
            TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->Parent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Parent(non-const TiXmlNode this)\n"
          "Parent(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Parent_20_comment =
    "C++ Interface:\n"
    "Parent(non-const TiXmlNode this)\n"
    "Parent(const TiXmlNode this)\n"
    "\n"
    "/// One step up the DOM.\n"
    "\n"
    "/// One step up the DOM.\n"
    "";
#else
static const char * Dtool_TiXmlNode_Parent_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::FirstChild(void)
 * TiXmlNode const *TiXmlNode::FirstChild(void) const
 * TiXmlNode *TiXmlNode::FirstChild(basic_string< char > const &_value)
 * TiXmlNode const *TiXmlNode::FirstChild(basic_string< char > const &_value) const
 * TiXmlNode *TiXmlNode::FirstChild(char const *_value)
 * TiXmlNode const *TiXmlNode::FirstChild(char const *value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_FirstChild_21(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::FirstChild(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChild", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChild"));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->FirstChild();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::FirstChild(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChild", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChild"));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->FirstChild();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::FirstChild(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChild", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChild", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->FirstChild(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::FirstChild(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChild", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChild", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->FirstChild(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::FirstChild(char const *value) const
            char *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->FirstChild((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::FirstChild(char const *_value)
            char *param1;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->FirstChild((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FirstChild() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FirstChild(non-const TiXmlNode this)\n"
          "FirstChild(const TiXmlNode this)\n"
          "FirstChild(non-const TiXmlNode this, string _value)\n"
          "FirstChild(const TiXmlNode this, string _value)\n"
          "FirstChild(const TiXmlNode this, string value)\n"
          "FirstChild(non-const TiXmlNode this, string _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_FirstChild_21_comment =
    "C++ Interface:\n"
    "FirstChild(non-const TiXmlNode this)\n"
    "FirstChild(const TiXmlNode this)\n"
    "FirstChild(non-const TiXmlNode this, string _value)\n"
    "FirstChild(const TiXmlNode this, string _value)\n"
    "FirstChild(const TiXmlNode this, string value)\n"
    "FirstChild(non-const TiXmlNode this, string _value)\n"
    "\n"
    "///< The first child of this node. Will be null if there are no children.\n"
    "\n"
    "///< The first child of this node. Will be null if there are no children.\n"
    "\n"
    "///< The first child of this node with the matching 'value'. Will be null if none found.\n"
    "/// The first child of this node with the matching 'value'. Will be null if none found.\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_FirstChild_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::LastChild(void)
 * TiXmlNode const *TiXmlNode::LastChild(void) const
 * TiXmlNode *TiXmlNode::LastChild(basic_string< char > const &_value)
 * TiXmlNode const *TiXmlNode::LastChild(basic_string< char > const &_value) const
 * TiXmlNode *TiXmlNode::LastChild(char const *_value)
 * TiXmlNode const *TiXmlNode::LastChild(char const *value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_LastChild_22(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // -2 TiXmlNode const *TiXmlNode::LastChild(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":LastChild", key_word_list));
            else
                (PyArg_Parse(args, ":LastChild"));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->LastChild();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::LastChild(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":LastChild", key_word_list));
            else
                (PyArg_Parse(args, ":LastChild"));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->LastChild();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        {
          // -2 TiXmlNode const *TiXmlNode::LastChild(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LastChild", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:LastChild", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->LastChild(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::LastChild(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LastChild", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:LastChild", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->LastChild(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::LastChild(char const *_value)
            char *param1;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:LastChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:LastChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->LastChild((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::LastChild(char const *value) const
            char *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:LastChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:LastChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->LastChild((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LastChild() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LastChild(const TiXmlNode this)\n"
          "LastChild(non-const TiXmlNode this)\n"
          "LastChild(const TiXmlNode this, string _value)\n"
          "LastChild(non-const TiXmlNode this, string _value)\n"
          "LastChild(non-const TiXmlNode this, string _value)\n"
          "LastChild(const TiXmlNode this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_LastChild_22_comment =
    "C++ Interface:\n"
    "LastChild(const TiXmlNode this)\n"
    "LastChild(non-const TiXmlNode this)\n"
    "LastChild(const TiXmlNode this, string _value)\n"
    "LastChild(non-const TiXmlNode this, string _value)\n"
    "LastChild(non-const TiXmlNode this, string _value)\n"
    "LastChild(const TiXmlNode this, string value)\n"
    "\n"
    "/// The last child of this node. Will be null if there are no children.\n"
    "\n"
    "/// The last child of this node matching 'value'. Will be null if there are no children.\n"
    "\n"
    "///< STL std::string form.\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_LastChild_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const
 * TiXmlNode *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous) const
 * TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_IterateChildren_23(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"previous", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:IterateChildren", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:IterateChildren", &param1));
                if(!PyErr_Occurred())
                {
                    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        TiXmlNode *return_value = (local_this)->IterateChildren(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"previous", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:IterateChildren", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:IterateChildren", &param1));
                if(!PyErr_Occurred())
                {
                    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->IterateChildren(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 TiXmlNode *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous)
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"_value", (char *)"previous", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:IterateChildren", key_word_list, &param1_str, &param1_len, &param2))
                {
                    TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        TiXmlNode *return_value = (local_this)->IterateChildren(basic_string<char>(param1_str, param1_len), param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlNode const *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous) const
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"_value", (char *)"previous", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:IterateChildren", key_word_list, &param1_str, &param1_len, &param2))
                {
                    TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->IterateChildren(basic_string<char>(param1_str, param1_len), param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous)
                char *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"_value", (char *)"previous", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "sO:IterateChildren", key_word_list, &param1, &param2))
                {
                    TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        TiXmlNode *return_value = (local_this)->IterateChildren((char const *)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const
                char *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"value", (char *)"previous", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "sO:IterateChildren", key_word_list, &param1, &param2))
                {
                    TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.IterateChildren", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->IterateChildren((char const *)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "IterateChildren() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "IterateChildren(non-const TiXmlNode this, const TiXmlNode previous)\n"
          "IterateChildren(const TiXmlNode this, const TiXmlNode previous)\n"
          "IterateChildren(non-const TiXmlNode this, string _value, const TiXmlNode previous)\n"
          "IterateChildren(const TiXmlNode this, string _value, const TiXmlNode previous)\n"
          "IterateChildren(non-const TiXmlNode this, string _value, const TiXmlNode previous)\n"
          "IterateChildren(const TiXmlNode this, string value, const TiXmlNode previous)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_IterateChildren_23_comment =
    "C++ Interface:\n"
    "IterateChildren(non-const TiXmlNode this, const TiXmlNode previous)\n"
    "IterateChildren(const TiXmlNode this, const TiXmlNode previous)\n"
    "IterateChildren(non-const TiXmlNode this, string _value, const TiXmlNode previous)\n"
    "IterateChildren(const TiXmlNode this, string _value, const TiXmlNode previous)\n"
    "IterateChildren(non-const TiXmlNode this, string _value, const TiXmlNode previous)\n"
    "IterateChildren(const TiXmlNode this, string value, const TiXmlNode previous)\n"
    "\n"
    "/** An alternate way to walk the children of a node.\n"
    "\011\011One way to iterate over nodes is:\n"
    "\011\011@verbatim\n"
    "\011\011\011for( child = parent->FirstChild(); child; child = child->NextSibling() )\n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011IterateChildren does the same thing with the syntax:\n"
    "\011\011@verbatim\n"
    "\011\011\011child = 0;\n"
    "\011\011\011while( child = parent->IterateChildren( child ) )\n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011IterateChildren takes the previous child as input and finds\n"
    "\011\011the next one. If the previous child is null, it returns the\n"
    "\011\011first. IterateChildren will return null when done.\n"
    "\011*/\n"
    "\n"
    "/// This flavor of IterateChildren searches for children with a particular 'value'\n"
    "\n"
    "/// This flavor of IterateChildren searches for children with a particular 'value'\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_IterateChildren_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_InsertEndChild_24(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"addThis", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:InsertEndChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:InsertEndChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.InsertEndChild", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    TiXmlNode *return_value = (local_this)->InsertEndChild(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlNode.InsertEndChild() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InsertEndChild(non-const TiXmlNode this, const TiXmlNode addThis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_InsertEndChild_24_comment =
    "C++ Interface:\n"
    "InsertEndChild(non-const TiXmlNode this, const TiXmlNode addThis)\n"
    "\n"
    "/** Add a new node related to this. Adds a child past the LastChild.\n"
    "\011\011Returns a pointer to the new object or NULL if an error occured.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_InsertEndChild_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_InsertBeforeChild_25(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"beforeThis", (char *)"addThis", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:InsertBeforeChild", key_word_list, &param1, &param2))
            {
                TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.InsertBeforeChild", 0, coerced_ptr, report_errors);
TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.InsertBeforeChild", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    TiXmlNode *return_value = (local_this)->InsertBeforeChild(param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlNode.InsertBeforeChild() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InsertBeforeChild(non-const TiXmlNode this, non-const TiXmlNode beforeThis, const TiXmlNode addThis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_InsertBeforeChild_25_comment =
    "C++ Interface:\n"
    "InsertBeforeChild(non-const TiXmlNode this, non-const TiXmlNode beforeThis, const TiXmlNode addThis)\n"
    "\n"
    "/** Add a new node related to this. Adds a child before the specified child.\n"
    "\011\011Returns a pointer to the new object or NULL if an error occured.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_InsertBeforeChild_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_InsertAfterChild_26(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"afterThis", (char *)"addThis", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:InsertAfterChild", key_word_list, &param1, &param2))
            {
                TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.InsertAfterChild", 0, coerced_ptr, report_errors);
TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.InsertAfterChild", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    TiXmlNode *return_value = (local_this)->InsertAfterChild(param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlNode.InsertAfterChild() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InsertAfterChild(non-const TiXmlNode this, non-const TiXmlNode afterThis, const TiXmlNode addThis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_InsertAfterChild_26_comment =
    "C++ Interface:\n"
    "InsertAfterChild(non-const TiXmlNode this, non-const TiXmlNode afterThis, const TiXmlNode addThis)\n"
    "\n"
    "/** Add a new node related to this. Adds a child after the specified child.\n"
    "\011\011Returns a pointer to the new object or NULL if an error occured.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_InsertAfterChild_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ReplaceChild_27(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"replaceThis", (char *)"withThis", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:ReplaceChild", key_word_list, &param1, &param2))
            {
                TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.ReplaceChild", 0, coerced_ptr, report_errors);
TiXmlNode *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlNode, 2, "TiXmlNode.ReplaceChild", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    TiXmlNode *return_value = (local_this)->ReplaceChild(param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlNode.ReplaceChild() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ReplaceChild(non-const TiXmlNode this, non-const TiXmlNode replaceThis, const TiXmlNode withThis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ReplaceChild_27_comment =
    "C++ Interface:\n"
    "ReplaceChild(non-const TiXmlNode this, non-const TiXmlNode replaceThis, const TiXmlNode withThis)\n"
    "\n"
    "/** Replace a child of this node.\n"
    "\011\011Returns a pointer to the new object or NULL if an error occured.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_ReplaceChild_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlNode::RemoveChild(TiXmlNode *removeThis)
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_RemoveChild_28(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool TiXmlNode::RemoveChild(TiXmlNode *removeThis)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"removeThis", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:RemoveChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:RemoveChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlNode, 1, "TiXmlNode.RemoveChild", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->RemoveChild(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlNode.RemoveChild() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RemoveChild(non-const TiXmlNode this, non-const TiXmlNode removeThis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_RemoveChild_28_comment =
    "C++ Interface:\n"
    "RemoveChild(non-const TiXmlNode this, non-const TiXmlNode removeThis)\n"
    "\n"
    "/// Delete a child of this node.\n"
    "";
#else
static const char * Dtool_TiXmlNode_RemoveChild_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::PreviousSibling(void)
 * TiXmlNode const *TiXmlNode::PreviousSibling(void) const
 * TiXmlNode *TiXmlNode::PreviousSibling(basic_string< char > const &_value)
 * TiXmlNode const *TiXmlNode::PreviousSibling(basic_string< char > const &_value) const
 * TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev)
 * TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_PreviousSibling_29(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // -2 TiXmlNode const *TiXmlNode::PreviousSibling(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":PreviousSibling", key_word_list));
            else
                (PyArg_Parse(args, ":PreviousSibling"));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->PreviousSibling();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::PreviousSibling(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":PreviousSibling", key_word_list));
            else
                (PyArg_Parse(args, ":PreviousSibling"));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->PreviousSibling();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::PreviousSibling(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PreviousSibling", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:PreviousSibling", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->PreviousSibling(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::PreviousSibling(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PreviousSibling", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:PreviousSibling", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->PreviousSibling(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const
            char *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:PreviousSibling", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:PreviousSibling", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->PreviousSibling((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev)
            char *param1;
            static char * key_word_list[] = {(char *)"_prev", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:PreviousSibling", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:PreviousSibling", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->PreviousSibling((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PreviousSibling() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PreviousSibling(const TiXmlNode this)\n"
          "PreviousSibling(non-const TiXmlNode this)\n"
          "PreviousSibling(non-const TiXmlNode this, string _value)\n"
          "PreviousSibling(const TiXmlNode this, string _value)\n"
          "PreviousSibling(const TiXmlNode this, string)\n"
          "PreviousSibling(non-const TiXmlNode this, string _prev)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_PreviousSibling_29_comment =
    "C++ Interface:\n"
    "PreviousSibling(const TiXmlNode this)\n"
    "PreviousSibling(non-const TiXmlNode this)\n"
    "PreviousSibling(non-const TiXmlNode this, string _value)\n"
    "PreviousSibling(const TiXmlNode this, string _value)\n"
    "PreviousSibling(const TiXmlNode this, string)\n"
    "PreviousSibling(non-const TiXmlNode this, string _prev)\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_PreviousSibling_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlNode::NextSibling(void)
 * TiXmlNode const *TiXmlNode::NextSibling(void) const
 * TiXmlNode *TiXmlNode::NextSibling(basic_string< char > const &_value)
 * TiXmlNode const *TiXmlNode::NextSibling(basic_string< char > const &_value) const
 * TiXmlNode *TiXmlNode::NextSibling(char const *_next)
 * TiXmlNode const *TiXmlNode::NextSibling(char const *) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_NextSibling_30(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::NextSibling(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":NextSibling", key_word_list));
            else
                (PyArg_Parse(args, ":NextSibling"));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->NextSibling();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::NextSibling(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":NextSibling", key_word_list));
            else
                (PyArg_Parse(args, ":NextSibling"));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->NextSibling();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::NextSibling(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:NextSibling", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:NextSibling", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->NextSibling(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::NextSibling(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:NextSibling", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:NextSibling", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->NextSibling(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlNode *TiXmlNode::NextSibling(char const *_next)
            char *param1;
            static char * key_word_list[] = {(char *)"_next", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:NextSibling", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:NextSibling", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode *return_value = (local_this)->NextSibling((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlNode const *TiXmlNode::NextSibling(char const *) const
            char *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:NextSibling", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:NextSibling", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlNode const *return_value = ((const TiXmlNode*)local_this)->NextSibling((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NextSibling() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NextSibling(non-const TiXmlNode this)\n"
          "NextSibling(const TiXmlNode this)\n"
          "NextSibling(non-const TiXmlNode this, string _value)\n"
          "NextSibling(const TiXmlNode this, string _value)\n"
          "NextSibling(non-const TiXmlNode this, string _next)\n"
          "NextSibling(const TiXmlNode this, string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_NextSibling_30_comment =
    "C++ Interface:\n"
    "NextSibling(non-const TiXmlNode this)\n"
    "NextSibling(const TiXmlNode this)\n"
    "NextSibling(non-const TiXmlNode this, string _value)\n"
    "NextSibling(const TiXmlNode this, string _value)\n"
    "NextSibling(non-const TiXmlNode this, string _next)\n"
    "NextSibling(const TiXmlNode this, string)\n"
    "\n"
    "///< STL std::string form.\n"
    "\n"
    "///< STL std::string form.\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "/// Navigate to a sibling node.\n"
    "\n"
    "/// Navigate to a sibling node with the given 'value'.\n"
    "\n"
    "/// Navigate to a sibling node with the given 'value'.\n"
    "";
#else
static const char * Dtool_TiXmlNode_NextSibling_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement *TiXmlNode::NextSiblingElement(void)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(void) const
 * TiXmlElement *TiXmlNode::NextSiblingElement(basic_string< char > const &_value)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(basic_string< char > const &_value) const
 * TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_NextSiblingElement_31(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":NextSiblingElement", key_word_list));
            else
                (PyArg_Parse(args, ":NextSiblingElement"));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->NextSiblingElement();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::NextSiblingElement(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":NextSiblingElement", key_word_list));
            else
                (PyArg_Parse(args, ":NextSiblingElement"));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->NextSiblingElement();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        {
          // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:NextSiblingElement", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:NextSiblingElement", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->NextSiblingElement(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::NextSiblingElement(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:NextSiblingElement", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:NextSiblingElement", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->NextSiblingElement(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const
            char *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:NextSiblingElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:NextSiblingElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->NextSiblingElement((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next)
            char *param1;
            static char * key_word_list[] = {(char *)"_next", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:NextSiblingElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:NextSiblingElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->NextSiblingElement((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NextSiblingElement() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NextSiblingElement(const TiXmlNode this)\n"
          "NextSiblingElement(non-const TiXmlNode this)\n"
          "NextSiblingElement(const TiXmlNode this, string _value)\n"
          "NextSiblingElement(non-const TiXmlNode this, string _value)\n"
          "NextSiblingElement(const TiXmlNode this, string)\n"
          "NextSiblingElement(non-const TiXmlNode this, string _next)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_NextSiblingElement_31_comment =
    "C++ Interface:\n"
    "NextSiblingElement(const TiXmlNode this)\n"
    "NextSiblingElement(non-const TiXmlNode this)\n"
    "NextSiblingElement(const TiXmlNode this, string _value)\n"
    "NextSiblingElement(non-const TiXmlNode this, string _value)\n"
    "NextSiblingElement(const TiXmlNode this, string)\n"
    "NextSiblingElement(non-const TiXmlNode this, string _next)\n"
    "\n"
    "/** Convenience function to get through elements.\n"
    "\011\011Calls NextSibling and ToElement. Will skip all non-Element\n"
    "\011\011nodes. Returns 0 if there is not another element.\n"
    "\011*/\n"
    "\n"
    "/** Convenience function to get through elements.\n"
    "\011\011Calls NextSibling and ToElement. Will skip all non-Element\n"
    "\011\011nodes. Returns 0 if there is not another element.\n"
    "\011*/\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_NextSiblingElement_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement *TiXmlNode::FirstChildElement(void)
 * TiXmlElement const *TiXmlNode::FirstChildElement(void) const
 * TiXmlElement *TiXmlNode::FirstChildElement(basic_string< char > const &_value)
 * TiXmlElement const *TiXmlNode::FirstChildElement(basic_string< char > const &_value) const
 * TiXmlElement *TiXmlNode::FirstChildElement(char const *_value)
 * TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_FirstChildElement_32(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::FirstChildElement(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChildElement", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChildElement"));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->FirstChildElement();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement const *TiXmlNode::FirstChildElement(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChildElement", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChildElement"));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->FirstChildElement();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::FirstChildElement(basic_string< char > const &_value)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChildElement", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChildElement", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->FirstChildElement(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement const *TiXmlNode::FirstChildElement(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChildElement", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChildElement", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->FirstChildElement(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 TiXmlElement *TiXmlNode::FirstChildElement(char const *_value)
            char *param1;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChildElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChildElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = (local_this)->FirstChildElement((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const
            char *param1;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChildElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChildElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->FirstChildElement((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FirstChildElement() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FirstChildElement(non-const TiXmlNode this)\n"
          "FirstChildElement(const TiXmlNode this)\n"
          "FirstChildElement(non-const TiXmlNode this, string _value)\n"
          "FirstChildElement(const TiXmlNode this, string _value)\n"
          "FirstChildElement(non-const TiXmlNode this, string _value)\n"
          "FirstChildElement(const TiXmlNode this, string _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_FirstChildElement_32_comment =
    "C++ Interface:\n"
    "FirstChildElement(non-const TiXmlNode this)\n"
    "FirstChildElement(const TiXmlNode this)\n"
    "FirstChildElement(non-const TiXmlNode this, string _value)\n"
    "FirstChildElement(const TiXmlNode this, string _value)\n"
    "FirstChildElement(non-const TiXmlNode this, string _value)\n"
    "FirstChildElement(const TiXmlNode this, string _value)\n"
    "\n"
    "/// Convenience function to get through elements.\n"
    "\n"
    "/// Convenience function to get through elements.\n"
    "\n"
    "/// Convenience function to get through elements.\n"
    "\n"
    "/// Convenience function to get through elements.\n"
    "\n"
    "///< STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlNode_FirstChildElement_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlNode::Type(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlNode::Type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Type", key_word_list));
        else
            (PyArg_Parse(args, ":Type"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlNode*)local_this)->Type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Type(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Type_33_comment =
    "C++ Interface:\n"
    "Type(const TiXmlNode this)\n"
    "\n"
    "/** Query the type (as an enumerated value, above) of this node.\n"
    "\011\011The possible types are: DOCUMENT, ELEMENT, COMMENT,\n"
    "\011\011\011\011\011\011\011\011UNKNOWN, TEXT, and DECLARATION.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_Type_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlDocument *TiXmlNode::GetDocument(void)
 * TiXmlDocument const *TiXmlNode::GetDocument(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_GetDocument_34(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlDocument *TiXmlNode::GetDocument(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetDocument", key_word_list));
        else
            (PyArg_Parse(args, ":GetDocument"));
        if(!PyErr_Occurred())
        {
            TiXmlDocument *return_value = (local_this)->GetDocument();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlDocument const *TiXmlNode::GetDocument(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetDocument", key_word_list));
        else
            (PyArg_Parse(args, ":GetDocument"));
        if(!PyErr_Occurred())
        {
            TiXmlDocument const *return_value = ((const TiXmlNode*)local_this)->GetDocument();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetDocument(non-const TiXmlNode this)\n"
          "GetDocument(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_GetDocument_34_comment =
    "C++ Interface:\n"
    "GetDocument(non-const TiXmlNode this)\n"
    "GetDocument(const TiXmlNode this)\n"
    "\n"
    "/** Return a pointer to the Document this node lives in.\n"
    "\011\011Returns null if not in a document.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_GetDocument_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlNode::NoChildren(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_NoChildren_35(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TiXmlNode::NoChildren(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":NoChildren", key_word_list));
        else
            (PyArg_Parse(args, ":NoChildren"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TiXmlNode*)local_this)->NoChildren();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NoChildren(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_NoChildren_35_comment =
    "C++ Interface:\n"
    "NoChildren(const TiXmlNode this)\n"
    "\n"
    "/// Returns true if this node has no children.\n"
    "";
#else
static const char * Dtool_TiXmlNode_NoChildren_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlDocument *TiXmlNode::ToDocument(void)
 * virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToDocument_36(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToDocument", key_word_list));
        else
            (PyArg_Parse(args, ":ToDocument"));
        if(!PyErr_Occurred())
        {
            TiXmlDocument const *return_value = ((const TiXmlNode*)local_this)->ToDocument();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlDocument *TiXmlNode::ToDocument(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToDocument", key_word_list));
        else
            (PyArg_Parse(args, ":ToDocument"));
        if(!PyErr_Occurred())
        {
            TiXmlDocument *return_value = (local_this)->ToDocument();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToDocument(const TiXmlNode this)\n"
          "ToDocument(non-const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToDocument_36_comment =
    "C++ Interface:\n"
    "ToDocument(const TiXmlNode this)\n"
    "ToDocument(non-const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToDocument_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlElement *TiXmlNode::ToElement(void)
 * virtual TiXmlElement const *TiXmlNode::ToElement(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToElement_37(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlElement *TiXmlNode::ToElement(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToElement", key_word_list));
        else
            (PyArg_Parse(args, ":ToElement"));
        if(!PyErr_Occurred())
        {
            TiXmlElement *return_value = (local_this)->ToElement();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual TiXmlElement const *TiXmlNode::ToElement(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToElement", key_word_list));
        else
            (PyArg_Parse(args, ":ToElement"));
        if(!PyErr_Occurred())
        {
            TiXmlElement const *return_value = ((const TiXmlNode*)local_this)->ToElement();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToElement(non-const TiXmlNode this)\n"
          "ToElement(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToElement_37_comment =
    "C++ Interface:\n"
    "ToElement(non-const TiXmlNode this)\n"
    "ToElement(const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToElement_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlComment *TiXmlNode::ToComment(void)
 * virtual TiXmlComment const *TiXmlNode::ToComment(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToComment_38(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlComment *TiXmlNode::ToComment(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToComment", key_word_list));
        else
            (PyArg_Parse(args, ":ToComment"));
        if(!PyErr_Occurred())
        {
            TiXmlComment *return_value = (local_this)->ToComment();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlComment,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual TiXmlComment const *TiXmlNode::ToComment(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToComment", key_word_list));
        else
            (PyArg_Parse(args, ":ToComment"));
        if(!PyErr_Occurred())
        {
            TiXmlComment const *return_value = ((const TiXmlNode*)local_this)->ToComment();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlComment,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToComment(non-const TiXmlNode this)\n"
          "ToComment(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToComment_38_comment =
    "C++ Interface:\n"
    "ToComment(non-const TiXmlNode this)\n"
    "ToComment(const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToComment_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlUnknown *TiXmlNode::ToUnknown(void)
 * virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToUnknown_39(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToUnknown", key_word_list));
        else
            (PyArg_Parse(args, ":ToUnknown"));
        if(!PyErr_Occurred())
        {
            TiXmlUnknown const *return_value = ((const TiXmlNode*)local_this)->ToUnknown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlUnknown,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlUnknown *TiXmlNode::ToUnknown(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToUnknown", key_word_list));
        else
            (PyArg_Parse(args, ":ToUnknown"));
        if(!PyErr_Occurred())
        {
            TiXmlUnknown *return_value = (local_this)->ToUnknown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlUnknown,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToUnknown(const TiXmlNode this)\n"
          "ToUnknown(non-const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToUnknown_39_comment =
    "C++ Interface:\n"
    "ToUnknown(const TiXmlNode this)\n"
    "ToUnknown(non-const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToUnknown_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlText *TiXmlNode::ToText(void)
 * virtual TiXmlText const *TiXmlNode::ToText(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToText_40(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlText *TiXmlNode::ToText(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToText", key_word_list));
        else
            (PyArg_Parse(args, ":ToText"));
        if(!PyErr_Occurred())
        {
            TiXmlText *return_value = (local_this)->ToText();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlText,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual TiXmlText const *TiXmlNode::ToText(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToText", key_word_list));
        else
            (PyArg_Parse(args, ":ToText"));
        if(!PyErr_Occurred())
        {
            TiXmlText const *return_value = ((const TiXmlNode*)local_this)->ToText();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlText,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToText(non-const TiXmlNode this)\n"
          "ToText(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToText_40_comment =
    "C++ Interface:\n"
    "ToText(non-const TiXmlNode this)\n"
    "ToText(const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToText_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void)
 * virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_ToDeclaration_41(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToDeclaration", key_word_list));
        else
            (PyArg_Parse(args, ":ToDeclaration"));
        if(!PyErr_Occurred())
        {
            TiXmlDeclaration const *return_value = ((const TiXmlNode*)local_this)->ToDeclaration();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDeclaration,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToDeclaration", key_word_list));
        else
            (PyArg_Parse(args, ":ToDeclaration"));
        if(!PyErr_Occurred())
        {
            TiXmlDeclaration *return_value = (local_this)->ToDeclaration();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDeclaration,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToDeclaration(const TiXmlNode this)\n"
          "ToDeclaration(non-const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_ToDeclaration_41_comment =
    "C++ Interface:\n"
    "ToDeclaration(const TiXmlNode this)\n"
    "ToDeclaration(non-const TiXmlNode this)\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "\n"
    "///< Cast to a more defined type. Will return null if not of the requested type.\n"
    "";
#else
static const char * Dtool_TiXmlNode_ToDeclaration_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TiXmlNode *TiXmlNode::Clone(void) const = 0
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Clone_42(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TiXmlNode *TiXmlNode::Clone(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Clone", key_word_list));
        else
            (PyArg_Parse(args, ":Clone"));
        if(!PyErr_Occurred())
        {
            TiXmlNode *return_value = ((const TiXmlNode*)local_this)->Clone();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Clone(const TiXmlNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Clone_42_comment =
    "C++ Interface:\n"
    "Clone(const TiXmlNode this)\n"
    "\n"
    "/** Create an exact duplicate of this node and return it. The memory must be deleted\n"
    "\011\011by the caller. \n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_Clone_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0
 *******************************************************************/
static PyObject *Dtool_TiXmlNode_Accept_43(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"visitor", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Accept", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Accept", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlVisitor *param1_this = (TiXmlVisitor *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlVisitor, 1, "TiXmlNode.Accept", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TiXmlNode*)local_this)->Accept(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Accept(const TiXmlNode this, non-const TiXmlVisitor visitor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlNode_Accept_43_comment =
    "C++ Interface:\n"
    "Accept(const TiXmlNode this, non-const TiXmlVisitor visitor)\n"
    "\n"
    "/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the \n"
    "\011\011XML tree will be conditionally visited and the host will be called back\n"
    "\011\011via the TiXmlVisitor interface.\n"
    "\n"
    "\011\011This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse\n"
    "\011\011the XML for the callbacks, so the performance of TinyXML is unchanged by using this\n"
    "\011\011interface versus any other.)\n"
    "\n"
    "\011\011The interface has been based on ideas from:\n"
    "\n"
    "\011\011- http://www.saxproject.org/\n"
    "\011\011- http://c2.com/cgi/wiki?HierarchicalVisitorPattern \n"
    "\n"
    "\011\011Which are both good references for \"visiting\".\n"
    "\n"
    "\011\011An example of using Accept():\n"
    "\011\011@verbatim\n"
    "\011\011TiXmlPrinter printer;\n"
    "\011\011tinyxmlDoc.Accept( &printer );\n"
    "\011\011const char* xmlcstr = printer.CStr();\n"
    "\011\011@endverbatim\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlNode_Accept_43_comment = NULL;
#endif

int  Dtool_Init_TiXmlNode(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TiXmlNode)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TiXmlNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlNode)
    {
        printf("TiXmlNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlNode * local_this = (TiXmlNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlNode)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlNode)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlDocument 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlDocument::operator =(TiXmlDocument const &copy)
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_operator_52(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlDocument::operator =(TiXmlDocument const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlDocument *param1_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDocument, 1, "TiXmlDocument.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlDocument *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlDocument,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlDocument.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlDocument this, const TiXmlDocument copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_operator_52_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlDocument this, const TiXmlDocument copy)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlDocument_operator_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [bool TiXmlDocument::LoadFile(FILE *, TiXmlEncoding encoding)]
 * Rejected Remap [bool TiXmlDocument::LoadFile(FILE *, TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))]
 * bool TiXmlDocument::LoadFile(TiXmlEncoding encoding)
 * bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
 * bool TiXmlDocument::LoadFile(basic_string< char > const &filename, TiXmlEncoding encoding)
 * bool TiXmlDocument::LoadFile(basic_string< char > const &filename, TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
 * bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding)
 * bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_LoadFile_53(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":LoadFile", key_word_list));
            else
                (PyArg_Parse(args, ":LoadFile"));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->LoadFile();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlDocument.LoadFile() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool TiXmlDocument::LoadFile(basic_string< char > const &filename, TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LoadFile", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:LoadFile", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->LoadFile(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool TiXmlDocument::LoadFile(TiXmlEncoding encoding)
            int param1;
            static char * key_word_list[] = {(char *)"encoding", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:LoadFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:LoadFile", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->LoadFile((TiXmlEncoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = (TIXML_DEFAULT_ENCODING))
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:LoadFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:LoadFile", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->LoadFile((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool TiXmlDocument::LoadFile(basic_string< char > const &filename, TiXmlEncoding encoding)
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:LoadFile", key_word_list, &param1_str, &param1_len, &param2))
            {
                bool return_value = (local_this)->LoadFile(basic_string<char>(param1_str, param1_len), (TiXmlEncoding)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding)
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"encoding", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:LoadFile", key_word_list, &param1, &param2))
            {
                bool return_value = (local_this)->LoadFile((char const *)param1, (TiXmlEncoding)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LoadFile() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LoadFile(non-const TiXmlDocument this)\n"
          "LoadFile(non-const TiXmlDocument this, string filename)\n"
          "LoadFile(non-const TiXmlDocument this, int encoding)\n"
          "LoadFile(non-const TiXmlDocument this, string filename)\n"
          "LoadFile(non-const TiXmlDocument this, string filename, int encoding)\n"
          "LoadFile(non-const TiXmlDocument this, string filename, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_LoadFile_53_comment =
    "C++ Interface:\n"
    "LoadFile(non-const TiXmlDocument this)\n"
    "LoadFile(non-const TiXmlDocument this, string filename)\n"
    "LoadFile(non-const TiXmlDocument this, int encoding)\n"
    "LoadFile(non-const TiXmlDocument this, string filename)\n"
    "LoadFile(non-const TiXmlDocument this, string filename, int encoding)\n"
    "LoadFile(non-const TiXmlDocument this, string filename, int encoding)\n"
    "\n"
    "/** Load a file using the current document value.\n"
    "\011\011Returns true if successful. Will delete any existing\n"
    "\011\011document data before loading.\n"
    "\011*/\n"
    "\n"
    "/// Load a file using the given filename. Returns true if successful.\n"
    "\n"
    "/** Load a file using the given FILE*. Returns true if successful. Note that this method\n"
    "\011\011doesn't stream - the entire object pointed at by the FILE*\n"
    "\011\011will be interpreted as an XML file. TinyXML doesn't stream in XML from the current\n"
    "\011\011file location. Streaming may be added in the future.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_LoadFile_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlDocument::SaveFile(void) const
 * Rejected Remap [bool TiXmlDocument::SaveFile(FILE *) const]
 * bool TiXmlDocument::SaveFile(basic_string< char > const &filename) const
 * bool TiXmlDocument::SaveFile(char const *filename) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_SaveFile_54(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-bool TiXmlDocument::SaveFile(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":SaveFile", key_word_list));
            else
                (PyArg_Parse(args, ":SaveFile"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const TiXmlDocument*)local_this)->SaveFile();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // -2 bool TiXmlDocument::SaveFile(basic_string< char > const &filename) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SaveFile", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:SaveFile", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const TiXmlDocument*)local_this)->SaveFile(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool TiXmlDocument::SaveFile(char const *filename) const
            char *param1;
            static char * key_word_list[] = {(char *)"filename", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:SaveFile", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:SaveFile", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const TiXmlDocument*)local_this)->SaveFile((char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SaveFile() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SaveFile(const TiXmlDocument this)\n"
          "SaveFile(const TiXmlDocument this, string filename)\n"
          "SaveFile(const TiXmlDocument this, string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_SaveFile_54_comment =
    "C++ Interface:\n"
    "SaveFile(const TiXmlDocument this)\n"
    "SaveFile(const TiXmlDocument this, string filename)\n"
    "SaveFile(const TiXmlDocument this, string filename)\n"
    "\n"
    "/// Save a file using the current document value. Returns true if successful.\n"
    "\n"
    "/// Save a file using the given filename. Returns true if successful.\n"
    "\n"
    "/// Save a file using the given FILE*. Returns true if successful.\n"
    "";
#else
static const char * Dtool_TiXmlDocument_SaveFile_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement *TiXmlDocument::RootElement(void)
 * TiXmlElement const *TiXmlDocument::RootElement(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_RootElement_55(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlElement *TiXmlDocument::RootElement(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":RootElement", key_word_list));
        else
            (PyArg_Parse(args, ":RootElement"));
        if(!PyErr_Occurred())
        {
            TiXmlElement *return_value = (local_this)->RootElement();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlElement const *TiXmlDocument::RootElement(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":RootElement", key_word_list));
        else
            (PyArg_Parse(args, ":RootElement"));
        if(!PyErr_Occurred())
        {
            TiXmlElement const *return_value = ((const TiXmlDocument*)local_this)->RootElement();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RootElement(non-const TiXmlDocument this)\n"
          "RootElement(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_RootElement_55_comment =
    "C++ Interface:\n"
    "RootElement(non-const TiXmlDocument this)\n"
    "RootElement(const TiXmlDocument this)\n"
    "\n"
    "/** Get the root element -- the only top level element -- of the document.\n"
    "\011\011In well formed XML, there should only be one. TinyXml is tolerant of\n"
    "\011\011multiple elements at the document level.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_RootElement_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlDocument::Error(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_Error_56(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TiXmlDocument::Error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Error", key_word_list));
        else
            (PyArg_Parse(args, ":Error"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TiXmlDocument*)local_this)->Error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Error(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_Error_56_comment =
    "C++ Interface:\n"
    "Error(const TiXmlDocument this)\n"
    "\n"
    "/** If an error occurs, Error will be set to true. Also,\n"
    "\011\011- The ErrorId() will contain the integer identifier of the error (not generally useful)\n"
    "\011\011- The ErrorDesc() method will return the name of the error. (very useful)\n"
    "\011\011- The ErrorRow() and ErrorCol() will return the location of the error (if known)\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_Error_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlDocument::ErrorDesc(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_ErrorDesc_57(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlDocument::ErrorDesc(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ErrorDesc", key_word_list));
        else
            (PyArg_Parse(args, ":ErrorDesc"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlDocument*)local_this)->ErrorDesc();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ErrorDesc(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_ErrorDesc_57_comment =
    "C++ Interface:\n"
    "ErrorDesc(const TiXmlDocument this)\n"
    "\n"
    "/// Contains a textual (english) description of the error if one occurs.\n"
    "";
#else
static const char * Dtool_TiXmlDocument_ErrorDesc_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlDocument::ErrorId(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_ErrorId_58(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlDocument::ErrorId(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ErrorId", key_word_list));
        else
            (PyArg_Parse(args, ":ErrorId"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlDocument*)local_this)->ErrorId();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ErrorId(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_ErrorId_58_comment =
    "C++ Interface:\n"
    "ErrorId(const TiXmlDocument this)\n"
    "\n"
    "/** Generally, you probably want the error string ( ErrorDesc() ). But if you\n"
    "\011\011prefer the ErrorId, this function will fetch it.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_ErrorId_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlDocument::ErrorRow(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_ErrorRow_59(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlDocument::ErrorRow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ErrorRow", key_word_list));
        else
            (PyArg_Parse(args, ":ErrorRow"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlDocument*)local_this)->ErrorRow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ErrorRow(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_ErrorRow_59_comment =
    "C++ Interface:\n"
    "ErrorRow(const TiXmlDocument this)\n"
    "\n"
    "/** Returns the location (if known) of the error. The first column is column 1, \n"
    "\011\011and the first row is row 1. A value of 0 means the row and column wasn't applicable\n"
    "\011\011(memory errors, for example, have no row/column) or the parser lost the error. (An\n"
    "\011\011error in the error reporting, in that case.)\n"
    "\n"
    "\011\011@sa SetTabSize, Row, Column\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_ErrorRow_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlDocument::ErrorCol(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_ErrorCol_60(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlDocument::ErrorCol(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ErrorCol", key_word_list));
        else
            (PyArg_Parse(args, ":ErrorCol"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlDocument*)local_this)->ErrorCol();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ErrorCol(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_ErrorCol_60_comment =
    "C++ Interface:\n"
    "ErrorCol(const TiXmlDocument this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlDocument_ErrorCol_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlDocument::SetTabSize(int _tabsize)
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_SetTabSize_61(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlDocument::SetTabSize(int _tabsize)
        int param1;
        static char * key_word_list[] = {(char *)"_tabsize", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetTabSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:SetTabSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetTabSize((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlDocument.SetTabSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetTabSize(non-const TiXmlDocument this, int _tabsize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_SetTabSize_61_comment =
    "C++ Interface:\n"
    "SetTabSize(non-const TiXmlDocument this, int _tabsize)\n"
    "\n"
    "/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())\n"
    "\011\011to report the correct values for row and column. It does not change the output\n"
    "\011\011or input in any way.\n"
    "\011\011\n"
    "\011\011By calling this method, with a tab size\n"
    "\011\011greater than 0, the row and column of each node and attribute is stored\n"
    "\011\011when the file is loaded. Very useful for tracking the DOM back in to\n"
    "\011\011the source file.\n"
    "\n"
    "\011\011The tab size is required for calculating the location of nodes. If not\n"
    "\011\011set, the default of 4 is used. The tabsize is set per document. Setting\n"
    "\011\011the tabsize to 0 disables row/column tracking.\n"
    "\n"
    "\011\011Note that row and column tracking is not supported when using operator>>.\n"
    "\n"
    "\011\011The tab size needs to be enabled before the parse or load. Correct usage:\n"
    "\011\011@verbatim\n"
    "\011\011TiXmlDocument doc;\n"
    "\011\011doc.SetTabSize( 8 );\n"
    "\011\011doc.Load( \"myfile.xml\" );\n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011@sa Row, Column\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_SetTabSize_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlDocument::TabSize(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_TabSize_62(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlDocument::TabSize(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":TabSize", key_word_list));
        else
            (PyArg_Parse(args, ":TabSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlDocument*)local_this)->TabSize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TabSize(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_TabSize_62_comment =
    "C++ Interface:\n"
    "TabSize(const TiXmlDocument this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlDocument_TabSize_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlDocument::ClearError(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_ClearError_63(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlDocument::ClearError(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ClearError", key_word_list));
        else
            (PyArg_Parse(args, ":ClearError"));
        if(!PyErr_Occurred())
        {
            (local_this)->ClearError();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlDocument.ClearError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ClearError(non-const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_ClearError_63_comment =
    "C++ Interface:\n"
    "ClearError(non-const TiXmlDocument this)\n"
    "\n"
    "/** If you have handled the error, it can be reset with this call. The error\n"
    "\011\011state is automatically cleared if you Parse a new XML block.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlDocument_ClearError_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlDocument::Print(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlDocument_Print_64(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlDocument * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlDocument,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void TiXmlDocument::Print(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Print", key_word_list));
        else
            (PyArg_Parse(args, ":Print"));
        if(!PyErr_Occurred())
        {
            ((const TiXmlDocument*)local_this)->Print();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Print(const TiXmlDocument this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlDocument_Print_64_comment =
    "C++ Interface:\n"
    "Print(const TiXmlDocument this)\n"
    "\n"
    "/** Write the document to standard out using formatted printing (\"pretty print\"). */\n"
    "";
#else
static const char * Dtool_TiXmlDocument_Print_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlDocument::TiXmlDocument(void)
 * TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy)
 * TiXmlDocument::TiXmlDocument(basic_string< char > const &documentName)
 * TiXmlDocument::TiXmlDocument(char const *documentName)
 *******************************************************************/
int  Dtool_Init_TiXmlDocument(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlDocument::TiXmlDocument(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlDocument", key_word_list))
            {
                TiXmlDocument *return_value = new TiXmlDocument();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDocument,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlDocument", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TiXmlDocument", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlDocument *param0_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlDocument, 0, "TiXmlDocument.TiXmlDocument", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TiXmlDocument *return_value = new TiXmlDocument(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDocument,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlDocument::TiXmlDocument(basic_string< char > const &documentName)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"documentName", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:TiXmlDocument", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:TiXmlDocument", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    TiXmlDocument *return_value = new TiXmlDocument(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDocument,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlDocument::TiXmlDocument(char const *documentName)
                char *param0;
                static char * key_word_list[] = {(char *)"documentName", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s:TiXmlDocument", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "s:TiXmlDocument", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlDocument *return_value = new TiXmlDocument((char const *)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlDocument,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TiXmlDocument() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TiXmlDocument()\n"
          "TiXmlDocument(const TiXmlDocument copy)\n"
          "TiXmlDocument(string documentName)\n"
          "TiXmlDocument(string documentName)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlDocument(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlDocument)
    {
        printf("TiXmlDocument ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlDocument * local_this = (TiXmlDocument *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlDocument)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlDocument(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlDocument)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlDocument*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlDocument*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlElement 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlElement::operator =(TiXmlElement const &base)
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_operator_68(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlElement::operator =(TiXmlElement const &base)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"base", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement *param1_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlElement, 1, "TiXmlElement.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlElement *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlElement.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlElement this, const TiXmlElement base)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_operator_68_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlElement this, const TiXmlElement base)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlElement_operator_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const *TiXmlElement::Attribute(basic_string< char > const &name) const
 * char const *TiXmlElement::Attribute(char const *name) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_Attribute_69(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 basic_string< char > const *TiXmlElement::Attribute(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Attribute", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:Attribute", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > const *return_value = ((const TiXmlElement*)local_this)->Attribute(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromStringAndSize(return_value->data(), (int)return_value->length());
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 char const *TiXmlElement::Attribute(char const *name) const
        char *param1;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:Attribute", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:Attribute", &param1));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlElement*)local_this)->Attribute((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Attribute(const TiXmlElement this, string name)\n"
          "Attribute(const TiXmlElement this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_Attribute_69_comment =
    "C++ Interface:\n"
    "Attribute(const TiXmlElement this, string name)\n"
    "Attribute(const TiXmlElement this, string name)\n"
    "\n"
    "/** Given an attribute name, Attribute() returns the value\n"
    "\011\011for the attribute of that name, or null if none exists.\n"
    "\011*/\n"
    "\n"
    "/** Given an attribute name, Attribute() returns the value\n"
    "\011\011for the attribute of that name, or null if none exists.\n"
    "\011\011If the attribute exists and can be converted to an integer,\n"
    "\011\011the integer value will be put in the return 'i', if 'i'\n"
    "\011\011is non-null.\n"
    "\011*/\n"
    "\n"
    "/** Given an attribute name, Attribute() returns the value\n"
    "\011\011for the attribute of that name, or null if none exists.\n"
    "\011\011If the attribute exists and can be converted to an double,\n"
    "\011\011the double value will be put in the return 'd', if 'd'\n"
    "\011\011is non-null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlElement_Attribute_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlElement::QueryStringAttribute(char const *name, basic_string< char > *_value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_QueryStringAttribute_73(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int TiXmlElement::QueryStringAttribute(char const *name, basic_string< char > *_value) const
            char *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "sO:QueryStringAttribute", key_word_list, &param1, &param2))
            {
                basic_string< char > *param2_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_basic_string_char, 2, "TiXmlElement.QueryStringAttribute", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    int return_value = ((const TiXmlElement*)local_this)->QueryStringAttribute((char const *)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "QueryStringAttribute(const TiXmlElement this, string name, non-const BasicString _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_QueryStringAttribute_73_comment =
    "C++ Interface:\n"
    "QueryStringAttribute(const TiXmlElement this, string name, non-const BasicString _value)\n"
    "\n"
    "/// QueryStringAttribute examines the attribute - see QueryIntAttribute().\n"
    "";
#else
static const char * Dtool_TiXmlElement_QueryStringAttribute_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlElement::QueryValueAttribute(basic_string< char > const &name, basic_string< char > *outValue) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_QueryValueAttribute_74(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int TiXmlElement::QueryValueAttribute(basic_string< char > const &name, basic_string< char > *outValue) const
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"outValue", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:QueryValueAttribute", key_word_list, &param1_str, &param1_len, &param2))
            {
                basic_string< char > *param2_this = (basic_string< char > *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_basic_string_char, 2, "TiXmlElement.QueryValueAttribute", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    int return_value = ((const TiXmlElement*)local_this)->QueryValueAttribute(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "QueryValueAttribute(const TiXmlElement this, string name, non-const BasicString outValue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_QueryValueAttribute_74_comment =
    "C++ Interface:\n"
    "QueryValueAttribute(const TiXmlElement this, string name, non-const BasicString outValue)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlElement_QueryValueAttribute_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlElement::SetAttribute(basic_string< char > const &name, basic_string< char > const &_value)
 * void TiXmlElement::SetAttribute(basic_string< char > const &name, int _value)
 * void TiXmlElement::SetAttribute(char const *name, char const *_value)
 * void TiXmlElement::SetAttribute(char const *name, int value)
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_SetAttribute_75(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetAttribute(basic_string< char > const &name, basic_string< char > const &_value)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"name", (char *)"_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:SetAttribute", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->SetAttribute(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetAttribute(basic_string< char > const &name, int _value)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"name", (char *)"_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:SetAttribute", key_word_list, &param1_str, &param1_len, &param2))
        {
            (local_this)->SetAttribute(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetAttribute(char const *name, int value)
        char *param1;
        int param2;
        static char * key_word_list[] = {(char *)"name", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "si:SetAttribute", key_word_list, &param1, &param2))
        {
            (local_this)->SetAttribute((char const *)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetAttribute(char const *name, char const *_value)
        char *param1;
        char *param2;
        static char * key_word_list[] = {(char *)"name", (char *)"_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ss:SetAttribute", key_word_list, &param1, &param2))
        {
            (local_this)->SetAttribute((char const *)param1, (char const *)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetAttribute(non-const TiXmlElement this, string name, string _value)\n"
          "SetAttribute(non-const TiXmlElement this, string name, int _value)\n"
          "SetAttribute(non-const TiXmlElement this, string name, int value)\n"
          "SetAttribute(non-const TiXmlElement this, string name, string _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_SetAttribute_75_comment =
    "C++ Interface:\n"
    "SetAttribute(non-const TiXmlElement this, string name, string _value)\n"
    "SetAttribute(non-const TiXmlElement this, string name, int _value)\n"
    "SetAttribute(non-const TiXmlElement this, string name, int value)\n"
    "SetAttribute(non-const TiXmlElement this, string name, string _value)\n"
    "\n"
    "/** Sets an attribute of name to a given value. The attribute\n"
    "\011\011will be created if it does not exist, or changed if it does.\n"
    "\011*/\n"
    "\n"
    "/// STL std::string form.\n"
    "\n"
    "///< STL std::string form.\n"
    "\n"
    "/** Sets an attribute of name to a given value. The attribute\n"
    "\011\011will be created if it does not exist, or changed if it does.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlElement_SetAttribute_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlElement::SetDoubleAttribute(basic_string< char > const &name, double value)
 * void TiXmlElement::SetDoubleAttribute(char const *name, double value)
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_SetDoubleAttribute_76(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetDoubleAttribute(basic_string< char > const &name, double value)
        char *param1_str; int param1_len;
        double param2;
        static char * key_word_list[] = {(char *)"name", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:SetDoubleAttribute", key_word_list, &param1_str, &param1_len, &param2))
        {
            (local_this)->SetDoubleAttribute(basic_string<char>(param1_str, param1_len), (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::SetDoubleAttribute(char const *name, double value)
        char *param1;
        double param2;
        static char * key_word_list[] = {(char *)"name", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "sd:SetDoubleAttribute", key_word_list, &param1, &param2))
        {
            (local_this)->SetDoubleAttribute((char const *)param1, (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetDoubleAttribute(non-const TiXmlElement this, string name, float value)\n"
          "SetDoubleAttribute(non-const TiXmlElement this, string name, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_SetDoubleAttribute_76_comment =
    "C++ Interface:\n"
    "SetDoubleAttribute(non-const TiXmlElement this, string name, float value)\n"
    "SetDoubleAttribute(non-const TiXmlElement this, string name, float value)\n"
    "\n"
    "///< STL std::string form.\n"
    "\n"
    "/** Sets an attribute of name to a given value. The attribute\n"
    "\011\011will be created if it does not exist, or changed if it does.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlElement_SetDoubleAttribute_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlElement::RemoveAttribute(basic_string< char > const &name)
 * void TiXmlElement::RemoveAttribute(char const *name)
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_RemoveAttribute_77(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::RemoveAttribute(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:RemoveAttribute", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:RemoveAttribute", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->RemoveAttribute(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlElement::RemoveAttribute(char const *name)
        char *param1;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:RemoveAttribute", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:RemoveAttribute", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->RemoveAttribute((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RemoveAttribute(non-const TiXmlElement this, string name)\n"
          "RemoveAttribute(non-const TiXmlElement this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_RemoveAttribute_77_comment =
    "C++ Interface:\n"
    "RemoveAttribute(non-const TiXmlElement this, string name)\n"
    "RemoveAttribute(non-const TiXmlElement this, string name)\n"
    "\n"
    "/** Deletes an attribute with the given name.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlElement_RemoveAttribute_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlElement::FirstAttribute(void)
 * TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_FirstAttribute_78(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstAttribute", key_word_list));
        else
            (PyArg_Parse(args, ":FirstAttribute"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlElement*)local_this)->FirstAttribute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlElement::FirstAttribute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstAttribute", key_word_list));
        else
            (PyArg_Parse(args, ":FirstAttribute"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->FirstAttribute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FirstAttribute(const TiXmlElement this)\n"
          "FirstAttribute(non-const TiXmlElement this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_FirstAttribute_78_comment =
    "C++ Interface:\n"
    "FirstAttribute(const TiXmlElement this)\n"
    "FirstAttribute(non-const TiXmlElement this)\n"
    "\n"
    "///< Access the first attribute in this element.\n"
    "";
#else
static const char * Dtool_TiXmlElement_FirstAttribute_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlElement::LastAttribute(void)
 * TiXmlAttribute const *TiXmlElement::LastAttribute(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_LastAttribute_79(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlElement::LastAttribute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":LastAttribute", key_word_list));
        else
            (PyArg_Parse(args, ":LastAttribute"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->LastAttribute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlAttribute const *TiXmlElement::LastAttribute(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":LastAttribute", key_word_list));
        else
            (PyArg_Parse(args, ":LastAttribute"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlElement*)local_this)->LastAttribute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "LastAttribute(non-const TiXmlElement this)\n"
          "LastAttribute(const TiXmlElement this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_LastAttribute_79_comment =
    "C++ Interface:\n"
    "LastAttribute(non-const TiXmlElement this)\n"
    "LastAttribute(const TiXmlElement this)\n"
    "\n"
    "///< Access the first attribute in this element.\n"
    "\n"
    "///< Access the last attribute in this element.\n"
    "";
#else
static const char * Dtool_TiXmlElement_LastAttribute_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlElement::GetText(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlElement_GetText_80(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlElement * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlElement,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlElement::GetText(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetText", key_word_list));
        else
            (PyArg_Parse(args, ":GetText"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlElement*)local_this)->GetText();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetText(const TiXmlElement this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlElement_GetText_80_comment =
    "C++ Interface:\n"
    "GetText(const TiXmlElement this)\n"
    "\n"
    "/** Convenience function for easy access to the text inside an element. Although easy\n"
    "\011\011and concise, GetText() is limited compared to getting the TiXmlText child\n"
    "\011\011and accessing it directly.\n"
    "\011\n"
    "\011\011If the first child of 'this' is a TiXmlText, the GetText()\n"
    "\011\011returns the character string of the Text node, else null is returned.\n"
    "\n"
    "\011\011This is a convenient method for getting the text of simple contained text:\n"
    "\011\011@verbatim\n"
    "\011\011<foo>This is text</foo>\n"
    "\011\011const char* str = fooElement->GetText();\n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011'str' will be a pointer to \"This is text\". \n"
    "\011\011\n"
    "\011\011Note that this function can be misleading. If the element foo was created from\n"
    "\011\011this XML:\n"
    "\011\011@verbatim\n"
    "\011\011<foo><b>This is text</b></foo> \n"
    "\011\011@endverbatim\n"
    "\n"
    "\011\011then the value of str would be null. The first child node isn't a text node, it is\n"
    "\011\011another element. From this XML:\n"
    "\011\011@verbatim\n"
    "\011\011<foo>This is <b>text</b></foo> \n"
    "\011\011@endverbatim\n"
    "\011\011GetText() will return \"This is \".\n"
    "\n"
    "\011\011WARNING: GetText() accesses a child node - don't become confused with the \n"
    "\011\011\011\011 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are \n"
    "\011\011\011\011 safe type casts on the referenced node.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlElement_GetText_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement::TiXmlElement(TiXmlElement const &)
 * TiXmlElement::TiXmlElement(basic_string< char > const &_value)
 * TiXmlElement::TiXmlElement(char const *in_value)
 *******************************************************************/
int  Dtool_Init_TiXmlElement(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 TiXmlElement::TiXmlElement(TiXmlElement const &)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlElement", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TiXmlElement", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlElement *param0_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlElement, 0, "TiXmlElement.TiXmlElement", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    TiXmlElement *return_value = new TiXmlElement(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlElement,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement::TiXmlElement(basic_string< char > const &_value)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:TiXmlElement", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:TiXmlElement", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = new TiXmlElement(basic_string<char>(param0_str, param0_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlElement,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlElement::TiXmlElement(char const *in_value)
            char *param0;
            static char * key_word_list[] = {(char *)"in_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:TiXmlElement", key_word_list, &param0));
            else
                (PyArg_Parse(args, "s:TiXmlElement", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlElement *return_value = new TiXmlElement((char const *)param0);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlElement,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TiXmlElement(const TiXmlElement)\n"
          "TiXmlElement(string _value)\n"
          "TiXmlElement(string in_value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlElement(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlElement)
    {
        printf("TiXmlElement ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlElement * local_this = (TiXmlElement *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlElement)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlElement(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlElement)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlElement*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlElement*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlCursor 
//********************************************************************
int  Dtool_Init_TiXmlCursor(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TiXmlCursor)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TiXmlCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlCursor)
    {
        printf("TiXmlCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlCursor * local_this = (TiXmlCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlCursor)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlCursor)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlVisitor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &)
 * virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *)
 *******************************************************************/
static PyObject *Dtool_TiXmlVisitor_VisitEnter_94(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlVisitor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlVisitor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:VisitEnter", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:VisitEnter", &param1));
                if(!PyErr_Occurred())
                {
                    TiXmlDocument *param1_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDocument, 1, "TiXmlVisitor.VisitEnter", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->VisitEnter(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TiXmlVisitor.VisitEnter() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:VisitEnter", key_word_list, &param1, &param2))
                {
                    TiXmlElement *param1_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlElement, 1, "TiXmlVisitor.VisitEnter", 1, coerced_ptr, report_errors);
TiXmlAttribute *param2_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TiXmlAttribute, 2, "TiXmlVisitor.VisitEnter", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->VisitEnter(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call TiXmlVisitor.VisitEnter() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "VisitEnter() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "VisitEnter(non-const TiXmlVisitor this, const TiXmlDocument)\n"
          "VisitEnter(non-const TiXmlVisitor this, const TiXmlElement, const TiXmlAttribute)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlVisitor_VisitEnter_94_comment =
    "C++ Interface:\n"
    "VisitEnter(non-const TiXmlVisitor this, const TiXmlDocument)\n"
    "VisitEnter(non-const TiXmlVisitor this, const TiXmlElement, const TiXmlAttribute)\n"
    "\n"
    "/*doc*/\n"
    "\n"
    "/*firstAttribute*/\n"
    "";
#else
static const char * Dtool_TiXmlVisitor_VisitEnter_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &)
 * virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &)
 *******************************************************************/
static PyObject *Dtool_TiXmlVisitor_VisitExit_95(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlVisitor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlVisitor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:VisitExit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:VisitExit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlDocument *param1_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDocument, 1, "TiXmlVisitor.VisitExit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->VisitExit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:VisitExit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:VisitExit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlElement *param1_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlElement, 1, "TiXmlVisitor.VisitExit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->VisitExit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VisitExit(non-const TiXmlVisitor this, const TiXmlDocument)\n"
          "VisitExit(non-const TiXmlVisitor this, const TiXmlElement)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlVisitor_VisitExit_95_comment =
    "C++ Interface:\n"
    "VisitExit(non-const TiXmlVisitor this, const TiXmlDocument)\n"
    "VisitExit(non-const TiXmlVisitor this, const TiXmlElement)\n"
    "\n"
    "/*doc*/\n"
    "\n"
    "/*element*/\n"
    "";
#else
static const char * Dtool_TiXmlVisitor_VisitExit_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool TiXmlVisitor::Visit(TiXmlComment const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlText const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &)
 *******************************************************************/
static PyObject *Dtool_TiXmlVisitor_Visit_96(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlVisitor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlVisitor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::Visit(TiXmlText const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Visit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Visit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlText *param1_this = (TiXmlText *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlText, 1, "TiXmlVisitor.Visit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->Visit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::Visit(TiXmlComment const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Visit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Visit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlComment *param1_this = (TiXmlComment *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlComment, 1, "TiXmlVisitor.Visit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->Visit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Visit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Visit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlUnknown *param1_this = (TiXmlUnknown *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlUnknown, 1, "TiXmlVisitor.Visit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->Visit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Visit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Visit", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlDeclaration *param1_this = (TiXmlDeclaration *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDeclaration, 1, "TiXmlVisitor.Visit", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->Visit(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Visit(non-const TiXmlVisitor this, const TiXmlText)\n"
          "Visit(non-const TiXmlVisitor this, const TiXmlComment)\n"
          "Visit(non-const TiXmlVisitor this, const TiXmlUnknown)\n"
          "Visit(non-const TiXmlVisitor this, const TiXmlDeclaration)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlVisitor_Visit_96_comment =
    "C++ Interface:\n"
    "Visit(non-const TiXmlVisitor this, const TiXmlText)\n"
    "Visit(non-const TiXmlVisitor this, const TiXmlComment)\n"
    "Visit(non-const TiXmlVisitor this, const TiXmlUnknown)\n"
    "Visit(non-const TiXmlVisitor this, const TiXmlDeclaration)\n"
    "\n"
    "/*declaration*/\n"
    "\n"
    "/*text*/\n"
    "\n"
    "/*comment*/\n"
    "\n"
    "/*unknown*/\n"
    "";
#else
static const char * Dtool_TiXmlVisitor_Visit_96_comment = NULL;
#endif

int  Dtool_Init_TiXmlVisitor(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (TiXmlVisitor)");
       return -1;
}
inline void  * Dtool_UpcastInterface_TiXmlVisitor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlVisitor)
    {
        printf("TiXmlVisitor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlVisitor * local_this = (TiXmlVisitor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlVisitor)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlVisitor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlVisitor)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlAttribute 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlAttribute::Name(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_Name_102(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlAttribute::Name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Name", key_word_list));
        else
            (PyArg_Parse(args, ":Name"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlAttribute*)local_this)->Name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Name(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_Name_102_comment =
    "C++ Interface:\n"
    "Name(const TiXmlAttribute this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_Name_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlAttribute::Value(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_Value_103(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-char const *TiXmlAttribute::Value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Value", key_word_list));
        else
            (PyArg_Parse(args, ":Value"));
        if(!PyErr_Occurred())
        {
            char const *return_value = ((const TiXmlAttribute*)local_this)->Value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Value(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_Value_103_comment =
    "C++ Interface:\n"
    "Value(const TiXmlAttribute this)\n"
    "\n"
    "///< Return the name of this attribute.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_Value_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &TiXmlAttribute::ValueStr(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_ValueStr_104(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &TiXmlAttribute::ValueStr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ValueStr", key_word_list));
        else
            (PyArg_Parse(args, ":ValueStr"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const TiXmlAttribute*)local_this)->ValueStr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ValueStr(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_ValueStr_104_comment =
    "C++ Interface:\n"
    "ValueStr(const TiXmlAttribute this)\n"
    "\n"
    "///< Return the value of this attribute.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_ValueStr_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TiXmlAttribute::IntValue(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_IntValue_105(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int TiXmlAttribute::IntValue(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":IntValue", key_word_list));
        else
            (PyArg_Parse(args, ":IntValue"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const TiXmlAttribute*)local_this)->IntValue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "IntValue(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_IntValue_105_comment =
    "C++ Interface:\n"
    "IntValue(const TiXmlAttribute this)\n"
    "\n"
    "///< Return the value of this attribute.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_IntValue_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double TiXmlAttribute::DoubleValue(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_DoubleValue_106(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double TiXmlAttribute::DoubleValue(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":DoubleValue", key_word_list));
        else
            (PyArg_Parse(args, ":DoubleValue"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const TiXmlAttribute*)local_this)->DoubleValue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DoubleValue(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_DoubleValue_106_comment =
    "C++ Interface:\n"
    "DoubleValue(const TiXmlAttribute this)\n"
    "\n"
    "///< Return the value of this attribute, converted to an integer.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_DoubleValue_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &TiXmlAttribute::NameTStr(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_NameTStr_107(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &TiXmlAttribute::NameTStr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":NameTStr", key_word_list));
        else
            (PyArg_Parse(args, ":NameTStr"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const TiXmlAttribute*)local_this)->NameTStr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NameTStr(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_NameTStr_107_comment =
    "C++ Interface:\n"
    "NameTStr(const TiXmlAttribute this)\n"
    "\n"
    "///< Return the value of this attribute, converted to a double.\n"
    "// Get the tinyxml string representation\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_NameTStr_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttribute::SetName(basic_string< char > const &_name)
 * void TiXmlAttribute::SetName(char const *_name)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_SetName_110(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlAttribute::SetName(basic_string< char > const &_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SetName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:SetName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->SetName(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlAttribute::SetName(char const *_name)
        char *param1;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:SetName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:SetName", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetName((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetName(non-const TiXmlAttribute this, string _name)\n"
          "SetName(non-const TiXmlAttribute this, string _name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_SetName_110_comment =
    "C++ Interface:\n"
    "SetName(non-const TiXmlAttribute this, string _name)\n"
    "SetName(non-const TiXmlAttribute this, string _name)\n"
    "\n"
    "/// STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_SetName_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttribute::SetValue(basic_string< char > const &_value)
 * void TiXmlAttribute::SetValue(char const *_value)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_SetValue_111(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlAttribute::SetValue(basic_string< char > const &_value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SetValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:SetValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->SetValue(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 void TiXmlAttribute::SetValue(char const *_value)
        char *param1;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:SetValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:SetValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetValue((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetValue(non-const TiXmlAttribute this, string _value)\n"
          "SetValue(non-const TiXmlAttribute this, string _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_SetValue_111_comment =
    "C++ Interface:\n"
    "SetValue(non-const TiXmlAttribute this, string _value)\n"
    "SetValue(non-const TiXmlAttribute this, string _value)\n"
    "\n"
    "///< Set the name of this attribute.\n"
    "\n"
    "/// STL std::string form.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_SetValue_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttribute::SetIntValue(int _value)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_SetIntValue_112(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlAttribute::SetIntValue(int _value)
        int param1;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:SetIntValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:SetIntValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetIntValue((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlAttribute.SetIntValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetIntValue(non-const TiXmlAttribute this, int _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_SetIntValue_112_comment =
    "C++ Interface:\n"
    "SetIntValue(non-const TiXmlAttribute this, int _value)\n"
    "\n"
    "///< Set the value.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_SetIntValue_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttribute::SetDoubleValue(double _value)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_SetDoubleValue_113(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlAttribute::SetDoubleValue(double _value)
        double param1;
        static char * key_word_list[] = {(char *)"_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:SetDoubleValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:SetDoubleValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetDoubleValue((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlAttribute.SetDoubleValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetDoubleValue(non-const TiXmlAttribute this, float _value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_SetDoubleValue_113_comment =
    "C++ Interface:\n"
    "SetDoubleValue(non-const TiXmlAttribute this, float _value)\n"
    "\n"
    "///< Set the value from an integer.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_SetDoubleValue_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttribute::Next(void)
 * TiXmlAttribute const *TiXmlAttribute::Next(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_Next_114(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 TiXmlAttribute const *TiXmlAttribute::Next(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Next", key_word_list));
        else
            (PyArg_Parse(args, ":Next"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlAttribute*)local_this)->Next();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttribute::Next(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Next", key_word_list));
        else
            (PyArg_Parse(args, ":Next"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->Next();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Next(const TiXmlAttribute this)\n"
          "Next(non-const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_Next_114_comment =
    "C++ Interface:\n"
    "Next(const TiXmlAttribute this)\n"
    "Next(non-const TiXmlAttribute this)\n"
    "\n"
    "/// Get the next sibling attribute in the DOM. Returns null at end.\n"
    "\n"
    "/// Get the next sibling attribute in the DOM. Returns null at end.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_Next_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttribute::Previous(void)
 * TiXmlAttribute const *TiXmlAttribute::Previous(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_Previous_115(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttribute::Previous(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Previous", key_word_list));
        else
            (PyArg_Parse(args, ":Previous"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->Previous();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlAttribute const *TiXmlAttribute::Previous(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Previous", key_word_list));
        else
            (PyArg_Parse(args, ":Previous"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlAttribute*)local_this)->Previous();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Previous(non-const TiXmlAttribute this)\n"
          "Previous(const TiXmlAttribute this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_Previous_115_comment =
    "C++ Interface:\n"
    "Previous(non-const TiXmlAttribute this)\n"
    "Previous(const TiXmlAttribute this)\n"
    "\n"
    "/// Get the previous sibling attribute in the DOM. Returns null at beginning.\n"
    "\n"
    "/// Get the previous sibling attribute in the DOM. Returns null at beginning.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_Previous_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlAttribute::operator ==(TiXmlAttribute const &rhs) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_operator_116(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool TiXmlAttribute::operator ==(TiXmlAttribute const &rhs) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rhs", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlAttribute *param1_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlAttribute, 1, "TiXmlAttribute.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TiXmlAttribute*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_operator_116_comment =
    "C++ Interface:\n"
    "eq(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_operator_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlAttribute::operator <(TiXmlAttribute const &rhs) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_operator_117(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool TiXmlAttribute::operator <(TiXmlAttribute const &rhs) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rhs", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:lessThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:lessThan", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlAttribute *param1_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlAttribute, 1, "TiXmlAttribute.lessThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TiXmlAttribute*)local_this)->operator <(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lessThan(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_operator_117_comment =
    "C++ Interface:\n"
    "lessThan(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_operator_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlAttribute::operator >(TiXmlAttribute const &rhs) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_operator_118(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool TiXmlAttribute::operator >(TiXmlAttribute const &rhs) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rhs", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:greaterThan", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:greaterThan", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlAttribute *param1_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlAttribute, 1, "TiXmlAttribute.greaterThan", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const TiXmlAttribute*)local_this)->operator >(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "greaterThan(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_operator_118_comment =
    "C++ Interface:\n"
    "greaterThan(const TiXmlAttribute this, const TiXmlAttribute rhs)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_operator_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttribute::SetDocument(TiXmlDocument *doc)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttribute_SetDocument_120(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttribute * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttribute,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlAttribute::SetDocument(TiXmlDocument *doc)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"doc", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:SetDocument", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:SetDocument", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlDocument *param1_this = (TiXmlDocument *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlDocument, 1, "TiXmlAttribute.SetDocument", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->SetDocument(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlAttribute.SetDocument() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetDocument(non-const TiXmlAttribute this, non-const TiXmlDocument doc)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttribute_SetDocument_120_comment =
    "C++ Interface:\n"
    "SetDocument(non-const TiXmlAttribute this, non-const TiXmlDocument doc)\n"
    "\n"
    "// [internal use]\n"
    "// Set the document pointer so the attribute can report errors.\n"
    "";
#else
static const char * Dtool_TiXmlAttribute_SetDocument_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute::TiXmlAttribute(void)
 * TiXmlAttribute::TiXmlAttribute(basic_string< char > const &_name, basic_string< char > const &_value)
 * TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value)
 *******************************************************************/
int  Dtool_Init_TiXmlAttribute(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlAttribute::TiXmlAttribute(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlAttribute", key_word_list))
            {
                TiXmlAttribute *return_value = new TiXmlAttribute();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlAttribute,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 TiXmlAttribute::TiXmlAttribute(basic_string< char > const &_name, basic_string< char > const &_value)
            char *param0_str; int param0_len;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_name", (char *)"_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:TiXmlAttribute", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
            {
                TiXmlAttribute *return_value = new TiXmlAttribute(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlAttribute,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value)
            char *param0;
            char *param1;
            static char * key_word_list[] = {(char *)"_name", (char *)"_value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ss:TiXmlAttribute", key_word_list, &param0, &param1))
            {
                TiXmlAttribute *return_value = new TiXmlAttribute((char const *)param0, (char const *)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlAttribute,true,false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TiXmlAttribute() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TiXmlAttribute()\n"
          "TiXmlAttribute(string _name, string _value)\n"
          "TiXmlAttribute(string _name, string _value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlAttribute(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlAttribute)
    {
        printf("TiXmlAttribute ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlAttribute * local_this = (TiXmlAttribute *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlAttribute)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlAttribute(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlAttribute)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlAttribute*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlAttributeSet 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttributeSet::Add(TiXmlAttribute *attribute)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_Add_125(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlAttributeSet::Add(TiXmlAttribute *attribute)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"attribute", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Add", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlAttribute *param1_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlAttribute, 1, "TiXmlAttributeSet.Add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->Add(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlAttributeSet.Add() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Add(non-const TiXmlAttributeSet this, non-const TiXmlAttribute attribute)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_Add_125_comment =
    "C++ Interface:\n"
    "Add(non-const TiXmlAttributeSet this, non-const TiXmlAttribute attribute)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_Add_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_Remove_126(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"attribute", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:Remove", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlAttribute *param1_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlAttribute, 1, "TiXmlAttributeSet.Remove", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->Remove(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlAttributeSet.Remove() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Remove(non-const TiXmlAttributeSet this, non-const TiXmlAttribute attribute)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_Remove_126_comment =
    "C++ Interface:\n"
    "Remove(non-const TiXmlAttributeSet this, non-const TiXmlAttribute attribute)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_Remove_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttributeSet::First(void)
 * TiXmlAttribute const *TiXmlAttributeSet::First(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_First_127(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttributeSet::First(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":First", key_word_list));
        else
            (PyArg_Parse(args, ":First"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->First();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlAttribute const *TiXmlAttributeSet::First(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":First", key_word_list));
        else
            (PyArg_Parse(args, ":First"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlAttributeSet*)local_this)->First();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "First(non-const TiXmlAttributeSet this)\n"
          "First(const TiXmlAttributeSet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_First_127_comment =
    "C++ Interface:\n"
    "First(non-const TiXmlAttributeSet this)\n"
    "First(const TiXmlAttributeSet this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_First_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttributeSet::Last(void)
 * TiXmlAttribute const *TiXmlAttributeSet::Last(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_Last_128(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 TiXmlAttribute const *TiXmlAttributeSet::Last(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Last", key_word_list));
        else
            (PyArg_Parse(args, ":Last"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute const *return_value = ((const TiXmlAttributeSet*)local_this)->Last();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttributeSet::Last(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Last", key_word_list));
        else
            (PyArg_Parse(args, ":Last"));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->Last();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Last(const TiXmlAttributeSet this)\n"
          "Last(non-const TiXmlAttributeSet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_Last_128_comment =
    "C++ Interface:\n"
    "Last(const TiXmlAttributeSet this)\n"
    "Last(non-const TiXmlAttributeSet this)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_Last_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttributeSet::Find(basic_string< char > const &_name) const
 * TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_Find_129(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 TiXmlAttribute *TiXmlAttributeSet::Find(basic_string< char > const &_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Find", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:Find", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = ((const TiXmlAttributeSet*)local_this)->Find(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const
        char *param1;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:Find", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:Find", &param1));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = ((const TiXmlAttributeSet*)local_this)->Find((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Find(const TiXmlAttributeSet this, string _name)\n"
          "Find(const TiXmlAttributeSet this, string _name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_Find_129_comment =
    "C++ Interface:\n"
    "Find(const TiXmlAttributeSet this, string _name)\n"
    "Find(const TiXmlAttributeSet this, string _name)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_Find_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(basic_string< char > const &_name)
 * TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name)
 *******************************************************************/
static PyObject *Dtool_TiXmlAttributeSet_FindOrCreate_130(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlAttributeSet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlAttributeSet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(basic_string< char > const &_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FindOrCreate", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:FindOrCreate", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->FindOrCreate(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name)
        char *param1;
        static char * key_word_list[] = {(char *)"_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:FindOrCreate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:FindOrCreate", &param1));
        if(!PyErr_Occurred())
        {
            TiXmlAttribute *return_value = (local_this)->FindOrCreate((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlAttribute,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FindOrCreate(non-const TiXmlAttributeSet this, string _name)\n"
          "FindOrCreate(non-const TiXmlAttributeSet this, string _name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlAttributeSet_FindOrCreate_130_comment =
    "C++ Interface:\n"
    "FindOrCreate(non-const TiXmlAttributeSet this, string _name)\n"
    "FindOrCreate(non-const TiXmlAttributeSet this, string _name)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlAttributeSet_FindOrCreate_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlAttributeSet::TiXmlAttributeSet(void)
 *******************************************************************/
int  Dtool_Init_TiXmlAttributeSet(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-TiXmlAttributeSet::TiXmlAttributeSet(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlAttributeSet", key_word_list))
        {
            TiXmlAttributeSet *return_value = new TiXmlAttributeSet();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlAttributeSet,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TiXmlAttributeSet()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlAttributeSet(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlAttributeSet)
    {
        printf("TiXmlAttributeSet ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlAttributeSet * local_this = (TiXmlAttributeSet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlAttributeSet)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlAttributeSet(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlAttributeSet)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlComment 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlComment::operator =(TiXmlComment const &base)
 *******************************************************************/
static PyObject *Dtool_TiXmlComment_operator_133(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlComment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlComment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlComment::operator =(TiXmlComment const &base)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"base", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlComment *param1_this = (TiXmlComment *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlComment, 1, "TiXmlComment.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlComment *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlComment,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlComment.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlComment this, const TiXmlComment base)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlComment_operator_133_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlComment this, const TiXmlComment base)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlComment_operator_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlComment::TiXmlComment(void)
 * TiXmlComment::TiXmlComment(TiXmlComment const &)
 * TiXmlComment::TiXmlComment(char const *_value)
 *******************************************************************/
int  Dtool_Init_TiXmlComment(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlComment::TiXmlComment(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlComment", key_word_list))
            {
                TiXmlComment *return_value = new TiXmlComment();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlComment,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 TiXmlComment::TiXmlComment(TiXmlComment const &)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlComment", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TiXmlComment", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlComment *param0_this = (TiXmlComment *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlComment, 0, "TiXmlComment.TiXmlComment", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TiXmlComment *return_value = new TiXmlComment(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlComment,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 TiXmlComment::TiXmlComment(char const *_value)
                char *param0;
                static char * key_word_list[] = {(char *)"_value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s:TiXmlComment", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "s:TiXmlComment", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlComment *return_value = new TiXmlComment((char const *)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlComment,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TiXmlComment() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TiXmlComment()\n"
          "TiXmlComment(const TiXmlComment)\n"
          "TiXmlComment(string _value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlComment(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlComment)
    {
        printf("TiXmlComment ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlComment * local_this = (TiXmlComment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlComment)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlComment(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlComment)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlComment*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlComment*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlText 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlText::operator =(TiXmlText const &base)
 *******************************************************************/
static PyObject *Dtool_TiXmlText_operator_136(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlText::operator =(TiXmlText const &base)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"base", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlText *param1_this = (TiXmlText *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlText, 1, "TiXmlText.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlText *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlText,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlText.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlText this, const TiXmlText base)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlText_operator_136_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlText this, const TiXmlText base)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlText_operator_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool TiXmlText::CDATA(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlText_CDATA_137(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool TiXmlText::CDATA(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":CDATA", key_word_list));
        else
            (PyArg_Parse(args, ":CDATA"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TiXmlText*)local_this)->CDATA();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CDATA(const TiXmlText this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlText_CDATA_137_comment =
    "C++ Interface:\n"
    "CDATA(const TiXmlText this)\n"
    "\n"
    "/// Queries whether this represents text using a CDATA section.\n"
    "";
#else
static const char * Dtool_TiXmlText_CDATA_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlText::SetCDATA(bool _cdata)
 *******************************************************************/
static PyObject *Dtool_TiXmlText_SetCDATA_138(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlText::SetCDATA(bool _cdata)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"_cdata", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:SetCDATA", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:SetCDATA", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetCDATA((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlText.SetCDATA() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetCDATA(non-const TiXmlText this, bool _cdata)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlText_SetCDATA_138_comment =
    "C++ Interface:\n"
    "SetCDATA(non-const TiXmlText this, bool _cdata)\n"
    "\n"
    "/// Turns on or off a CDATA representation of text.\n"
    "";
#else
static const char * Dtool_TiXmlText_SetCDATA_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlText::TiXmlText(TiXmlText const &copy)
 * TiXmlText::TiXmlText(basic_string< char > const &initValue)
 * TiXmlText::TiXmlText(char const *initValue)
 *******************************************************************/
int  Dtool_Init_TiXmlText(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 TiXmlText::TiXmlText(TiXmlText const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlText", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TiXmlText", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlText *param0_this = (TiXmlText *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlText, 0, "TiXmlText.TiXmlText", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    TiXmlText *return_value = new TiXmlText(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlText,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlText::TiXmlText(basic_string< char > const &initValue)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"initValue", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:TiXmlText", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:TiXmlText", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                TiXmlText *return_value = new TiXmlText(basic_string<char>(param0_str, param0_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlText,true,false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlText::TiXmlText(char const *initValue)
            char *param0;
            static char * key_word_list[] = {(char *)"initValue", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:TiXmlText", key_word_list, &param0));
            else
                (PyArg_Parse(args, "s:TiXmlText", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlText *return_value = new TiXmlText((char const *)param0);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlText,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TiXmlText(const TiXmlText copy)\n"
          "TiXmlText(string initValue)\n"
          "TiXmlText(string initValue)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlText(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlText)
    {
        printf("TiXmlText ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlText * local_this = (TiXmlText *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlText)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlText(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlText)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlText*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlText*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlUnknown 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlUnknown::operator =(TiXmlUnknown const &copy)
 *******************************************************************/
static PyObject *Dtool_TiXmlUnknown_operator_141(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlUnknown * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlUnknown,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void TiXmlUnknown::operator =(TiXmlUnknown const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlUnknown *param1_this = (TiXmlUnknown *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlUnknown, 1, "TiXmlUnknown.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlUnknown *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlUnknown,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlUnknown.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlUnknown this, const TiXmlUnknown copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlUnknown_operator_141_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlUnknown this, const TiXmlUnknown copy)\n"
    "\n"
    "";
#else
static const char * Dtool_TiXmlUnknown_operator_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlUnknown::TiXmlUnknown(void)
 * TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy)
 *******************************************************************/
int  Dtool_Init_TiXmlUnknown(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlUnknown::TiXmlUnknown(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlUnknown", key_word_list))
            {
                TiXmlUnknown *return_value = new TiXmlUnknown();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlUnknown,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlUnknown", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TiXmlUnknown", &param0));
                if(!PyErr_Occurred())
                {
                    TiXmlUnknown *param0_this = (TiXmlUnknown *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlUnknown, 0, "TiXmlUnknown.TiXmlUnknown", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TiXmlUnknown *return_value = new TiXmlUnknown(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlUnknown,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TiXmlUnknown() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TiXmlUnknown()\n"
          "TiXmlUnknown(const TiXmlUnknown copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlUnknown(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlUnknown)
    {
        printf("TiXmlUnknown ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlUnknown * local_this = (TiXmlUnknown *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlUnknown)
        return local_this;
    if(requested_type == &Dtool_TiXmlBase)
        return ( TiXmlBase *)( TiXmlNode *) local_this;
    if(requested_type == &Dtool_TiXmlNode)
        return ( TiXmlNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlUnknown(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlUnknown)
        return from_this;
    if(from_type == &Dtool_TiXmlBase)
    {
          TiXmlBase* other_this = (TiXmlBase*)from_this;
          return (TiXmlUnknown*)other_this;
    }
    if(from_type == &Dtool_TiXmlNode)
    {
          TiXmlNode* other_this = (TiXmlNode*)from_this;
          return (TiXmlUnknown*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle TiXmlHandle::operator =(TiXmlHandle const &ref)
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_operator_144(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-TiXmlHandle TiXmlHandle::operator =(TiXmlHandle const &ref)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ref", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlHandle *param1_this = (TiXmlHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TiXmlHandle, 1, "TiXmlHandle.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    TiXmlHandle *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call TiXmlHandle.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const TiXmlHandle this, const TiXmlHandle ref)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_operator_144_comment =
    "C++ Interface:\n"
    "assign(non-const TiXmlHandle this, const TiXmlHandle ref)\n"
    "\n"
    "/// Copy constructor\n"
    "";
#else
static const char * Dtool_TiXmlHandle_operator_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle TiXmlHandle::FirstChild(void) const
 * TiXmlHandle TiXmlHandle::FirstChild(basic_string< char > const &_value) const
 * TiXmlHandle TiXmlHandle::FirstChild(char const *value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_FirstChild_145(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlHandle TiXmlHandle::FirstChild(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChild", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChild"));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChild();
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // -2 TiXmlHandle TiXmlHandle::FirstChild(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChild", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChild", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChild(basic_string<char>(param1_str, param1_len));
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlHandle TiXmlHandle::FirstChild(char const *value) const
            char *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChild", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChild", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChild((char const *)param1);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FirstChild() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FirstChild(const TiXmlHandle this)\n"
          "FirstChild(const TiXmlHandle this, string _value)\n"
          "FirstChild(const TiXmlHandle this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_FirstChild_145_comment =
    "C++ Interface:\n"
    "FirstChild(const TiXmlHandle this)\n"
    "FirstChild(const TiXmlHandle this, string _value)\n"
    "FirstChild(const TiXmlHandle this, string value)\n"
    "\n"
    "/// Return a handle to the first child node.\n"
    "\n"
    "/// Return a handle to the first child node with the given name.\n"
    "";
#else
static const char * Dtool_TiXmlHandle_FirstChild_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle TiXmlHandle::FirstChildElement(void) const
 * TiXmlHandle TiXmlHandle::FirstChildElement(basic_string< char > const &_value) const
 * TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_FirstChildElement_146(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TiXmlHandle TiXmlHandle::FirstChildElement(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":FirstChildElement", key_word_list));
            else
                (PyArg_Parse(args, ":FirstChildElement"));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChildElement();
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // -2 TiXmlHandle TiXmlHandle::FirstChildElement(basic_string< char > const &_value) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"_value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FirstChildElement", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:FirstChildElement", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChildElement(basic_string<char>(param1_str, param1_len));
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const
            char *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s:FirstChildElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "s:FirstChildElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->FirstChildElement((char const *)param1);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "FirstChildElement() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "FirstChildElement(const TiXmlHandle this)\n"
          "FirstChildElement(const TiXmlHandle this, string _value)\n"
          "FirstChildElement(const TiXmlHandle this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_FirstChildElement_146_comment =
    "C++ Interface:\n"
    "FirstChildElement(const TiXmlHandle this)\n"
    "FirstChildElement(const TiXmlHandle this, string _value)\n"
    "FirstChildElement(const TiXmlHandle this, string value)\n"
    "\n"
    "/// Return a handle to the first child element.\n"
    "\n"
    "/// Return a handle to the first child element with the given name.\n"
    "";
#else
static const char * Dtool_TiXmlHandle_FirstChildElement_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle TiXmlHandle::Child(basic_string< char > const &_value, int index) const
 * TiXmlHandle TiXmlHandle::Child(char const *value, int index) const
 * TiXmlHandle TiXmlHandle::Child(int index) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_Child_147(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-TiXmlHandle TiXmlHandle::Child(int index) const
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:Child", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:Child", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->Child((int)param1);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 TiXmlHandle TiXmlHandle::Child(basic_string< char > const &_value, int index) const
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"_value", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:Child", key_word_list, &param1_str, &param1_len, &param2))
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->Child(basic_string<char>(param1_str, param1_len), (int)param2);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlHandle TiXmlHandle::Child(char const *value, int index) const
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"value", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:Child", key_word_list, &param1, &param2))
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->Child((char const *)param1, (int)param2);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Child() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Child(const TiXmlHandle this, int index)\n"
          "Child(const TiXmlHandle this, string _value, int index)\n"
          "Child(const TiXmlHandle this, string value, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_Child_147_comment =
    "C++ Interface:\n"
    "Child(const TiXmlHandle this, int index)\n"
    "Child(const TiXmlHandle this, string _value, int index)\n"
    "Child(const TiXmlHandle this, string value, int index)\n"
    "\n"
    "/** Return a handle to the \"index\" child with the given name. \n"
    "\011\011The first child is 0, the second 1, etc.\n"
    "\011*/\n"
    "\n"
    "/** Return a handle to the \"index\" child. \n"
    "\011\011The first child is 0, the second 1, etc.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_Child_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle TiXmlHandle::ChildElement(basic_string< char > const &_value, int index) const
 * TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const
 * TiXmlHandle TiXmlHandle::ChildElement(int index) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_ChildElement_148(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-TiXmlHandle TiXmlHandle::ChildElement(int index) const
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:ChildElement", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:ChildElement", &param1));
            if(!PyErr_Occurred())
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->ChildElement((int)param1);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // -2 TiXmlHandle TiXmlHandle::ChildElement(basic_string< char > const &_value, int index) const
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"_value", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:ChildElement", key_word_list, &param1_str, &param1_len, &param2))
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->ChildElement(basic_string<char>(param1_str, param1_len), (int)param2);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const
            char *param1;
            int param2;
            static char * key_word_list[] = {(char *)"value", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "si:ChildElement", key_word_list, &param1, &param2))
            {
                TiXmlHandle result = ((const TiXmlHandle*)local_this)->ChildElement((char const *)param1, (int)param2);
                TiXmlHandle *return_value = new TiXmlHandle(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlHandle,true, false);
                }
            }
            PyErr_Clear(); 
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ChildElement() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ChildElement(const TiXmlHandle this, int index)\n"
          "ChildElement(const TiXmlHandle this, string _value, int index)\n"
          "ChildElement(const TiXmlHandle this, string value, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_ChildElement_148_comment =
    "C++ Interface:\n"
    "ChildElement(const TiXmlHandle this, int index)\n"
    "ChildElement(const TiXmlHandle this, string _value, int index)\n"
    "ChildElement(const TiXmlHandle this, string value, int index)\n"
    "\n"
    "/** Return a handle to the \"index\" child element with the given name. \n"
    "\011\011The first child element is 0, the second 1, etc. Note that only TiXmlElements\n"
    "\011\011are indexed: other types are not counted.\n"
    "\011*/\n"
    "\n"
    "/** Return a handle to the \"index\" child element. \n"
    "\011\011The first child element is 0, the second 1, etc. Note that only TiXmlElements\n"
    "\011\011are indexed: other types are not counted.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_ChildElement_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlHandle::ToNode(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_ToNode_149(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlNode *TiXmlHandle::ToNode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToNode", key_word_list));
        else
            (PyArg_Parse(args, ":ToNode"));
        if(!PyErr_Occurred())
        {
            TiXmlNode *return_value = ((const TiXmlHandle*)local_this)->ToNode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToNode(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_ToNode_149_comment =
    "C++ Interface:\n"
    "ToNode(const TiXmlHandle this)\n"
    "\n"
    "/** Return the handle as a TiXmlNode. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_ToNode_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement *TiXmlHandle::ToElement(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_ToElement_150(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlElement *TiXmlHandle::ToElement(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToElement", key_word_list));
        else
            (PyArg_Parse(args, ":ToElement"));
        if(!PyErr_Occurred())
        {
            TiXmlElement *return_value = ((const TiXmlHandle*)local_this)->ToElement();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToElement(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_ToElement_150_comment =
    "C++ Interface:\n"
    "ToElement(const TiXmlHandle this)\n"
    "\n"
    "/** Return the handle as a TiXmlElement. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_ToElement_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlText *TiXmlHandle::ToText(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_ToText_151(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlText *TiXmlHandle::ToText(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToText", key_word_list));
        else
            (PyArg_Parse(args, ":ToText"));
        if(!PyErr_Occurred())
        {
            TiXmlText *return_value = ((const TiXmlHandle*)local_this)->ToText();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlText,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToText(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_ToText_151_comment =
    "C++ Interface:\n"
    "ToText(const TiXmlHandle this)\n"
    "\n"
    "/**\011Return the handle as a TiXmlText. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_ToText_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlUnknown *TiXmlHandle::ToUnknown(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_ToUnknown_152(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlUnknown *TiXmlHandle::ToUnknown(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ToUnknown", key_word_list));
        else
            (PyArg_Parse(args, ":ToUnknown"));
        if(!PyErr_Occurred())
        {
            TiXmlUnknown *return_value = ((const TiXmlHandle*)local_this)->ToUnknown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlUnknown,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ToUnknown(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_ToUnknown_152_comment =
    "C++ Interface:\n"
    "ToUnknown(const TiXmlHandle this)\n"
    "\n"
    "/** Return the handle as a TiXmlUnknown. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_ToUnknown_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlNode *TiXmlHandle::Node(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_Node_153(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlNode *TiXmlHandle::Node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Node", key_word_list));
        else
            (PyArg_Parse(args, ":Node"));
        if(!PyErr_Occurred())
        {
            TiXmlNode *return_value = ((const TiXmlHandle*)local_this)->Node();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlNode,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Node(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_Node_153_comment =
    "C++ Interface:\n"
    "Node(const TiXmlHandle this)\n"
    "\n"
    "/** @deprecated use ToNode. \n"
    "\011\011Return the handle as a TiXmlNode. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_Node_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlElement *TiXmlHandle::Element(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_Element_154(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlElement *TiXmlHandle::Element(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Element", key_word_list));
        else
            (PyArg_Parse(args, ":Element"));
        if(!PyErr_Occurred())
        {
            TiXmlElement *return_value = ((const TiXmlHandle*)local_this)->Element();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlElement,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Element(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_Element_154_comment =
    "C++ Interface:\n"
    "Element(const TiXmlHandle this)\n"
    "\n"
    "/** @deprecated use ToElement. \n"
    "\011\011Return the handle as a TiXmlElement. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_Element_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlText *TiXmlHandle::Text(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_Text_155(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlText *TiXmlHandle::Text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Text", key_word_list));
        else
            (PyArg_Parse(args, ":Text"));
        if(!PyErr_Occurred())
        {
            TiXmlText *return_value = ((const TiXmlHandle*)local_this)->Text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlText,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Text(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_Text_155_comment =
    "C++ Interface:\n"
    "Text(const TiXmlHandle this)\n"
    "\n"
    "/**\011@deprecated use ToText()\n"
    "\011\011Return the handle as a TiXmlText. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_Text_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlUnknown *TiXmlHandle::Unknown(void) const
 *******************************************************************/
static PyObject *Dtool_TiXmlHandle_Unknown_156(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-TiXmlUnknown *TiXmlHandle::Unknown(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Unknown", key_word_list));
        else
            (PyArg_Parse(args, ":Unknown"));
        if(!PyErr_Occurred())
        {
            TiXmlUnknown *return_value = ((const TiXmlHandle*)local_this)->Unknown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TiXmlUnknown,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Unknown(const TiXmlHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlHandle_Unknown_156_comment =
    "C++ Interface:\n"
    "Unknown(const TiXmlHandle this)\n"
    "\n"
    "/** @deprecated use ToUnknown()\n"
    "\011\011Return the handle as a TiXmlUnknown. This may return null.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlHandle_Unknown_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref)
 * TiXmlHandle::TiXmlHandle(TiXmlNode *_node)
 *******************************************************************/
int  Dtool_Init_TiXmlHandle(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 TiXmlHandle::TiXmlHandle(TiXmlNode *_node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"_node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TiXmlHandle", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlNode *param0_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlNode, 0, "TiXmlHandle.TiXmlHandle", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    TiXmlHandle *return_value = new TiXmlHandle(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlHandle,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"ref", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:TiXmlHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:TiXmlHandle", &param0));
            if(!PyErr_Occurred())
            {
                TiXmlHandle *param0_this = (TiXmlHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TiXmlHandle, 0, "TiXmlHandle.TiXmlHandle", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    TiXmlHandle *return_value = new TiXmlHandle(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlHandle,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TiXmlHandle(non-const TiXmlNode _node)\n"
          "TiXmlHandle(const TiXmlHandle ref)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlHandle)
    {
        printf("TiXmlHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlHandle * local_this = (TiXmlHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlHandle)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlHandle)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TiXmlPrinter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void TiXmlPrinter::SetIndent(char const *_indent)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_SetIndent_160(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlPrinter::SetIndent(char const *_indent)
        char *param1;
        static char * key_word_list[] = {(char *)"_indent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:SetIndent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:SetIndent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetIndent((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.SetIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetIndent(non-const TiXmlPrinter this, string _indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_SetIndent_160_comment =
    "C++ Interface:\n"
    "SetIndent(non-const TiXmlPrinter this, string _indent)\n"
    "\n"
    "/** Set the indent characters for printing. By default 4 spaces\n"
    "\011\011but tab (\\t) is also useful, or null/empty string for no indentation.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_SetIndent_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlPrinter::Indent(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_Indent_161(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *TiXmlPrinter::Indent(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Indent", key_word_list));
        else
            (PyArg_Parse(args, ":Indent"));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->Indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.Indent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Indent(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_Indent_161_comment =
    "C++ Interface:\n"
    "Indent(non-const TiXmlPrinter this)\n"
    "\n"
    "/// Query the indention string.\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_Indent_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlPrinter::SetLineBreak(char const *_lineBreak)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_SetLineBreak_162(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlPrinter::SetLineBreak(char const *_lineBreak)
        char *param1;
        static char * key_word_list[] = {(char *)"_lineBreak", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s:SetLineBreak", key_word_list, &param1));
        else
            (PyArg_Parse(args, "s:SetLineBreak", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->SetLineBreak((char const *)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.SetLineBreak() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetLineBreak(non-const TiXmlPrinter this, string _lineBreak)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_SetLineBreak_162_comment =
    "C++ Interface:\n"
    "SetLineBreak(non-const TiXmlPrinter this, string _lineBreak)\n"
    "\n"
    "/** Set the line breaking string. By default set to newline (\\n). \n"
    "\011\011Some operating systems prefer other characters, or can be\n"
    "\011\011set to the null/empty string for no indenation.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_SetLineBreak_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlPrinter::LineBreak(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_LineBreak_163(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *TiXmlPrinter::LineBreak(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":LineBreak", key_word_list));
        else
            (PyArg_Parse(args, ":LineBreak"));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->LineBreak();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.LineBreak() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "LineBreak(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_LineBreak_163_comment =
    "C++ Interface:\n"
    "LineBreak(non-const TiXmlPrinter this)\n"
    "\n"
    "/// Query the current line breaking string.\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_LineBreak_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TiXmlPrinter::SetStreamPrinting(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_SetStreamPrinting_164(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TiXmlPrinter::SetStreamPrinting(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":SetStreamPrinting", key_word_list));
        else
            (PyArg_Parse(args, ":SetStreamPrinting"));
        if(!PyErr_Occurred())
        {
            (local_this)->SetStreamPrinting();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.SetStreamPrinting() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SetStreamPrinting(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_SetStreamPrinting_164_comment =
    "C++ Interface:\n"
    "SetStreamPrinting(non-const TiXmlPrinter this)\n"
    "\n"
    "/** Switch over to \"stream printing\" which is the most dense formatting without \n"
    "\011\011linebreaks. Common when the XML is needed for network transmission.\n"
    "\011*/\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_SetStreamPrinting_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *TiXmlPrinter::CStr(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_CStr_165(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *TiXmlPrinter::CStr(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":CStr", key_word_list));
        else
            (PyArg_Parse(args, ":CStr"));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->CStr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.CStr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CStr(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_CStr_165_comment =
    "C++ Interface:\n"
    "CStr(non-const TiXmlPrinter this)\n"
    "\n"
    "/// Return the result.\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_CStr_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int TiXmlPrinter::Size(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_Size_166(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned int TiXmlPrinter::Size(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Size", key_word_list));
        else
            (PyArg_Parse(args, ":Size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->Size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.Size() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Size(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_Size_166_comment =
    "C++ Interface:\n"
    "Size(non-const TiXmlPrinter this)\n"
    "\n"
    "/// Return the length of the result string.\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_Size_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &TiXmlPrinter::Str(void)
 *******************************************************************/
static PyObject *Dtool_TiXmlPrinter_Str_167(PyObject *self, PyObject *args,PyObject *kwds) {
    TiXmlPrinter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TiXmlPrinter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > const &TiXmlPrinter::Str(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Str", key_word_list));
        else
            (PyArg_Parse(args, ":Str"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = (local_this)->Str();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TiXmlPrinter.Str() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Str(non-const TiXmlPrinter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TiXmlPrinter_Str_167_comment =
    "C++ Interface:\n"
    "Str(non-const TiXmlPrinter this)\n"
    "\n"
    "/// Return the result.\n"
    "";
#else
static const char * Dtool_TiXmlPrinter_Str_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TiXmlPrinter::TiXmlPrinter(void)
 *******************************************************************/
int  Dtool_Init_TiXmlPrinter(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-TiXmlPrinter::TiXmlPrinter(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":TiXmlPrinter", key_word_list))
        {
            TiXmlPrinter *return_value = new TiXmlPrinter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_TiXmlPrinter,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TiXmlPrinter()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TiXmlPrinter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TiXmlPrinter)
    {
        printf("TiXmlPrinter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TiXmlPrinter * local_this = (TiXmlPrinter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TiXmlPrinter)
        return local_this;
    if(requested_type == &Dtool_TiXmlVisitor)
        return ( TiXmlVisitor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TiXmlPrinter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TiXmlPrinter)
        return from_this;
    if(from_type == &Dtool_TiXmlVisitor)
    {
          TiXmlVisitor* other_this = (TiXmlVisitor*)from_this;
          return (TiXmlPrinter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. TiXmlBase | TiXmlBase
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlBase[]= {
  { "SetCondenseWhiteSpace",(PyCFunction ) &Dtool_TiXmlBase_SetCondenseWhiteSpace_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment},
  { "IsWhiteSpaceCondensed",(PyCFunction ) &Dtool_TiXmlBase_IsWhiteSpaceCondensed_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment},
  { "Row",(PyCFunction ) &Dtool_TiXmlBase_Row_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlBase_Row_6_comment},
  { "Column",(PyCFunction ) &Dtool_TiXmlBase_Column_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlBase_Column_7_comment},
  { "EncodeString",(PyCFunction ) &Dtool_TiXmlBase_EncodeString_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlBase_EncodeString_11_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlBase.As_PyTypeObject().tp_doc =
          "/** TiXmlBase is a base class for every class in TinyXml.\n"
          "\011It does little except to establish that TinyXml classes\n"
          "\011can be printed and provide some utility functions.\n"
          "\n"
          "\011In XML, the document and elements can contain\n"
          "\011other elements and other types of nodes.\n"
          "\n"
          "\011@verbatim\n"
          "\011A Document can contain:\011Element\011(container or leaf)\n"
          "\011\011\011\011\011\011\011Comment (leaf)\n"
          "\011\011\011\011\011\011\011Unknown (leaf)\n"
          "\011\011\011\011\011\011\011Declaration( leaf )\n"
          "\n"
          "\011An Element can contain:\011Element (container or leaf)\n"
          "\011\011\011\011\011\011\011Text\011(leaf)\n"
          "\011\011\011\011\011\011\011Attributes (not on tree)\n"
          "\011\011\011\011\011\011\011Comment (leaf)\n"
          "\011\011\011\011\011\011\011Unknown (leaf)\n"
          "\n"
          "\011A Decleration contains: Attributes (not on tree)\n"
          "\011@endverbatim\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TiXmlBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TiXmlBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlBase)");
             printf(" Error In PyType_ReadyTiXmlBase");
             return;
        }
        Py_INCREF(&Dtool_TiXmlBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlBase.As_PyTypeObject().tp_dict,"TiXmlBase",&Dtool_TiXmlBase.As_PyObject());
        //  Static Method SetCondenseWhiteSpace
        PyDict_SetItemString(Dtool_TiXmlBase.As_PyTypeObject().tp_dict,"SetCondenseWhiteSpace",PyCFunction_New(&Dtool_Methods_TiXmlBase[0],&Dtool_TiXmlBase.As_PyObject()));
        //  Static Method IsWhiteSpaceCondensed
        PyDict_SetItemString(Dtool_TiXmlBase.As_PyTypeObject().tp_dict,"IsWhiteSpaceCondensed",PyCFunction_New(&Dtool_Methods_TiXmlBase[1],&Dtool_TiXmlBase.As_PyObject()));
        //  Static Method EncodeString
        PyDict_SetItemString(Dtool_TiXmlBase.As_PyTypeObject().tp_dict,"EncodeString",PyCFunction_New(&Dtool_Methods_TiXmlBase[4],&Dtool_TiXmlBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TiXmlBase,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlBase.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlBase",(PyObject *)&Dtool_TiXmlBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlDeclaration | TiXmlDeclaration
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlDeclaration[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlDeclaration_operator_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDeclaration_operator_45_comment},
  { "Version",(PyCFunction ) &Dtool_TiXmlDeclaration_Version_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDeclaration_Version_46_comment},
  { "Encoding",(PyCFunction ) &Dtool_TiXmlDeclaration_Encoding_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDeclaration_Encoding_47_comment},
  { "Standalone",(PyCFunction ) &Dtool_TiXmlDeclaration_Standalone_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDeclaration_Standalone_48_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlDeclaration(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlDeclaration.As_PyTypeObject().tp_doc =
          "/** In correct XML the declaration is the first entry in the file.\n"
          "\011@verbatim\n"
          "\011\011<?xml version=\"1.0\" standalone=\"yes\"?>\n"
          "\011@endverbatim\n"
          "\n"
          "\011TinyXml will happily read or write files without a declaration,\n"
          "\011however. There are 3 possible attributes to the declaration:\n"
          "\011version, encoding, and standalone.\n"
          "\n"
          "\011Note: In this version of the code, the attributes are\n"
          "\011handled as special cases, not generic attributes, simply\n"
          "\011because there can only be at most 3 and they are always the same.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlDeclaration.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlDeclaration.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlDeclaration.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlDeclaration.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlDeclaration.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlDeclaration)");
             printf(" Error In PyType_ReadyTiXmlDeclaration");
             return;
        }
        Py_INCREF(&Dtool_TiXmlDeclaration.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlDeclaration.As_PyTypeObject().tp_dict,"TiXmlDeclaration",&Dtool_TiXmlDeclaration.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlDeclaration,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlDeclaration.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlDeclaration",(PyObject *)&Dtool_TiXmlDeclaration.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlNode | TiXmlNode
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlNode[]= {
  { "Value",(PyCFunction ) &Dtool_TiXmlNode_Value_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Value_15_comment},
  { "ValueStr",(PyCFunction ) &Dtool_TiXmlNode_ValueStr_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ValueStr_16_comment},
  { "ValueTStr",(PyCFunction ) &Dtool_TiXmlNode_ValueTStr_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ValueTStr_17_comment},
  { "SetValue",(PyCFunction ) &Dtool_TiXmlNode_SetValue_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_SetValue_18_comment},
  { "Clear",(PyCFunction ) &Dtool_TiXmlNode_Clear_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Clear_19_comment},
  { "Parent",(PyCFunction ) &Dtool_TiXmlNode_Parent_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Parent_20_comment},
  { "FirstChild",(PyCFunction ) &Dtool_TiXmlNode_FirstChild_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_FirstChild_21_comment},
  { "LastChild",(PyCFunction ) &Dtool_TiXmlNode_LastChild_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_LastChild_22_comment},
  { "IterateChildren",(PyCFunction ) &Dtool_TiXmlNode_IterateChildren_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_IterateChildren_23_comment},
  { "InsertEndChild",(PyCFunction ) &Dtool_TiXmlNode_InsertEndChild_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_InsertEndChild_24_comment},
  { "InsertBeforeChild",(PyCFunction ) &Dtool_TiXmlNode_InsertBeforeChild_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_InsertBeforeChild_25_comment},
  { "InsertAfterChild",(PyCFunction ) &Dtool_TiXmlNode_InsertAfterChild_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_InsertAfterChild_26_comment},
  { "ReplaceChild",(PyCFunction ) &Dtool_TiXmlNode_ReplaceChild_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ReplaceChild_27_comment},
  { "RemoveChild",(PyCFunction ) &Dtool_TiXmlNode_RemoveChild_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_RemoveChild_28_comment},
  { "PreviousSibling",(PyCFunction ) &Dtool_TiXmlNode_PreviousSibling_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_PreviousSibling_29_comment},
  { "NextSibling",(PyCFunction ) &Dtool_TiXmlNode_NextSibling_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_NextSibling_30_comment},
  { "NextSiblingElement",(PyCFunction ) &Dtool_TiXmlNode_NextSiblingElement_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_NextSiblingElement_31_comment},
  { "FirstChildElement",(PyCFunction ) &Dtool_TiXmlNode_FirstChildElement_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_FirstChildElement_32_comment},
  { "Type",(PyCFunction ) &Dtool_TiXmlNode_Type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Type_33_comment},
  { "GetDocument",(PyCFunction ) &Dtool_TiXmlNode_GetDocument_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_GetDocument_34_comment},
  { "NoChildren",(PyCFunction ) &Dtool_TiXmlNode_NoChildren_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_NoChildren_35_comment},
  { "ToDocument",(PyCFunction ) &Dtool_TiXmlNode_ToDocument_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToDocument_36_comment},
  { "ToElement",(PyCFunction ) &Dtool_TiXmlNode_ToElement_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToElement_37_comment},
  { "ToComment",(PyCFunction ) &Dtool_TiXmlNode_ToComment_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToComment_38_comment},
  { "ToUnknown",(PyCFunction ) &Dtool_TiXmlNode_ToUnknown_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToUnknown_39_comment},
  { "ToText",(PyCFunction ) &Dtool_TiXmlNode_ToText_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToText_40_comment},
  { "ToDeclaration",(PyCFunction ) &Dtool_TiXmlNode_ToDeclaration_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_ToDeclaration_41_comment},
  { "Clone",(PyCFunction ) &Dtool_TiXmlNode_Clone_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Clone_42_comment},
  { "Accept",(PyCFunction ) &Dtool_TiXmlNode_Accept_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlNode_Accept_43_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlNode.As_PyTypeObject().tp_doc =
          "/** The parent class for everything in the Document Object Model.\n"
          "\011(Except for attributes).\n"
          "\011Nodes have siblings, a parent, and children. A node can be\n"
          "\011in a document, or stand on its own. The type of a TiXmlNode\n"
          "\011can be queried, and it can be cast to its more defined type.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlBase._Dtool_ClassInit(NULL);
        Dtool_TiXmlNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlBase.As_PyTypeObject());
        Dtool_TiXmlNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlNode.As_PyTypeObject().tp_dict);
        // Enum  TiXmlNode::NodeType;
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLDOCUMENT",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLELEMENT",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLCOMMENT",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLUNKNOWN",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLTEXT",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLDECLARATION",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TINYXMLTYPECOUNT",PyInt_FromLong(6));
        if(PyType_Ready(&Dtool_TiXmlNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlNode)");
             printf(" Error In PyType_ReadyTiXmlNode");
             return;
        }
        Py_INCREF(&Dtool_TiXmlNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlNode.As_PyTypeObject().tp_dict,"TiXmlNode",&Dtool_TiXmlNode.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlNode,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlNode.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlNode",(PyObject *)&Dtool_TiXmlNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlDocument | TiXmlDocument
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlDocument[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlDocument_operator_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_operator_52_comment},
  { "LoadFile",(PyCFunction ) &Dtool_TiXmlDocument_LoadFile_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_LoadFile_53_comment},
  { "SaveFile",(PyCFunction ) &Dtool_TiXmlDocument_SaveFile_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_SaveFile_54_comment},
  { "RootElement",(PyCFunction ) &Dtool_TiXmlDocument_RootElement_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_RootElement_55_comment},
  { "Error",(PyCFunction ) &Dtool_TiXmlDocument_Error_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_Error_56_comment},
  { "ErrorDesc",(PyCFunction ) &Dtool_TiXmlDocument_ErrorDesc_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_ErrorDesc_57_comment},
  { "ErrorId",(PyCFunction ) &Dtool_TiXmlDocument_ErrorId_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_ErrorId_58_comment},
  { "ErrorRow",(PyCFunction ) &Dtool_TiXmlDocument_ErrorRow_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_ErrorRow_59_comment},
  { "ErrorCol",(PyCFunction ) &Dtool_TiXmlDocument_ErrorCol_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_ErrorCol_60_comment},
  { "SetTabSize",(PyCFunction ) &Dtool_TiXmlDocument_SetTabSize_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_SetTabSize_61_comment},
  { "TabSize",(PyCFunction ) &Dtool_TiXmlDocument_TabSize_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_TabSize_62_comment},
  { "ClearError",(PyCFunction ) &Dtool_TiXmlDocument_ClearError_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_ClearError_63_comment},
  { "Print",(PyCFunction ) &Dtool_TiXmlDocument_Print_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlDocument_Print_64_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlDocument(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlDocument.As_PyTypeObject().tp_doc =
          "/** Always the top level node. A document binds together all the\n"
          "\011XML pieces. It can be saved, loaded, and printed to the screen.\n"
          "\011The 'value' of a document node is the xml file name.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlDocument.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlDocument.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlDocument.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlDocument.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlDocument.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlDocument)");
             printf(" Error In PyType_ReadyTiXmlDocument");
             return;
        }
        Py_INCREF(&Dtool_TiXmlDocument.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlDocument.As_PyTypeObject().tp_dict,"TiXmlDocument",&Dtool_TiXmlDocument.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlDocument,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlDocument.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlDocument",(PyObject *)&Dtool_TiXmlDocument.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlElement | TiXmlElement
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlElement[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlElement_operator_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_operator_68_comment},
  { "Attribute",(PyCFunction ) &Dtool_TiXmlElement_Attribute_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_Attribute_69_comment},
  { "QueryStringAttribute",(PyCFunction ) &Dtool_TiXmlElement_QueryStringAttribute_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_QueryStringAttribute_73_comment},
  { "QueryValueAttribute",(PyCFunction ) &Dtool_TiXmlElement_QueryValueAttribute_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_QueryValueAttribute_74_comment},
  { "SetAttribute",(PyCFunction ) &Dtool_TiXmlElement_SetAttribute_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_SetAttribute_75_comment},
  { "SetDoubleAttribute",(PyCFunction ) &Dtool_TiXmlElement_SetDoubleAttribute_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_SetDoubleAttribute_76_comment},
  { "RemoveAttribute",(PyCFunction ) &Dtool_TiXmlElement_RemoveAttribute_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_RemoveAttribute_77_comment},
  { "FirstAttribute",(PyCFunction ) &Dtool_TiXmlElement_FirstAttribute_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_FirstAttribute_78_comment},
  { "LastAttribute",(PyCFunction ) &Dtool_TiXmlElement_LastAttribute_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_LastAttribute_79_comment},
  { "GetText",(PyCFunction ) &Dtool_TiXmlElement_GetText_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlElement_GetText_80_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlElement(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlElement.As_PyTypeObject().tp_doc =
          "/** The element is a container class. It has a value, the element name,\n"
          "\011and can contain other elements, text, comments, and unknowns.\n"
          "\011Elements also contain an arbitrary number of attributes.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlElement.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlElement.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlElement.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlElement.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlElement.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlElement)");
             printf(" Error In PyType_ReadyTiXmlElement");
             return;
        }
        Py_INCREF(&Dtool_TiXmlElement.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlElement.As_PyTypeObject().tp_dict,"TiXmlElement",&Dtool_TiXmlElement.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlElement,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlElement.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlElement",(PyObject *)&Dtool_TiXmlElement.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlCursor | TiXmlCursor
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlCursor[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlCursor.As_PyTypeObject().tp_doc =
          "/*\011Internal structure for tracking location of items \n"
          "\011in the XML file.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TiXmlCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TiXmlCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlCursor)");
             printf(" Error In PyType_ReadyTiXmlCursor");
             return;
        }
        Py_INCREF(&Dtool_TiXmlCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlCursor.As_PyTypeObject().tp_dict,"TiXmlCursor",&Dtool_TiXmlCursor.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlCursor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlCursor.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlCursor",(PyObject *)&Dtool_TiXmlCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlVisitor | TiXmlVisitor
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlVisitor[]= {
  { "VisitEnter",(PyCFunction ) &Dtool_TiXmlVisitor_VisitEnter_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlVisitor_VisitEnter_94_comment},
  { "VisitExit",(PyCFunction ) &Dtool_TiXmlVisitor_VisitExit_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlVisitor_VisitExit_95_comment},
  { "Visit",(PyCFunction ) &Dtool_TiXmlVisitor_Visit_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlVisitor_Visit_96_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlVisitor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlVisitor.As_PyTypeObject().tp_doc =
          "/**\n"
          "\011Implements the interface to the \"Visitor pattern\" (see the Accept() method.)\n"
          "\011If you call the Accept() method, it requires being passed a TiXmlVisitor\n"
          "\011class to handle callbacks. For nodes that contain other nodes (Document, Element)\n"
          "\011you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves\n"
          "\011are simply called with Visit().\n"
          "\n"
          "\011If you return 'true' from a Visit method, recursive parsing will continue. If you return\n"
          "\011false, <b>no children of this node or its sibilings</b> will be Visited.\n"
          "\n"
          "\011All flavors of Visit methods have a default implementation that returns 'true' (continue \n"
          "\011visiting). You need to only override methods that are interesting to you.\n"
          "\n"
          "\011Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.\n"
          "\n"
          "\011You should never change the document from a callback.\n"
          "\n"
          "\011@sa TiXmlNode::Accept()\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TiXmlVisitor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TiXmlVisitor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlVisitor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlVisitor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlVisitor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlVisitor)");
             printf(" Error In PyType_ReadyTiXmlVisitor");
             return;
        }
        Py_INCREF(&Dtool_TiXmlVisitor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlVisitor.As_PyTypeObject().tp_dict,"TiXmlVisitor",&Dtool_TiXmlVisitor.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlVisitor,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlVisitor.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlVisitor",(PyObject *)&Dtool_TiXmlVisitor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlAttribute | TiXmlAttribute
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlAttribute[]= {
  { "Name",(PyCFunction ) &Dtool_TiXmlAttribute_Name_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_Name_102_comment},
  { "Value",(PyCFunction ) &Dtool_TiXmlAttribute_Value_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_Value_103_comment},
  { "ValueStr",(PyCFunction ) &Dtool_TiXmlAttribute_ValueStr_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_ValueStr_104_comment},
  { "IntValue",(PyCFunction ) &Dtool_TiXmlAttribute_IntValue_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_IntValue_105_comment},
  { "DoubleValue",(PyCFunction ) &Dtool_TiXmlAttribute_DoubleValue_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_DoubleValue_106_comment},
  { "NameTStr",(PyCFunction ) &Dtool_TiXmlAttribute_NameTStr_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_NameTStr_107_comment},
  { "SetName",(PyCFunction ) &Dtool_TiXmlAttribute_SetName_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_SetName_110_comment},
  { "SetValue",(PyCFunction ) &Dtool_TiXmlAttribute_SetValue_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_SetValue_111_comment},
  { "SetIntValue",(PyCFunction ) &Dtool_TiXmlAttribute_SetIntValue_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_SetIntValue_112_comment},
  { "SetDoubleValue",(PyCFunction ) &Dtool_TiXmlAttribute_SetDoubleValue_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_SetDoubleValue_113_comment},
  { "Next",(PyCFunction ) &Dtool_TiXmlAttribute_Next_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_Next_114_comment},
  { "Previous",(PyCFunction ) &Dtool_TiXmlAttribute_Previous_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_Previous_115_comment},
  { "eq",(PyCFunction ) &Dtool_TiXmlAttribute_operator_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_operator_116_comment},
  { "lessThan",(PyCFunction ) &Dtool_TiXmlAttribute_operator_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_operator_117_comment},
  { "greaterThan",(PyCFunction ) &Dtool_TiXmlAttribute_operator_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_operator_118_comment},
  { "SetDocument",(PyCFunction ) &Dtool_TiXmlAttribute_SetDocument_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttribute_SetDocument_120_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlAttribute(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlAttribute.As_PyTypeObject().tp_doc =
          "/** An attribute is a name-value pair. Elements have an arbitrary\n"
          "\011number of attributes, each with a unique name.\n"
          "\n"
          "\011@note The attributes are not TiXmlNodes, since they are not\n"
          "\011\011  part of the tinyXML document object model. There are other\n"
          "\011\011  suggested ways to look at this problem.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlBase._Dtool_ClassInit(NULL);
        Dtool_TiXmlAttribute.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlBase.As_PyTypeObject());
        Dtool_TiXmlAttribute.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlAttribute.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlAttribute.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlAttribute.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlAttribute)");
             printf(" Error In PyType_ReadyTiXmlAttribute");
             return;
        }
        Py_INCREF(&Dtool_TiXmlAttribute.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlAttribute.As_PyTypeObject().tp_dict,"TiXmlAttribute",&Dtool_TiXmlAttribute.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlAttribute,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlAttribute.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlAttribute",(PyObject *)&Dtool_TiXmlAttribute.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlAttributeSet | TiXmlAttributeSet
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlAttributeSet[]= {
  { "Add",(PyCFunction ) &Dtool_TiXmlAttributeSet_Add_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_Add_125_comment},
  { "Remove",(PyCFunction ) &Dtool_TiXmlAttributeSet_Remove_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_Remove_126_comment},
  { "First",(PyCFunction ) &Dtool_TiXmlAttributeSet_First_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_First_127_comment},
  { "Last",(PyCFunction ) &Dtool_TiXmlAttributeSet_Last_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_Last_128_comment},
  { "Find",(PyCFunction ) &Dtool_TiXmlAttributeSet_Find_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_Find_129_comment},
  { "FindOrCreate",(PyCFunction ) &Dtool_TiXmlAttributeSet_FindOrCreate_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlAttributeSet_FindOrCreate_130_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlAttributeSet(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_doc =
          "/*\011A class used to manage a group of attributes.\n"
          "\011It is only used internally, both by the ELEMENT and the DECLARATION.\n"
          "\011\n"
          "\011The set can be changed transparent to the Element and Declaration\n"
          "\011classes that use it, but NOT transparent to the Attribute\n"
          "\011which has to implement a next() and previous() method. Which makes\n"
          "\011it a bit problematic and prevents the use of STL.\n"
          "\n"
          "\011This version is implemented with circular lists because:\n"
          "\011\011- I like circular lists\n"
          "\011\011- it demonstrates some independence from the (typical) doubly linked list.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlAttributeSet.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlAttributeSet)");
             printf(" Error In PyType_ReadyTiXmlAttributeSet");
             return;
        }
        Py_INCREF(&Dtool_TiXmlAttributeSet.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlAttributeSet.As_PyTypeObject().tp_dict,"TiXmlAttributeSet",&Dtool_TiXmlAttributeSet.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlAttributeSet,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlAttributeSet.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlAttributeSet",(PyObject *)&Dtool_TiXmlAttributeSet.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlComment | TiXmlComment
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlComment[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlComment_operator_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlComment_operator_133_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlComment(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlComment.As_PyTypeObject().tp_doc =
          "/**\011An XML comment.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlComment.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlComment.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlComment.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlComment.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlComment.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlComment)");
             printf(" Error In PyType_ReadyTiXmlComment");
             return;
        }
        Py_INCREF(&Dtool_TiXmlComment.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlComment.As_PyTypeObject().tp_dict,"TiXmlComment",&Dtool_TiXmlComment.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlComment,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlComment.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlComment",(PyObject *)&Dtool_TiXmlComment.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlText | TiXmlText
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlText[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlText_operator_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlText_operator_136_comment},
  { "CDATA",(PyCFunction ) &Dtool_TiXmlText_CDATA_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlText_CDATA_137_comment},
  { "SetCDATA",(PyCFunction ) &Dtool_TiXmlText_SetCDATA_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlText_SetCDATA_138_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlText(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlText.As_PyTypeObject().tp_doc =
          "/** XML text. A text node can have 2 ways to output the next. \"normal\" output \n"
          "\011and CDATA. It will default to the mode it was parsed from the XML file and\n"
          "\011you generally want to leave it alone, but you can change the output mode with \n"
          "\011SetCDATA() and query it with CDATA().\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlText.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlText.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlText.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlText.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlText.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlText)");
             printf(" Error In PyType_ReadyTiXmlText");
             return;
        }
        Py_INCREF(&Dtool_TiXmlText.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlText.As_PyTypeObject().tp_dict,"TiXmlText",&Dtool_TiXmlText.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlText,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlText.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlText",(PyObject *)&Dtool_TiXmlText.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlUnknown | TiXmlUnknown
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlUnknown[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlUnknown_operator_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlUnknown_operator_141_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlUnknown(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlUnknown.As_PyTypeObject().tp_doc =
          "/** Any tag that tinyXml doesn't recognize is saved as an\n"
          "\011unknown. It is a tag of text, but should not be modified.\n"
          "\011It will be written back to the XML, unchanged, when the file\n"
          "\011is saved.\n"
          "\n"
          "\011DTD tags get thrown into TiXmlUnknowns.\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlNode._Dtool_ClassInit(NULL);
        Dtool_TiXmlUnknown.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlNode.As_PyTypeObject());
        Dtool_TiXmlUnknown.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlUnknown.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlUnknown.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlUnknown.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlUnknown)");
             printf(" Error In PyType_ReadyTiXmlUnknown");
             return;
        }
        Py_INCREF(&Dtool_TiXmlUnknown.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlUnknown.As_PyTypeObject().tp_dict,"TiXmlUnknown",&Dtool_TiXmlUnknown.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlUnknown,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlUnknown.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlUnknown",(PyObject *)&Dtool_TiXmlUnknown.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlHandle | TiXmlHandle
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlHandle[]= {
  { "assign",(PyCFunction ) &Dtool_TiXmlHandle_operator_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_operator_144_comment},
  { "FirstChild",(PyCFunction ) &Dtool_TiXmlHandle_FirstChild_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_FirstChild_145_comment},
  { "FirstChildElement",(PyCFunction ) &Dtool_TiXmlHandle_FirstChildElement_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_FirstChildElement_146_comment},
  { "Child",(PyCFunction ) &Dtool_TiXmlHandle_Child_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_Child_147_comment},
  { "ChildElement",(PyCFunction ) &Dtool_TiXmlHandle_ChildElement_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_ChildElement_148_comment},
  { "ToNode",(PyCFunction ) &Dtool_TiXmlHandle_ToNode_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_ToNode_149_comment},
  { "ToElement",(PyCFunction ) &Dtool_TiXmlHandle_ToElement_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_ToElement_150_comment},
  { "ToText",(PyCFunction ) &Dtool_TiXmlHandle_ToText_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_ToText_151_comment},
  { "ToUnknown",(PyCFunction ) &Dtool_TiXmlHandle_ToUnknown_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_ToUnknown_152_comment},
  { "Node",(PyCFunction ) &Dtool_TiXmlHandle_Node_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_Node_153_comment},
  { "Element",(PyCFunction ) &Dtool_TiXmlHandle_Element_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_Element_154_comment},
  { "Text",(PyCFunction ) &Dtool_TiXmlHandle_Text_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_Text_155_comment},
  { "Unknown",(PyCFunction ) &Dtool_TiXmlHandle_Unknown_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlHandle_Unknown_156_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlHandle.As_PyTypeObject().tp_doc =
          "/**\n"
          "\011A TiXmlHandle is a class that wraps a node pointer with null checks; this is\n"
          "\011an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml\n"
          "\011DOM structure. It is a separate utility class.\n"
          "\n"
          "\011Take an example:\n"
          "\011@verbatim\n"
          "\011<Document>\n"
          "\011\011<Element attributeA = \"valueA\">\n"
          "\011\011\011<Child attributeB = \"value1\" />\n"
          "\011\011\011<Child attributeB = \"value2\" />\n"
          "\011\011</Element>\n"
          "\011<Document>\n"
          "\011@endverbatim\n"
          "\n"
          "\011Assuming you want the value of \"attributeB\" in the 2nd \"Child\" element, it's very \n"
          "\011easy to write a *lot* of code that looks like:\n"
          "\n"
          "\011@verbatim\n"
          "\011TiXmlElement* root = document.FirstChildElement( \"Document\" );\n"
          "\011if ( root )\n"
          "\011{\n"
          "\011\011TiXmlElement* element = root->FirstChildElement( \"Element\" );\n"
          "\011\011if ( element )\n"
          "\011\011{\n"
          "\011\011\011TiXmlElement* child = element->FirstChildElement( \"Child\" );\n"
          "\011\011\011if ( child )\n"
          "\011\011\011{\n"
          "\011\011\011\011TiXmlElement* child2 = child->NextSiblingElement( \"Child\" );\n"
          "\011\011\011\011if ( child2 )\n"
          "\011\011\011\011{\n"
          "\011\011\011\011\011// Finally do something useful.\n"
          "\011@endverbatim\n"
          "\n"
          "\011And that doesn't even cover \"else\" cases. TiXmlHandle addresses the verbosity\n"
          "\011of such code. A TiXmlHandle checks for null\011pointers so it is perfectly safe \n"
          "\011and correct to use:\n"
          "\n"
          "\011@verbatim\n"
          "\011TiXmlHandle docHandle( &document );\n"
          "\011TiXmlElement* child2 = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", 1 ).ToElement();\n"
          "\011if ( child2 )\n"
          "\011{\n"
          "\011\011// do something useful\n"
          "\011@endverbatim\n"
          "\n"
          "\011Which is MUCH more concise and useful.\n"
          "\n"
          "\011It is also safe to copy handles - internally they are nothing more than node pointers.\n"
          "\011@verbatim\n"
          "\011TiXmlHandle handleCopy = handle;\n"
          "\011@endverbatim\n"
          "\n"
          "\011What they should not be used for is iteration:\n"
          "\n"
          "\011@verbatim\n"
          "\011int i=0; \n"
          "\011while ( true )\n"
          "\011{\n"
          "\011\011TiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", i ).ToElement();\n"
          "\011\011if ( !child )\n"
          "\011\011\011break;\n"
          "\011\011// do something\n"
          "\011\011++i;\n"
          "\011}\n"
          "\011@endverbatim\n"
          "\n"
          "\011It seems reasonable, but it is in fact two embedded while loops. The Child method is \n"
          "\011a linear walk to find the element, so this code would iterate much more than it needs \n"
          "\011to. Instead, prefer:\n"
          "\n"
          "\011@verbatim\n"
          "\011TiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).FirstChild( \"Child\" ).ToElement();\n"
          "\n"
          "\011for( child; child; child=child->NextSiblingElement() )\n"
          "\011{\n"
          "\011\011// do something\n"
          "\011}\n"
          "\011@endverbatim\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_TiXmlHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_TiXmlHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlHandle.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlHandle)");
             printf(" Error In PyType_ReadyTiXmlHandle");
             return;
        }
        Py_INCREF(&Dtool_TiXmlHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlHandle.As_PyTypeObject().tp_dict,"TiXmlHandle",&Dtool_TiXmlHandle.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlHandle,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlHandle.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlHandle",(PyObject *)&Dtool_TiXmlHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TiXmlPrinter | TiXmlPrinter
//********************************************************************
PyMethodDef Dtool_Methods_TiXmlPrinter[]= {
  { "SetIndent",(PyCFunction ) &Dtool_TiXmlPrinter_SetIndent_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_SetIndent_160_comment},
  { "Indent",(PyCFunction ) &Dtool_TiXmlPrinter_Indent_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_Indent_161_comment},
  { "SetLineBreak",(PyCFunction ) &Dtool_TiXmlPrinter_SetLineBreak_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_SetLineBreak_162_comment},
  { "LineBreak",(PyCFunction ) &Dtool_TiXmlPrinter_LineBreak_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_LineBreak_163_comment},
  { "SetStreamPrinting",(PyCFunction ) &Dtool_TiXmlPrinter_SetStreamPrinting_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_SetStreamPrinting_164_comment},
  { "CStr",(PyCFunction ) &Dtool_TiXmlPrinter_CStr_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_CStr_165_comment},
  { "Size",(PyCFunction ) &Dtool_TiXmlPrinter_Size_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_Size_166_comment},
  { "Str",(PyCFunction ) &Dtool_TiXmlPrinter_Str_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TiXmlPrinter_Str_167_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TiXmlPrinter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TiXmlPrinter.As_PyTypeObject().tp_doc =
          "/** Print to memory functionality. The TiXmlPrinter is useful when you need to:\n"
          "\n"
          "\011-# Print to memory (especially in non-STL mode)\n"
          "\011-# Control formatting (line endings, etc.)\n"
          "\n"
          "\011When constructed, the TiXmlPrinter is in its default \"pretty printing\" mode.\n"
          "\011Before calling Accept() you can call methods to control the printing\n"
          "\011of the XML document. After TiXmlNode::Accept() is called, the printed document can\n"
          "\011be accessed via the CStr(), Str(), and Size() methods.\n"
          "\n"
          "\011TiXmlPrinter uses the Visitor API.\n"
          "\011@verbatim\n"
          "\011TiXmlPrinter printer;\n"
          "\011printer.SetIndent( \"\\t\" );\n"
          "\n"
          "\011doc.Accept( &printer );\n"
          "\011fprintf( stdout, \"%s\", printer.CStr() );\n"
          "\011@endverbatim\n"
          "*/";
#endif
        // Dependent Objects   
        Dtool_TiXmlVisitor._Dtool_ClassInit(NULL);
        Dtool_TiXmlPrinter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TiXmlVisitor.As_PyTypeObject());
        Dtool_TiXmlPrinter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TiXmlPrinter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TiXmlPrinter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TiXmlPrinter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TiXmlPrinter)");
             printf(" Error In PyType_ReadyTiXmlPrinter");
             return;
        }
        Py_INCREF(&Dtool_TiXmlPrinter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TiXmlPrinter.As_PyTypeObject().tp_dict,"TiXmlPrinter",&Dtool_TiXmlPrinter.As_PyObject());
        RegisterRuntimeClass(&Dtool_TiXmlPrinter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TiXmlPrinter.As_PyTypeObject());
        PyModule_AddObject(module, "TiXmlPrinter",(PyObject *)&Dtool_TiXmlPrinter.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..TiXmlEncoding
//********************************************************************
   PyModule_AddIntConstant(module,"TIXMLENCODINGUNKNOWN",0);
   PyModule_AddIntConstant(module,"TIXMLENCODINGUTF8",1);
   PyModule_AddIntConstant(module,"TIXMLENCODINGLEGACY",2);
   PyModule_AddStringConstant(module,"TINYXMLINCLUDED","");
   PyModule_AddStringConstant(module,"TIXMLSAFE","");
   PyModule_AddStringConstant(module,"TIXMLSNPRINTF","_snprintf_s");
   PyModule_AddStringConstant(module,"TIXMLSSCANF","sscanf_s");
   PyModule_AddStringConstant(module,"TIXMLSTRING","std::string");
//********************************************************************
//*** Module Init Updcall ..TiXmlBase
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlBase(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlDeclaration
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlDeclaration(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlNode
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlNode(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlDocument
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlDocument(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlElement
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlElement(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlCursor
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlCursor(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlVisitor
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlVisitor(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlAttribute
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlAttribute(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlAttributeSet
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlAttributeSet(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlComment
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlComment(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlText
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlText(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlUnknown
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlUnknown(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlHandle
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlHandle(module);
//********************************************************************
//*** Module Init Updcall ..TiXmlPrinter
//********************************************************************
   Dtool_PyModuleClassInit_TiXmlPrinter(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "readXmlStream", (PyCFunction) &Dtool_read_xml_stream_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_read_xml_stream_81_comment},
  { "writeXmlStream", (PyCFunction) &Dtool_write_xml_stream_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_write_xml_stream_82_comment},
  { "getTIXMLMAJORVERSION", (PyCFunction) &Dtool_get_TIXML_MAJOR_VERSION_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_TIXML_MAJOR_VERSION_84_comment},
  { "getTIXMLMINORVERSION", (PyCFunction) &Dtool_get_TIXML_MINOR_VERSION_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_TIXML_MINOR_VERSION_86_comment},
  { "getTIXMLPATCHVERSION", (PyCFunction) &Dtool_get_TIXML_PATCH_VERSION_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_TIXML_PATCH_VERSION_88_comment},
  { "getTIXMLDEFAULTENCODING", (PyCFunction) &Dtool_get_TIXML_DEFAULT_ENCODING_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_TIXML_DEFAULT_ENCODING_98_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdxml_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212927,  /* file_identifier */
  "libdxml",  /* library_name */
  "Pra7",  /* library_hash_name */
  "panda",  /* module_name */
  "libdxml.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  459  /* next_index */
};

Configure(_in_configure_libdxml);
ConfigureFn(_in_configure_libdxml) {
  interrogate_request_module(&_in_module_def);
}

