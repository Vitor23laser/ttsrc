/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/net -Ipanda/src/net -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libnet_igate.cxx -od built_Rocket/pandac/input/libnet.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/net -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libnet config_net.h connection.h connectionListener.h connectionManager.h connectionReader.h connectionWriter.h datagramGeneratorNet.h datagramQueue.h datagramSinkNet.h datagramTCPHeader.h datagramUDPHeader.h netAddress.h netDatagram.h net_composite.cxx queuedConnectionListener.h queuedConnectionManager.h queuedConnectionReader.h queuedReturn.h recentConnectionReader.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libnet
#include "py_panda.h"  

#include "conditionVar.h"
#include "configVariableBool.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "config_net.h"
#include "connection.h"
#include "connectionListener.h"
#include "connectionManager.h"
#include "connectionReader.h"
#include "connectionWriter.h"
#include "datagramGenerator.h"
#include "datagramGeneratorNet.h"
#include "datagramIterator.h"
#include "datagramQueue.h"
#include "datagramSink.h"
#include "datagramSinkNet.h"
#include "datagramTCPHeader.h"
#include "datagramUDPHeader.h"
#include "lightMutex.h"
#include "lightReMutex.h"
#include "netAddress.h"
#include "netDatagram.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "queuedConnectionListener.h"
#include "queuedConnectionManager.h"
#include "queuedConnectionReader.h"
#include "queuedReturn.h"
#include "recentConnectionReader.h"
#include "referenceCount.h"
#include "thread.h"
#include "threadPriority.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PointerTo_Connection
//********************************************************************
typedef  PointerTo< Connection >  PointerTo_Connection_localtype;
Define_Module_Class(panda,PointerTo_Connection,PointerTo_Connection_localtype,PointerToConnection);
//********************************************************************
//*** prototypes for .. PointerToBase_Connection
//********************************************************************
typedef  PointerToBase< Connection >  PointerToBase_Connection_localtype;
Define_Module_Class_Private(panda,PointerToBase_Connection,PointerToBase_Connection_localtype,PointerToBaseConnection);
//********************************************************************
//*** prototypes for .. NetAddress
//********************************************************************
typedef  NetAddress  NetAddress_localtype;
Define_Module_Class(panda,NetAddress,NetAddress_localtype,NetAddress);
//********************************************************************
//*** prototypes for .. Connection
//********************************************************************
typedef  Connection  Connection_localtype;
Define_Module_ClassRef(panda,Connection,Connection_localtype,Connection);
//********************************************************************
//*** prototypes for .. ConnectionReader
//********************************************************************
typedef  ConnectionReader  ConnectionReader_localtype;
Define_Module_Class(panda,ConnectionReader,ConnectionReader_localtype,ConnectionReader);
//********************************************************************
//*** prototypes for .. ConnectionListener
//********************************************************************
typedef  ConnectionListener  ConnectionListener_localtype;
Define_Module_Class(panda,ConnectionListener,ConnectionListener_localtype,ConnectionListener);
//********************************************************************
//*** prototypes for .. NetDatagram
//********************************************************************
typedef  NetDatagram  NetDatagram_localtype;
Define_Module_Class(panda,NetDatagram,NetDatagram_localtype,NetDatagram);
//********************************************************************
//*** prototypes for .. ConnectionManager
//********************************************************************
typedef  ConnectionManager  ConnectionManager_localtype;
Define_Module_Class(panda,ConnectionManager,ConnectionManager_localtype,ConnectionManager);
//********************************************************************
//*** prototypes for .. ConnectionWriter
//********************************************************************
typedef  ConnectionWriter  ConnectionWriter_localtype;
Define_Module_Class(panda,ConnectionWriter,ConnectionWriter_localtype,ConnectionWriter);
//********************************************************************
//*** prototypes for .. DatagramGeneratorNet
//********************************************************************
typedef  DatagramGeneratorNet  DatagramGeneratorNet_localtype;
Define_Module_Class(panda,DatagramGeneratorNet,DatagramGeneratorNet_localtype,DatagramGeneratorNet);
//********************************************************************
//*** prototypes for .. QueuedReturn_Datagram
//********************************************************************
typedef  QueuedReturn< Datagram >  QueuedReturn_Datagram_localtype;
Define_Module_Class_Private(panda,QueuedReturn_Datagram,QueuedReturn_Datagram_localtype,QueuedReturnDatagram);
//********************************************************************
//*** prototypes for .. DatagramSinkNet
//********************************************************************
typedef  DatagramSinkNet  DatagramSinkNet_localtype;
Define_Module_Class(panda,DatagramSinkNet,DatagramSinkNet_localtype,DatagramSinkNet);
//********************************************************************
//*** prototypes for .. QueuedConnectionListener
//********************************************************************
typedef  QueuedConnectionListener  QueuedConnectionListener_localtype;
Define_Module_Class(panda,QueuedConnectionListener,QueuedConnectionListener_localtype,QueuedConnectionListener);
//********************************************************************
//*** prototypes for .. QueuedReturn_ConnectionListenerData
//********************************************************************
typedef  QueuedReturn< ConnectionListenerData >  QueuedReturn_ConnectionListenerData_localtype;
Define_Module_Class_Private(panda,QueuedReturn_ConnectionListenerData,QueuedReturn_ConnectionListenerData_localtype,QueuedReturnConnectionListenerData);
//********************************************************************
//*** prototypes for .. QueuedConnectionManager
//********************************************************************
typedef  QueuedConnectionManager  QueuedConnectionManager_localtype;
Define_Module_Class(panda,QueuedConnectionManager,QueuedConnectionManager_localtype,QueuedConnectionManager);
//********************************************************************
//*** prototypes for .. QueuedReturn_PointerTo_Connection
//********************************************************************
typedef  QueuedReturn< PointerTo< Connection > >  QueuedReturn_PointerTo_Connection_localtype;
Define_Module_Class_Private(panda,QueuedReturn_PointerTo_Connection,QueuedReturn_PointerTo_Connection_localtype,QueuedReturnPointerToConnection);
//********************************************************************
//*** prototypes for .. QueuedConnectionReader
//********************************************************************
typedef  QueuedConnectionReader  QueuedConnectionReader_localtype;
Define_Module_Class(panda,QueuedConnectionReader,QueuedConnectionReader_localtype,QueuedConnectionReader);
//********************************************************************
//*** prototypes for .. QueuedReturn_NetDatagram
//********************************************************************
typedef  QueuedReturn< NetDatagram >  QueuedReturn_NetDatagram_localtype;
Define_Module_Class_Private(panda,QueuedReturn_NetDatagram,QueuedReturn_NetDatagram_localtype,QueuedReturnNetDatagram);
//********************************************************************
//*** prototypes for .. RecentConnectionReader
//********************************************************************
typedef  RecentConnectionReader  RecentConnectionReader_localtype;
Define_Module_Class(panda,RecentConnectionReader,RecentConnectionReader_localtype,RecentConnectionReader);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramGenerator;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramSink;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerToVoid;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Socket_Address;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Socket_IP;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PointerTo< Connection > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Connection *::PointerTo< Connection >::p(void) const
 *******************************************************************/
static PyObject *Dtool_PointerTo_Connection_p_8(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerTo< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Connection *::PointerTo< Connection >::p(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":p", key_word_list));
        else
            (PyArg_Parse(args, ":p"));
        if(!PyErr_Occurred())
        {
            Connection *return_value = ((const PointerTo< Connection >*)local_this)->p();
            if (return_value != (Connection *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Connection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "p(const PointerTo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerTo_Connection_p_8_comment =
    "C++ Interface:\n"
    "p(const PointerTo this)\n"
    "\n"
    "// When downcasting to a derived class from a PointerTo<BaseClass>,\n"
    "// C++ would normally require you to cast twice: once to an actual\n"
    "// BaseClass pointer, and then again to your desired pointer.  You\n"
    "// can use the handy function p() to avoid this first cast and make\n"
    "// your code look a bit cleaner.\n"
    "// e.g. instead of (MyType *)(BaseClass *)ptr, use (MyType *)ptr.p()\n"
    "// If your base class is a derivative of TypedObject, you might want\n"
    "// to use the DCAST macro defined in typedObject.h instead,\n"
    "// e.g. DCAST(MyType, ptr).  This provides a clean downcast that\n"
    "// doesn't require .p() or any double-casting, and it can be\n"
    "// run-time checked for correctness.\n"
    "";
#else
static const char * Dtool_PointerTo_Connection_p_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< Connection > &::PointerTo< Connection >::operator =(Connection *ptr)
 * inline PointerTo< Connection > &::PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
 *******************************************************************/
static PyObject *Dtool_PointerTo_Connection_operator_9(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerTo< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline PointerTo< Connection > &::PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "PointerTo.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(param1_this);
                    PointerTo< Connection > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerTo_Connection,false, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline PointerTo< Connection > &::PointerTo< Connection >::operator =(Connection *ptr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ptr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "PointerTo.assign", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(param1_this);
                    PointerTo< Connection > *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerTo_Connection,false, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PointerTo this, const Connection copy)\n"
          "assign(non-const PointerTo this, non-const Connection ptr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerTo_Connection_operator_9_comment =
    "C++ Interface:\n"
    "assign(non-const PointerTo this, const Connection copy)\n"
    "assign(non-const PointerTo this, non-const Connection ptr)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerTo_Connection_operator_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ::PointerTo< Connection >::is_null(void) const
 *******************************************************************/
static PyObject *Dtool_PointerTo_Connection_is_null_10(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerTo< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ::PointerTo< Connection >::is_null(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isNull", key_word_list));
        else
            (PyArg_Parse(args, ":isNull"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PointerTo< Connection >*)local_this)->is_null();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isNull(const PointerTo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerTo_Connection_is_null_10_comment =
    "C++ Interface:\n"
    "isNull(const PointerTo this)\n"
    "\n"
    "// These functions normally wouldn't need to be redefined here, but\n"
    "// we do so anyway just to help out interrogate (which doesn't seem\n"
    "// to want to automatically export the PointerToBase class).  When\n"
    "// this works again in interrogate, we can remove these.\n"
    "";
#else
static const char * Dtool_PointerTo_Connection_is_null_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerTo< Connection >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerTo_Connection_clear_11(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerTo< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerTo< Connection >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerTo.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerTo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerTo_Connection_clear_11_comment =
    "C++ Interface:\n"
    "clear(non-const PointerTo this)\n"
    "\n"
    "// These functions normally wouldn't need to be redefined here, but\n"
    "// we do so anyway just to help out interrogate (which doesn't seem\n"
    "// to want to automatically export the PointerToBase class).  When\n"
    "// this works again in interrogate, we can remove these.\n"
    "";
#else
static const char * Dtool_PointerTo_Connection_clear_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerTo< Connection >::PointerTo(Connection *ptr)
 * inline ::PointerTo< Connection >::PointerTo(Connection *ptr = ((Connection *)((void *)(0))))
 * inline ::PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
 *******************************************************************/
int  Dtool_Init_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerTo< Connection >::PointerTo(Connection *ptr = ((Connection *)((void *)(0))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerTo", key_word_list))
            {
                PointerTo< Connection > *return_value = new PointerTo< Connection >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerTo_Connection,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerTo", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerTo", &param0));
                if(!PyErr_Occurred())
                {
                    Connection *param0_this = (Connection *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Connection, 0, "PointerTo.PointerTo", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerTo_Connection,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerTo< Connection >::PointerTo(Connection *ptr)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"ptr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerTo", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerTo", &param0));
                if(!PyErr_Occurred())
                {
                    Connection *param0_this = (Connection *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Connection, 0, "PointerTo.PointerTo", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerTo_Connection,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerTo() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerTo()\n"
          "PointerTo(const Connection copy)\n"
          "PointerTo(non-const Connection ptr)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerTo_Connection)
    {
        printf("PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerTo< Connection > * local_this = (PointerTo< Connection > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerTo_Connection)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_Connection)
        return ( PointerToBase< Connection > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< Connection > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerTo_Connection)
        return from_this;
    if(from_type == &Dtool_PointerToBase_Connection)
    {
          PointerToBase< Connection >* other_this = (PointerToBase< Connection >*)from_this;
          return (PointerTo< Connection >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerTo< Connection >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< Connection > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< Connection >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_Connection_clear_4(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< Connection >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_Connection_clear_4_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_Connection_clear_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< Connection >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_Connection_output_5(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< Connection >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< Connection >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_Connection_output_5_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_Connection_output_5_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_Connection(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< Connection >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_Connection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_Connection)
    {
        printf("PointerToBase_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< Connection > * local_this = (PointerToBase< Connection > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_Connection)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_Connection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_Connection)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< Connection >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NetAddress 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool NetAddress::set_any(int port)
 *******************************************************************/
static PyObject *Dtool_NetAddress_set_any_14(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool NetAddress::set_any(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAny", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAny", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_any((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NetAddress.setAny() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAny(non-const NetAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_set_any_14_comment =
    "C++ Interface:\n"
    "setAny(non-const NetAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::set_any\n"
    "//       Access: Public\n"
    "//  Description: Sets the address up to refer to a particular port,\n"
    "//               but not to any particular IP.  Returns true if\n"
    "//               successful, false otherwise (currently, this only\n"
    "//               returns true).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_set_any_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool NetAddress::set_localhost(int port)
 *******************************************************************/
static PyObject *Dtool_NetAddress_set_localhost_15(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool NetAddress::set_localhost(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLocalhost", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLocalhost", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_localhost((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NetAddress.setLocalhost() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLocalhost(non-const NetAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_set_localhost_15_comment =
    "C++ Interface:\n"
    "setLocalhost(non-const NetAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::set_localhost\n"
    "//       Access: Public\n"
    "//  Description: Sets the address up to refer to a particular port,\n"
    "//               on this host.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_set_localhost_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool NetAddress::set_host(basic_string< char > const &hostname, int port)
 *******************************************************************/
static PyObject *Dtool_NetAddress_set_host_16(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool NetAddress::set_host(basic_string< char > const &hostname, int port)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"hostname", (char *)"port", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setHost", key_word_list, &param1_str, &param1_len, &param2))
        {
            bool return_value = (local_this)->set_host(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NetAddress.setHost() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHost(non-const NetAddress this, string hostname, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_set_host_16_comment =
    "C++ Interface:\n"
    "setHost(non-const NetAddress this, string hostname, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::set_host\n"
    "//       Access: Public\n"
    "//  Description: Sets the address up to refer to a particular port\n"
    "//               on a particular host.  Returns true if the hostname\n"
    "//               is known, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_set_host_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NetAddress::clear(void)
 *******************************************************************/
static PyObject *Dtool_NetAddress_clear_17(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NetAddress::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NetAddress.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const NetAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_clear_17_comment =
    "C++ Interface:\n"
    "clear(non-const NetAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::clear\n"
    "//       Access: Public\n"
    "//  Description: Resets the NetAddress to its initial state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_clear_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NetAddress::get_port(void) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_get_port_18(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int NetAddress::get_port(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPort", key_word_list));
        else
            (PyArg_Parse(args, ":getPort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NetAddress*)local_this)->get_port();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPort(const NetAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_get_port_18_comment =
    "C++ Interface:\n"
    "getPort(const NetAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::get_port\n"
    "//       Access: Public\n"
    "//  Description: Returns the port number to which this address refers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_get_port_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NetAddress::set_port(int port)
 *******************************************************************/
static PyObject *Dtool_NetAddress_set_port_19(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NetAddress::set_port(int port)
        int param1;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_port((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NetAddress.setPort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPort(non-const NetAddress this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_set_port_19_comment =
    "C++ Interface:\n"
    "setPort(non-const NetAddress this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::set_port\n"
    "//       Access: Public\n"
    "//  Description: Resets the port number without otherwise changing the\n"
    "//               address.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_set_port_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > NetAddress::get_ip_string(void) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_get_ip_string_20(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > NetAddress::get_ip_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIpString", key_word_list));
        else
            (PyArg_Parse(args, ":getIpString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const NetAddress*)local_this)->get_ip_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIpString(const NetAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_get_ip_string_20_comment =
    "C++ Interface:\n"
    "getIpString(const NetAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::get_ip_string\n"
    "//       Access: Public\n"
    "//  Description: Returns the IP address to which this address refers,\n"
    "//               formatted as a string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_get_ip_string_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned int NetAddress::get_ip(void) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_get_ip_21(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned int NetAddress::get_ip(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIp", key_word_list));
        else
            (PyArg_Parse(args, ":getIp"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const NetAddress*)local_this)->get_ip();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIp(const NetAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_get_ip_21_comment =
    "C++ Interface:\n"
    "getIp(const NetAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::get_ip\n"
    "//       Access: Public\n"
    "//  Description: Returns the IP address to which this address refers,\n"
    "//               as a 32-bit integer, in host byte order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_get_ip_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned char NetAddress::get_ip_component(int n) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_get_ip_component_22(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned char NetAddress::get_ip_component(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getIpComponent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getIpComponent", &param1));
        if(!PyErr_Occurred())
        {
            unsigned char return_value = ((const NetAddress*)local_this)->get_ip_component((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIpComponent(const NetAddress this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_get_ip_component_22_comment =
    "C++ Interface:\n"
    "getIpComponent(const NetAddress this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::get_ip_component\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth 8-bit component of the IP address.\n"
    "//               An IP address has four components; component 0 is the\n"
    "//               first (leftmost), and component 3 is the last\n"
    "//               (rightmost) in the dotted number convention.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_get_ip_component_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Socket_Address const &NetAddress::get_addr(void) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_get_addr_23(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Socket_Address const &NetAddress::get_addr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAddr", key_word_list));
        else
            (PyArg_Parse(args, ":getAddr"));
        if(!PyErr_Occurred())
        {
            Socket_Address const *return_value = &(((const NetAddress*)local_this)->get_addr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Socket_Address,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAddr(const NetAddress this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_get_addr_23_comment =
    "C++ Interface:\n"
    "getAddr(const NetAddress this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::get_addr\n"
    "//       Access: Public\n"
    "//  Description: Returns the Socket_Address for this address.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_get_addr_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NetAddress::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_NetAddress_output_24(PyObject *self, PyObject *args,PyObject *kwds) {
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void NetAddress::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "NetAddress.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const NetAddress*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const NetAddress this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetAddress_output_24_comment =
    "C++ Interface:\n"
    "output(const NetAddress this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetAddress::output\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetAddress_output_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NetAddress::NetAddress(void)
 * NetAddress::NetAddress(Socket_Address const &addr)
 *******************************************************************/
int  Dtool_Init_NetAddress(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-NetAddress::NetAddress(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":NetAddress", key_word_list))
            {
                NetAddress *return_value = new NetAddress();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_NetAddress,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-NetAddress::NetAddress(Socket_Address const &addr)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"addr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:NetAddress", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:NetAddress", &param0));
                if(!PyErr_Occurred())
                {
                    Socket_Address *param0_this = (Socket_Address *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Socket_Address, 0, "NetAddress.NetAddress", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        NetAddress *return_value = new NetAddress(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NetAddress,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NetAddress() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NetAddress()\n"
          "NetAddress(const SocketAddress addr)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NetAddress(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NetAddress)
    {
        printf("NetAddress ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NetAddress * local_this = (NetAddress *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NetAddress)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NetAddress(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NetAddress)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Connection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * NetAddress Connection::get_address(void) const
 *******************************************************************/
static PyObject *Dtool_Connection_get_address_29(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NetAddress Connection::get_address(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAddress", key_word_list));
        else
            (PyArg_Parse(args, ":getAddress"));
        if(!PyErr_Occurred())
        {
            NetAddress result = ((const Connection*)local_this)->get_address();
            NetAddress *return_value = new NetAddress(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NetAddress,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAddress(const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_get_address_29_comment =
    "C++ Interface:\n"
    "getAddress(const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::get_address\n"
    "//       Access: Published\n"
    "//  Description: Returns the address bound to this connection, if it\n"
    "//               is a TCP connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_get_address_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionManager *Connection::get_manager(void) const
 *******************************************************************/
static PyObject *Dtool_Connection_get_manager_30(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ConnectionManager *Connection::get_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManager", key_word_list));
        else
            (PyArg_Parse(args, ":getManager"));
        if(!PyErr_Occurred())
        {
            ConnectionManager *return_value = ((const Connection*)local_this)->get_manager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManager(const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_get_manager_30_comment =
    "C++ Interface:\n"
    "getManager(const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::get_manager\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the ConnectionManager object\n"
    "//               that serves this connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_get_manager_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Socket_IP *Connection::get_socket(void) const
 *******************************************************************/
static PyObject *Dtool_Connection_get_socket_31(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Socket_IP *Connection::get_socket(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSocket", key_word_list));
        else
            (PyArg_Parse(args, ":getSocket"));
        if(!PyErr_Occurred())
        {
            Socket_IP *return_value = ((const Connection*)local_this)->get_socket();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Socket_IP,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSocket(const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_get_socket_31_comment =
    "C++ Interface:\n"
    "getSocket(const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::get_socket\n"
    "//       Access: Published\n"
    "//  Description: Returns the internal Socket_IP that defines the\n"
    "//               connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_get_socket_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_collect_tcp(bool collect_tcp)
 *******************************************************************/
static PyObject *Dtool_Connection_set_collect_tcp_32(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_collect_tcp(bool collect_tcp)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"collect_tcp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollectTcp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCollectTcp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setCollectTcp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcp(non-const Connection this, bool collect_tcp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_collect_tcp_32_comment =
    "C++ Interface:\n"
    "setCollectTcp(non-const Connection this, bool collect_tcp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: Enables or disables \"collect-tcp\" mode.  In this\n"
    "//               mode, individual TCP packets are not sent\n"
    "//               immediately, but rather they are collected together\n"
    "//               and accumulated to be sent periodically as one larger\n"
    "//               TCP packet.  This cuts down on overhead from the\n"
    "//               TCP/IP protocol, especially if many small packets\n"
    "//               need to be sent on the same connection, but it\n"
    "//               introduces additional latency (since packets must be\n"
    "//               held before they can be sent).\n"
    "//\n"
    "//               See set_collect_tcp_interval() to specify the\n"
    "//               interval of time for which to hold packets before\n"
    "//               sending them.\n"
    "//\n"
    "//               If you enable this mode, you may also need to\n"
    "//               periodically call consider_flush() to flush the queue\n"
    "//               if no packets have been sent recently.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_collect_tcp_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Connection::get_collect_tcp(void) const
 *******************************************************************/
static PyObject *Dtool_Connection_get_collect_tcp_33(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Connection::get_collect_tcp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcp", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Connection*)local_this)->get_collect_tcp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcp(const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_get_collect_tcp_33_comment =
    "C++ Interface:\n"
    "getCollectTcp(const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::get_collect_tcp\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of \"collect-tcp\" mode.\n"
    "//               See set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_get_collect_tcp_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_collect_tcp_interval(double interval)
 *******************************************************************/
static PyObject *Dtool_Connection_set_collect_tcp_interval_34(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_collect_tcp_interval(double interval)
        double param1;
        static char * key_word_list[] = {(char *)"interval", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCollectTcpInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCollectTcpInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collect_tcp_interval((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setCollectTcpInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollectTcpInterval(non-const Connection this, float interval)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_collect_tcp_interval_34_comment =
    "C++ Interface:\n"
    "setCollectTcpInterval(non-const Connection this, float interval)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: Specifies the interval in time, in seconds, for which\n"
    "//               to hold TCP packets before sending all of the\n"
    "//               recently received packets at once.  This only has\n"
    "//               meaning if \"collect-tcp\" mode is enabled; see\n"
    "//               set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_collect_tcp_interval_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double Connection::get_collect_tcp_interval(void) const
 *******************************************************************/
static PyObject *Dtool_Connection_get_collect_tcp_interval_35(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double Connection::get_collect_tcp_interval(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollectTcpInterval", key_word_list));
        else
            (PyArg_Parse(args, ":getCollectTcpInterval"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const Connection*)local_this)->get_collect_tcp_interval();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollectTcpInterval(const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_get_collect_tcp_interval_35_comment =
    "C++ Interface:\n"
    "getCollectTcpInterval(const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::get_collect_tcp_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the interval in time, in seconds, for which\n"
    "//               to hold TCP packets before sending all of the\n"
    "//               recently received packets at once.  This only has\n"
    "//               meaning if \"collect-tcp\" mode is enabled; see\n"
    "//               set_collect_tcp().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_get_collect_tcp_interval_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Connection::consider_flush(void)
 *******************************************************************/
static PyObject *Dtool_Connection_consider_flush_36(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Connection::consider_flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":considerFlush", key_word_list));
        else
            (PyArg_Parse(args, ":considerFlush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->consider_flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.considerFlush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerFlush(non-const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_consider_flush_36_comment =
    "C++ Interface:\n"
    "considerFlush(non-const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::consider_flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued TCP datagram(s) if\n"
    "//               enough time has elapsed.  This only has meaning if\n"
    "//               set_collect_tcp() has been set to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_consider_flush_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Connection::flush(void)
 *******************************************************************/
static PyObject *Dtool_Connection_flush_37(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Connection::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const Connection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_flush_37_comment =
    "C++ Interface:\n"
    "flush(non-const Connection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued TCP datagram(s) now.\n"
    "//               This only has meaning if set_collect_tcp() has been\n"
    "//               set to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_flush_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_linger(bool flag, double time)
 *******************************************************************/
static PyObject *Dtool_Connection_set_linger_38(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_linger(bool flag, double time)
        PyObject *param1;
        double param2;
        static char * key_word_list[] = {(char *)"flag", (char *)"time", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setLinger", key_word_list, &param1, &param2))
        {
            (local_this)->set_linger((PyObject_IsTrue(param1)!=0), (double)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setLinger() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLinger(non-const Connection this, bool flag, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_linger_38_comment =
    "C++ Interface:\n"
    "setLinger(non-const Connection this, bool flag, float time)\n"
    "\n"
    "// Socket options.\n"
    "//  void set_nonblock(bool flag);\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_linger\n"
    "//       Access: Published\n"
    "//  Description: Sets the time to linger on close if data is present.\n"
    "//               If flag is false, when you close a socket with data\n"
    "//               available the system attempts to deliver the data to\n"
    "//               the peer (the default behavior).  If flag is false\n"
    "//               but time is zero, the system discards any undelivered\n"
    "//               data when you close the socket.  If flag is false but\n"
    "//               time is nonzero, the system waits up to time seconds\n"
    "//               to deliver the data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_linger_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_reuse_addr(bool flag)
 *******************************************************************/
static PyObject *Dtool_Connection_set_reuse_addr_39(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_reuse_addr(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setReuseAddr", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setReuseAddr", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reuse_addr((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setReuseAddr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReuseAddr(non-const Connection this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_reuse_addr_39_comment =
    "C++ Interface:\n"
    "setReuseAddr(non-const Connection this, bool flag)\n"
    "\n"
    "// Socket options.\n"
    "//  void set_nonblock(bool flag);\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_reuse_addr\n"
    "//       Access: Published\n"
    "//  Description: Sets whether local address reuse is allowed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_reuse_addr_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_keep_alive(bool flag)
 *******************************************************************/
static PyObject *Dtool_Connection_set_keep_alive_40(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_keep_alive(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setKeepAlive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setKeepAlive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_keep_alive((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setKeepAlive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKeepAlive(non-const Connection this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_keep_alive_40_comment =
    "C++ Interface:\n"
    "setKeepAlive(non-const Connection this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_keep_alive\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the connection is periodically tested to\n"
    "//               see if it is still alive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_keep_alive_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_recv_buffer_size(int size)
 *******************************************************************/
static PyObject *Dtool_Connection_set_recv_buffer_size_41(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_recv_buffer_size(int size)
        int param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRecvBufferSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRecvBufferSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_recv_buffer_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setRecvBufferSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRecvBufferSize(non-const Connection this, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_recv_buffer_size_41_comment =
    "C++ Interface:\n"
    "setRecvBufferSize(non-const Connection this, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_recv_buffer_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the size of the receive buffer, in bytes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_recv_buffer_size_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_send_buffer_size(int size)
 *******************************************************************/
static PyObject *Dtool_Connection_set_send_buffer_size_42(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_send_buffer_size(int size)
        int param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSendBufferSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSendBufferSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_send_buffer_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setSendBufferSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSendBufferSize(non-const Connection this, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_send_buffer_size_42_comment =
    "C++ Interface:\n"
    "setSendBufferSize(non-const Connection this, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_send_buffer_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the size of the send buffer, in bytes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_send_buffer_size_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_ip_time_to_live(int ttl)
 *******************************************************************/
static PyObject *Dtool_Connection_set_ip_time_to_live_43(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_ip_time_to_live(int ttl)
        int param1;
        static char * key_word_list[] = {(char *)"ttl", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setIpTimeToLive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setIpTimeToLive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_ip_time_to_live((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setIpTimeToLive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIpTimeToLive(non-const Connection this, int ttl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_ip_time_to_live_43_comment =
    "C++ Interface:\n"
    "setIpTimeToLive(non-const Connection this, int ttl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_ip_time_to_live\n"
    "//       Access: Published\n"
    "//  Description: Sets IP time-to-live.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_ip_time_to_live_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_ip_type_of_service(int tos)
 *******************************************************************/
static PyObject *Dtool_Connection_set_ip_type_of_service_44(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_ip_type_of_service(int tos)
        int param1;
        static char * key_word_list[] = {(char *)"tos", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setIpTypeOfService", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setIpTypeOfService", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_ip_type_of_service((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setIpTypeOfService() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIpTypeOfService(non-const Connection this, int tos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_ip_type_of_service_44_comment =
    "C++ Interface:\n"
    "setIpTypeOfService(non-const Connection this, int tos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_ip_type_of_service\n"
    "//       Access: Published\n"
    "//  Description: Sets IP type-of-service and precedence.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_ip_type_of_service_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_no_delay(bool flag)
 *******************************************************************/
static PyObject *Dtool_Connection_set_no_delay_45(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_no_delay(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNoDelay", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setNoDelay", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_no_delay((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setNoDelay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNoDelay(non-const Connection this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_no_delay_45_comment =
    "C++ Interface:\n"
    "setNoDelay(non-const Connection this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_no_delay\n"
    "//       Access: Published\n"
    "//  Description: If flag is true, this disables the Nagle algorithm,\n"
    "//               and prevents delaying of send to coalesce packets.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_no_delay_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Connection::set_max_segment(int size)
 *******************************************************************/
static PyObject *Dtool_Connection_set_max_segment_46(PyObject *self, PyObject *args,PyObject *kwds) {
    Connection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Connection::set_max_segment(int size)
        int param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxSegment", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxSegment", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_segment((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Connection.setMaxSegment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxSegment(non-const Connection this, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Connection_set_max_segment_46_comment =
    "C++ Interface:\n"
    "setMaxSegment(non-const Connection this, int size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Connection::set_max_segment\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum segment size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Connection_set_max_segment_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
 *******************************************************************/
int  Dtool_Init_Connection(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", (char *)"socket", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Connection", key_word_list, &param0, &param1))
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "Connection.Connection", 0, coerced_ptr, report_errors);
Socket_IP *param1_this = (Socket_IP *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Socket_IP, 1, "Connection.Connection", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    Connection *return_value = new Connection(param0_this, param1_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Connection,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Connection(non-const ConnectionManager manager, non-const SocketIP socket)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Connection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Connection)
    {
        printf("Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Connection * local_this = (Connection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Connection)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Connection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Connection)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Connection*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConnectionReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool ConnectionReader::add_connection(Connection *connection)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_add_connection_49(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConnectionReader::add_connection(Connection *connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addConnection", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "ConnectionReader.addConnection", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_connection(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionReader.addConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addConnection(non-const ConnectionReader this, non-const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_add_connection_49_comment =
    "C++ Interface:\n"
    "addConnection(non-const ConnectionReader this, non-const Connection connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::add_connection\n"
    "//       Access: Published\n"
    "//  Description: Adds a new socket to the list of sockets the\n"
    "//               ConnectionReader will monitor.  A datagram that comes\n"
    "//               in on any of the monitored sockets will be reported.\n"
    "//               In the case of a ConnectionListener, this adds a new\n"
    "//               rendezvous socket; any activity on any of the\n"
    "//               monitored sockets will cause a connection to be\n"
    "//               accepted.\n"
    "//\n"
    "//               The return value is true if the connection was added,\n"
    "//               false if it was already there.\n"
    "//\n"
    "//               add_connection() is thread-safe, and may be called at\n"
    "//               will by any thread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_add_connection_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionReader::remove_connection(Connection *connection)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_remove_connection_50(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConnectionReader::remove_connection(Connection *connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeConnection", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "ConnectionReader.removeConnection", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_connection(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionReader.removeConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeConnection(non-const ConnectionReader this, non-const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_remove_connection_50_comment =
    "C++ Interface:\n"
    "removeConnection(non-const ConnectionReader this, non-const Connection connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::remove_connection\n"
    "//       Access: Published\n"
    "//  Description: Removes a socket from the list of sockets being\n"
    "//               monitored.  Returns true if the socket was correctly\n"
    "//               removed, false if it was not on the list in the first\n"
    "//               place.\n"
    "//\n"
    "//               remove_connection() is thread-safe, and may be called\n"
    "//               at will by any thread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_remove_connection_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionReader::is_connection_ok(Connection *connection)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_is_connection_ok_51(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConnectionReader::is_connection_ok(Connection *connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isConnectionOk", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isConnectionOk", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "ConnectionReader.isConnectionOk", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->is_connection_ok(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionReader.isConnectionOk() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConnectionOk(non-const ConnectionReader this, non-const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_is_connection_ok_51_comment =
    "C++ Interface:\n"
    "isConnectionOk(non-const ConnectionReader this, non-const Connection connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::is_connection_ok\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated connection has been\n"
    "//               added to the ConnectionReader and is being monitored\n"
    "//               properly, false if it is not known, or if there was\n"
    "//               some error condition detected on the connection.  (If\n"
    "//               there was an error condition, normally the\n"
    "//               ConnectionManager would have been informed and closed\n"
    "//               the connection.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_is_connection_ok_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionReader::poll(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_poll_52(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionReader::poll(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":poll", key_word_list));
        else
            (PyArg_Parse(args, ":poll"));
        if(!PyErr_Occurred())
        {
            (local_this)->poll();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.poll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "poll(non-const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_poll_52_comment =
    "C++ Interface:\n"
    "poll(non-const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::poll\n"
    "//       Access: Published\n"
    "//  Description: Explicitly polls the available sockets to see if any\n"
    "//               of them have any noise.  This function does nothing\n"
    "//               unless this is a polling-type ConnectionReader,\n"
    "//               i.e. it was created with zero threads (and\n"
    "//               is_polling() will return true).\n"
    "//\n"
    "//               It is not necessary to call this explicitly for a\n"
    "//               QueuedConnectionReader.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_poll_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionManager *ConnectionReader::get_manager(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_get_manager_53(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ConnectionManager *ConnectionReader::get_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManager", key_word_list));
        else
            (PyArg_Parse(args, ":getManager"));
        if(!PyErr_Occurred())
        {
            ConnectionManager *return_value = ((const ConnectionReader*)local_this)->get_manager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManager(const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_get_manager_53_comment =
    "C++ Interface:\n"
    "getManager(const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::get_manager\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the ConnectionManager object\n"
    "//               that serves this ConnectionReader.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_get_manager_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ConnectionReader::is_polling(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_is_polling_54(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ConnectionReader::is_polling(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPolling", key_word_list));
        else
            (PyArg_Parse(args, ":isPolling"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConnectionReader*)local_this)->is_polling();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPolling(const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_is_polling_54_comment =
    "C++ Interface:\n"
    "isPolling(const ConnectionReader this)\n"
    "\n"
    "// Filename: connectionReader.I\n"
    "// Created by:  drose (15Feb09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::is_polling\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the reader is a polling reader,\n"
    "//               i.e. it has no threads.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_is_polling_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionReader::get_num_threads(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_get_num_threads_55(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionReader::get_num_threads(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumThreads", key_word_list));
        else
            (PyArg_Parse(args, ":getNumThreads"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionReader*)local_this)->get_num_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumThreads(const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_get_num_threads_55_comment =
    "C++ Interface:\n"
    "getNumThreads(const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::get_num_threads\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of threads the ConnectionReader\n"
    "//               has been created with.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_get_num_threads_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionReader::set_raw_mode(bool mode)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_set_raw_mode_56(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionReader::set_raw_mode(bool mode)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRawMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRawMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_raw_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.setRawMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRawMode(non-const ConnectionReader this, bool mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_set_raw_mode_56_comment =
    "C++ Interface:\n"
    "setRawMode(non-const ConnectionReader this, bool mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::set_raw_mode\n"
    "//       Access: Published\n"
    "//  Description: Sets the ConnectionReader into raw mode (or turns off\n"
    "//               raw mode).  In raw mode, datagram headers are not\n"
    "//               expected; instead, all the data available on the pipe\n"
    "//               is treated as a single datagram.\n"
    "//\n"
    "//               This is similar to set_tcp_header_size(0), except that it\n"
    "//               also turns off headers for UDP packets.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_set_raw_mode_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionReader::get_raw_mode(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_get_raw_mode_57(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ConnectionReader::get_raw_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRawMode", key_word_list));
        else
            (PyArg_Parse(args, ":getRawMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConnectionReader*)local_this)->get_raw_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRawMode(const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_get_raw_mode_57_comment =
    "C++ Interface:\n"
    "getRawMode(const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::get_raw_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the raw mode flag.\n"
    "//               See set_raw_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_get_raw_mode_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionReader::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_set_tcp_header_size_58(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionReader::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const ConnectionReader this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_set_tcp_header_size_58_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const ConnectionReader this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::set_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the header size of TCP packets.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_set_tcp_header_size_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionReader::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_get_tcp_header_size_59(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionReader::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionReader*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_get_tcp_header_size_59_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::get_tcp_header_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of TCP header size.\n"
    "//               See set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_get_tcp_header_size_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionReader::shutdown(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_shutdown_60(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionReader::shutdown(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":shutdown", key_word_list));
        else
            (PyArg_Parse(args, ":shutdown"));
        if(!PyErr_Occurred())
        {
            (local_this)->shutdown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.shutdown() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shutdown(non-const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_shutdown_60_comment =
    "C++ Interface:\n"
    "shutdown(non-const ConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionReader::shutdown\n"
    "//       Access: Published\n"
    "//  Description: Terminates all threads cleanly.  Normally this is\n"
    "//               only called by the destructor, but it may be called\n"
    "//               explicitly before destruction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionReader_shutdown_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_102(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDatagramGeneratorNet", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDatagramGeneratorNet"));
        if(!PyErr_Occurred())
        {
            DatagramGeneratorNet *return_value = (DatagramGeneratorNet *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramGeneratorNet,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.downcastToDatagramGeneratorNet() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDatagramGeneratorNet(non-const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_102_comment =
    "C++ Interface:\n"
    "downcastToDatagramGeneratorNet(non-const ConnectionReader this)\n"
    "\n"
    "downcast from ConnectionReader to DatagramGeneratorNet\n"
    "";
#else
static const char * Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_161(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionReader", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionReader"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionReader *return_value = (QueuedConnectionReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionReader.downcastToQueuedConnectionReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionReader(non-const ConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_161_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionReader(non-const ConnectionReader this)\n"
    "\n"
    "downcast from ConnectionReader to QueuedConnectionReader\n"
    "";
#else
static const char * Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_161_comment = NULL;
#endif

int  Dtool_Init_ConnectionReader(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConnectionReader)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConnectionReader)
    {
        printf("ConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConnectionReader * local_this = (ConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConnectionReader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConnectionReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConnectionReader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConnectionListener 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_131(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionListener * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionListener,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionListener", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionListener"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionListener *return_value = (QueuedConnectionListener *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionListener,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionListener.downcastToQueuedConnectionListener() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionListener(non-const ConnectionListener this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_131_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionListener(non-const ConnectionListener this)\n"
    "\n"
    "downcast from ConnectionListener to QueuedConnectionListener\n"
    "";
#else
static const char * Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_131_comment = NULL;
#endif

int  Dtool_Init_ConnectionListener(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConnectionListener)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConnectionListener)
    {
        printf("ConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConnectionListener * local_this = (ConnectionListener *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConnectionListener)
        return local_this;
    if(requested_type == &Dtool_ConnectionReader)
        return ( ConnectionReader *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConnectionListener(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConnectionListener)
        return from_this;
    if(from_type == &Dtool_ConnectionReader)
    {
          ConnectionReader* other_this = (ConnectionReader*)from_this;
          return (ConnectionListener*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NetDatagram 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void NetDatagram::operator =(Datagram const &copy)
 * void NetDatagram::operator =(NetDatagram const &copy)
 *******************************************************************/
static PyObject *Dtool_NetDatagram_operator_66(PyObject *self, PyObject *args,PyObject *kwds) {
    NetDatagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void NetDatagram::operator =(NetDatagram const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                NetDatagram *param1_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetDatagram, 1, "NetDatagram.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    NetDatagram *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_NetDatagram,false, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void NetDatagram::operator =(Datagram const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "NetDatagram.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    NetDatagram *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_NetDatagram,false, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const NetDatagram this, const NetDatagram copy)\n"
          "assign(non-const NetDatagram this, const Datagram copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_operator_66_comment =
    "C++ Interface:\n"
    "assign(non-const NetDatagram this, const NetDatagram copy)\n"
    "assign(non-const NetDatagram this, const Datagram copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetDatagram_operator_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NetDatagram::set_connection(PointerTo< Connection > const &connection)
 *******************************************************************/
static PyObject *Dtool_NetDatagram_set_connection_67(PyObject *self, PyObject *args,PyObject *kwds) {
    NetDatagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NetDatagram::set_connection(PointerTo< Connection > const &connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setConnection", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "NetDatagram.setConnection", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_connection(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NetDatagram.setConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setConnection(non-const NetDatagram this, const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_set_connection_67_comment =
    "C++ Interface:\n"
    "setConnection(non-const NetDatagram this, const Connection connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::set_connection\n"
    "//       Access: Public\n"
    "//  Description: Specifies the socket to which the datagram should be\n"
    "//               written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetDatagram_set_connection_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< Connection > NetDatagram::get_connection(void) const
 *******************************************************************/
static PyObject *Dtool_NetDatagram_get_connection_68(PyObject *self, PyObject *args,PyObject *kwds) {
    NetDatagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< Connection > NetDatagram::get_connection(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConnection", key_word_list));
        else
            (PyArg_Parse(args, ":getConnection"));
        if(!PyErr_Occurred())
        {
            PointerTo< Connection > return_value = ((const NetDatagram*)local_this)->get_connection();
            if (return_value != (Connection *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConnection(const NetDatagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_get_connection_68_comment =
    "C++ Interface:\n"
    "getConnection(const NetDatagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::set_connection\n"
    "//       Access: Public\n"
    "//  Description: Retrieves the socket from which the datagram was\n"
    "//               read, or to which it is scheduled to be written.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetDatagram_get_connection_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NetDatagram::set_address(NetAddress const &address)
 *******************************************************************/
static PyObject *Dtool_NetDatagram_set_address_69(PyObject *self, PyObject *args,PyObject *kwds) {
    NetDatagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NetDatagram::set_address(NetAddress const &address)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"address", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAddress", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAddress", &param1));
            if(!PyErr_Occurred())
            {
                NetAddress *param1_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetAddress, 1, "NetDatagram.setAddress", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_address(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NetDatagram.setAddress() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAddress(non-const NetDatagram this, const NetAddress address)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_set_address_69_comment =
    "C++ Interface:\n"
    "setAddress(non-const NetDatagram this, const NetAddress address)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::set_address\n"
    "//       Access: Public\n"
    "//  Description: Specifies the host to which the datagram should be\n"
    "//               sent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetDatagram_set_address_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NetAddress const &NetDatagram::get_address(void) const
 *******************************************************************/
static PyObject *Dtool_NetDatagram_get_address_70(PyObject *self, PyObject *args,PyObject *kwds) {
    NetDatagram * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NetAddress const &NetDatagram::get_address(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAddress", key_word_list));
        else
            (PyArg_Parse(args, ":getAddress"));
        if(!PyErr_Occurred())
        {
            NetAddress const *return_value = &(((const NetDatagram*)local_this)->get_address());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NetAddress,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAddress(const NetDatagram this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_get_address_70_comment =
    "C++ Interface:\n"
    "getAddress(const NetDatagram this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NetDatagram::set_address\n"
    "//       Access: Public\n"
    "//  Description: Retrieves the host from which the datagram was\n"
    "//               read, or to which it is scheduled to be sent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NetDatagram_get_address_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NetDatagram::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NetDatagram_get_class_type_71(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NetDatagram::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NetDatagram::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NetDatagram_get_class_type_71_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NetDatagram_get_class_type_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NetDatagram::NetDatagram(void)
 * NetDatagram::NetDatagram(Datagram const &copy)
 * NetDatagram::NetDatagram(NetDatagram const &copy)
 *******************************************************************/
int  Dtool_Init_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-NetDatagram::NetDatagram(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":NetDatagram", key_word_list))
            {
                NetDatagram *return_value = new NetDatagram();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_NetDatagram,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 NetDatagram::NetDatagram(NetDatagram const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:NetDatagram", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:NetDatagram", &param0));
                if(!PyErr_Occurred())
                {
                    NetDatagram *param0_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NetDatagram, 0, "NetDatagram.NetDatagram", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        NetDatagram *return_value = new NetDatagram(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NetDatagram,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 NetDatagram::NetDatagram(Datagram const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:NetDatagram", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:NetDatagram", &param0));
                if(!PyErr_Occurred())
                {
                    Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Datagram, 0, "NetDatagram.NetDatagram", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        NetDatagram *return_value = new NetDatagram(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_NetDatagram,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "NetDatagram() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "NetDatagram()\n"
          "NetDatagram(const NetDatagram copy)\n"
          "NetDatagram(const Datagram copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NetDatagram)
    {
        printf("NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NetDatagram * local_this = (NetDatagram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NetDatagram)
        return local_this;
    if(requested_type == &Dtool_Datagram)
        return ( Datagram *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Datagram *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NetDatagram)
        return from_this;
    if(from_type == &Dtool_Datagram)
    {
          Datagram* other_this = (Datagram*)from_this;
          return (NetDatagram*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NetDatagram*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConnectionManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(int port)
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(int port = (0))
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_open_UDP_connection_76(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(int port = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":openUDPConnection", key_word_list));
            else
                (PyArg_Parse(args, ":openUDPConnection"));
            if(!PyErr_Occurred())
            {
                PointerTo< Connection > return_value = (local_this)->open_UDP_connection();
                if (return_value != (Connection *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionManager.openUDPConnection() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(int port)
            int param1;
            static char * key_word_list[] = {(char *)"port", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:openUDPConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:openUDPConnection", &param1));
            if(!PyErr_Occurred())
            {
                PointerTo< Connection > return_value = (local_this)->open_UDP_connection((int)param1);
                if (return_value != (Connection *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionManager.openUDPConnection() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openUDPConnection() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openUDPConnection(non-const ConnectionManager this)\n"
          "openUDPConnection(non-const ConnectionManager this, int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_open_UDP_connection_76_comment =
    "C++ Interface:\n"
    "openUDPConnection(non-const ConnectionManager this)\n"
    "openUDPConnection(non-const ConnectionManager this, int port)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_UDP_connection\n"
    "//       Access: Public\n"
    "//  Description: Opens a socket for sending and/or receiving UDP\n"
    "//               packets.  If the port number is greater than zero,\n"
    "//               the UDP connection will be opened for listening on\n"
    "//               the indicated port; otherwise, it will be useful only\n"
    "//               for sending.\n"
    "//\n"
    "//               Use a ConnectionReader and ConnectionWriter to handle\n"
    "//               the actual communication.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionManager_open_UDP_connection_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(basic_string< char > const &hostname, int port, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(int port, int backlog)
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_open_TCP_server_rendezvous_77(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"address", (char *)"backlog", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:openTCPServerRendezvous", key_word_list, &param1, &param2))
                {
                    NetAddress *param1_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetAddress, 1, "ConnectionManager.openTCPServerRendezvous", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< Connection > return_value = (local_this)->open_TCP_server_rendezvous(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (Connection *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(int port, int backlog)
                int param1;
                int param2;
                static char * key_word_list[] = {(char *)"port", (char *)"backlog", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:openTCPServerRendezvous", key_word_list, &param1, &param2))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    PointerTo< Connection > return_value = (local_this)->open_TCP_server_rendezvous((int)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    if (return_value != (Connection *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(basic_string< char > const &hostname, int port, int backlog)
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"hostname", (char *)"port", (char *)"backlog", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:openTCPServerRendezvous", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                PointerTo< Connection > return_value = (local_this)->open_TCP_server_rendezvous(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (return_value != (Connection *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionManager.openTCPServerRendezvous() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openTCPServerRendezvous() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openTCPServerRendezvous(non-const ConnectionManager this, const NetAddress address, int backlog)\n"
          "openTCPServerRendezvous(non-const ConnectionManager this, int port, int backlog)\n"
          "openTCPServerRendezvous(non-const ConnectionManager this, string hostname, int port, int backlog)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_open_TCP_server_rendezvous_77_comment =
    "C++ Interface:\n"
    "openTCPServerRendezvous(non-const ConnectionManager this, const NetAddress address, int backlog)\n"
    "openTCPServerRendezvous(non-const ConnectionManager this, int port, int backlog)\n"
    "openTCPServerRendezvous(non-const ConnectionManager this, string hostname, int port, int backlog)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_TCP_server_rendezvous\n"
    "//       Access: Public\n"
    "//  Description: Creates a socket to be used as a rendezvous socket\n"
    "//               for a server to listen for TCP connections.  The\n"
    "//               socket returned by this call should only be added to\n"
    "//               a ConnectionListener (not to a generic\n"
    "//               ConnectionReader).\n"
    "//\n"
    "//               This variant of this method accepts a single port,\n"
    "//               and will listen to that port on all available\n"
    "//               interfaces.\n"
    "//\n"
    "//               backlog is the maximum length of the queue of pending\n"
    "//               connections.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_TCP_server_rendezvous\n"
    "//       Access: Public\n"
    "//  Description: Creates a socket to be used as a rendezvous socket\n"
    "//               for a server to listen for TCP connections.  The\n"
    "//               socket returned by this call should only be added to\n"
    "//               a ConnectionListener (not to a generic\n"
    "//               ConnectionReader).\n"
    "//\n"
    "//               This variant of this method accepts a \"hostname\",\n"
    "//               which is usually just an IP address in dotted\n"
    "//               notation, and a port number.  It will listen on the\n"
    "//               interface indicated by the IP address.  If the IP\n"
    "//               address is empty string, it will listen on all\n"
    "//               interfaces.\n"
    "//\n"
    "//               backlog is the maximum length of the queue of pending\n"
    "//               connections.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_TCP_server_rendezvous\n"
    "//       Access: Public\n"
    "//  Description: Creates a socket to be used as a rendezvous socket\n"
    "//               for a server to listen for TCP connections.  The\n"
    "//               socket returned by this call should only be added to\n"
    "//               a ConnectionListener (not to a generic\n"
    "//               ConnectionReader).\n"
    "//\n"
    "//               This variant of this method accepts a NetAddress,\n"
    "//               which allows you to specify a specific interface to\n"
    "//               listen to.\n"
    "//\n"
    "//               backlog is the maximum length of the queue of pending\n"
    "//               connections.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionManager_open_TCP_server_rendezvous_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(basic_string< char > const &hostname, int port, int timeout_ms)
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_open_TCP_client_connection_78(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"address", (char *)"timeout_ms", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:openTCPClientConnection", key_word_list, &param1, &param2))
                {
                    NetAddress *param1_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetAddress, 1, "ConnectionManager.openTCPClientConnection", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        PointerTo< Connection > return_value = (local_this)->open_TCP_client_connection(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        if (return_value != (Connection *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ConnectionManager.openTCPClientConnection() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(basic_string< char > const &hostname, int port, int timeout_ms)
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"hostname", (char *)"port", (char *)"timeout_ms", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:openTCPClientConnection", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                PointerTo< Connection > return_value = (local_this)->open_TCP_client_connection(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (return_value != (Connection *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value.p(),Dtool_Connection,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionManager.openTCPClientConnection() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "openTCPClientConnection() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "openTCPClientConnection(non-const ConnectionManager this, const NetAddress address, int timeout_ms)\n"
          "openTCPClientConnection(non-const ConnectionManager this, string hostname, int port, int timeout_ms)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_open_TCP_client_connection_78_comment =
    "C++ Interface:\n"
    "openTCPClientConnection(non-const ConnectionManager this, const NetAddress address, int timeout_ms)\n"
    "openTCPClientConnection(non-const ConnectionManager this, string hostname, int port, int timeout_ms)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_TCP_client_connection\n"
    "//       Access: Public\n"
    "//  Description: Attempts to establish a TCP client connection to a\n"
    "//               server at the indicated address.  If the connection\n"
    "//               is not established within timeout_ms milliseconds, a\n"
    "//               null connection is returned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::open_TCP_client_connection\n"
    "//       Access: Public\n"
    "//  Description: This is a shorthand version of the function to\n"
    "//               directly establish communications to a named host and\n"
    "//               port.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionManager_open_TCP_client_connection_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_close_connection_79(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:closeConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:closeConnection", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "ConnectionManager.closeConnection", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->close_connection(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConnectionManager.closeConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "closeConnection(non-const ConnectionManager this, const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_close_connection_79_comment =
    "C++ Interface:\n"
    "closeConnection(non-const ConnectionManager this, const Connection connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::close_connection\n"
    "//       Access: Public\n"
    "//  Description: Terminates a UDP or TCP socket previously opened.\n"
    "//               This also removes it from any associated\n"
    "//               ConnectionReader or ConnectionListeners.\n"
    "//\n"
    "//               The socket itself may not be immediately closed--it\n"
    "//               will not be closed until all outstanding pointers to\n"
    "//               it are cleared, including any pointers remaining in\n"
    "//               NetDatagrams recently received from the socket.\n"
    "//\n"
    "//               The return value is true if the connection was marked\n"
    "//               to be closed, or false if close_connection() had\n"
    "//               already been called (or the connection did not belong\n"
    "//               to this ConnectionManager).  In neither case can you\n"
    "//               infer anything about whether the connection has\n"
    "//               *actually* been closed yet based on the return value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionManager_close_connection_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static basic_string< char > ConnectionManager::get_host_name(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_get_host_name_80(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static basic_string< char > ConnectionManager::get_host_name(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getHostName", key_word_list))
        {
            basic_string< char > return_value = ConnectionManager::get_host_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHostName()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_get_host_name_80_comment =
    "C++ Interface:\n"
    "getHostName()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionManager::get_host_name\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the name of this particular machine on the\n"
    "//               network, if available, or the empty string if the\n"
    "//               hostname cannot be determined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionManager_get_host_name_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_146(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionManager", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionManager"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionManager *return_value = (QueuedConnectionManager *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionManager,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionManager.downcastToQueuedConnectionManager() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionManager(non-const ConnectionManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_146_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionManager(non-const ConnectionManager this)\n"
    "\n"
    "downcast from ConnectionManager to QueuedConnectionManager\n"
    "";
#else
static const char * Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionManager::ConnectionManager(void)
 *******************************************************************/
int  Dtool_Init_ConnectionManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ConnectionManager::ConnectionManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":ConnectionManager", key_word_list))
        {
            ConnectionManager *return_value = new ConnectionManager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ConnectionManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConnectionManager()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConnectionManager)
    {
        printf("ConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConnectionManager * local_this = (ConnectionManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConnectionManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConnectionManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConnectionManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConnectionWriter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ConnectionWriter::set_max_queue_size(int max_size)
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_set_max_queue_size_84(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionWriter::set_max_queue_size(int max_size)
        int param1;
        static char * key_word_list[] = {(char *)"max_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxQueueSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxQueueSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_queue_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionWriter.setMaxQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxQueueSize(non-const ConnectionWriter this, int max_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_set_max_queue_size_84_comment =
    "C++ Interface:\n"
    "setMaxQueueSize(non-const ConnectionWriter this, int max_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::set_max_queue_size\n"
    "//       Access: Public\n"
    "//  Description: Limits the number of packets that may be pending on\n"
    "//               the outbound queue.  This only has an effect when\n"
    "//               using threads; if num_threads is 0, then all packets\n"
    "//               are sent immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_set_max_queue_size_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionWriter::get_max_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_max_queue_size_85(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionWriter::get_max_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionWriter*)local_this)->get_max_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxQueueSize(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_max_queue_size_85_comment =
    "C++ Interface:\n"
    "getMaxQueueSize(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_max_queue_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the maximum size the queue is allowed to grow\n"
    "//               to.  See set_max_queue_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_max_queue_size_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionWriter::get_current_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_current_queue_size_86(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionWriter::get_current_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionWriter*)local_this)->get_current_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentQueueSize(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_current_queue_size_86_comment =
    "C++ Interface:\n"
    "getCurrentQueueSize(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_current_queue_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the current number of things in the queue.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_current_queue_size_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block)
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = (0))
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block)
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = (0))
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_send_87(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"datagram", (char *)"connection", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:send", key_word_list, &param1, &param2))
                {
                    Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
Connection *param2_this = (Connection *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Connection, 2, "ConnectionWriter.send", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->send(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ConnectionWriter.send() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = (0))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"datagram", (char *)"connection", (char *)"address", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:send", key_word_list, &param1, &param2, &param3))
                {
                    Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
Connection *param2_this = (Connection *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Connection, 2, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
NetAddress *param3_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NetAddress, 3, "ConnectionWriter.send", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->send(*param1_this, param2_this, *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"datagram", (char *)"connection", (char *)"block", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:send", key_word_list, &param1, &param2, &param3))
                {
                    Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
Connection *param2_this = (Connection *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Connection, 2, "ConnectionWriter.send", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->send(*param1_this, param2_this, (PyObject_IsTrue(param3)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"datagram", (char *)"connection", (char *)"address", (char *)"block", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:send", key_word_list, &param1, &param2, &param3, &param4))
                {
                    Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
Connection *param2_this = (Connection *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Connection, 2, "ConnectionWriter.send", 1, coerced_ptr, report_errors);
NetAddress *param3_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NetAddress, 3, "ConnectionWriter.send", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = (local_this)->send(*param1_this, param2_this, *param3_this, (PyObject_IsTrue(param4)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ConnectionWriter.send() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "send() takes 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection)\n"
          "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, const NetAddress address)\n"
          "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, bool block)\n"
          "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_send_87_comment =
    "C++ Interface:\n"
    "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection)\n"
    "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, const NetAddress address)\n"
    "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, bool block)\n"
    "send(non-const ConnectionWriter this, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::send\n"
    "//       Access: Public\n"
    "//  Description: Enqueues a datagram for transmittal on the indicated\n"
    "//               socket.  Since the host address is not specified with\n"
    "//               this form, this function should only be used for\n"
    "//               sending TCP packets.  Use the other send() method for\n"
    "//               sending UDP packets.\n"
    "//\n"
    "//               Returns true if successful, false if there was an\n"
    "//               error.  In the normal, threaded case, this function\n"
    "//               only returns false if the send queue is filled; it's\n"
    "//               impossible to detect a transmission error at this\n"
    "//               point.\n"
    "//\n"
    "//               If block is true, this will not return false if the\n"
    "//               send queue is filled; instead, it will wait until\n"
    "//               there is space available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::send\n"
    "//       Access: Public\n"
    "//  Description: Enqueues a datagram for transmittal on the indicated\n"
    "//               socket.  This form of the function allows the\n"
    "//               specification of a destination host address, and so\n"
    "//               is appropriate for UDP packets.  Use the other send()\n"
    "//               method for sending TCP packets.\n"
    "//\n"
    "//               Returns true if successful, false if there was an\n"
    "//               error.  In the normal, threaded case, this function\n"
    "//               only returns false if the send queue is filled; it's\n"
    "//               impossible to detect a transmission error at this\n"
    "//               point.\n"
    "//\n"
    "//               If block is true, this will not return false if the\n"
    "//               send queue is filled; instead, it will wait until\n"
    "//               there is space available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_send_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_is_valid_for_udp_88(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"datagram", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isValidForUdp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isValidForUdp", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "ConnectionWriter.isValidForUdp", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const ConnectionWriter*)local_this)->is_valid_for_udp(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValidForUdp(const ConnectionWriter this, const Datagram datagram)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_is_valid_for_udp_88_comment =
    "C++ Interface:\n"
    "isValidForUdp(const ConnectionWriter this, const Datagram datagram)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::is_valid_for_udp\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the datagram is small enough to be\n"
    "//               sent over a UDP packet, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_is_valid_for_udp_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionManager *ConnectionWriter::get_manager(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_manager_89(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ConnectionManager *ConnectionWriter::get_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManager", key_word_list));
        else
            (PyArg_Parse(args, ":getManager"));
        if(!PyErr_Occurred())
        {
            ConnectionManager *return_value = ((const ConnectionWriter*)local_this)->get_manager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManager(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_manager_89_comment =
    "C++ Interface:\n"
    "getManager(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_manager\n"
    "//       Access: Public\n"
    "//  Description: Returns a pointer to the ConnectionManager object\n"
    "//               that serves this ConnectionWriter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_manager_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionWriter::is_immediate(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_is_immediate_90(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ConnectionWriter::is_immediate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isImmediate", key_word_list));
        else
            (PyArg_Parse(args, ":isImmediate"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConnectionWriter*)local_this)->is_immediate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isImmediate(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_is_immediate_90_comment =
    "C++ Interface:\n"
    "isImmediate(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::is_immediate\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the writer is an immediate writer,\n"
    "//               i.e. it has no threads.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_is_immediate_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionWriter::get_num_threads(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_num_threads_91(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionWriter::get_num_threads(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumThreads", key_word_list));
        else
            (PyArg_Parse(args, ":getNumThreads"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionWriter*)local_this)->get_num_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumThreads(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_num_threads_91_comment =
    "C++ Interface:\n"
    "getNumThreads(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_num_threads\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of threads the ConnectionWriter\n"
    "//               has been created with.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_num_threads_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionWriter::set_raw_mode(bool mode)
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_set_raw_mode_92(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionWriter::set_raw_mode(bool mode)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRawMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRawMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_raw_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionWriter.setRawMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRawMode(non-const ConnectionWriter this, bool mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_set_raw_mode_92_comment =
    "C++ Interface:\n"
    "setRawMode(non-const ConnectionWriter this, bool mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::set_raw_mode\n"
    "//       Access: Public\n"
    "//  Description: Sets the ConnectionWriter into raw mode (or turns off\n"
    "//               raw mode).  In raw mode, datagrams are not sent along\n"
    "//               with their headers; the bytes in the datagram are\n"
    "//               simply sent down the pipe.\n"
    "//\n"
    "//               Setting the ConnectionWriter to raw mode must be done\n"
    "//               with care.  This can only be done when the matching\n"
    "//               ConnectionReader is also set to raw mode, or when the\n"
    "//               ConnectionWriter is communicating to a process that\n"
    "//               does not expect datagrams.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_set_raw_mode_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ConnectionWriter::get_raw_mode(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_raw_mode_93(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ConnectionWriter::get_raw_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRawMode", key_word_list));
        else
            (PyArg_Parse(args, ":getRawMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ConnectionWriter*)local_this)->get_raw_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRawMode(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_raw_mode_93_comment =
    "C++ Interface:\n"
    "getRawMode(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_raw_mode\n"
    "//       Access: Public\n"
    "//  Description: Returns the current setting of the raw mode flag.\n"
    "//               See set_raw_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_raw_mode_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_set_tcp_header_size_94(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionWriter.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const ConnectionWriter this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_set_tcp_header_size_94_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const ConnectionWriter this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::set_tcp_header_size\n"
    "//       Access: Public\n"
    "//  Description: Sets the header size of TCP packets.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_set_tcp_header_size_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ConnectionWriter::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_get_tcp_header_size_95(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ConnectionWriter::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConnectionWriter*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_get_tcp_header_size_95_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::get_tcp_header_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the current setting of TCP header size.\n"
    "//               See set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_get_tcp_header_size_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConnectionWriter::shutdown(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_shutdown_96(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ConnectionWriter::shutdown(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":shutdown", key_word_list));
        else
            (PyArg_Parse(args, ":shutdown"));
        if(!PyErr_Occurred())
        {
            (local_this)->shutdown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionWriter.shutdown() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shutdown(non-const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_shutdown_96_comment =
    "C++ Interface:\n"
    "shutdown(non-const ConnectionWriter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConnectionWriter::shutdown\n"
    "//       Access: Published\n"
    "//  Description: Stops all the threads and cleans them up.  This is\n"
    "//               called automatically by the destructor, but it may be\n"
    "//               called explicitly before destruction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConnectionWriter_shutdown_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void)
 *******************************************************************/
static PyObject *Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_121(PyObject *self, PyObject *args,PyObject *kwds) {
    ConnectionWriter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConnectionWriter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDatagramSinkNet", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDatagramSinkNet"));
        if(!PyErr_Occurred())
        {
            DatagramSinkNet *return_value = (DatagramSinkNet *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramSinkNet,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConnectionWriter.downcastToDatagramSinkNet() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDatagramSinkNet(non-const ConnectionWriter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_121_comment =
    "C++ Interface:\n"
    "downcastToDatagramSinkNet(non-const ConnectionWriter this)\n"
    "\n"
    "downcast from ConnectionWriter to DatagramSinkNet\n"
    "";
#else
static const char * Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, basic_string< char > const &thread_name)
 * ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, basic_string< char > const &thread_name = ((string())))
 *******************************************************************/
int  Dtool_Init_ConnectionWriter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, basic_string< char > const &thread_name = ((string())))
                PyObject *param0;
                int param1;
                static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:ConnectionWriter", key_word_list, &param0, &param1))
                {
                    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConnectionWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, basic_string< char > const &thread_name)
                PyObject *param0;
                int param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", (char *)"thread_name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Ois#:ConnectionWriter", key_word_list, &param0, &param1, &param2_str, &param2_len))
                {
                    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ConnectionWriter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ConnectionWriter() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ConnectionWriter(non-const ConnectionManager manager, int num_threads)\n"
          "ConnectionWriter(non-const ConnectionManager manager, int num_threads, string thread_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConnectionWriter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConnectionWriter)
    {
        printf("ConnectionWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConnectionWriter * local_this = (ConnectionWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConnectionWriter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConnectionWriter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConnectionWriter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DatagramGeneratorNet 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_get_datagram_113(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "DatagramGeneratorNet.getDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramGeneratorNet.getDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDatagram(non-const DatagramGeneratorNet this, non-const Datagram data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_get_datagram_113_comment =
    "C++ Interface:\n"
    "getDatagram(non-const DatagramGeneratorNet this, non-const Datagram data)\n"
    "\n"
    "// Inherited from DatagramGenerator\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramGeneratorNet::get_datagram\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Reads the next datagram from the stream.  Blocks\n"
    "//               until a datagram is available.  Returns true on\n"
    "//               success, false on stream closed or error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_get_datagram_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGeneratorNet::is_eof(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_is_eof_114(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramGeneratorNet::is_eof(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEof", key_word_list));
        else
            (PyArg_Parse(args, ":isEof"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_eof();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGeneratorNet.isEof() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEof(non-const DatagramGeneratorNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_is_eof_114_comment =
    "C++ Interface:\n"
    "isEof(non-const DatagramGeneratorNet this)\n"
    "\n"
    "// Inherited from DatagramGenerator\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramGeneratorNet::is_eof\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if the stream has been closed normally.\n"
    "//               This test may only be made after a call to\n"
    "//               get_datagram() has failed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_is_eof_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramGeneratorNet::is_error(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_is_error_115(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramGeneratorNet::is_error(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGeneratorNet.isError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(non-const DatagramGeneratorNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_is_error_115_comment =
    "C++ Interface:\n"
    "isError(non-const DatagramGeneratorNet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramGeneratorNet::is_error\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if the stream has an error condition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_is_error_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_99(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDatagramGenerator", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDatagramGenerator"));
        if(!PyErr_Occurred())
        {
            DatagramGenerator *return_value = (DatagramGenerator *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramGenerator,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGeneratorNet.upcastToDatagramGenerator() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDatagramGenerator(non-const DatagramGeneratorNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_99_comment =
    "C++ Interface:\n"
    "upcastToDatagramGenerator(non-const DatagramGeneratorNet this)\n"
    "\n"
    "upcast from DatagramGeneratorNet to DatagramGenerator\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_101(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConnectionReader", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConnectionReader"));
        if(!PyErr_Occurred())
        {
            ConnectionReader *return_value = (ConnectionReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGeneratorNet.upcastToConnectionReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConnectionReader(non-const DatagramGeneratorNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_101_comment =
    "C++ Interface:\n"
    "upcastToConnectionReader(non-const DatagramGeneratorNet this)\n"
    "\n"
    "upcast from DatagramGeneratorNet to ConnectionReader\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
 *******************************************************************/
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_109(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramGeneratorNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramGeneratorNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToQueuedReturnDatagram", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToQueuedReturnDatagram"));
        if(!PyErr_Occurred())
        {
            QueuedReturn< Datagram > *return_value = (QueuedReturn< Datagram > *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedReturn_Datagram,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramGeneratorNet.upcastToQueuedReturnDatagram() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToQueuedReturnDatagram(non-const DatagramGeneratorNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_109_comment =
    "C++ Interface:\n"
    "upcastToQueuedReturnDatagram(non-const DatagramGeneratorNet this)\n"
    "\n"
    "upcast from DatagramGeneratorNet to QueuedReturn< Datagram >\n"
    "";
#else
static const char * Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
 *******************************************************************/
int  Dtool_Init_DatagramGeneratorNet(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
            PyObject *param0;
            int param1;
            static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:DatagramGeneratorNet", key_word_list, &param0, &param1))
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "DatagramGeneratorNet.DatagramGeneratorNet", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    DatagramGeneratorNet *return_value = new DatagramGeneratorNet(param0_this, (int)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramGeneratorNet,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DatagramGeneratorNet(non-const ConnectionManager manager, int num_threads)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DatagramGeneratorNet(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DatagramGeneratorNet)
    {
        printf("DatagramGeneratorNet ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DatagramGeneratorNet * local_this = (DatagramGeneratorNet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DatagramGeneratorNet)
        return local_this;
    if(requested_type == &Dtool_ConnectionReader)
        return ( ConnectionReader *) local_this;
    if(requested_type == &Dtool_DatagramGenerator)
        return ( DatagramGenerator *) local_this;
    if(requested_type == &Dtool_QueuedReturn_Datagram)
        return ( QueuedReturn< Datagram > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DatagramGeneratorNet(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DatagramGeneratorNet)
        return from_this;
    if(from_type == &Dtool_ConnectionReader)
    {
          ConnectionReader* other_this = (ConnectionReader*)from_this;
          return (DatagramGeneratorNet*)other_this;
    }
    if(from_type == &Dtool_DatagramGenerator)
    {
          DatagramGenerator* other_this = (DatagramGenerator*)from_this;
          return (DatagramGeneratorNet*)other_this;
    }
    if(from_type == &Dtool_QueuedReturn_Datagram)
    {
          QueuedReturn< Datagram >* other_this = (QueuedReturn< Datagram >*)from_this;
          return (DatagramGeneratorNet*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedReturn< Datagram > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< Datagram >::set_max_queue_size(int max_size)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_set_max_queue_size_104(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< Datagram >::set_max_queue_size(int max_size)
        int param1;
        static char * key_word_list[] = {(char *)"max_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxQueueSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxQueueSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_queue_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.setMaxQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_set_max_queue_size_104_comment =
    "C++ Interface:\n"
    "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_set_max_queue_size_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< Datagram >::get_max_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_get_max_queue_size_105(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< Datagram >::get_max_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< Datagram >*)local_this)->get_max_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_get_max_queue_size_105_comment =
    "C++ Interface:\n"
    "getMaxQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_get_max_queue_size_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< Datagram >::get_current_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_get_current_queue_size_106(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< Datagram >::get_current_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< Datagram >*)local_this)->get_current_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_get_current_queue_size_106_comment =
    "C++ Interface:\n"
    "getCurrentQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_get_current_queue_size_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ::QueuedReturn< Datagram >::get_overflow_flag(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_get_overflow_flag_107(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ::QueuedReturn< Datagram >::get_overflow_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const QueuedReturn< Datagram >*)local_this)->get_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowFlag(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_get_overflow_flag_107_comment =
    "C++ Interface:\n"
    "getOverflowFlag(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_get_overflow_flag_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< Datagram >::reset_overflow_flag(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_reset_overflow_flag_108(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< Datagram >::reset_overflow_flag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":resetOverflowFlag"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.resetOverflowFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOverflowFlag(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_reset_overflow_flag_108_comment =
    "C++ Interface:\n"
    "resetOverflowFlag(non-const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_reset_overflow_flag_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramGeneratorNet *::QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_110(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< Datagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_Datagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DatagramGeneratorNet *::QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDatagramGeneratorNet", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDatagramGeneratorNet"));
        if(!PyErr_Occurred())
        {
            DatagramGeneratorNet *return_value = (DatagramGeneratorNet *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramGeneratorNet,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.downcastToDatagramGeneratorNet() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDatagramGeneratorNet(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_110_comment =
    "C++ Interface:\n"
    "downcastToDatagramGeneratorNet(non-const QueuedReturn this)\n"
    "\n"
    "downcast from QueuedReturn< Datagram > to DatagramGeneratorNet\n"
    "";
#else
static const char * Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_110_comment = NULL;
#endif

int  Dtool_Init_QueuedReturn_Datagram(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (QueuedReturn< Datagram >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_QueuedReturn_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedReturn_Datagram)
    {
        printf("QueuedReturn_Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedReturn< Datagram > * local_this = (QueuedReturn< Datagram > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedReturn_Datagram)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedReturn_Datagram(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedReturn_Datagram)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DatagramSinkNet 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DatagramSinkNet::set_target(Connection *connection)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_set_target_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DatagramSinkNet::set_target(Connection *connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTarget", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTarget", &param1));
            if(!PyErr_Occurred())
            {
                Connection *param1_this = (Connection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Connection, 1, "DatagramSinkNet.setTarget", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_target(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramSinkNet.setTarget() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTarget(non-const DatagramSinkNet this, non-const Connection connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_set_target_123_comment =
    "C++ Interface:\n"
    "setTarget(non-const DatagramSinkNet this, non-const Connection connection)\n"
    "\n"
    "// Filename: datagramSinkNet.I\n"
    "// Created by:  drose (15Feb09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramSinkNet::set_target\n"
    "//       Access: Published\n"
    "//  Description: Specifies the Connection that will receive all future\n"
    "//               Datagrams sent.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_set_target_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Connection *DatagramSinkNet::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_get_target_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Connection *DatagramSinkNet::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            Connection *return_value = ((const DatagramSinkNet*)local_this)->get_target();
            if (return_value != (Connection *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Connection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const DatagramSinkNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_get_target_124_comment =
    "C++ Interface:\n"
    "getTarget(const DatagramSinkNet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramSinkNet::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the current target Connection, or NULL if the\n"
    "//               target has not yet been set.  See set_target().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_get_target_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_put_datagram_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:putDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:putDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "DatagramSinkNet.putDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->put_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DatagramSinkNet.putDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "putDatagram(non-const DatagramSinkNet this, const Datagram data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_put_datagram_125_comment =
    "C++ Interface:\n"
    "putDatagram(non-const DatagramSinkNet this, const Datagram data)\n"
    "\n"
    "// Inherited from DatagramSink\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramSinkNet::put_datagram\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Sends the given datagram to the target.  Returns true\n"
    "//               on success, false if there is an error.  Blocks if\n"
    "//               necessary until the target is ready.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_put_datagram_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DatagramSinkNet::is_error(void)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_is_error_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool DatagramSinkNet::is_error(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isError", key_word_list));
        else
            (PyArg_Parse(args, ":isError"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSinkNet.isError() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isError(non-const DatagramSinkNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_is_error_126_comment =
    "C++ Interface:\n"
    "isError(non-const DatagramSinkNet this)\n"
    "\n"
    "// Inherited from DatagramSink\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramSinkNet::is_error\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns true if there is an error on the target\n"
    "//               connection, or if the target has never been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_is_error_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DatagramSinkNet::flush(void)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_flush_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void DatagramSinkNet::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSinkNet.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const DatagramSinkNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_flush_127_comment =
    "C++ Interface:\n"
    "flush(non-const DatagramSinkNet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DatagramSinkNet::flush\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Ensures that all datagrams previously written will be\n"
    "//               visible on the stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_flush_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_upcast_to_DatagramSink_118(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDatagramSink", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDatagramSink"));
        if(!PyErr_Occurred())
        {
            DatagramSink *return_value = (DatagramSink *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DatagramSink,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSinkNet.upcastToDatagramSink() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDatagramSink(non-const DatagramSinkNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_upcast_to_DatagramSink_118_comment =
    "C++ Interface:\n"
    "upcastToDatagramSink(non-const DatagramSinkNet this)\n"
    "\n"
    "upcast from DatagramSinkNet to DatagramSink\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_upcast_to_DatagramSink_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
 *******************************************************************/
static PyObject *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_120(PyObject *self, PyObject *args,PyObject *kwds) {
    DatagramSinkNet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DatagramSinkNet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConnectionWriter", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConnectionWriter"));
        if(!PyErr_Occurred())
        {
            ConnectionWriter *return_value = (ConnectionWriter *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionWriter,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DatagramSinkNet.upcastToConnectionWriter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConnectionWriter(non-const DatagramSinkNet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_120_comment =
    "C++ Interface:\n"
    "upcastToConnectionWriter(non-const DatagramSinkNet this)\n"
    "\n"
    "upcast from DatagramSinkNet to ConnectionWriter\n"
    "";
#else
static const char * Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
 *******************************************************************/
int  Dtool_Init_DatagramSinkNet(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
            PyObject *param0;
            int param1;
            static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:DatagramSinkNet", key_word_list, &param0, &param1))
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "DatagramSinkNet.DatagramSinkNet", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    DatagramSinkNet *return_value = new DatagramSinkNet(param0_this, (int)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DatagramSinkNet,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DatagramSinkNet(non-const ConnectionManager manager, int num_threads)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DatagramSinkNet(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DatagramSinkNet)
    {
        printf("DatagramSinkNet ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DatagramSinkNet * local_this = (DatagramSinkNet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DatagramSinkNet)
        return local_this;
    if(requested_type == &Dtool_ConnectionWriter)
        return ( ConnectionWriter *) local_this;
    if(requested_type == &Dtool_DatagramSink)
        return ( DatagramSink *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DatagramSinkNet(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DatagramSinkNet)
        return from_this;
    if(from_type == &Dtool_ConnectionWriter)
    {
          ConnectionWriter* other_this = (ConnectionWriter*)from_this;
          return (DatagramSinkNet*)other_this;
    }
    if(from_type == &Dtool_DatagramSink)
    {
          DatagramSink* other_this = (DatagramSink*)from_this;
          return (DatagramSinkNet*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedConnectionListener 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionListener::new_connection_available(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionListener_new_connection_available_142(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionListener * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionListener,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool QueuedConnectionListener::new_connection_available(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":newConnectionAvailable", key_word_list));
        else
            (PyArg_Parse(args, ":newConnectionAvailable"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->new_connection_available();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionListener.newConnectionAvailable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "newConnectionAvailable(non-const QueuedConnectionListener this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionListener_new_connection_available_142_comment =
    "C++ Interface:\n"
    "newConnectionAvailable(non-const QueuedConnectionListener this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionListener::new_connection_available\n"
    "//       Access: Public\n"
    "//  Description: Returns true if a new connection was recently\n"
    "//               established; the connection information may then be\n"
    "//               retrieved via get_new_connection().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionListener_new_connection_available_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionListener_get_new_connection_143(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionListener * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionListener,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"new_connection", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNewConnection", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getNewConnection", &param1));
                if(!PyErr_Occurred())
                {
                    PointerTo< Connection > *param1_this = (PointerTo< Connection > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PointerTo_Connection, 1, "QueuedConnectionListener.getNewConnection", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->get_new_connection(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call QueuedConnectionListener.getNewConnection() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"rendezvous", (char *)"address", (char *)"new_connection", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:getNewConnection", key_word_list, &param1, &param2, &param3))
                {
                    PointerTo< Connection > *param1_this = (PointerTo< Connection > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PointerTo_Connection, 1, "QueuedConnectionListener.getNewConnection", 0, coerced_ptr, report_errors);
NetAddress *param2_this = (NetAddress *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NetAddress, 2, "QueuedConnectionListener.getNewConnection", 0, coerced_ptr, report_errors);
PointerTo< Connection > *param3_this = (PointerTo< Connection > *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PointerTo_Connection, 3, "QueuedConnectionListener.getNewConnection", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = (local_this)->get_new_connection(*param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call QueuedConnectionListener.getNewConnection() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNewConnection() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNewConnection(non-const QueuedConnectionListener this, non-const PointerTo new_connection)\n"
          "getNewConnection(non-const QueuedConnectionListener this, non-const PointerTo rendezvous, non-const NetAddress address, non-const PointerTo new_connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionListener_get_new_connection_143_comment =
    "C++ Interface:\n"
    "getNewConnection(non-const QueuedConnectionListener this, non-const PointerTo new_connection)\n"
    "getNewConnection(non-const QueuedConnectionListener this, non-const PointerTo rendezvous, non-const NetAddress address, non-const PointerTo new_connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionListener::get_new_connection\n"
    "//       Access: Public\n"
    "//  Description: If a previous call to new_connection_available()\n"
    "//               returned true, this function will return information\n"
    "//               about the newly established connection.\n"
    "//\n"
    "//               The rendezvous parameter is the particular rendezvous\n"
    "//               socket this new connection originally communicated\n"
    "//               with; it is provided in case the ConnectionListener\n"
    "//               was monitorind more than one and you care which one\n"
    "//               it was.  The address parameter is the net address of\n"
    "//               the new client, and new_connection is the socket of\n"
    "//               the newly established connection.\n"
    "//\n"
    "//               The return value is true if a connection was\n"
    "//               successfully returned, or false if there was, in\n"
    "//               fact, no new connection.  (This may happen if there\n"
    "//               are multiple threads accessing the\n"
    "//               QueuedConnectionListener).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionListener::get_new_connection\n"
    "//       Access: Public\n"
    "//  Description: This flavor of get_new_connection() simply returns a\n"
    "//               new connection, assuming the user doesn't care about\n"
    "//               the rendezvous socket that originated it or the\n"
    "//               address it came from.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionListener_get_new_connection_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_130(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionListener * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionListener,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConnectionListener", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConnectionListener"));
        if(!PyErr_Occurred())
        {
            ConnectionListener *return_value = (ConnectionListener *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionListener,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionListener.upcastToConnectionListener() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConnectionListener(non-const QueuedConnectionListener this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_130_comment =
    "C++ Interface:\n"
    "upcastToConnectionListener(non-const QueuedConnectionListener this)\n"
    "\n"
    "upcast from QueuedConnectionListener to ConnectionListener\n"
    "";
#else
static const char * Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_138(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionListener * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionListener,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToQueuedReturnConnectionListenerData", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToQueuedReturnConnectionListenerData"));
        if(!PyErr_Occurred())
        {
            QueuedReturn< ConnectionListenerData > *return_value = (QueuedReturn< ConnectionListenerData > *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedReturn_ConnectionListenerData,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionListener.upcastToQueuedReturnConnectionListenerData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToQueuedReturnConnectionListenerData(non-const QueuedConnectionListener this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_138_comment =
    "C++ Interface:\n"
    "upcastToQueuedReturnConnectionListenerData(non-const QueuedConnectionListener this)\n"
    "\n"
    "upcast from QueuedConnectionListener to QueuedReturn< ConnectionListenerData >\n"
    "";
#else
static const char * Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
 *******************************************************************/
int  Dtool_Init_QueuedConnectionListener(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
            PyObject *param0;
            int param1;
            static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:QueuedConnectionListener", key_word_list, &param0, &param1))
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "QueuedConnectionListener.QueuedConnectionListener", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    QueuedConnectionListener *return_value = new QueuedConnectionListener(param0_this, (int)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_QueuedConnectionListener,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "QueuedConnectionListener(non-const ConnectionManager manager, int num_threads)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_QueuedConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedConnectionListener)
    {
        printf("QueuedConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedConnectionListener * local_this = (QueuedConnectionListener *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedConnectionListener)
        return local_this;
    if(requested_type == &Dtool_ConnectionListener)
        return ( ConnectionListener *) local_this;
    if(requested_type == &Dtool_ConnectionReader)
        return ( ConnectionReader *)( ConnectionListener *) local_this;
    if(requested_type == &Dtool_QueuedReturn_ConnectionListenerData)
        return ( QueuedReturn< ConnectionListenerData > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedConnectionListener(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedConnectionListener)
        return from_this;
    if(from_type == &Dtool_ConnectionListener)
    {
          ConnectionListener* other_this = (ConnectionListener*)from_this;
          return (QueuedConnectionListener*)other_this;
    }
    if(from_type == &Dtool_ConnectionReader)
    {
          ConnectionReader* other_this = (ConnectionReader*)from_this;
          return (QueuedConnectionListener*)other_this;
    }
    if(from_type == &Dtool_QueuedReturn_ConnectionListenerData)
    {
          QueuedReturn< ConnectionListenerData >* other_this = (QueuedReturn< ConnectionListenerData >*)from_this;
          return (QueuedConnectionListener*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedReturn< ConnectionListenerData > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_133(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
        int param1;
        static char * key_word_list[] = {(char *)"max_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxQueueSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxQueueSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_queue_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.setMaxQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_133_comment =
    "C++ Interface:\n"
    "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_134(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< ConnectionListenerData >*)local_this)->get_max_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_134_comment =
    "C++ Interface:\n"
    "getMaxQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_135(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< ConnectionListenerData >*)local_this)->get_current_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_135_comment =
    "C++ Interface:\n"
    "getCurrentQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ::QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_136(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ::QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const QueuedReturn< ConnectionListenerData >*)local_this)->get_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowFlag(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_136_comment =
    "C++ Interface:\n"
    "getOverflowFlag(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_137(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":resetOverflowFlag"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.resetOverflowFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOverflowFlag(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_137_comment =
    "C++ Interface:\n"
    "resetOverflowFlag(non-const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionListener *::QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_139(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< ConnectionListenerData > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_ConnectionListenerData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionListener *::QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionListener", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionListener"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionListener *return_value = (QueuedConnectionListener *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionListener,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.downcastToQueuedConnectionListener() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionListener(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_139_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionListener(non-const QueuedReturn this)\n"
    "\n"
    "downcast from QueuedReturn< ConnectionListenerData > to QueuedConnectionListener\n"
    "";
#else
static const char * Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_139_comment = NULL;
#endif

int  Dtool_Init_QueuedReturn_ConnectionListenerData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (QueuedReturn< ConnectionListenerData >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_QueuedReturn_ConnectionListenerData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedReturn_ConnectionListenerData)
    {
        printf("QueuedReturn_ConnectionListenerData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedReturn< ConnectionListenerData > * local_this = (QueuedReturn< ConnectionListenerData > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedReturn_ConnectionListenerData)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedReturn_ConnectionListenerData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedReturn_ConnectionListenerData)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedConnectionManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionManager::reset_connection_available(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionManager_reset_connection_available_157(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool QueuedConnectionManager::reset_connection_available(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetConnectionAvailable", key_word_list));
        else
            (PyArg_Parse(args, ":resetConnectionAvailable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const QueuedConnectionManager*)local_this)->reset_connection_available();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetConnectionAvailable(const QueuedConnectionManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionManager_reset_connection_available_157_comment =
    "C++ Interface:\n"
    "resetConnectionAvailable(const QueuedConnectionManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionManager::reset_connection_available\n"
    "//       Access: Public\n"
    "//  Description: Returns true if one of the readers/writers/listeners\n"
    "//               reported a connection reset recently.  If so, the\n"
    "//               particular connection that has been reset can be\n"
    "//               extracted via get_reset_connection().\n"
    "//\n"
    "//               Only connections which were externally reset are\n"
    "//               certain to appear in this list.  Those which were\n"
    "//               explicitly closed via a call to close_connection()\n"
    "//               may or may not be reported.  Furthermore, it is the\n"
    "//               responsibility of the caller to subsequently call\n"
    "//               close_connection() with any connection reported reset\n"
    "//               by this call.  (There is no harm in calling\n"
    "//               close_connection() more than once on a given socket.)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionManager_reset_connection_available_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionManager_get_reset_connection_158(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"connection", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getResetConnection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getResetConnection", &param1));
            if(!PyErr_Occurred())
            {
                PointerTo< Connection > *param1_this = (PointerTo< Connection > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PointerTo_Connection, 1, "QueuedConnectionManager.getResetConnection", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_reset_connection(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call QueuedConnectionManager.getResetConnection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getResetConnection(non-const QueuedConnectionManager this, non-const PointerTo connection)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionManager_get_reset_connection_158_comment =
    "C++ Interface:\n"
    "getResetConnection(non-const QueuedConnectionManager this, non-const PointerTo connection)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionManager::get_reset_connection\n"
    "//       Access: Public\n"
    "//  Description: If a previous call to reset_connection_available()\n"
    "//               returned true, this function will return information\n"
    "//               about the newly reset connection.\n"
    "//\n"
    "//               Only connections which were externally reset are\n"
    "//               certain to appear in this list.  Those which were\n"
    "//               explicitly closed via a call to close_connection()\n"
    "//               may or may not be reported.  Furthermore, it is the\n"
    "//               responsibility of the caller to subsequently call\n"
    "//               close_connection() with any connection reported reset\n"
    "//               by this call.  (There is no harm in calling\n"
    "//               close_connection() more than once on a given socket.)\n"
    "//\n"
    "//               The return value is true if a connection was\n"
    "//               successfully returned, or false if there was, in\n"
    "//               fact, no reset connection.  (This may happen if\n"
    "//               there are multiple threads accessing the\n"
    "//               QueuedConnectionManager).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionManager_get_reset_connection_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_145(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConnectionManager", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConnectionManager"));
        if(!PyErr_Occurred())
        {
            ConnectionManager *return_value = (ConnectionManager *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionManager,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionManager.upcastToConnectionManager() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConnectionManager(non-const QueuedConnectionManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_145_comment =
    "C++ Interface:\n"
    "upcastToConnectionManager(non-const QueuedConnectionManager this)\n"
    "\n"
    "upcast from QueuedConnectionManager to ConnectionManager\n"
    "";
#else
static const char * Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_153(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToQueuedReturnPointerToConnection", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToQueuedReturnPointerToConnection"));
        if(!PyErr_Occurred())
        {
            QueuedReturn< PointerTo< Connection > > *return_value = (QueuedReturn< PointerTo< Connection > > *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedReturn_PointerTo_Connection,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionManager.upcastToQueuedReturnPointerToConnection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToQueuedReturnPointerToConnection(non-const QueuedConnectionManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_153_comment =
    "C++ Interface:\n"
    "upcastToQueuedReturnPointerToConnection(non-const QueuedConnectionManager this)\n"
    "\n"
    "upcast from QueuedConnectionManager to QueuedReturn< PointerTo< Connection > >\n"
    "";
#else
static const char * Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionManager::QueuedConnectionManager(void)
 *******************************************************************/
int  Dtool_Init_QueuedConnectionManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-QueuedConnectionManager::QueuedConnectionManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":QueuedConnectionManager", key_word_list))
        {
            QueuedConnectionManager *return_value = new QueuedConnectionManager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_QueuedConnectionManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "QueuedConnectionManager()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_QueuedConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedConnectionManager)
    {
        printf("QueuedConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedConnectionManager * local_this = (QueuedConnectionManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedConnectionManager)
        return local_this;
    if(requested_type == &Dtool_ConnectionManager)
        return ( ConnectionManager *) local_this;
    if(requested_type == &Dtool_QueuedReturn_PointerTo_Connection)
        return ( QueuedReturn< PointerTo< Connection > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedConnectionManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedConnectionManager)
        return from_this;
    if(from_type == &Dtool_ConnectionManager)
    {
          ConnectionManager* other_this = (ConnectionManager*)from_this;
          return (QueuedConnectionManager*)other_this;
    }
    if(from_type == &Dtool_QueuedReturn_PointerTo_Connection)
    {
          QueuedReturn< PointerTo< Connection > >* other_this = (QueuedReturn< PointerTo< Connection > >*)from_this;
          return (QueuedConnectionManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedReturn< PointerTo< Connection > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_148(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
        int param1;
        static char * key_word_list[] = {(char *)"max_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxQueueSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxQueueSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_queue_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.setMaxQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_148_comment =
    "C++ Interface:\n"
    "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_149(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< PointerTo< Connection > >*)local_this)->get_max_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_149_comment =
    "C++ Interface:\n"
    "getMaxQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_150(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< PointerTo< Connection > >*)local_this)->get_current_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_150_comment =
    "C++ Interface:\n"
    "getCurrentQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ::QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_151(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ::QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const QueuedReturn< PointerTo< Connection > >*)local_this)->get_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowFlag(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_151_comment =
    "C++ Interface:\n"
    "getOverflowFlag(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_152(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":resetOverflowFlag"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.resetOverflowFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOverflowFlag(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_152_comment =
    "C++ Interface:\n"
    "resetOverflowFlag(non-const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionManager *::QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_154(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< PointerTo< Connection > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_PointerTo_Connection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionManager *::QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionManager", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionManager"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionManager *return_value = (QueuedConnectionManager *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionManager,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.downcastToQueuedConnectionManager() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionManager(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_154_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionManager(non-const QueuedReturn this)\n"
    "\n"
    "downcast from QueuedReturn< PointerTo< Connection > > to QueuedConnectionManager\n"
    "";
#else
static const char * Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_154_comment = NULL;
#endif

int  Dtool_Init_QueuedReturn_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (QueuedReturn< PointerTo< Connection > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_QueuedReturn_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedReturn_PointerTo_Connection)
    {
        printf("QueuedReturn_PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedReturn< PointerTo< Connection > > * local_this = (QueuedReturn< PointerTo< Connection > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedReturn_PointerTo_Connection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedReturn_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedReturn_PointerTo_Connection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedConnectionReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionReader::data_available(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionReader_data_available_172(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool QueuedConnectionReader::data_available(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":dataAvailable", key_word_list));
        else
            (PyArg_Parse(args, ":dataAvailable"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->data_available();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionReader.dataAvailable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dataAvailable(non-const QueuedConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionReader_data_available_172_comment =
    "C++ Interface:\n"
    "dataAvailable(non-const QueuedConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionReader::data_available\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a datagram is available on the queue;\n"
    "//               call get_data() to extract the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionReader_data_available_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool QueuedConnectionReader::get_data(Datagram &result)
 * bool QueuedConnectionReader::get_data(NetDatagram &result)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionReader_get_data_173(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool QueuedConnectionReader::get_data(NetDatagram &result)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"result", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getData", &param1));
            if(!PyErr_Occurred())
            {
                NetDatagram *param1_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetDatagram, 1, "QueuedConnectionReader.getData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool QueuedConnectionReader::get_data(Datagram &result)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"result", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getData", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "QueuedConnectionReader.getData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(non-const QueuedConnectionReader this, non-const NetDatagram result)\n"
          "getData(non-const QueuedConnectionReader this, non-const Datagram result)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionReader_get_data_173_comment =
    "C++ Interface:\n"
    "getData(non-const QueuedConnectionReader this, non-const NetDatagram result)\n"
    "getData(non-const QueuedConnectionReader this, non-const Datagram result)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionReader::get_data\n"
    "//       Access: Published\n"
    "//  Description: If a previous call to data_available() returned\n"
    "//               true, this function will return the datagram that has\n"
    "//               become available.\n"
    "//\n"
    "//               The return value is true if a datagram was\n"
    "//               successfully returned, or false if there was, in\n"
    "//               fact, no datagram available.  (This may happen if\n"
    "//               there are multiple threads accessing the\n"
    "//               QueuedConnectionReader).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: QueuedConnectionReader::get_data\n"
    "//       Access: Published\n"
    "//  Description: This flavor of QueuedConnectionReader::get_data(),\n"
    "//               works like the other, except that it only fills a\n"
    "//               Datagram object, not a NetDatagram object.  This\n"
    "//               means that the Datagram cannot be queried for its\n"
    "//               source Connection and/or NetAddress, but it is useful\n"
    "//               in all other respects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_QueuedConnectionReader_get_data_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_160(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToConnectionReader", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToConnectionReader"));
        if(!PyErr_Occurred())
        {
            ConnectionReader *return_value = (ConnectionReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionReader.upcastToConnectionReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToConnectionReader(non-const QueuedConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_160_comment =
    "C++ Interface:\n"
    "upcastToConnectionReader(non-const QueuedConnectionReader this)\n"
    "\n"
    "upcast from QueuedConnectionReader to ConnectionReader\n"
    "";
#else
static const char * Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
 *******************************************************************/
static PyObject *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_168(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToQueuedReturnNetDatagram", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToQueuedReturnNetDatagram"));
        if(!PyErr_Occurred())
        {
            QueuedReturn< NetDatagram > *return_value = (QueuedReturn< NetDatagram > *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedReturn_NetDatagram,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedConnectionReader.upcastToQueuedReturnNetDatagram() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToQueuedReturnNetDatagram(non-const QueuedConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_168_comment =
    "C++ Interface:\n"
    "upcastToQueuedReturnNetDatagram(non-const QueuedConnectionReader this)\n"
    "\n"
    "upcast from QueuedConnectionReader to QueuedReturn< NetDatagram >\n"
    "";
#else
static const char * Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
 *******************************************************************/
int  Dtool_Init_QueuedConnectionReader(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
            PyObject *param0;
            int param1;
            static char * key_word_list[] = {(char *)"manager", (char *)"num_threads", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:QueuedConnectionReader", key_word_list, &param0, &param1))
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "QueuedConnectionReader.QueuedConnectionReader", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    QueuedConnectionReader *return_value = new QueuedConnectionReader(param0_this, (int)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_QueuedConnectionReader,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "QueuedConnectionReader(non-const ConnectionManager manager, int num_threads)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_QueuedConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedConnectionReader)
    {
        printf("QueuedConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedConnectionReader * local_this = (QueuedConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedConnectionReader)
        return local_this;
    if(requested_type == &Dtool_ConnectionReader)
        return ( ConnectionReader *) local_this;
    if(requested_type == &Dtool_QueuedReturn_NetDatagram)
        return ( QueuedReturn< NetDatagram > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedConnectionReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedConnectionReader)
        return from_this;
    if(from_type == &Dtool_ConnectionReader)
    {
          ConnectionReader* other_this = (ConnectionReader*)from_this;
          return (QueuedConnectionReader*)other_this;
    }
    if(from_type == &Dtool_QueuedReturn_NetDatagram)
    {
          QueuedReturn< NetDatagram >* other_this = (QueuedReturn< NetDatagram >*)from_this;
          return (QueuedConnectionReader*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. QueuedReturn< NetDatagram > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_163(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
        int param1;
        static char * key_word_list[] = {(char *)"max_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMaxQueueSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMaxQueueSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_queue_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.setMaxQueueSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_set_max_queue_size_163_comment =
    "C++ Interface:\n"
    "setMaxQueueSize(non-const QueuedReturn this, int max_size)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_set_max_queue_size_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< NetDatagram >::get_max_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_164(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< NetDatagram >::get_max_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< NetDatagram >*)local_this)->get_max_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_get_max_queue_size_164_comment =
    "C++ Interface:\n"
    "getMaxQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_get_max_queue_size_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ::QueuedReturn< NetDatagram >::get_current_queue_size(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_165(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ::QueuedReturn< NetDatagram >::get_current_queue_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentQueueSize", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentQueueSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const QueuedReturn< NetDatagram >*)local_this)->get_current_queue_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentQueueSize(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_get_current_queue_size_165_comment =
    "C++ Interface:\n"
    "getCurrentQueueSize(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_get_current_queue_size_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ::QueuedReturn< NetDatagram >::get_overflow_flag(void) const
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_166(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool ::QueuedReturn< NetDatagram >::get_overflow_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getOverflowFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const QueuedReturn< NetDatagram >*)local_this)->get_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowFlag(const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_get_overflow_flag_166_comment =
    "C++ Interface:\n"
    "getOverflowFlag(const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_get_overflow_flag_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::QueuedReturn< NetDatagram >::reset_overflow_flag(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_167(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ::QueuedReturn< NetDatagram >::reset_overflow_flag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetOverflowFlag", key_word_list));
        else
            (PyArg_Parse(args, ":resetOverflowFlag"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_overflow_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.resetOverflowFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOverflowFlag(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_167_comment =
    "C++ Interface:\n"
    "resetOverflowFlag(non-const QueuedReturn this)\n"
    "\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * QueuedConnectionReader *::QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader(void)
 *******************************************************************/
static PyObject *Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_169(PyObject *self, PyObject *args,PyObject *kwds) {
    QueuedReturn< NetDatagram > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_QueuedReturn_NetDatagram,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-QueuedConnectionReader *::QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToQueuedConnectionReader", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToQueuedConnectionReader"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionReader *return_value = (QueuedConnectionReader *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call QueuedReturn.downcastToQueuedConnectionReader() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToQueuedConnectionReader(non-const QueuedReturn this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_169_comment =
    "C++ Interface:\n"
    "downcastToQueuedConnectionReader(non-const QueuedReturn this)\n"
    "\n"
    "downcast from QueuedReturn< NetDatagram > to QueuedConnectionReader\n"
    "";
#else
static const char * Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_169_comment = NULL;
#endif

int  Dtool_Init_QueuedReturn_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (QueuedReturn< NetDatagram >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_QueuedReturn_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_QueuedReturn_NetDatagram)
    {
        printf("QueuedReturn_NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    QueuedReturn< NetDatagram > * local_this = (QueuedReturn< NetDatagram > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_QueuedReturn_NetDatagram)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_QueuedReturn_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_QueuedReturn_NetDatagram)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RecentConnectionReader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool RecentConnectionReader::data_available(void)
 *******************************************************************/
static PyObject *Dtool_RecentConnectionReader_data_available_176(PyObject *self, PyObject *args,PyObject *kwds) {
    RecentConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecentConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool RecentConnectionReader::data_available(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":dataAvailable", key_word_list));
        else
            (PyArg_Parse(args, ":dataAvailable"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->data_available();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RecentConnectionReader.dataAvailable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dataAvailable(non-const RecentConnectionReader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecentConnectionReader_data_available_176_comment =
    "C++ Interface:\n"
    "dataAvailable(non-const RecentConnectionReader this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecentConnectionReader::data_available\n"
    "//       Access: Public\n"
    "//  Description: Returns true if a datagram is available on the queue;\n"
    "//               call get_data() to extract the datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecentConnectionReader_data_available_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool RecentConnectionReader::get_data(Datagram &result)
 * bool RecentConnectionReader::get_data(NetDatagram &result)
 *******************************************************************/
static PyObject *Dtool_RecentConnectionReader_get_data_177(PyObject *self, PyObject *args,PyObject *kwds) {
    RecentConnectionReader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RecentConnectionReader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool RecentConnectionReader::get_data(NetDatagram &result)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"result", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getData", &param1));
            if(!PyErr_Occurred())
            {
                NetDatagram *param1_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NetDatagram, 1, "RecentConnectionReader.getData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool RecentConnectionReader::get_data(Datagram &result)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"result", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getData", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "RecentConnectionReader.getData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->get_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(non-const RecentConnectionReader this, non-const NetDatagram result)\n"
          "getData(non-const RecentConnectionReader this, non-const Datagram result)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RecentConnectionReader_get_data_177_comment =
    "C++ Interface:\n"
    "getData(non-const RecentConnectionReader this, non-const NetDatagram result)\n"
    "getData(non-const RecentConnectionReader this, non-const Datagram result)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecentConnectionReader::get_data\n"
    "//       Access: Public\n"
    "//  Description: If a previous call to data_available() returned\n"
    "//               true, this function will return the datagram that has\n"
    "//               become available.\n"
    "//\n"
    "//               The return value is true if a datagram was\n"
    "//               successfully returned, or false if there was, in\n"
    "//               fact, no datagram available.  (This may happen if\n"
    "//               there are multiple threads accessing the\n"
    "//               RecentConnectionReader).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: RecentConnectionReader::get_data\n"
    "//       Access: Public\n"
    "//  Description: This flavor of RecentConnectionReader::get_data(),\n"
    "//               works like the other, except that it only fills a\n"
    "//               Datagram object, not a NetDatagram object.  This\n"
    "//               means that the Datagram cannot be queried for its\n"
    "//               source Connection and/or NetAddress, but it is useful\n"
    "//               in all other respects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RecentConnectionReader_get_data_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
 *******************************************************************/
int  Dtool_Init_RecentConnectionReader(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:RecentConnectionReader", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:RecentConnectionReader", &param0));
            if(!PyErr_Occurred())
            {
                ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConnectionManager, 0, "RecentConnectionReader.RecentConnectionReader", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    RecentConnectionReader *return_value = new RecentConnectionReader(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_RecentConnectionReader,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "RecentConnectionReader(non-const ConnectionManager manager)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RecentConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RecentConnectionReader)
    {
        printf("RecentConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RecentConnectionReader * local_this = (RecentConnectionReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RecentConnectionReader)
        return local_this;
    if(requested_type == &Dtool_ConnectionReader)
        return ( ConnectionReader *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RecentConnectionReader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RecentConnectionReader)
        return from_this;
    if(from_type == &Dtool_ConnectionReader)
    {
          ConnectionReader* other_this = (ConnectionReader*)from_this;
          return (RecentConnectionReader*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PointerTo_Connection | PointerToConnection
//********************************************************************
PyMethodDef Dtool_Methods_PointerTo_Connection[]= {
  { "p",(PyCFunction ) &Dtool_PointerTo_Connection_p_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerTo_Connection_p_8_comment},
  { "assign",(PyCFunction ) &Dtool_PointerTo_Connection_operator_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerTo_Connection_operator_9_comment},
  { "isNull",(PyCFunction ) &Dtool_PointerTo_Connection_is_null_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerTo_Connection_is_null_10_comment},
  { "clear",(PyCFunction ) &Dtool_PointerTo_Connection_clear_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerTo_Connection_clear_11_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerTo_Connection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_Connection._Dtool_ClassInit(NULL);
        Dtool_PointerTo_Connection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_Connection.As_PyTypeObject());
        Dtool_PointerTo_Connection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerTo_Connection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerTo_Connection.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerTo_Connection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerTo_Connection)");
             printf(" Error In PyType_ReadyPointerTo_Connection");
             return;
        }
        Py_INCREF(&Dtool_PointerTo_Connection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerTo_Connection.As_PyTypeObject().tp_dict,"PointerToConnection",&Dtool_PointerTo_Connection.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerTo_Connection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerTo_Connection.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToConnection",(PyObject *)&Dtool_PointerTo_Connection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_Connection | PointerToBaseConnection
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_Connection[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_Connection_clear_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_Connection_clear_4_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_Connection_output_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_Connection_output_5_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_Connection
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_Connection(PyObject * self)
{
    PointerToBase< Connection > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_Connection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_Connection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_Connection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_Connection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_Connection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_Connection.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_Connection.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_Connection;
        // __str__ Repr Proxy
        Dtool_PointerToBase_Connection.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_Connection;
        if(PyType_Ready(&Dtool_PointerToBase_Connection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_Connection)");
             printf(" Error In PyType_ReadyPointerToBase_Connection");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_Connection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_Connection.As_PyTypeObject().tp_dict,"PointerToBaseConnection",&Dtool_PointerToBase_Connection.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_Connection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_Connection.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseConnection",(PyObject *)&Dtool_PointerToBase_Connection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NetAddress | NetAddress
//********************************************************************
PyMethodDef Dtool_Methods_NetAddress[]= {
  { "setAny",(PyCFunction ) &Dtool_NetAddress_set_any_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_set_any_14_comment},
  { "setLocalhost",(PyCFunction ) &Dtool_NetAddress_set_localhost_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_set_localhost_15_comment},
  { "setHost",(PyCFunction ) &Dtool_NetAddress_set_host_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_set_host_16_comment},
  { "clear",(PyCFunction ) &Dtool_NetAddress_clear_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_clear_17_comment},
  { "getPort",(PyCFunction ) &Dtool_NetAddress_get_port_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_get_port_18_comment},
  { "setPort",(PyCFunction ) &Dtool_NetAddress_set_port_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_set_port_19_comment},
  { "getIpString",(PyCFunction ) &Dtool_NetAddress_get_ip_string_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_get_ip_string_20_comment},
  { "getIp",(PyCFunction ) &Dtool_NetAddress_get_ip_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_get_ip_21_comment},
  { "getIpComponent",(PyCFunction ) &Dtool_NetAddress_get_ip_component_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_get_ip_component_22_comment},
  { "getAddr",(PyCFunction ) &Dtool_NetAddress_get_addr_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_get_addr_23_comment},
  { "output",(PyCFunction ) &Dtool_NetAddress_output_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetAddress_output_24_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     NetAddress
//////////////////
static PyObject *  Dtool_Repr_NetAddress(PyObject * self)
{
    NetAddress * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NetAddress,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_NetAddress(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NetAddress.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NetAddress.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NetAddress.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NetAddress.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_NetAddress.As_PyTypeObject().tp_repr = & Dtool_Repr_NetAddress;
        // __str__ Repr Proxy
        Dtool_NetAddress.As_PyTypeObject().tp_str = & Dtool_Repr_NetAddress;
        if(PyType_Ready(&Dtool_NetAddress.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NetAddress)");
             printf(" Error In PyType_ReadyNetAddress");
             return;
        }
        Py_INCREF(&Dtool_NetAddress.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NetAddress.As_PyTypeObject().tp_dict,"NetAddress",&Dtool_NetAddress.As_PyObject());
        RegisterRuntimeClass(&Dtool_NetAddress,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NetAddress.As_PyTypeObject());
        PyModule_AddObject(module, "NetAddress",(PyObject *)&Dtool_NetAddress.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Connection | Connection
//********************************************************************
PyMethodDef Dtool_Methods_Connection[]= {
  { "getAddress",(PyCFunction ) &Dtool_Connection_get_address_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_get_address_29_comment},
  { "getManager",(PyCFunction ) &Dtool_Connection_get_manager_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_get_manager_30_comment},
  { "getSocket",(PyCFunction ) &Dtool_Connection_get_socket_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_get_socket_31_comment},
  { "setCollectTcp",(PyCFunction ) &Dtool_Connection_set_collect_tcp_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_collect_tcp_32_comment},
  { "getCollectTcp",(PyCFunction ) &Dtool_Connection_get_collect_tcp_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_get_collect_tcp_33_comment},
  { "setCollectTcpInterval",(PyCFunction ) &Dtool_Connection_set_collect_tcp_interval_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_collect_tcp_interval_34_comment},
  { "getCollectTcpInterval",(PyCFunction ) &Dtool_Connection_get_collect_tcp_interval_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_get_collect_tcp_interval_35_comment},
  { "considerFlush",(PyCFunction ) &Dtool_Connection_consider_flush_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_consider_flush_36_comment},
  { "flush",(PyCFunction ) &Dtool_Connection_flush_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_flush_37_comment},
  { "setLinger",(PyCFunction ) &Dtool_Connection_set_linger_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_linger_38_comment},
  { "setReuseAddr",(PyCFunction ) &Dtool_Connection_set_reuse_addr_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_reuse_addr_39_comment},
  { "setKeepAlive",(PyCFunction ) &Dtool_Connection_set_keep_alive_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_keep_alive_40_comment},
  { "setRecvBufferSize",(PyCFunction ) &Dtool_Connection_set_recv_buffer_size_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_recv_buffer_size_41_comment},
  { "setSendBufferSize",(PyCFunction ) &Dtool_Connection_set_send_buffer_size_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_send_buffer_size_42_comment},
  { "setIpTimeToLive",(PyCFunction ) &Dtool_Connection_set_ip_time_to_live_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_ip_time_to_live_43_comment},
  { "setIpTypeOfService",(PyCFunction ) &Dtool_Connection_set_ip_type_of_service_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_ip_type_of_service_44_comment},
  { "setNoDelay",(PyCFunction ) &Dtool_Connection_set_no_delay_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_no_delay_45_comment},
  { "setMaxSegment",(PyCFunction ) &Dtool_Connection_set_max_segment_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Connection_set_max_segment_46_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Connection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Connection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Connection\n"
          "// Description : Represents a single TCP or UDP socket for input or\n"
          "//               output.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Connection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_Connection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Connection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Connection.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Connection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Connection)");
             printf(" Error In PyType_ReadyConnection");
             return;
        }
        Py_INCREF(&Dtool_Connection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Connection.As_PyTypeObject().tp_dict,"Connection",&Dtool_Connection.As_PyObject());
        RegisterRuntimeClass(&Dtool_Connection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Connection.As_PyTypeObject());
        PyModule_AddObject(module, "Connection",(PyObject *)&Dtool_Connection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConnectionReader | ConnectionReader
//********************************************************************
PyMethodDef Dtool_Methods_ConnectionReader[]= {
  { "addConnection",(PyCFunction ) &Dtool_ConnectionReader_add_connection_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_add_connection_49_comment},
  { "removeConnection",(PyCFunction ) &Dtool_ConnectionReader_remove_connection_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_remove_connection_50_comment},
  { "isConnectionOk",(PyCFunction ) &Dtool_ConnectionReader_is_connection_ok_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_is_connection_ok_51_comment},
  { "poll",(PyCFunction ) &Dtool_ConnectionReader_poll_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_poll_52_comment},
  { "getManager",(PyCFunction ) &Dtool_ConnectionReader_get_manager_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_get_manager_53_comment},
  { "isPolling",(PyCFunction ) &Dtool_ConnectionReader_is_polling_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_is_polling_54_comment},
  { "getNumThreads",(PyCFunction ) &Dtool_ConnectionReader_get_num_threads_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_get_num_threads_55_comment},
  { "setRawMode",(PyCFunction ) &Dtool_ConnectionReader_set_raw_mode_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_set_raw_mode_56_comment},
  { "getRawMode",(PyCFunction ) &Dtool_ConnectionReader_get_raw_mode_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_get_raw_mode_57_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_ConnectionReader_set_tcp_header_size_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_set_tcp_header_size_58_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_ConnectionReader_get_tcp_header_size_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_get_tcp_header_size_59_comment},
  { "shutdown",(PyCFunction ) &Dtool_ConnectionReader_shutdown_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_shutdown_60_comment},
  { "downcastToDatagramGeneratorNet",(PyCFunction ) &Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_downcast_to_DatagramGeneratorNet_102_comment},
  { "downcastToQueuedConnectionReader",(PyCFunction ) &Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionReader_downcast_to_QueuedConnectionReader_161_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConnectionReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConnectionReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConnectionReader\n"
          "// Description : This is an abstract base class for a family of\n"
          "//               classes that listen for activity on a socket and\n"
          "//               respond to it, for instance by reading a datagram and\n"
          "//               serving it (or queueing it up for later service).\n"
          "//\n"
          "//               A ConnectionReader may define an arbitrary number of\n"
          "//               threads (at least one) to process datagrams coming in\n"
          "//               from an arbitrary number of sockets that it is\n"
          "//               monitoring.  The number of threads is specified at\n"
          "//               construction time and cannot be changed, but the set\n"
          "//               of sockets that is to be monitored may be constantly\n"
          "//               modified at will.\n"
          "//\n"
          "//               This is an abstract class because it doesn't define\n"
          "//               how to process each received datagram.  See\n"
          "//               QueuedConnectionReader.  Also note that\n"
          "//               ConnectionListener derives from this class, extending\n"
          "//               it to accept connections on a rendezvous socket\n"
          "//               rather than read datagrams.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConnectionReader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConnectionReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConnectionReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConnectionReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConnectionReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConnectionReader)");
             printf(" Error In PyType_ReadyConnectionReader");
             return;
        }
        Py_INCREF(&Dtool_ConnectionReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConnectionReader.As_PyTypeObject().tp_dict,"ConnectionReader",&Dtool_ConnectionReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConnectionReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConnectionReader.As_PyTypeObject());
        PyModule_AddObject(module, "ConnectionReader",(PyObject *)&Dtool_ConnectionReader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConnectionListener | ConnectionListener
//********************************************************************
PyMethodDef Dtool_Methods_ConnectionListener[]= {
  { "downcastToQueuedConnectionListener",(PyCFunction ) &Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionListener_downcast_to_QueuedConnectionListener_131_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConnectionListener(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConnectionListener.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConnectionListener\n"
          "// Description : This is a special kind of ConnectionReader that waits\n"
          "//               for activity on a rendezvous port and accepts a TCP\n"
          "//               connection (instead of attempting to read a datagram\n"
          "//               from the rendezvous port).\n"
          "//\n"
          "//               It is itself an abstract class, as it doesn't define\n"
          "//               what to do with the established connection.  See\n"
          "//               QueuedConnectionListener.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConnectionReader._Dtool_ClassInit(NULL);
        Dtool_ConnectionListener.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConnectionReader.As_PyTypeObject());
        Dtool_ConnectionListener.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConnectionListener.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConnectionListener.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConnectionListener.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConnectionListener)");
             printf(" Error In PyType_ReadyConnectionListener");
             return;
        }
        Py_INCREF(&Dtool_ConnectionListener.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConnectionListener.As_PyTypeObject().tp_dict,"ConnectionListener",&Dtool_ConnectionListener.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConnectionListener,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConnectionListener.As_PyTypeObject());
        PyModule_AddObject(module, "ConnectionListener",(PyObject *)&Dtool_ConnectionListener.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NetDatagram | NetDatagram
//********************************************************************
PyMethodDef Dtool_Methods_NetDatagram[]= {
  { "assign",(PyCFunction ) &Dtool_NetDatagram_operator_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_operator_66_comment},
  { "setConnection",(PyCFunction ) &Dtool_NetDatagram_set_connection_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_set_connection_67_comment},
  { "getConnection",(PyCFunction ) &Dtool_NetDatagram_get_connection_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_get_connection_68_comment},
  { "setAddress",(PyCFunction ) &Dtool_NetDatagram_set_address_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_set_address_69_comment},
  { "getAddress",(PyCFunction ) &Dtool_NetDatagram_get_address_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_get_address_70_comment},
  { "getClassType",(PyCFunction ) &Dtool_NetDatagram_get_class_type_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NetDatagram_get_class_type_71_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NetDatagram(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NetDatagram.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NetDatagram\n"
          "// Description : A specific kind of Datagram, especially for sending\n"
          "//               across or receiving from a network.  It's different\n"
          "//               only in that it knows which Connection and/or\n"
          "//               NetAddress it is to be sent to or was received from.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Datagram._Dtool_ClassInit(NULL);
        Dtool_NetDatagram.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Datagram.As_PyTypeObject());
        Dtool_NetDatagram.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NetDatagram.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NetDatagram.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NetDatagram.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NetDatagram)");
             printf(" Error In PyType_ReadyNetDatagram");
             return;
        }
        Py_INCREF(&Dtool_NetDatagram.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NetDatagram.As_PyTypeObject().tp_dict,"NetDatagram",&Dtool_NetDatagram.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NetDatagram.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NetDatagram[5],&Dtool_NetDatagram.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NetDatagram,NetDatagram::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NetDatagram.As_PyTypeObject());
        PyModule_AddObject(module, "NetDatagram",(PyObject *)&Dtool_NetDatagram.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConnectionManager | ConnectionManager
//********************************************************************
PyMethodDef Dtool_Methods_ConnectionManager[]= {
  { "openUDPConnection",(PyCFunction ) &Dtool_ConnectionManager_open_UDP_connection_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_open_UDP_connection_76_comment},
  { "openTCPServerRendezvous",(PyCFunction ) &Dtool_ConnectionManager_open_TCP_server_rendezvous_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_open_TCP_server_rendezvous_77_comment},
  { "openTCPClientConnection",(PyCFunction ) &Dtool_ConnectionManager_open_TCP_client_connection_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_open_TCP_client_connection_78_comment},
  { "closeConnection",(PyCFunction ) &Dtool_ConnectionManager_close_connection_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_close_connection_79_comment},
  { "getHostName",(PyCFunction ) &Dtool_ConnectionManager_get_host_name_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_get_host_name_80_comment},
  { "downcastToQueuedConnectionManager",(PyCFunction ) &Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionManager_downcast_to_QueuedConnectionManager_146_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConnectionManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConnectionManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConnectionManager\n"
          "// Description : The primary interface to the low-level networking\n"
          "//               layer in this package.  A ConnectionManager is used\n"
          "//               to establish and destroy TCP and UDP connections.\n"
          "//               Communication on these connections, once established,\n"
          "//               is handled via ConnectionReader, ConnectionWriter,\n"
          "//               and ConnectionListener.\n"
          "//\n"
          "//               You may use this class directly if you don't care\n"
          "//               about tracking which connections have been\n"
          "//               unexpectedly closed; otherwise, you should use\n"
          "//               QueuedConnectionManager to get reports about these\n"
          "//               events (or derive your own class to handle these\n"
          "//               events properly).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConnectionManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConnectionManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConnectionManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConnectionManager.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConnectionManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConnectionManager)");
             printf(" Error In PyType_ReadyConnectionManager");
             return;
        }
        Py_INCREF(&Dtool_ConnectionManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConnectionManager.As_PyTypeObject().tp_dict,"ConnectionManager",&Dtool_ConnectionManager.As_PyObject());
        //  Static Method getHostName
        PyDict_SetItemString(Dtool_ConnectionManager.As_PyTypeObject().tp_dict,"getHostName",PyCFunction_New(&Dtool_Methods_ConnectionManager[4],&Dtool_ConnectionManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ConnectionManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConnectionManager.As_PyTypeObject());
        PyModule_AddObject(module, "ConnectionManager",(PyObject *)&Dtool_ConnectionManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConnectionWriter | ConnectionWriter
//********************************************************************
PyMethodDef Dtool_Methods_ConnectionWriter[]= {
  { "setMaxQueueSize",(PyCFunction ) &Dtool_ConnectionWriter_set_max_queue_size_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_set_max_queue_size_84_comment},
  { "getMaxQueueSize",(PyCFunction ) &Dtool_ConnectionWriter_get_max_queue_size_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_max_queue_size_85_comment},
  { "getCurrentQueueSize",(PyCFunction ) &Dtool_ConnectionWriter_get_current_queue_size_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_current_queue_size_86_comment},
  { "send",(PyCFunction ) &Dtool_ConnectionWriter_send_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_send_87_comment},
  { "isValidForUdp",(PyCFunction ) &Dtool_ConnectionWriter_is_valid_for_udp_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_is_valid_for_udp_88_comment},
  { "getManager",(PyCFunction ) &Dtool_ConnectionWriter_get_manager_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_manager_89_comment},
  { "isImmediate",(PyCFunction ) &Dtool_ConnectionWriter_is_immediate_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_is_immediate_90_comment},
  { "getNumThreads",(PyCFunction ) &Dtool_ConnectionWriter_get_num_threads_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_num_threads_91_comment},
  { "setRawMode",(PyCFunction ) &Dtool_ConnectionWriter_set_raw_mode_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_set_raw_mode_92_comment},
  { "getRawMode",(PyCFunction ) &Dtool_ConnectionWriter_get_raw_mode_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_raw_mode_93_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_ConnectionWriter_set_tcp_header_size_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_set_tcp_header_size_94_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_ConnectionWriter_get_tcp_header_size_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_get_tcp_header_size_95_comment},
  { "shutdown",(PyCFunction ) &Dtool_ConnectionWriter_shutdown_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_shutdown_96_comment},
  { "downcastToDatagramSinkNet",(PyCFunction ) &Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConnectionWriter_downcast_to_DatagramSinkNet_121_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConnectionWriter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConnectionWriter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConnectionWriter\n"
          "// Description : This class handles threaded delivery of datagrams to\n"
          "//               various TCP or UDP sockets.\n"
          "//\n"
          "//               A ConnectionWriter may define an arbitrary number of\n"
          "//               threads (0 or more) to write its datagrams to\n"
          "//               sockets.  The number of threads is specified at\n"
          "//               construction time and cannot be changed.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConnectionWriter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConnectionWriter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConnectionWriter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConnectionWriter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConnectionWriter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConnectionWriter)");
             printf(" Error In PyType_ReadyConnectionWriter");
             return;
        }
        Py_INCREF(&Dtool_ConnectionWriter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConnectionWriter.As_PyTypeObject().tp_dict,"ConnectionWriter",&Dtool_ConnectionWriter.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConnectionWriter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConnectionWriter.As_PyTypeObject());
        PyModule_AddObject(module, "ConnectionWriter",(PyObject *)&Dtool_ConnectionWriter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DatagramGeneratorNet | DatagramGeneratorNet
//********************************************************************
PyMethodDef Dtool_Methods_DatagramGeneratorNet[]= {
  { "getDatagram",(PyCFunction ) &Dtool_DatagramGeneratorNet_get_datagram_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_get_datagram_113_comment},
  { "isEof",(PyCFunction ) &Dtool_DatagramGeneratorNet_is_eof_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_is_eof_114_comment},
  { "isError",(PyCFunction ) &Dtool_DatagramGeneratorNet_is_error_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_is_error_115_comment},
  { "upcastToDatagramGenerator",(PyCFunction ) &Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_99_comment},
  { "upcastToConnectionReader",(PyCFunction ) &Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_101_comment},
  { "upcastToQueuedReturnDatagram",(PyCFunction ) &Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_109_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DatagramGeneratorNet(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DatagramGeneratorNet\n"
          "// Description : This class provides datagrams one-at-a-time as read\n"
          "//               directly from the net, via a TCP connection.  If a\n"
          "//               datagram is not available, get_datagram() will block\n"
          "//               until one is.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DatagramGenerator._Dtool_ClassInit(NULL);
        Dtool_ConnectionReader._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_Datagram._Dtool_ClassInit(NULL);
        Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_bases = Py_BuildValue("(OOO)",&Dtool_DatagramGenerator.As_PyTypeObject(),&Dtool_ConnectionReader.As_PyTypeObject(),&Dtool_QueuedReturn_Datagram.As_PyTypeObject());
        Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DatagramGeneratorNet.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DatagramGeneratorNet)");
             printf(" Error In PyType_ReadyDatagramGeneratorNet");
             return;
        }
        Py_INCREF(&Dtool_DatagramGeneratorNet.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DatagramGeneratorNet.As_PyTypeObject().tp_dict,"DatagramGeneratorNet",&Dtool_DatagramGeneratorNet.As_PyObject());
        RegisterRuntimeClass(&Dtool_DatagramGeneratorNet,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DatagramGeneratorNet.As_PyTypeObject());
        PyModule_AddObject(module, "DatagramGeneratorNet",(PyObject *)&Dtool_DatagramGeneratorNet.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedReturn_Datagram | QueuedReturnDatagram
//********************************************************************
PyMethodDef Dtool_Methods_QueuedReturn_Datagram[]= {
  { "setMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_Datagram_set_max_queue_size_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_set_max_queue_size_104_comment},
  { "getMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_Datagram_get_max_queue_size_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_get_max_queue_size_105_comment},
  { "getCurrentQueueSize",(PyCFunction ) &Dtool_QueuedReturn_Datagram_get_current_queue_size_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_get_current_queue_size_106_comment},
  { "getOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_Datagram_get_overflow_flag_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_get_overflow_flag_107_comment},
  { "resetOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_Datagram_reset_overflow_flag_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_reset_overflow_flag_108_comment},
  { "downcastToDatagramGeneratorNet",(PyCFunction ) &Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_Datagram_downcast_to_DatagramGeneratorNet_110_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedReturn_Datagram(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_Datagram.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_QueuedReturn_Datagram.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedReturn_Datagram.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedReturn_Datagram.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedReturn_Datagram.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedReturn_Datagram)");
             printf(" Error In PyType_ReadyQueuedReturn_Datagram");
             return;
        }
        Py_INCREF(&Dtool_QueuedReturn_Datagram.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedReturn_Datagram.As_PyTypeObject().tp_dict,"QueuedReturnDatagram",&Dtool_QueuedReturn_Datagram.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedReturn_Datagram,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedReturn_Datagram.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedReturnDatagram",(PyObject *)&Dtool_QueuedReturn_Datagram.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DatagramSinkNet | DatagramSinkNet
//********************************************************************
PyMethodDef Dtool_Methods_DatagramSinkNet[]= {
  { "setTarget",(PyCFunction ) &Dtool_DatagramSinkNet_set_target_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_set_target_123_comment},
  { "getTarget",(PyCFunction ) &Dtool_DatagramSinkNet_get_target_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_get_target_124_comment},
  { "putDatagram",(PyCFunction ) &Dtool_DatagramSinkNet_put_datagram_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_put_datagram_125_comment},
  { "isError",(PyCFunction ) &Dtool_DatagramSinkNet_is_error_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_is_error_126_comment},
  { "flush",(PyCFunction ) &Dtool_DatagramSinkNet_flush_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_flush_127_comment},
  { "upcastToDatagramSink",(PyCFunction ) &Dtool_DatagramSinkNet_upcast_to_DatagramSink_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_upcast_to_DatagramSink_118_comment},
  { "upcastToConnectionWriter",(PyCFunction ) &Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_120_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DatagramSinkNet(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DatagramSinkNet.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DatagramSinkNet\n"
          "// Description : This class accepts datagrams one-at-a-time and sends\n"
          "//               them over the net, via a TCP connection.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DatagramSink._Dtool_ClassInit(NULL);
        Dtool_ConnectionWriter._Dtool_ClassInit(NULL);
        Dtool_DatagramSinkNet.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_DatagramSink.As_PyTypeObject(),&Dtool_ConnectionWriter.As_PyTypeObject());
        Dtool_DatagramSinkNet.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DatagramSinkNet.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DatagramSinkNet.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DatagramSinkNet.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DatagramSinkNet)");
             printf(" Error In PyType_ReadyDatagramSinkNet");
             return;
        }
        Py_INCREF(&Dtool_DatagramSinkNet.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DatagramSinkNet.As_PyTypeObject().tp_dict,"DatagramSinkNet",&Dtool_DatagramSinkNet.As_PyObject());
        RegisterRuntimeClass(&Dtool_DatagramSinkNet,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DatagramSinkNet.As_PyTypeObject());
        PyModule_AddObject(module, "DatagramSinkNet",(PyObject *)&Dtool_DatagramSinkNet.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedConnectionListener | QueuedConnectionListener
//********************************************************************
PyMethodDef Dtool_Methods_QueuedConnectionListener[]= {
  { "newConnectionAvailable",(PyCFunction ) &Dtool_QueuedConnectionListener_new_connection_available_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionListener_new_connection_available_142_comment},
  { "getNewConnection",(PyCFunction ) &Dtool_QueuedConnectionListener_get_new_connection_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionListener_get_new_connection_143_comment},
  { "upcastToConnectionListener",(PyCFunction ) &Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_130_comment},
  { "upcastToQueuedReturnConnectionListenerData",(PyCFunction ) &Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_138_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedConnectionListener(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_QueuedConnectionListener.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : QueuedConnectionListener\n"
          "// Description : This flavor of ConnectionListener will queue up all\n"
          "//               of the TCP connections it established for later\n"
          "//               detection by the client code.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConnectionListener._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_ConnectionListenerData._Dtool_ClassInit(NULL);
        Dtool_QueuedConnectionListener.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_ConnectionListener.As_PyTypeObject(),&Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject());
        Dtool_QueuedConnectionListener.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedConnectionListener.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedConnectionListener.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedConnectionListener.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedConnectionListener)");
             printf(" Error In PyType_ReadyQueuedConnectionListener");
             return;
        }
        Py_INCREF(&Dtool_QueuedConnectionListener.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedConnectionListener.As_PyTypeObject().tp_dict,"QueuedConnectionListener",&Dtool_QueuedConnectionListener.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedConnectionListener,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedConnectionListener.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedConnectionListener",(PyObject *)&Dtool_QueuedConnectionListener.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedReturn_ConnectionListenerData | QueuedReturnConnectionListenerData
//********************************************************************
PyMethodDef Dtool_Methods_QueuedReturn_ConnectionListenerData[]= {
  { "setMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_133_comment},
  { "getMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_134_comment},
  { "getCurrentQueueSize",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_135_comment},
  { "getOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_136_comment},
  { "resetOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_137_comment},
  { "downcastToQueuedConnectionListener",(PyCFunction ) &Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_ConnectionListenerData_downcast_to_QueuedConnectionListener_139_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedReturn_ConnectionListenerData)");
             printf(" Error In PyType_ReadyQueuedReturn_ConnectionListenerData");
             return;
        }
        Py_INCREF(&Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject().tp_dict,"QueuedReturnConnectionListenerData",&Dtool_QueuedReturn_ConnectionListenerData.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedReturn_ConnectionListenerData,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedReturnConnectionListenerData",(PyObject *)&Dtool_QueuedReturn_ConnectionListenerData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedConnectionManager | QueuedConnectionManager
//********************************************************************
PyMethodDef Dtool_Methods_QueuedConnectionManager[]= {
  { "resetConnectionAvailable",(PyCFunction ) &Dtool_QueuedConnectionManager_reset_connection_available_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionManager_reset_connection_available_157_comment},
  { "getResetConnection",(PyCFunction ) &Dtool_QueuedConnectionManager_get_reset_connection_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionManager_get_reset_connection_158_comment},
  { "upcastToConnectionManager",(PyCFunction ) &Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_145_comment},
  { "upcastToQueuedReturnPointerToConnection",(PyCFunction ) &Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_153_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedConnectionManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_QueuedConnectionManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : QueuedConnectionManager\n"
          "// Description : This flavor of ConnectionManager will queue up all of\n"
          "//               the reset-connection messages from the\n"
          "//               ConnectionReaders and ConnectionWriters and report\n"
          "//               them to the client on demand.\n"
          "//\n"
          "//               When a reset connection has been discovered via\n"
          "//               reset_connection_available()/get_reset_connection(),\n"
          "//               it is still the responsibility of the client to call\n"
          "//               close_connection() on that connection to free up its\n"
          "//               resources.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConnectionManager._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_PointerTo_Connection._Dtool_ClassInit(NULL);
        Dtool_QueuedConnectionManager.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_ConnectionManager.As_PyTypeObject(),&Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject());
        Dtool_QueuedConnectionManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedConnectionManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedConnectionManager.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedConnectionManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedConnectionManager)");
             printf(" Error In PyType_ReadyQueuedConnectionManager");
             return;
        }
        Py_INCREF(&Dtool_QueuedConnectionManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedConnectionManager.As_PyTypeObject().tp_dict,"QueuedConnectionManager",&Dtool_QueuedConnectionManager.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedConnectionManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedConnectionManager.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedConnectionManager",(PyObject *)&Dtool_QueuedConnectionManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedReturn_PointerTo_Connection | QueuedReturnPointerToConnection
//********************************************************************
PyMethodDef Dtool_Methods_QueuedReturn_PointerTo_Connection[]= {
  { "setMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_148_comment},
  { "getMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_149_comment},
  { "getCurrentQueueSize",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_150_comment},
  { "getOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_151_comment},
  { "resetOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_152_comment},
  { "downcastToQueuedConnectionManager",(PyCFunction ) &Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_PointerTo_Connection_downcast_to_QueuedConnectionManager_154_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedReturn_PointerTo_Connection)");
             printf(" Error In PyType_ReadyQueuedReturn_PointerTo_Connection");
             return;
        }
        Py_INCREF(&Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject().tp_dict,"QueuedReturnPointerToConnection",&Dtool_QueuedReturn_PointerTo_Connection.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedReturn_PointerTo_Connection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedReturnPointerToConnection",(PyObject *)&Dtool_QueuedReturn_PointerTo_Connection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedConnectionReader | QueuedConnectionReader
//********************************************************************
PyMethodDef Dtool_Methods_QueuedConnectionReader[]= {
  { "dataAvailable",(PyCFunction ) &Dtool_QueuedConnectionReader_data_available_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionReader_data_available_172_comment},
  { "getData",(PyCFunction ) &Dtool_QueuedConnectionReader_get_data_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionReader_get_data_173_comment},
  { "upcastToConnectionReader",(PyCFunction ) &Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_160_comment},
  { "upcastToQueuedReturnNetDatagram",(PyCFunction ) &Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_168_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedConnectionReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_QueuedConnectionReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : QueuedConnectionReader\n"
          "// Description : This flavor of ConnectionReader will read from its\n"
          "//               sockets and queue up all of the datagrams read for\n"
          "//               later receipt by the client code.  This class is\n"
          "//               useful for client code that doesn't want to deal with\n"
          "//               threading and is willing to poll for datagrams at its\n"
          "//               convenience.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConnectionReader._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_NetDatagram._Dtool_ClassInit(NULL);
        Dtool_QueuedConnectionReader.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_ConnectionReader.As_PyTypeObject(),&Dtool_QueuedReturn_NetDatagram.As_PyTypeObject());
        Dtool_QueuedConnectionReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedConnectionReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedConnectionReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedConnectionReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedConnectionReader)");
             printf(" Error In PyType_ReadyQueuedConnectionReader");
             return;
        }
        Py_INCREF(&Dtool_QueuedConnectionReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedConnectionReader.As_PyTypeObject().tp_dict,"QueuedConnectionReader",&Dtool_QueuedConnectionReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedConnectionReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedConnectionReader.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedConnectionReader",(PyObject *)&Dtool_QueuedConnectionReader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. QueuedReturn_NetDatagram | QueuedReturnNetDatagram
//********************************************************************
PyMethodDef Dtool_Methods_QueuedReturn_NetDatagram[]= {
  { "setMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_set_max_queue_size_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_set_max_queue_size_163_comment},
  { "getMaxQueueSize",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_get_max_queue_size_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_get_max_queue_size_164_comment},
  { "getCurrentQueueSize",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_get_current_queue_size_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_get_current_queue_size_165_comment},
  { "getOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_get_overflow_flag_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_get_overflow_flag_166_comment},
  { "resetOverflowFlag",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_167_comment},
  { "downcastToQueuedConnectionReader",(PyCFunction ) &Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_QueuedReturn_NetDatagram_downcast_to_QueuedConnectionReader_169_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_QueuedReturn_NetDatagram.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_QueuedReturn_NetDatagram.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_QueuedReturn_NetDatagram.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_QueuedReturn_NetDatagram.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_QueuedReturn_NetDatagram.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(QueuedReturn_NetDatagram)");
             printf(" Error In PyType_ReadyQueuedReturn_NetDatagram");
             return;
        }
        Py_INCREF(&Dtool_QueuedReturn_NetDatagram.As_PyTypeObject());
        PyDict_SetItemString(Dtool_QueuedReturn_NetDatagram.As_PyTypeObject().tp_dict,"QueuedReturnNetDatagram",&Dtool_QueuedReturn_NetDatagram.As_PyObject());
        RegisterRuntimeClass(&Dtool_QueuedReturn_NetDatagram,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_QueuedReturn_NetDatagram.As_PyTypeObject());
        PyModule_AddObject(module, "QueuedReturnNetDatagram",(PyObject *)&Dtool_QueuedReturn_NetDatagram.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RecentConnectionReader | RecentConnectionReader
//********************************************************************
PyMethodDef Dtool_Methods_RecentConnectionReader[]= {
  { "dataAvailable",(PyCFunction ) &Dtool_RecentConnectionReader_data_available_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecentConnectionReader_data_available_176_comment},
  { "getData",(PyCFunction ) &Dtool_RecentConnectionReader_get_data_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RecentConnectionReader_get_data_177_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RecentConnectionReader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RecentConnectionReader.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RecentConnectionReader\n"
          "// Description : This flavor of ConnectionReader will read from its\n"
          "//               sockets and retain only the single most recent\n"
          "//               datagram for inspection by client code.  It's useful\n"
          "//               particularly for reading telemetry-type data from UDP\n"
          "//               sockets where you don't care about getting every last\n"
          "//               socket, and in fact if the sockets are coming too\n"
          "//               fast you'd prefer to skip some of them.\n"
          "//\n"
          "//               This class will always create one thread for itself.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ConnectionReader._Dtool_ClassInit(NULL);
        Dtool_RecentConnectionReader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConnectionReader.As_PyTypeObject());
        Dtool_RecentConnectionReader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RecentConnectionReader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RecentConnectionReader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RecentConnectionReader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RecentConnectionReader)");
             printf(" Error In PyType_ReadyRecentConnectionReader");
             return;
        }
        Py_INCREF(&Dtool_RecentConnectionReader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RecentConnectionReader.As_PyTypeObject().tp_dict,"RecentConnectionReader",&Dtool_RecentConnectionReader.As_PyObject());
        RegisterRuntimeClass(&Dtool_RecentConnectionReader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RecentConnectionReader.As_PyTypeObject());
        PyModule_AddObject(module, "RecentConnectionReader",(PyObject *)&Dtool_RecentConnectionReader.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PointerTo< Connection >
//********************************************************************
   Dtool_PyModuleClassInit_PointerTo_Connection(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< Connection >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_Connection(module);
//********************************************************************
//*** Module Init Updcall ..NetAddress
//********************************************************************
   Dtool_PyModuleClassInit_NetAddress(module);
//********************************************************************
//*** Module Init Updcall ..Connection
//********************************************************************
   Dtool_PyModuleClassInit_Connection(module);
//********************************************************************
//*** Module Init Updcall ..ConnectionReader
//********************************************************************
   Dtool_PyModuleClassInit_ConnectionReader(module);
//********************************************************************
//*** Module Init Updcall ..ConnectionListener
//********************************************************************
   Dtool_PyModuleClassInit_ConnectionListener(module);
//********************************************************************
//*** Module Init Updcall ..NetDatagram
//********************************************************************
   Dtool_PyModuleClassInit_NetDatagram(module);
//********************************************************************
//*** Module Init Updcall ..ConnectionManager
//********************************************************************
   Dtool_PyModuleClassInit_ConnectionManager(module);
//********************************************************************
//*** Module Init Updcall ..ConnectionWriter
//********************************************************************
   Dtool_PyModuleClassInit_ConnectionWriter(module);
//********************************************************************
//*** Module Init Updcall ..DatagramGeneratorNet
//********************************************************************
   Dtool_PyModuleClassInit_DatagramGeneratorNet(module);
//********************************************************************
//*** Module Init Updcall ..QueuedReturn< Datagram >
//********************************************************************
   Dtool_PyModuleClassInit_QueuedReturn_Datagram(module);
//********************************************************************
//*** Module Init Updcall ..DatagramSinkNet
//********************************************************************
   Dtool_PyModuleClassInit_DatagramSinkNet(module);
//********************************************************************
//*** Module Init Updcall ..QueuedConnectionListener
//********************************************************************
   Dtool_PyModuleClassInit_QueuedConnectionListener(module);
//********************************************************************
//*** Module Init Updcall ..QueuedReturn< ConnectionListenerData >
//********************************************************************
   Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(module);
//********************************************************************
//*** Module Init Updcall ..QueuedConnectionManager
//********************************************************************
   Dtool_PyModuleClassInit_QueuedConnectionManager(module);
//********************************************************************
//*** Module Init Updcall ..QueuedReturn< PointerTo< Connection > >
//********************************************************************
   Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(module);
//********************************************************************
//*** Module Init Updcall ..QueuedConnectionReader
//********************************************************************
   Dtool_PyModuleClassInit_QueuedConnectionReader(module);
//********************************************************************
//*** Module Init Updcall ..QueuedReturn< NetDatagram >
//********************************************************************
   Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(module);
//********************************************************************
//*** Module Init Updcall ..RecentConnectionReader
//********************************************************************
   Dtool_PyModuleClassInit_RecentConnectionReader(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libnet_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212831,  /* file_identifier */
  "libnet",  /* library_name */
  "9ImM",  /* library_hash_name */
  "panda",  /* module_name */
  "libnet.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  403  /* next_index */
};

Configure(_in_configure_libnet);
ConfigureFn(_in_configure_libnet) {
  interrogate_request_module(&_in_module_def);
}

