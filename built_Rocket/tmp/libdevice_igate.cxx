/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/device -Ipanda/src/device -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdevice_igate.cxx -od built_Rocket/pandac/input/libdevice.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/device -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libdevice analogNode.h buttonNode.h clientAnalogDevice.h clientBase.h clientButtonDevice.h clientDevice.h clientDialDevice.h clientTrackerDevice.h config_device.h device_composite.cxx dialNode.h mouseAndKeyboard.h trackerData.h trackerNode.h virtualMouse.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdevice
#include "py_panda.h"  

#include "analogNode.h"
#include "buttonEventList.h"
#include "buttonNode.h"
#include "clientAnalogDevice.h"
#include "clientBase.h"
#include "clientButtonDevice.h"
#include "clientDevice.h"
#include "clientDialDevice.h"
#include "clientTrackerDevice.h"
#include "configVariableBool.h"
#include "config_device.h"
#include "dataNode.h"
#include "dialNode.h"
#include "linmath_events.h"
#include "mouseAndKeyboard.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "trackerData.h"
#include "trackerNode.h"
#include "virtualMouse.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ClientBase
//********************************************************************
typedef  ClientBase  ClientBase_localtype;
Define_Module_ClassRef(panda,ClientBase,ClientBase_localtype,ClientBase);
//********************************************************************
//*** prototypes for .. AnalogNode
//********************************************************************
typedef  AnalogNode  AnalogNode_localtype;
Define_Module_ClassRef(panda,AnalogNode,AnalogNode_localtype,AnalogNode);
//********************************************************************
//*** prototypes for .. ButtonNode
//********************************************************************
typedef  ButtonNode  ButtonNode_localtype;
Define_Module_ClassRef(panda,ButtonNode,ButtonNode_localtype,ButtonNode);
//********************************************************************
//*** prototypes for .. DialNode
//********************************************************************
typedef  DialNode  DialNode_localtype;
Define_Module_ClassRef(panda,DialNode,DialNode_localtype,DialNode);
//********************************************************************
//*** prototypes for .. MouseAndKeyboard
//********************************************************************
typedef  MouseAndKeyboard  MouseAndKeyboard_localtype;
Define_Module_ClassRef(panda,MouseAndKeyboard,MouseAndKeyboard_localtype,MouseAndKeyboard);
//********************************************************************
//*** prototypes for .. TrackerNode
//********************************************************************
typedef  TrackerNode  TrackerNode_localtype;
Define_Module_ClassRef(panda,TrackerNode,TrackerNode_localtype,TrackerNode);
//********************************************************************
//*** prototypes for .. VirtualMouse
//********************************************************************
typedef  VirtualMouse  VirtualMouse_localtype;
Define_Module_ClassRef(panda,VirtualMouse,VirtualMouse_localtype,VirtualMouse);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ButtonHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DataNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsWindow;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LOrientationf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. ClientBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool ClientBase::fork_asynchronous_thread(double poll_time)
 *******************************************************************/
static PyObject *Dtool_ClientBase_fork_asynchronous_thread_3(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool ClientBase::fork_asynchronous_thread(double poll_time)
        double param1;
        static char * key_word_list[] = {(char *)"poll_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:forkAsynchronousThread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:forkAsynchronousThread", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->fork_asynchronous_thread((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClientBase.forkAsynchronousThread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forkAsynchronousThread(non-const ClientBase this, float poll_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_fork_asynchronous_thread_3_comment =
    "C++ Interface:\n"
    "forkAsynchronousThread(non-const ClientBase this, float poll_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::fork_asynchronous_thread\n"
    "//       Access: Public\n"
    "//  Description: Forks a separate thread to do all the polling of\n"
    "//               connected devices.  The forked thread will poll after\n"
    "//               every poll_time seconds has elapsed.  Returns true if\n"
    "//               the fork was successful, or false otherwise (for\n"
    "//               instance, because we were already forked, or because\n"
    "//               asynchronous threads are disabled).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_fork_asynchronous_thread_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ClientBase::is_forked(void) const
 *******************************************************************/
static PyObject *Dtool_ClientBase_is_forked_4(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ClientBase::is_forked(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isForked", key_word_list));
        else
            (PyArg_Parse(args, ":isForked"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ClientBase*)local_this)->is_forked();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isForked(const ClientBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_is_forked_4_comment =
    "C++ Interface:\n"
    "isForked(const ClientBase this)\n"
    "\n"
    "// Filename: clientBase.I\n"
    "// Created by:  drose (25Jan01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::is_forked\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the ClientBase has been forked (and,\n"
    "//               therefore, poll() does not need to be called), false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_is_forked_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ClientBase::poll(void)
 *******************************************************************/
static PyObject *Dtool_ClientBase_poll_5(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool ClientBase::poll(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":poll", key_word_list));
        else
            (PyArg_Parse(args, ":poll"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->poll();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClientBase.poll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "poll(non-const ClientBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_poll_5_comment =
    "C++ Interface:\n"
    "poll(non-const ClientBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::poll\n"
    "//       Access: Public\n"
    "//  Description: Initiates a poll of the client devices, if we are not\n"
    "//               forked and if we have not already polled this frame.\n"
    "//               Returns true if the poll occurred, or false if it did\n"
    "//               not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_poll_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double ClientBase::get_last_poll_time(void) const
 *******************************************************************/
static PyObject *Dtool_ClientBase_get_last_poll_time_6(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double ClientBase::get_last_poll_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastPollTime", key_word_list));
        else
            (PyArg_Parse(args, ":getLastPollTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const ClientBase*)local_this)->get_last_poll_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastPollTime(const ClientBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_get_last_poll_time_6_comment =
    "C++ Interface:\n"
    "getLastPollTime(const ClientBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::get_last_poll_time\n"
    "//       Access: Public\n"
    "//  Description: Returns the time (according to the global\n"
    "//               ClockObject's get_real_time() method) of the last\n"
    "//               device poll.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_get_last_poll_time_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_ClientBase_set_coordinate_system_7(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClientBase.setCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoordinateSystem(non-const ClientBase this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_set_coordinate_system_7_comment =
    "C++ Interface:\n"
    "setCoordinateSystem(non-const ClientBase this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::set_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Specifies the coordinate system that all devices\n"
    "//               associated with this client will operate in.\n"
    "//               Normally, this is CS_default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_set_coordinate_system_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem ClientBase::get_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_ClientBase_get_coordinate_system_8(PyObject *self, PyObject *args,PyObject *kwds) {
    ClientBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClientBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem ClientBase::get_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const ClientBase*)local_this)->get_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoordinateSystem(const ClientBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_get_coordinate_system_8_comment =
    "C++ Interface:\n"
    "getCoordinateSystem(const ClientBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ClientBase::get_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate system that all devices\n"
    "//               associated with this client will operate in.\n"
    "//               Normally, this is CS_default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ClientBase_get_coordinate_system_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ClientBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ClientBase_get_class_type_9(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ClientBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ClientBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClientBase_get_class_type_9_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ClientBase_get_class_type_9_comment = NULL;
#endif

int  Dtool_Init_ClientBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ClientBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ClientBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ClientBase)
    {
        printf("ClientBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ClientBase * local_this = (ClientBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ClientBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ClientBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ClientBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ClientBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ClientBase*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ClientBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnalogNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool AnalogNode::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_is_valid_13(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnalogNode::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnalogNode*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const AnalogNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_is_valid_13_comment =
    "C++ Interface:\n"
    "isValid(const AnalogNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the AnalogNode is valid and\n"
    "//               connected to a server, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_is_valid_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnalogNode::get_num_controls(void) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_get_num_controls_14(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnalogNode::get_num_controls(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumControls", key_word_list));
        else
            (PyArg_Parse(args, ":getNumControls"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnalogNode*)local_this)->get_num_controls();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumControls(const AnalogNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_get_num_controls_14_comment =
    "C++ Interface:\n"
    "getNumControls(const AnalogNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::get_num_controls\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of analog controls known to the\n"
    "//               AnalogNode.  This number may change as more controls\n"
    "//               are discovered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_get_num_controls_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnalogNode::get_control_state(int index) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_get_control_state_15(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnalogNode::get_control_state(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getControlState", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getControlState", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnalogNode*)local_this)->get_control_state((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getControlState(const AnalogNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_get_control_state_15_comment =
    "C++ Interface:\n"
    "getControlState(const AnalogNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::get_control_state\n"
    "//       Access: Public\n"
    "//  Description: Returns the current position of indicated analog\n"
    "//               control identified by its index number, or 0.0 if\n"
    "//               the control is unknown.  The normal range of a single\n"
    "//               control is -1.0 to 1.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_get_control_state_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnalogNode::is_control_known(int index) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_is_control_known_16(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnalogNode::is_control_known(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isControlKnown", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isControlKnown", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnalogNode*)local_this)->is_control_known((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isControlKnown(const AnalogNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_is_control_known_16_comment =
    "C++ Interface:\n"
    "isControlKnown(const AnalogNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::is_control_known\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the state of the indicated analog\n"
    "//               control is known, or false if we have never heard\n"
    "//               anything about this particular control.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_is_control_known_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnalogNode::set_output(int channel, int index, bool flip)
 *******************************************************************/
static PyObject *Dtool_AnalogNode_set_output_17(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnalogNode::set_output(int channel, int index, bool flip)
        int param1;
        int param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"channel", (char *)"index", (char *)"flip", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setOutput", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_output((int)param1, (int)param2, (PyObject_IsTrue(param3)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnalogNode.setOutput() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOutput(non-const AnalogNode this, int channel, int index, bool flip)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_set_output_17_comment =
    "C++ Interface:\n"
    "setOutput(non-const AnalogNode this, int channel, int index, bool flip)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::set_output\n"
    "//       Access: Public\n"
    "//  Description: Causes a particular analog control to be placed in\n"
    "//               the data graph for the indicated channel.  Normally,\n"
    "//               a mouse uses channels 0 and 1 for the X and Y\n"
    "//               information, respectively; channels 0, 1, and 2 are\n"
    "//               available.  If flip is true, the analog control value\n"
    "//               will be reversed before outputting it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_set_output_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnalogNode::clear_output(int channel)
 *******************************************************************/
static PyObject *Dtool_AnalogNode_clear_output_18(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnalogNode::clear_output(int channel)
        int param1;
        static char * key_word_list[] = {(char *)"channel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearOutput", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearOutput", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_output((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnalogNode.clearOutput() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearOutput(non-const AnalogNode this, int channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_clear_output_18_comment =
    "C++ Interface:\n"
    "clearOutput(non-const AnalogNode this, int channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::clear_output\n"
    "//       Access: Public\n"
    "//  Description: Removes the output to the data graph associated with\n"
    "//               the indicated channel.  See set_output().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_clear_output_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnalogNode::get_output(int channel) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_get_output_19(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnalogNode::get_output(int channel) const
        int param1;
        static char * key_word_list[] = {(char *)"channel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getOutput", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getOutput", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnalogNode*)local_this)->get_output((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOutput(const AnalogNode this, int channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_get_output_19_comment =
    "C++ Interface:\n"
    "getOutput(const AnalogNode this, int channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::get_output\n"
    "//       Access: Public\n"
    "//  Description: Returns the analog control index that is output to\n"
    "//               the data graph on the indicated channel, or -1 if no\n"
    "//               control is output on that channel.  See set_output().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_get_output_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnalogNode::is_output_flipped(int channel) const
 *******************************************************************/
static PyObject *Dtool_AnalogNode_is_output_flipped_20(PyObject *self, PyObject *args,PyObject *kwds) {
    AnalogNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnalogNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnalogNode::is_output_flipped(int channel) const
        int param1;
        static char * key_word_list[] = {(char *)"channel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isOutputFlipped", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isOutputFlipped", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnalogNode*)local_this)->is_output_flipped((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOutputFlipped(const AnalogNode this, int channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_is_output_flipped_20_comment =
    "C++ Interface:\n"
    "isOutputFlipped(const AnalogNode this, int channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnalogNode::is_output_flipped\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the analog control index that is\n"
    "//               output to the data graph on the indicated channel is\n"
    "//               flipped.  See set_output().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnalogNode_is_output_flipped_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnalogNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnalogNode_get_class_type_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnalogNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnalogNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnalogNode_get_class_type_21_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnalogNode_get_class_type_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnalogNode::AnalogNode(ClientBase *client, basic_string< char > const &device_name)
 *******************************************************************/
int  Dtool_Init_AnalogNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-AnalogNode::AnalogNode(ClientBase *client, basic_string< char > const &device_name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"client", (char *)"device_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:AnalogNode", key_word_list, &param0, &param1_str, &param1_len))
            {
                ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ClientBase, 0, "AnalogNode.AnalogNode", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    AnalogNode *return_value = new AnalogNode(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_AnalogNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnalogNode(non-const ClientBase client, string device_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AnalogNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnalogNode)
    {
        printf("AnalogNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnalogNode * local_this = (AnalogNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnalogNode)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnalogNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnalogNode)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (AnalogNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnalogNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (AnalogNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnalogNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnalogNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ButtonNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonNode::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonNode_is_valid_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonNode::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonNode*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const ButtonNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_is_valid_24_comment =
    "C++ Interface:\n"
    "isValid(const ButtonNode this)\n"
    "\n"
    "// Filename: buttonNode.I\n"
    "// Created by:  drose (12Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the ButtonNode is valid and\n"
    "//               connected to a server, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_is_valid_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ButtonNode::get_num_buttons(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonNode_get_num_buttons_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ButtonNode::get_num_buttons(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumButtons", key_word_list));
        else
            (PyArg_Parse(args, ":getNumButtons"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ButtonNode*)local_this)->get_num_buttons();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumButtons(const ButtonNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_get_num_buttons_25_comment =
    "C++ Interface:\n"
    "getNumButtons(const ButtonNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::get_num_buttons\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of buttons known to the\n"
    "//               ButtonNode.  This includes those buttons whose state\n"
    "//               has been seen, as well as buttons that have been\n"
    "//               associated with a ButtonHandle even if their state is\n"
    "//               unknown.  This number may change as more buttons are\n"
    "//               discovered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_get_num_buttons_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonNode::set_button_map(int index, ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_ButtonNode_set_button_map_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ButtonNode::set_button_map(int index, ButtonHandle button)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"button", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setButtonMap", key_word_list, &param1, &param2))
            {
                ButtonHandle *param2_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ButtonHandle, 2, "ButtonNode.setButtonMap", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_button_map((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ButtonNode.setButtonMap() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonMap(non-const ButtonNode this, int index, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_set_button_map_26_comment =
    "C++ Interface:\n"
    "setButtonMap(non-const ButtonNode this, int index, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::set_button_map\n"
    "//       Access: Public\n"
    "//  Description: Associates the indicated ButtonHandle with the button\n"
    "//               of the indicated index number.  When the given button\n"
    "//               index changes state, a corresponding ButtonEvent will\n"
    "//               be generated with the given ButtonHandle.  Pass\n"
    "//               ButtonHandle::none() to turn off any association.\n"
    "//\n"
    "//               It is not necessary to call this if you simply want\n"
    "//               to query the state of the various buttons by index\n"
    "//               number; this is only necessary in order to generate\n"
    "//               ButtonEvents when the buttons change state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_set_button_map_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ButtonHandle ButtonNode::get_button_map(int index) const
 *******************************************************************/
static PyObject *Dtool_ButtonNode_get_button_map_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ButtonHandle ButtonNode::get_button_map(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getButtonMap", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getButtonMap", &param1));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = ((const ButtonNode*)local_this)->get_button_map((int)param1);
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonMap(const ButtonNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_get_button_map_27_comment =
    "C++ Interface:\n"
    "getButtonMap(const ButtonNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::get_button_map\n"
    "//       Access: Public\n"
    "//  Description: Returns the ButtonHandle that was previously\n"
    "//               associated with the given index number by\n"
    "//               a call to set_button_map(), or ButtonHandle::none()\n"
    "//               if no button was associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_get_button_map_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonNode::get_button_state(int index) const
 *******************************************************************/
static PyObject *Dtool_ButtonNode_get_button_state_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonNode::get_button_state(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getButtonState", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getButtonState", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonNode*)local_this)->get_button_state((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonState(const ButtonNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_get_button_state_28_comment =
    "C++ Interface:\n"
    "getButtonState(const ButtonNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::get_button_state\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the indicated button (identified by\n"
    "//               its index number) is currently known to be down, or\n"
    "//               false if it is up or unknown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_get_button_state_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonNode::is_button_known(int index) const
 *******************************************************************/
static PyObject *Dtool_ButtonNode_is_button_known_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonNode::is_button_known(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isButtonKnown", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isButtonKnown", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonNode*)local_this)->is_button_known((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isButtonKnown(const ButtonNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_is_button_known_29_comment =
    "C++ Interface:\n"
    "isButtonKnown(const ButtonNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonNode::is_button_known\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the state of the indicated button is\n"
    "//               known, or false if we have never heard anything about\n"
    "//               this particular button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonNode_is_button_known_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ButtonNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ButtonNode_get_class_type_30(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ButtonNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ButtonNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonNode_get_class_type_30_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ButtonNode_get_class_type_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ButtonNode::ButtonNode(ClientBase *client, basic_string< char > const &device_name)
 *******************************************************************/
int  Dtool_Init_ButtonNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-ButtonNode::ButtonNode(ClientBase *client, basic_string< char > const &device_name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"client", (char *)"device_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:ButtonNode", key_word_list, &param0, &param1_str, &param1_len))
            {
                ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ClientBase, 0, "ButtonNode.ButtonNode", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ButtonNode *return_value = new ButtonNode(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ButtonNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ButtonNode(non-const ClientBase client, string device_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ButtonNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ButtonNode)
    {
        printf("ButtonNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ButtonNode * local_this = (ButtonNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ButtonNode)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ButtonNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ButtonNode)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (ButtonNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ButtonNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ButtonNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ButtonNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ButtonNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DialNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool DialNode::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_DialNode_is_valid_33(PyObject *self, PyObject *args,PyObject *kwds) {
    DialNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DialNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DialNode::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DialNode*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const DialNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DialNode_is_valid_33_comment =
    "C++ Interface:\n"
    "isValid(const DialNode this)\n"
    "\n"
    "// Filename: dialNode.I\n"
    "// Created by:  drose (12Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DialNode::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the DialNode is valid and\n"
    "//               connected to a server, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DialNode_is_valid_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DialNode::get_num_dials(void) const
 *******************************************************************/
static PyObject *Dtool_DialNode_get_num_dials_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DialNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DialNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DialNode::get_num_dials(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDials", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDials"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DialNode*)local_this)->get_num_dials();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDials(const DialNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DialNode_get_num_dials_34_comment =
    "C++ Interface:\n"
    "getNumDials(const DialNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DialNode::get_num_dials\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of dial dials known to the\n"
    "//               DialNode.  This number may change as more dials\n"
    "//               are discovered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DialNode_get_num_dials_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double DialNode::read_dial(int index)
 *******************************************************************/
static PyObject *Dtool_DialNode_read_dial_35(PyObject *self, PyObject *args,PyObject *kwds) {
    DialNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DialNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double DialNode::read_dial(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:readDial", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:readDial", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->read_dial((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DialNode.readDial() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readDial(non-const DialNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DialNode_read_dial_35_comment =
    "C++ Interface:\n"
    "readDial(non-const DialNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DialNode::read_dial\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of complete revolutions of the\n"
    "//               dial since the last time read_dial() was called.\n"
    "//               This is a destructive operation; it is not possible\n"
    "//               to read the dial without resetting the counter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DialNode_read_dial_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DialNode::is_dial_known(int index) const
 *******************************************************************/
static PyObject *Dtool_DialNode_is_dial_known_36(PyObject *self, PyObject *args,PyObject *kwds) {
    DialNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DialNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DialNode::is_dial_known(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isDialKnown", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isDialKnown", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DialNode*)local_this)->is_dial_known((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDialKnown(const DialNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DialNode_is_dial_known_36_comment =
    "C++ Interface:\n"
    "isDialKnown(const DialNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DialNode::is_dial_known\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the state of the indicated dial\n"
    "//               dial is known, or false if we have never heard\n"
    "//               anything about this particular dial.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DialNode_is_dial_known_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DialNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DialNode_get_class_type_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DialNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DialNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DialNode_get_class_type_37_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DialNode_get_class_type_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DialNode::DialNode(ClientBase *client, basic_string< char > const &device_name)
 *******************************************************************/
int  Dtool_Init_DialNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DialNode::DialNode(ClientBase *client, basic_string< char > const &device_name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"client", (char *)"device_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:DialNode", key_word_list, &param0, &param1_str, &param1_len))
            {
                ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ClientBase, 0, "DialNode.DialNode", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    DialNode *return_value = new DialNode(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DialNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DialNode(non-const ClientBase client, string device_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DialNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DialNode)
    {
        printf("DialNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DialNode * local_this = (DialNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DialNode)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DialNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DialNode)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (DialNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DialNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (DialNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DialNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (DialNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseAndKeyboard 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
 *******************************************************************/
static PyObject *Dtool_MouseAndKeyboard_set_source_40(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseAndKeyboard * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseAndKeyboard,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"window", (char *)"device", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setSource", key_word_list, &param1, &param2))
            {
                GraphicsWindow *param1_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsWindow, 1, "MouseAndKeyboard.setSource", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_source(param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseAndKeyboard.setSource() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSource(non-const MouseAndKeyboard this, non-const GraphicsWindow window, int device)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseAndKeyboard_set_source_40_comment =
    "C++ Interface:\n"
    "setSource(non-const MouseAndKeyboard this, non-const GraphicsWindow window, int device)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseAndKeyboard::set_source\n"
    "//       Access: Public\n"
    "//  Description: Redirects the class to get the data from the mouse\n"
    "//               and keyboard associated with a different window\n"
    "//               and/or device number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseAndKeyboard_set_source_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseAndKeyboard::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseAndKeyboard_get_class_type_41(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseAndKeyboard::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseAndKeyboard::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseAndKeyboard_get_class_type_41_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseAndKeyboard_get_class_type_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_MouseAndKeyboard(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, basic_string< char > const &name)
            PyObject *param0;
            int param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"window", (char *)"device", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Ois#:MouseAndKeyboard", key_word_list, &param0, &param1, &param2_str, &param2_len))
            {
                GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsWindow, 0, "MouseAndKeyboard.MouseAndKeyboard", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    MouseAndKeyboard *return_value = new MouseAndKeyboard(param0_this, (int)param1, basic_string<char>(param2_str, param2_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseAndKeyboard,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MouseAndKeyboard(non-const GraphicsWindow window, int device, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MouseAndKeyboard(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseAndKeyboard)
    {
        printf("MouseAndKeyboard ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseAndKeyboard * local_this = (MouseAndKeyboard *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseAndKeyboard)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseAndKeyboard(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseAndKeyboard)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (MouseAndKeyboard*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseAndKeyboard*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MouseAndKeyboard*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseAndKeyboard*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseAndKeyboard*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TrackerNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool TrackerNode::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_is_valid_45(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TrackerNode::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TrackerNode*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_is_valid_45_comment =
    "C++ Interface:\n"
    "isValid(const TrackerNode this)\n"
    "\n"
    "// Filename: trackerNode.I\n"
    "// Created by:  drose (12Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the TrackerNode is valid and\n"
    "//               connected to a server, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_is_valid_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &TrackerNode::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_pos_46(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &TrackerNode::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const TrackerNode*)local_this)->get_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_pos_46_comment =
    "C++ Interface:\n"
    "getPos(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_pos\n"
    "//       Access: Public\n"
    "//  Description: Returns the current position of the tracker, if it is\n"
    "//               available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_pos_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LOrientationf const &TrackerNode::get_orient(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_orient_47(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LOrientationf const &TrackerNode::get_orient(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrient", key_word_list));
        else
            (PyArg_Parse(args, ":getOrient"));
        if(!PyErr_Occurred())
        {
            LOrientationf const *return_value = &(((const TrackerNode*)local_this)->get_orient());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LOrientationf,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrient(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_orient_47_comment =
    "C++ Interface:\n"
    "getOrient(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_orient\n"
    "//       Access: Public\n"
    "//  Description: Returns the current orientation of the tracker, if it\n"
    "//               is available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_orient_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &TrackerNode::get_transform(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_transform_48(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &TrackerNode::get_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getTransform"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const TrackerNode*)local_this)->get_transform());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTransform(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_transform_48_comment =
    "C++ Interface:\n"
    "getTransform(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_transform\n"
    "//       Access: Public\n"
    "//  Description: Returns the current position and orientation of the\n"
    "//               tracker, as a combined matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_transform_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double TrackerNode::get_time(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_time_49(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double TrackerNode::get_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTime", key_word_list));
        else
            (PyArg_Parse(args, ":getTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const TrackerNode*)local_this)->get_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTime(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_time_49_comment =
    "C++ Interface:\n"
    "getTime(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_time\n"
    "//       Access: Public\n"
    "//  Description: Returns the time of the tracker's last update.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_time_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool TrackerNode::has_time(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_has_time_50(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool TrackerNode::has_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTime", key_word_list));
        else
            (PyArg_Parse(args, ":hasTime"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const TrackerNode*)local_this)->has_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTime(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_has_time_50_comment =
    "C++ Interface:\n"
    "hasTime(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::has_time\n"
    "//       Access: Public\n"
    "//  Description: True if this data comes with timestamps.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_has_time_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_TrackerNode_set_tracker_coordinate_system_51(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTrackerCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTrackerCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tracker_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TrackerNode.setTrackerCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTrackerCoordinateSystem(non-const TrackerNode this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_set_tracker_coordinate_system_51_comment =
    "C++ Interface:\n"
    "setTrackerCoordinateSystem(non-const TrackerNode this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::set_tracker_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Specifies the coordinate system that the tracker\n"
    "//               associated with this node will operate in.  Normally,\n"
    "//               this is set from the ClientBase that's used to create\n"
    "//               the TrackerNode, so it should not need to be set on\n"
    "//               an individual tracker basis.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_set_tracker_coordinate_system_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_tracker_coordinate_system_52(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrackerCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getTrackerCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const TrackerNode*)local_this)->get_tracker_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrackerCoordinateSystem(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_tracker_coordinate_system_52_comment =
    "C++ Interface:\n"
    "getTrackerCoordinateSystem(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_tracker_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate system that the tracker\n"
    "//               associated with this node will operate in.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_tracker_coordinate_system_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_TrackerNode_set_graph_coordinate_system_53(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setGraphCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setGraphCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_graph_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TrackerNode.setGraphCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGraphCoordinateSystem(non-const TrackerNode this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_set_graph_coordinate_system_53_comment =
    "C++ Interface:\n"
    "setGraphCoordinateSystem(non-const TrackerNode this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::set_graph_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Specifies the coordinate system that the TrackerNode\n"
    "//               will convert its transform into for passing down the\n"
    "//               data graph.  Normally, this is CS_default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_set_graph_coordinate_system_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_graph_coordinate_system_54(PyObject *self, PyObject *args,PyObject *kwds) {
    TrackerNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TrackerNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGraphCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getGraphCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const TrackerNode*)local_this)->get_graph_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGraphCoordinateSystem(const TrackerNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_graph_coordinate_system_54_comment =
    "C++ Interface:\n"
    "getGraphCoordinateSystem(const TrackerNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TrackerNode::get_graph_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate system that the TrackerNode\n"
    "//               will convert its transform into for passing down the\n"
    "//               data graph.  Normally, this is CS_default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TrackerNode_get_graph_coordinate_system_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TrackerNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TrackerNode_get_class_type_55(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TrackerNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TrackerNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TrackerNode_get_class_type_55_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TrackerNode_get_class_type_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TrackerNode::TrackerNode(ClientBase *client, basic_string< char > const &device_name)
 *******************************************************************/
int  Dtool_Init_TrackerNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-TrackerNode::TrackerNode(ClientBase *client, basic_string< char > const &device_name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"client", (char *)"device_name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:TrackerNode", key_word_list, &param0, &param1_str, &param1_len))
            {
                ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ClientBase, 0, "TrackerNode.TrackerNode", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    TrackerNode *return_value = new TrackerNode(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_TrackerNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TrackerNode(non-const ClientBase client, string device_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TrackerNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TrackerNode)
    {
        printf("TrackerNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TrackerNode * local_this = (TrackerNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TrackerNode)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TrackerNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TrackerNode)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (TrackerNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (TrackerNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (TrackerNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TrackerNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (TrackerNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. VirtualMouse 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void VirtualMouse::set_mouse_pos(int x, int y)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_set_mouse_pos_58(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualMouse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualMouse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void VirtualMouse::set_mouse_pos(int x, int y)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setMousePos", key_word_list, &param1, &param2))
        {
            (local_this)->set_mouse_pos((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call VirtualMouse.setMousePos() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMousePos(non-const VirtualMouse this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_set_mouse_pos_58_comment =
    "C++ Interface:\n"
    "setMousePos(non-const VirtualMouse this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualMouse::set_mouse_pos\n"
    "//       Access: Published\n"
    "//  Description: Sets the current mouse pixel location, where (0,0) is\n"
    "//               the upper left, and (width-1, height-1) is the lower\n"
    "//               right pixel of the virtual window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualMouse_set_mouse_pos_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualMouse::set_window_size(int width, int height)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_set_window_size_59(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualMouse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualMouse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void VirtualMouse::set_window_size(int width, int height)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setWindowSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_window_size((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call VirtualMouse.setWindowSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWindowSize(non-const VirtualMouse this, int width, int height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_set_window_size_59_comment =
    "C++ Interface:\n"
    "setWindowSize(non-const VirtualMouse this, int width, int height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualMouse::set_window_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the size of the \"window\" in which the mouse\n"
    "//               rolls.  This changes the meaning of the values passed\n"
    "//               to set_mouse_pos().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualMouse_set_window_size_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualMouse::set_mouse_on(bool flag)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_set_mouse_on_60(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualMouse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualMouse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void VirtualMouse::set_mouse_on(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMouseOn", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMouseOn", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mouse_on((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call VirtualMouse.setMouseOn() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMouseOn(non-const VirtualMouse this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_set_mouse_on_60_comment =
    "C++ Interface:\n"
    "setMouseOn(non-const VirtualMouse this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualMouse::set_mouse_on\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the mouse should appear to be within the\n"
    "//               window or not.  If this is true, the mouse is within\n"
    "//               the window; if false, the mouse is not within the\n"
    "//               window (and set_mouse_pos() means nothing).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualMouse_set_mouse_on_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualMouse::press_button(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_press_button_61(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualMouse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualMouse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void VirtualMouse::press_button(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pressButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pressButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "VirtualMouse.pressButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->press_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call VirtualMouse.pressButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pressButton(non-const VirtualMouse this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_press_button_61_comment =
    "C++ Interface:\n"
    "pressButton(non-const VirtualMouse this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualMouse::press_button\n"
    "//       Access: Published\n"
    "//  Description: Simulates a mouse or keyboard button being depressed.\n"
    "//               This should be followed up by a call to\n"
    "//               release_button() sometime later (possibly\n"
    "//               immediately).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualMouse_press_button_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VirtualMouse::release_button(ButtonHandle button)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_release_button_62(PyObject *self, PyObject *args,PyObject *kwds) {
    VirtualMouse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VirtualMouse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void VirtualMouse::release_button(ButtonHandle button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:releaseButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:releaseButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "VirtualMouse.releaseButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->release_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call VirtualMouse.releaseButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseButton(non-const VirtualMouse this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_release_button_62_comment =
    "C++ Interface:\n"
    "releaseButton(non-const VirtualMouse this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VirtualMouse::release_button\n"
    "//       Access: Published\n"
    "//  Description: Simulates the button being released.  This should\n"
    "//               follow a previous call to press_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VirtualMouse_release_button_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VirtualMouse::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VirtualMouse_get_class_type_63(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VirtualMouse::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VirtualMouse::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VirtualMouse_get_class_type_63_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VirtualMouse_get_class_type_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * VirtualMouse::VirtualMouse(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_VirtualMouse(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-VirtualMouse::VirtualMouse(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:VirtualMouse", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:VirtualMouse", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            VirtualMouse *return_value = new VirtualMouse(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_VirtualMouse,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VirtualMouse(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_VirtualMouse(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VirtualMouse)
    {
        printf("VirtualMouse ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VirtualMouse * local_this = (VirtualMouse *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VirtualMouse)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VirtualMouse(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VirtualMouse)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (VirtualMouse*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (VirtualMouse*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (VirtualMouse*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VirtualMouse*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (VirtualMouse*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ClientBase | ClientBase
//********************************************************************
PyMethodDef Dtool_Methods_ClientBase[]= {
  { "forkAsynchronousThread",(PyCFunction ) &Dtool_ClientBase_fork_asynchronous_thread_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_fork_asynchronous_thread_3_comment},
  { "isForked",(PyCFunction ) &Dtool_ClientBase_is_forked_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_is_forked_4_comment},
  { "poll",(PyCFunction ) &Dtool_ClientBase_poll_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_poll_5_comment},
  { "getLastPollTime",(PyCFunction ) &Dtool_ClientBase_get_last_poll_time_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_get_last_poll_time_6_comment},
  { "setCoordinateSystem",(PyCFunction ) &Dtool_ClientBase_set_coordinate_system_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_set_coordinate_system_7_comment},
  { "getCoordinateSystem",(PyCFunction ) &Dtool_ClientBase_get_coordinate_system_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_get_coordinate_system_8_comment},
  { "getClassType",(PyCFunction ) &Dtool_ClientBase_get_class_type_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClientBase_get_class_type_9_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ClientBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ClientBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ClientBase\n"
          "// Description : An abstract base class for a family of client\n"
          "//               device interfaces--including trackers, buttons,\n"
          "//               dials, and other analog inputs.\n"
          "//\n"
          "//               This provides a common interface to connect to such\n"
          "//               devices and extract their data; it is used by\n"
          "//               TrackerNode etc. to put these devices in the data\n"
          "//               graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ClientBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_ClientBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ClientBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ClientBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ClientBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ClientBase)");
             printf(" Error In PyType_ReadyClientBase");
             return;
        }
        Py_INCREF(&Dtool_ClientBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ClientBase.As_PyTypeObject().tp_dict,"ClientBase",&Dtool_ClientBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ClientBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ClientBase[6],&Dtool_ClientBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ClientBase,ClientBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ClientBase.As_PyTypeObject());
        PyModule_AddObject(module, "ClientBase",(PyObject *)&Dtool_ClientBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnalogNode | AnalogNode
//********************************************************************
PyMethodDef Dtool_Methods_AnalogNode[]= {
  { "isValid",(PyCFunction ) &Dtool_AnalogNode_is_valid_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_is_valid_13_comment},
  { "getNumControls",(PyCFunction ) &Dtool_AnalogNode_get_num_controls_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_get_num_controls_14_comment},
  { "getControlState",(PyCFunction ) &Dtool_AnalogNode_get_control_state_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_get_control_state_15_comment},
  { "isControlKnown",(PyCFunction ) &Dtool_AnalogNode_is_control_known_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_is_control_known_16_comment},
  { "setOutput",(PyCFunction ) &Dtool_AnalogNode_set_output_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_set_output_17_comment},
  { "clearOutput",(PyCFunction ) &Dtool_AnalogNode_clear_output_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_clear_output_18_comment},
  { "getOutput",(PyCFunction ) &Dtool_AnalogNode_get_output_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_get_output_19_comment},
  { "isOutputFlipped",(PyCFunction ) &Dtool_AnalogNode_is_output_flipped_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_is_output_flipped_20_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnalogNode_get_class_type_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnalogNode_get_class_type_21_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnalogNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnalogNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnalogNode\n"
          "// Description : This is the primary interface to analog controls like\n"
          "//               sliders and joysticks associated with a ClientBase.\n"
          "//               This creates a node that connects to the named analog\n"
          "//               device, if it exists, and provides hooks to the user\n"
          "//               to read the state of any of the sequentially numbered\n"
          "//               controls associated with that device.\n"
          "//\n"
          "//               Each control can return a value ranging from -1 to 1,\n"
          "//               reflecting the current position of the control within\n"
          "//               its total range of motion.\n"
          "//\n"
          "//               The user may choose up to two analog controls to\n"
          "//               place on the data graph as the two channels of an\n"
          "//               xy datagram, similarly to the way a mouse places its\n"
          "//               position data.  In this way, an AnalogNode may be\n"
          "//               used in place of a mouse.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_AnalogNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_AnalogNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnalogNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnalogNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnalogNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnalogNode)");
             printf(" Error In PyType_ReadyAnalogNode");
             return;
        }
        Py_INCREF(&Dtool_AnalogNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnalogNode.As_PyTypeObject().tp_dict,"AnalogNode",&Dtool_AnalogNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnalogNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnalogNode[8],&Dtool_AnalogNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnalogNode,AnalogNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnalogNode.As_PyTypeObject());
        PyModule_AddObject(module, "AnalogNode",(PyObject *)&Dtool_AnalogNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ButtonNode | ButtonNode
//********************************************************************
PyMethodDef Dtool_Methods_ButtonNode[]= {
  { "isValid",(PyCFunction ) &Dtool_ButtonNode_is_valid_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_is_valid_24_comment},
  { "getNumButtons",(PyCFunction ) &Dtool_ButtonNode_get_num_buttons_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_get_num_buttons_25_comment},
  { "setButtonMap",(PyCFunction ) &Dtool_ButtonNode_set_button_map_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_set_button_map_26_comment},
  { "getButtonMap",(PyCFunction ) &Dtool_ButtonNode_get_button_map_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_get_button_map_27_comment},
  { "getButtonState",(PyCFunction ) &Dtool_ButtonNode_get_button_state_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_get_button_state_28_comment},
  { "isButtonKnown",(PyCFunction ) &Dtool_ButtonNode_is_button_known_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_is_button_known_29_comment},
  { "getClassType",(PyCFunction ) &Dtool_ButtonNode_get_class_type_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonNode_get_class_type_30_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ButtonNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ButtonNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ButtonNode\n"
          "// Description : This is the primary interface to on/off button\n"
          "//               devices associated with a ClientBase.  This creates a\n"
          "//               node that connects to the named button device, if it\n"
          "//               exists, and provides hooks to the user to read the\n"
          "//               state of any of the sequentially numbered buttons\n"
          "//               associated with that device.\n"
          "//\n"
          "//               It also can associate an arbitrary ButtonHandle with\n"
          "//               each button; when buttons are associated with\n"
          "//               ButtonHandles, this node will put appropriate up and\n"
          "//               down events on the data graph for each button state\n"
          "//               change.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_ButtonNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_ButtonNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ButtonNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ButtonNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ButtonNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ButtonNode)");
             printf(" Error In PyType_ReadyButtonNode");
             return;
        }
        Py_INCREF(&Dtool_ButtonNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ButtonNode.As_PyTypeObject().tp_dict,"ButtonNode",&Dtool_ButtonNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ButtonNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ButtonNode[6],&Dtool_ButtonNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ButtonNode,ButtonNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ButtonNode.As_PyTypeObject());
        PyModule_AddObject(module, "ButtonNode",(PyObject *)&Dtool_ButtonNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DialNode | DialNode
//********************************************************************
PyMethodDef Dtool_Methods_DialNode[]= {
  { "isValid",(PyCFunction ) &Dtool_DialNode_is_valid_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DialNode_is_valid_33_comment},
  { "getNumDials",(PyCFunction ) &Dtool_DialNode_get_num_dials_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DialNode_get_num_dials_34_comment},
  { "readDial",(PyCFunction ) &Dtool_DialNode_read_dial_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DialNode_read_dial_35_comment},
  { "isDialKnown",(PyCFunction ) &Dtool_DialNode_is_dial_known_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DialNode_is_dial_known_36_comment},
  { "getClassType",(PyCFunction ) &Dtool_DialNode_get_class_type_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DialNode_get_class_type_37_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DialNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DialNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DialNode\n"
          "// Description : This is the primary interface to infinite dial type\n"
          "//               devices associated with a ClientBase.  This creates a\n"
          "//               node that connects to the named dial device, if it\n"
          "//               exists, and provides hooks to the user to read the\n"
          "//               state of any of the sequentially numbered dial\n"
          "//               controls associated with that device.\n"
          "//\n"
          "//               A dial is a rotating device that does not have\n"
          "//               stops--it can keep rotating any number of times.\n"
          "//               Therefore it does not have a specific position at any\n"
          "//               given time, unlike an AnalogDevice.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_DialNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_DialNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DialNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DialNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DialNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DialNode)");
             printf(" Error In PyType_ReadyDialNode");
             return;
        }
        Py_INCREF(&Dtool_DialNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DialNode.As_PyTypeObject().tp_dict,"DialNode",&Dtool_DialNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DialNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DialNode[4],&Dtool_DialNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DialNode,DialNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DialNode.As_PyTypeObject());
        PyModule_AddObject(module, "DialNode",(PyObject *)&Dtool_DialNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseAndKeyboard | MouseAndKeyboard
//********************************************************************
PyMethodDef Dtool_Methods_MouseAndKeyboard[]= {
  { "setSource",(PyCFunction ) &Dtool_MouseAndKeyboard_set_source_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseAndKeyboard_set_source_40_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseAndKeyboard_get_class_type_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseAndKeyboard_get_class_type_41_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseAndKeyboard(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseAndKeyboard.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseAndKeyboard\n"
          "// Description : Reads the mouse and/or keyboard data sent from a\n"
          "//               GraphicsWindow, and transmits it down the data graph.\n"
          "//\n"
          "//               The mouse and keyboard devices are bundled together\n"
          "//               into one device here, because they interrelate so\n"
          "//               much.  A mouse might be constrained by the holding\n"
          "//               down of the shift key, for instance, or the clicking\n"
          "//               of the mouse button might be handled in much the same\n"
          "//               way as a keyboard key.\n"
          "//\n"
          "//               Mouse data is sent down the data graph as an x,y\n"
          "//               position as well as the set of buttons currently\n"
          "//               being held down; keyboard data is sent down as a set\n"
          "//               of keypress events in an EventDataTransition.  To\n"
          "//               throw these events to the system, you must attach an\n"
          "//               EventThrower to the MouseAndKeyboard object;\n"
          "//               otherwise, the events will be discarded.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_MouseAndKeyboard.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_MouseAndKeyboard.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseAndKeyboard.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseAndKeyboard.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseAndKeyboard.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseAndKeyboard)");
             printf(" Error In PyType_ReadyMouseAndKeyboard");
             return;
        }
        Py_INCREF(&Dtool_MouseAndKeyboard.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseAndKeyboard.As_PyTypeObject().tp_dict,"MouseAndKeyboard",&Dtool_MouseAndKeyboard.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseAndKeyboard.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseAndKeyboard[1],&Dtool_MouseAndKeyboard.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseAndKeyboard,MouseAndKeyboard::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseAndKeyboard.As_PyTypeObject());
        PyModule_AddObject(module, "MouseAndKeyboard",(PyObject *)&Dtool_MouseAndKeyboard.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TrackerNode | TrackerNode
//********************************************************************
PyMethodDef Dtool_Methods_TrackerNode[]= {
  { "isValid",(PyCFunction ) &Dtool_TrackerNode_is_valid_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_is_valid_45_comment},
  { "getPos",(PyCFunction ) &Dtool_TrackerNode_get_pos_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_pos_46_comment},
  { "getOrient",(PyCFunction ) &Dtool_TrackerNode_get_orient_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_orient_47_comment},
  { "getTransform",(PyCFunction ) &Dtool_TrackerNode_get_transform_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_transform_48_comment},
  { "getTime",(PyCFunction ) &Dtool_TrackerNode_get_time_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_time_49_comment},
  { "hasTime",(PyCFunction ) &Dtool_TrackerNode_has_time_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_has_time_50_comment},
  { "setTrackerCoordinateSystem",(PyCFunction ) &Dtool_TrackerNode_set_tracker_coordinate_system_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_set_tracker_coordinate_system_51_comment},
  { "getTrackerCoordinateSystem",(PyCFunction ) &Dtool_TrackerNode_get_tracker_coordinate_system_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_tracker_coordinate_system_52_comment},
  { "setGraphCoordinateSystem",(PyCFunction ) &Dtool_TrackerNode_set_graph_coordinate_system_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_set_graph_coordinate_system_53_comment},
  { "getGraphCoordinateSystem",(PyCFunction ) &Dtool_TrackerNode_get_graph_coordinate_system_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_graph_coordinate_system_54_comment},
  { "getClassType",(PyCFunction ) &Dtool_TrackerNode_get_class_type_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TrackerNode_get_class_type_55_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TrackerNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TrackerNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TrackerNode\n"
          "// Description : This is the primary interface to a Tracker object\n"
          "//               associated with a ClientBase.  It reads the position\n"
          "//               and orientation information from the tracker and\n"
          "//               makes it available as a transformation on the data\n"
          "//               graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_TrackerNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_TrackerNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TrackerNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TrackerNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TrackerNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TrackerNode)");
             printf(" Error In PyType_ReadyTrackerNode");
             return;
        }
        Py_INCREF(&Dtool_TrackerNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TrackerNode.As_PyTypeObject().tp_dict,"TrackerNode",&Dtool_TrackerNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TrackerNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TrackerNode[10],&Dtool_TrackerNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TrackerNode,TrackerNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TrackerNode.As_PyTypeObject());
        PyModule_AddObject(module, "TrackerNode",(PyObject *)&Dtool_TrackerNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. VirtualMouse | VirtualMouse
//********************************************************************
PyMethodDef Dtool_Methods_VirtualMouse[]= {
  { "setMousePos",(PyCFunction ) &Dtool_VirtualMouse_set_mouse_pos_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_set_mouse_pos_58_comment},
  { "setWindowSize",(PyCFunction ) &Dtool_VirtualMouse_set_window_size_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_set_window_size_59_comment},
  { "setMouseOn",(PyCFunction ) &Dtool_VirtualMouse_set_mouse_on_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_set_mouse_on_60_comment},
  { "pressButton",(PyCFunction ) &Dtool_VirtualMouse_press_button_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_press_button_61_comment},
  { "releaseButton",(PyCFunction ) &Dtool_VirtualMouse_release_button_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_release_button_62_comment},
  { "getClassType",(PyCFunction ) &Dtool_VirtualMouse_get_class_type_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VirtualMouse_get_class_type_63_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_VirtualMouse(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VirtualMouse.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VirtualMouse\n"
          "// Description : Poses as a MouseAndKeyboard object in the datagraph,\n"
          "//               but accepts input from user calls, rather than\n"
          "//               reading the actual mouse and keyboard from an input\n"
          "//               device.  The user can write high-level code to put\n"
          "//               the mouse wherever he/she wants, and to insert\n"
          "//               keypresses on demand.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_VirtualMouse.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_VirtualMouse.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VirtualMouse.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VirtualMouse.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_VirtualMouse.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VirtualMouse)");
             printf(" Error In PyType_ReadyVirtualMouse");
             return;
        }
        Py_INCREF(&Dtool_VirtualMouse.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VirtualMouse.As_PyTypeObject().tp_dict,"VirtualMouse",&Dtool_VirtualMouse.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VirtualMouse.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VirtualMouse[5],&Dtool_VirtualMouse.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VirtualMouse,VirtualMouse::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VirtualMouse.As_PyTypeObject());
        PyModule_AddObject(module, "VirtualMouse",(PyObject *)&Dtool_VirtualMouse.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..ClientBase
//********************************************************************
   Dtool_PyModuleClassInit_ClientBase(module);
//********************************************************************
//*** Module Init Updcall ..AnalogNode
//********************************************************************
   Dtool_PyModuleClassInit_AnalogNode(module);
//********************************************************************
//*** Module Init Updcall ..ButtonNode
//********************************************************************
   Dtool_PyModuleClassInit_ButtonNode(module);
//********************************************************************
//*** Module Init Updcall ..DialNode
//********************************************************************
   Dtool_PyModuleClassInit_DialNode(module);
//********************************************************************
//*** Module Init Updcall ..MouseAndKeyboard
//********************************************************************
   Dtool_PyModuleClassInit_MouseAndKeyboard(module);
//********************************************************************
//*** Module Init Updcall ..TrackerNode
//********************************************************************
   Dtool_PyModuleClassInit_TrackerNode(module);
//********************************************************************
//*** Module Init Updcall ..VirtualMouse
//********************************************************************
   Dtool_PyModuleClassInit_VirtualMouse(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdevice_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212879,  /* file_identifier */
  "libdevice",  /* library_name */
  "OfOP",  /* library_hash_name */
  "panda",  /* module_name */
  "libdevice.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  160  /* next_index */
};

Configure(_in_configure_libdevice);
ConfigureFn(_in_configure_libdevice) {
  interrogate_request_module(&_in_module_def);
}

