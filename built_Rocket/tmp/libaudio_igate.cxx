/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/audio -Ipanda/src/audio -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libaudio_igate.cxx -od built_Rocket/pandac/input/libaudio.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/audio -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libaudio audio.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libaudio
#include "py_panda.h"  

#include "audio.h"
#include "audioManager.h"
#include "audioSound.h"
#include "filterProperties.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. FilterProperties
//********************************************************************
typedef  FilterProperties  FilterProperties_localtype;
Define_Module_ClassRef(panda,FilterProperties,FilterProperties_localtype,FilterProperties);
//********************************************************************
//*** prototypes for .. AudioSound
//********************************************************************
typedef  AudioSound  AudioSound_localtype;
Define_Module_ClassRef(panda,AudioSound,AudioSound_localtype,AudioSound);
//********************************************************************
//*** prototypes for .. AudioManager
//********************************************************************
typedef  AudioManager  AudioManager_localtype;
Define_Module_ClassRef(panda,AudioManager,AudioManager_localtype,AudioManager);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MovieAudio;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. FilterProperties 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::clear(void)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_clear_4(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const FilterProperties this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_clear_4_comment =
    "C++ Interface:\n"
    "clear(non-const FilterProperties this)\n"
    "\n"
    "// Filename: filterProperties.I\n"
    "// Created by: jyelon (01Aug2007)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::clear\n"
    "//      Access: Published\n"
    "// Description: Removes all DSP postprocessing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_clear_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_lowpass(float cutoff_freq, float resonance_q)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_lowpass_5(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_lowpass(float cutoff_freq, float resonance_q)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"cutoff_freq", (char *)"resonance_q", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addLowpass", key_word_list, &param1, &param2))
        {
            (local_this)->add_lowpass((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addLowpass() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLowpass(non-const FilterProperties this, float cutoff_freq, float resonance_q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_lowpass_5_comment =
    "C++ Interface:\n"
    "addLowpass(non-const FilterProperties this, float cutoff_freq, float resonance_q)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::apply_lowpass\n"
    "//      Access: Published\n"
    "// Description: Add a lowpass filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_lowpass_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_highpass(float cutoff_freq, float resonance_q)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_highpass_6(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_highpass(float cutoff_freq, float resonance_q)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"cutoff_freq", (char *)"resonance_q", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addHighpass", key_word_list, &param1, &param2))
        {
            (local_this)->add_highpass((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addHighpass() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addHighpass(non-const FilterProperties this, float cutoff_freq, float resonance_q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_highpass_6_comment =
    "C++ Interface:\n"
    "addHighpass(non-const FilterProperties this, float cutoff_freq, float resonance_q)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_highpass\n"
    "//      Access: Published\n"
    "// Description: Add a highpass filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_highpass_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_echo(float drymix, float wetmix, float delay, float decayratio)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_echo_7(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_echo(float drymix, float wetmix, float delay, float decayratio)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"drymix", (char *)"wetmix", (char *)"delay", (char *)"decayratio", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:addEcho", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->add_echo((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addEcho() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addEcho(non-const FilterProperties this, float drymix, float wetmix, float delay, float decayratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_echo_7_comment =
    "C++ Interface:\n"
    "addEcho(non-const FilterProperties this, float drymix, float wetmix, float delay, float decayratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_echo\n"
    "//      Access: Published\n"
    "// Description: Add a echo filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_echo_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_flange(float drymix, float wetmix, float depth, float rate)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_flange_8(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_flange(float drymix, float wetmix, float depth, float rate)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"drymix", (char *)"wetmix", (char *)"depth", (char *)"rate", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:addFlange", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->add_flange((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addFlange() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFlange(non-const FilterProperties this, float drymix, float wetmix, float depth, float rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_flange_8_comment =
    "C++ Interface:\n"
    "addFlange(non-const FilterProperties this, float drymix, float wetmix, float depth, float rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_flange\n"
    "//      Access: Published\n"
    "// Description: Add a flange filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_flange_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_distort(float level)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_distort_9(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_distort(float level)
        double param1;
        static char * key_word_list[] = {(char *)"level", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addDistort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addDistort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_distort((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addDistort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addDistort(non-const FilterProperties this, float level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_distort_9_comment =
    "C++ Interface:\n"
    "addDistort(non-const FilterProperties this, float level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_distort\n"
    "//      Access: Published\n"
    "// Description: Add a distort filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_distort_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_normalize(float fadetime, float threshold, float maxamp)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_normalize_10(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_normalize(float fadetime, float threshold, float maxamp)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"fadetime", (char *)"threshold", (char *)"maxamp", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addNormalize", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->add_normalize((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addNormalize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addNormalize(non-const FilterProperties this, float fadetime, float threshold, float maxamp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_normalize_10_comment =
    "C++ Interface:\n"
    "addNormalize(non-const FilterProperties this, float fadetime, float threshold, float maxamp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_normalize\n"
    "//      Access: Published\n"
    "// Description: Add a normalize filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_normalize_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_parameq(float center_freq, float bandwidth, float gain)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_parameq_11(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_parameq(float center_freq, float bandwidth, float gain)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"center_freq", (char *)"bandwidth", (char *)"gain", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addParameq", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->add_parameq((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addParameq() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addParameq(non-const FilterProperties this, float center_freq, float bandwidth, float gain)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_parameq_11_comment =
    "C++ Interface:\n"
    "addParameq(non-const FilterProperties this, float center_freq, float bandwidth, float gain)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_parameq\n"
    "//      Access: Published\n"
    "// Description: Add a parameq filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_parameq_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_pitchshift(float pitch, float fftsize, float overlap)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_pitchshift_12(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_pitchshift(float pitch, float fftsize, float overlap)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"pitch", (char *)"fftsize", (char *)"overlap", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addPitchshift", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->add_pitchshift((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addPitchshift() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPitchshift(non-const FilterProperties this, float pitch, float fftsize, float overlap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_pitchshift_12_comment =
    "C++ Interface:\n"
    "addPitchshift(non-const FilterProperties this, float pitch, float fftsize, float overlap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_pitchshift\n"
    "//      Access: Published\n"
    "// Description: Add a pitchshift filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_pitchshift_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_chorus(float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth, float feedback)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_chorus_13(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_chorus(float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth, float feedback)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        static char * key_word_list[] = {(char *)"drymix", (char *)"wet1", (char *)"wet2", (char *)"wet3", (char *)"delay", (char *)"rate", (char *)"depth", (char *)"feedback", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddd:addChorus", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
        {
            (local_this)->add_chorus((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addChorus() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addChorus(non-const FilterProperties this, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth, float feedback)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_chorus_13_comment =
    "C++ Interface:\n"
    "addChorus(non-const FilterProperties this, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth, float feedback)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_chorus\n"
    "//      Access: Published\n"
    "// Description: Add a chorus filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_chorus_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_reverb(float drymix, float wetmix, float roomsize, float damp, float width)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_reverb_14(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_reverb(float drymix, float wetmix, float roomsize, float damp, float width)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        static char * key_word_list[] = {(char *)"drymix", (char *)"wetmix", (char *)"roomsize", (char *)"damp", (char *)"width", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddd:addReverb", key_word_list, &param1, &param2, &param3, &param4, &param5))
        {
            (local_this)->add_reverb((float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addReverb() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addReverb(non-const FilterProperties this, float drymix, float wetmix, float roomsize, float damp, float width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_reverb_14_comment =
    "C++ Interface:\n"
    "addReverb(non-const FilterProperties this, float drymix, float wetmix, float roomsize, float damp, float width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_reverb\n"
    "//      Access: Published\n"
    "// Description: Add a reverb filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_reverb_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void FilterProperties::add_compress(float threshold, float attack, float release, float gainmakeup)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_add_compress_15(PyObject *self, PyObject *args,PyObject *kwds) {
    FilterProperties * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FilterProperties,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FilterProperties::add_compress(float threshold, float attack, float release, float gainmakeup)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"threshold", (char *)"attack", (char *)"release", (char *)"gainmakeup", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:addCompress", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->add_compress((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FilterProperties.addCompress() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCompress(non-const FilterProperties this, float threshold, float attack, float release, float gainmakeup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_add_compress_15_comment =
    "C++ Interface:\n"
    "addCompress(non-const FilterProperties this, float threshold, float attack, float release, float gainmakeup)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function: FilterProperties::add_compress\n"
    "//      Access: Published\n"
    "// Description: Add a compress filter to the end of the DSP chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FilterProperties_add_compress_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FilterProperties::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FilterProperties_get_class_type_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FilterProperties::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FilterProperties::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FilterProperties_get_class_type_16_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FilterProperties_get_class_type_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FilterProperties::FilterProperties(void)
 *******************************************************************/
int  Dtool_Init_FilterProperties(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-FilterProperties::FilterProperties(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":FilterProperties", key_word_list))
        {
            FilterProperties *return_value = new FilterProperties();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_FilterProperties,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FilterProperties()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FilterProperties(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FilterProperties)
    {
        printf("FilterProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FilterProperties * local_this = (FilterProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FilterProperties)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FilterProperties(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FilterProperties)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FilterProperties*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FilterProperties*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (FilterProperties*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AudioSound 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::play(void) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_play_18(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::play(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":play", key_word_list));
        else
            (PyArg_Parse(args, ":play"));
        if(!PyErr_Occurred())
        {
            (local_this)->play();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.play() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "play(non-const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_play_18_comment =
    "C++ Interface:\n"
    "play(non-const AudioSound this)\n"
    "\n"
    "// For best compatability, set the loop_count,\n"
    "// volume, and balance, prior to calling play().  You may\n"
    "// set them while they're playing, but it's implementation\n"
    "// specific whether you get the results.\n"
    "// - Calling play() a second time on the same sound before it is\n"
    "//   finished will start the sound again (creating a skipping or\n"
    "//   stuttering effect).\n"
    "";
#else
static const char * Dtool_AudioSound_play_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::stop(void) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_stop_19(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::stop(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stop", key_word_list));
        else
            (PyArg_Parse(args, ":stop"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.stop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stop(non-const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_stop_19_comment =
    "C++ Interface:\n"
    "stop(non-const AudioSound this)\n"
    "\n"
    "// For best compatability, set the loop_count,\n"
    "// volume, and balance, prior to calling play().  You may\n"
    "// set them while they're playing, but it's implementation\n"
    "// specific whether you get the results.\n"
    "// - Calling play() a second time on the same sound before it is\n"
    "//   finished will start the sound again (creating a skipping or\n"
    "//   stuttering effect).\n"
    "";
#else
static const char * Dtool_AudioSound_stop_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_loop(bool loop) = 0
 * virtual void AudioSound::set_loop(bool loop = (1)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_loop_20(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_loop(bool loop = (1)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setLoop", key_word_list));
            else
                (PyArg_Parse(args, ":setLoop"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_loop();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setLoop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_loop(bool loop) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"loop", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLoop", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLoop", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_loop((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setLoop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLoop() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLoop(non-const AudioSound this)\n"
          "setLoop(non-const AudioSound this, bool loop)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_loop_20_comment =
    "C++ Interface:\n"
    "setLoop(non-const AudioSound this)\n"
    "setLoop(non-const AudioSound this, bool loop)\n"
    "\n"
    "// loop: false = play once; true = play forever.\n"
    "// inits to false.\n"
    "";
#else
static const char * Dtool_AudioSound_set_loop_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioSound::get_loop(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_loop_21(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool AudioSound::get_loop(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoop", key_word_list));
        else
            (PyArg_Parse(args, ":getLoop"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AudioSound*)local_this)->get_loop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoop(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_loop_21_comment =
    "C++ Interface:\n"
    "getLoop(const AudioSound this)\n"
    "\n"
    "// loop: false = play once; true = play forever.\n"
    "// inits to false.\n"
    "";
#else
static const char * Dtool_AudioSound_get_loop_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_loop_count(unsigned long int loop_count) = 0
 * virtual void AudioSound::set_loop_count(unsigned long int loop_count = (1)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_loop_count_22(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_loop_count(unsigned long int loop_count = (1)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setLoopCount", key_word_list));
            else
                (PyArg_Parse(args, ":setLoopCount"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_loop_count();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setLoopCount() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_loop_count(unsigned long int loop_count) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"loop_count", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLoopCount", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLoopCount", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->set_loop_count(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setLoopCount() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLoopCount() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLoopCount(non-const AudioSound this)\n"
          "setLoopCount(non-const AudioSound this, unsigned int loop_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_loop_count_22_comment =
    "C++ Interface:\n"
    "setLoopCount(non-const AudioSound this)\n"
    "setLoopCount(non-const AudioSound this, unsigned int loop_count)\n"
    "\n"
    "// loop_count: 0 = forever; 1 = play once; n = play n times.\n"
    "// inits to 1.\n"
    "";
#else
static const char * Dtool_AudioSound_set_loop_count_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual unsigned long int AudioSound::get_loop_count(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_loop_count_23(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual unsigned long int AudioSound::get_loop_count(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLoopCount", key_word_list));
        else
            (PyArg_Parse(args, ":getLoopCount"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = ((const AudioSound*)local_this)->get_loop_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLoopCount(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_loop_count_23_comment =
    "C++ Interface:\n"
    "getLoopCount(const AudioSound this)\n"
    "\n"
    "// loop_count: 0 = forever; 1 = play once; n = play n times.\n"
    "// inits to 1.\n"
    "";
#else
static const char * Dtool_AudioSound_get_loop_count_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_time(float start_time) = 0
 * virtual void AudioSound::set_time(float start_time = (0)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_time_24(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_time(float start_time = (0)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setTime", key_word_list));
            else
                (PyArg_Parse(args, ":setTime"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_time();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_time(float start_time) = 0
            double param1;
            static char * key_word_list[] = {(char *)"start_time", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTime", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setTime", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_time((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setTime() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setTime(non-const AudioSound this)\n"
          "setTime(non-const AudioSound this, float start_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_time_24_comment =
    "C++ Interface:\n"
    "setTime(non-const AudioSound this)\n"
    "setTime(non-const AudioSound this, float start_time)\n"
    "\n"
    "// Control time position within the sound.\n"
    "// This is similar (in concept) to the seek position within\n"
    "// a file.\n"
    "// time in seconds: 0 = beginning; length() = end.\n"
    "// inits to 0.0.\n"
    "// - The current time position will not change while the sound is\n"
    "//   playing; you must call play() again to effect the change.  To\n"
    "//   play the same sound from a time offset a second time,\n"
    "//   explicitly set the time position again.  When looping, the\n"
    "//   second and later loops will start from the beginning of the\n"
    "//   sound.\n"
    "// - If a sound is playing, calling get_time() repeatedly will\n"
    "//   return different results over time.  e.g.:\n"
    "//   float percent_complete = s.get_time() / s.length();\n"
    "";
#else
static const char * Dtool_AudioSound_set_time_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_time(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_time_25(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_time(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTime", key_word_list));
        else
            (PyArg_Parse(args, ":getTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTime(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_time_25_comment =
    "C++ Interface:\n"
    "getTime(const AudioSound this)\n"
    "\n"
    "// Control time position within the sound.\n"
    "// This is similar (in concept) to the seek position within\n"
    "// a file.\n"
    "// time in seconds: 0 = beginning; length() = end.\n"
    "// inits to 0.0.\n"
    "// - The current time position will not change while the sound is\n"
    "//   playing; you must call play() again to effect the change.  To\n"
    "//   play the same sound from a time offset a second time,\n"
    "//   explicitly set the time position again.  When looping, the\n"
    "//   second and later loops will start from the beginning of the\n"
    "//   sound.\n"
    "// - If a sound is playing, calling get_time() repeatedly will\n"
    "//   return different results over time.  e.g.:\n"
    "//   float percent_complete = s.get_time() / s.length();\n"
    "";
#else
static const char * Dtool_AudioSound_get_time_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_volume(float volume) = 0
 * virtual void AudioSound::set_volume(float volume = (1)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_volume_26(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_volume(float volume = (1)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setVolume", key_word_list));
            else
                (PyArg_Parse(args, ":setVolume"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_volume();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setVolume() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_volume(float volume) = 0
            double param1;
            static char * key_word_list[] = {(char *)"volume", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVolume", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setVolume", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_volume((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setVolume() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVolume() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVolume(non-const AudioSound this)\n"
          "setVolume(non-const AudioSound this, float volume)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_volume_26_comment =
    "C++ Interface:\n"
    "setVolume(non-const AudioSound this)\n"
    "setVolume(non-const AudioSound this, float volume)\n"
    "\n"
    "// 0 = minimum; 1.0 = maximum.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioSound_set_volume_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_volume(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_volume_27(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_volume(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVolume", key_word_list));
        else
            (PyArg_Parse(args, ":getVolume"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_volume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVolume(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_volume_27_comment =
    "C++ Interface:\n"
    "getVolume(const AudioSound this)\n"
    "\n"
    "// 0 = minimum; 1.0 = maximum.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioSound_get_volume_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_balance(float balance_right) = 0
 * virtual void AudioSound::set_balance(float balance_right = (0)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_balance_28(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_balance(float balance_right = (0)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setBalance", key_word_list));
            else
                (PyArg_Parse(args, ":setBalance"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_balance();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setBalance() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_balance(float balance_right) = 0
            double param1;
            static char * key_word_list[] = {(char *)"balance_right", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBalance", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setBalance", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_balance((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setBalance() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setBalance() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setBalance(non-const AudioSound this)\n"
          "setBalance(non-const AudioSound this, float balance_right)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_balance_28_comment =
    "C++ Interface:\n"
    "setBalance(non-const AudioSound this)\n"
    "setBalance(non-const AudioSound this, float balance_right)\n"
    "\n"
    "// -1.0 is hard left\n"
    "// 0.0 is centered\n"
    "// 1.0 is hard right\n"
    "// inits to 0.0.\n"
    "";
#else
static const char * Dtool_AudioSound_set_balance_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_balance(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_balance_29(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_balance(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBalance", key_word_list));
        else
            (PyArg_Parse(args, ":getBalance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_balance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBalance(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_balance_29_comment =
    "C++ Interface:\n"
    "getBalance(const AudioSound this)\n"
    "\n"
    "// -1.0 is hard left\n"
    "// 0.0 is centered\n"
    "// 1.0 is hard right\n"
    "// inits to 0.0.\n"
    "";
#else
static const char * Dtool_AudioSound_get_balance_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_play_rate(float play_rate) = 0
 * virtual void AudioSound::set_play_rate(float play_rate = (1)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_play_rate_30(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_play_rate(float play_rate = (1)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setPlayRate", key_word_list));
            else
                (PyArg_Parse(args, ":setPlayRate"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_play_rate();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setPlayRate() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_play_rate(float play_rate) = 0
            double param1;
            static char * key_word_list[] = {(char *)"play_rate", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPlayRate", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setPlayRate", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_play_rate((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setPlayRate() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPlayRate() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPlayRate(non-const AudioSound this)\n"
          "setPlayRate(non-const AudioSound this, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_play_rate_30_comment =
    "C++ Interface:\n"
    "setPlayRate(non-const AudioSound this)\n"
    "setPlayRate(non-const AudioSound this, float play_rate)\n"
    "\n"
    "// play_rate is any positive float value.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioSound_set_play_rate_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_play_rate(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_play_rate_31(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_play_rate(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlayRate", key_word_list));
        else
            (PyArg_Parse(args, ":getPlayRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_play_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlayRate(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_play_rate_31_comment =
    "C++ Interface:\n"
    "getPlayRate(const AudioSound this)\n"
    "\n"
    "// play_rate is any positive float value.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioSound_get_play_rate_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_active(bool flag) = 0
 * virtual void AudioSound::set_active(bool flag = (1)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_active_32(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_active(bool flag = (1)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setActive", key_word_list));
            else
                (PyArg_Parse(args, ":setActive"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_active();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setActive() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_active(bool flag) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"flag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setActive", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_active((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setActive() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setActive() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setActive(non-const AudioSound this)\n"
          "setActive(non-const AudioSound this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_active_32_comment =
    "C++ Interface:\n"
    "setActive(non-const AudioSound this)\n"
    "setActive(non-const AudioSound this, bool flag)\n"
    "\n"
    "// inits to manager's state.\n"
    "";
#else
static const char * Dtool_AudioSound_set_active_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioSound::get_active(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_active_33(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool AudioSound::get_active(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AudioSound*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_active_33_comment =
    "C++ Interface:\n"
    "getActive(const AudioSound this)\n"
    "\n"
    "// inits to manager's state.\n"
    "";
#else
static const char * Dtool_AudioSound_get_active_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_finished_event(basic_string< char > const &event) = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_finished_event_34(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_finished_event(basic_string< char > const &event) = 0
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFinishedEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFinishedEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_finished_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.setFinishedEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinishedEvent(non-const AudioSound this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_finished_event_34_comment =
    "C++ Interface:\n"
    "setFinishedEvent(non-const AudioSound this, string event)\n"
    "\n"
    "// Set (or clear) the event that will be thrown when the sound\n"
    "// finishes playing.  To clear the event, pass an empty string.\n"
    "";
#else
static const char * Dtool_AudioSound_set_finished_event_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > const &AudioSound::get_finished_event(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_finished_event_35(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > const &AudioSound::get_finished_event(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinishedEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getFinishedEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const AudioSound*)local_this)->get_finished_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinishedEvent(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_finished_event_35_comment =
    "C++ Interface:\n"
    "getFinishedEvent(const AudioSound this)\n"
    "\n"
    "// Set (or clear) the event that will be thrown when the sound\n"
    "// finishes playing.  To clear the event, pass an empty string.\n"
    "";
#else
static const char * Dtool_AudioSound_get_finished_event_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual basic_string< char > const &AudioSound::get_name(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_name_36(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual basic_string< char > const &AudioSound::get_name(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const AudioSound*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_name_36_comment =
    "C++ Interface:\n"
    "getName(const AudioSound this)\n"
    "\n"
    "// There is no set_name(), this is intentional.\n"
    "";
#else
static const char * Dtool_AudioSound_get_name_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::length(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_length_37(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::length(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_length_37_comment =
    "C++ Interface:\n"
    "length(const AudioSound this)\n"
    "\n"
    "// return: playing time in seconds.\n"
    "";
#else
static const char * Dtool_AudioSound_length_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_3d_attributes(float px, float py, float pz, float vx, float vy, float vz)
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_3d_attributes_38(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_3d_attributes(float px, float py, float pz, float vx, float vy, float vz)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", (char *)"vx", (char *)"vy", (char *)"vz", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:set3dAttributes", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
        {
            (local_this)->set_3d_attributes((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.set3dAttributes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set3dAttributes(non-const AudioSound this, float px, float py, float pz, float vx, float vy, float vz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_3d_attributes_38_comment =
    "C++ Interface:\n"
    "set3dAttributes(non-const AudioSound this, float px, float py, float pz, float vx, float vy, float vz)\n"
    "\n"
    "// Controls the position of this sound's emitter.\n"
    "// px, py and pz are the emitter's position.\n"
    "// vx, vy and vz are the emitter's velocity in UNITS PER SECOND (default: meters).\n"
    "";
#else
static const char * Dtool_AudioSound_set_3d_attributes_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_3d_min_distance(float dist)
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_3d_min_distance_40(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_3d_min_distance(float dist)
        double param1;
        static char * key_word_list[] = {(char *)"dist", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:set3dMinDistance", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:set3dMinDistance", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_3d_min_distance((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.set3dMinDistance() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set3dMinDistance(non-const AudioSound this, float dist)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_3d_min_distance_40_comment =
    "C++ Interface:\n"
    "set3dMinDistance(non-const AudioSound this, float dist)\n"
    "\n"
    "// Controls the distance (in units) that this sound begins to fall off.\n"
    "// Also affects the rate it falls off.\n"
    "// Default is 1.0\n"
    "// Closer/Faster, <1.0\n"
    "// Farther/Slower, >1.0\n"
    "";
#else
static const char * Dtool_AudioSound_set_3d_min_distance_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_3d_min_distance(void) const
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_3d_min_distance_41(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_3d_min_distance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get3dMinDistance", key_word_list));
        else
            (PyArg_Parse(args, ":get3dMinDistance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_3d_min_distance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get3dMinDistance(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_3d_min_distance_41_comment =
    "C++ Interface:\n"
    "get3dMinDistance(const AudioSound this)\n"
    "\n"
    "// Controls the distance (in units) that this sound begins to fall off.\n"
    "// Also affects the rate it falls off.\n"
    "// Default is 1.0\n"
    "// Closer/Faster, <1.0\n"
    "// Farther/Slower, >1.0\n"
    "";
#else
static const char * Dtool_AudioSound_get_3d_min_distance_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_3d_max_distance(float dist)
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_3d_max_distance_42(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_3d_max_distance(float dist)
        double param1;
        static char * key_word_list[] = {(char *)"dist", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:set3dMaxDistance", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:set3dMaxDistance", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_3d_max_distance((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.set3dMaxDistance() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set3dMaxDistance(non-const AudioSound this, float dist)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_3d_max_distance_42_comment =
    "C++ Interface:\n"
    "set3dMaxDistance(non-const AudioSound this, float dist)\n"
    "\n"
    "// Controls the maximum distance (in units) that this sound stops falling off.\n"
    "// The sound does not stop at that point, it just doesn't get any quieter.\n"
    "// You should rarely need to adjust this.\n"
    "// Default is 1000000000.0\n"
    "";
#else
static const char * Dtool_AudioSound_set_3d_max_distance_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_3d_max_distance(void) const
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_3d_max_distance_43(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioSound::get_3d_max_distance(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":get3dMaxDistance", key_word_list));
        else
            (PyArg_Parse(args, ":get3dMaxDistance"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioSound*)local_this)->get_3d_max_distance();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get3dMaxDistance(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_3d_max_distance_43_comment =
    "C++ Interface:\n"
    "get3dMaxDistance(const AudioSound this)\n"
    "\n"
    "// Controls the maximum distance (in units) that this sound stops falling off.\n"
    "// The sound does not stop at that point, it just doesn't get any quieter.\n"
    "// You should rarely need to adjust this.\n"
    "// Default is 1000000000.0\n"
    "";
#else
static const char * Dtool_AudioSound_get_3d_max_distance_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_speaker_mix(int speaker)
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_speaker_mix_44(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual float AudioSound::get_speaker_mix(int speaker)
        int param1;
        static char * key_word_list[] = {(char *)"speaker", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSpeakerMix", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSpeakerMix", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_speaker_mix((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.getSpeakerMix() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeakerMix(non-const AudioSound this, int speaker)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_speaker_mix_44_comment =
    "C++ Interface:\n"
    "getSpeakerMix(non-const AudioSound this, int speaker)\n"
    "\n"
    "// *_speaker_mix and *_speaker_level(s) serve the same purpose.\n"
    "// *_speaker_mix is for use with FMOD.\n"
    "// *_speaker_level(s) is for use with Miles.\n"
    "// Both interfaces exist because of a significant difference in the\n"
    "// two APIs.  Hopefully the difference can be reconciled into a single\n"
    "// interface at some point.\n"
    "";
#else
static const char * Dtool_AudioSound_get_speaker_mix_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_speaker_mix(float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_speaker_mix_45(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_speaker_mix(float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        static char * key_word_list[] = {(char *)"frontleft", (char *)"frontright", (char *)"center", (char *)"sub", (char *)"backleft", (char *)"backright", (char *)"sideleft", (char *)"sideright", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddd:setSpeakerMix", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
        {
            (local_this)->set_speaker_mix((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.setSpeakerMix() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpeakerMix(non-const AudioSound this, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_speaker_mix_45_comment =
    "C++ Interface:\n"
    "setSpeakerMix(non-const AudioSound this, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n"
    "\n"
    "// *_speaker_mix and *_speaker_level(s) serve the same purpose.\n"
    "// *_speaker_mix is for use with FMOD.\n"
    "// *_speaker_level(s) is for use with Miles.\n"
    "// Both interfaces exist because of a significant difference in the\n"
    "// two APIs.  Hopefully the difference can be reconciled into a single\n"
    "// interface at some point.\n"
    "";
#else
static const char * Dtool_AudioSound_set_speaker_mix_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioSound::get_speaker_level(int index)
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_speaker_level_46(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual float AudioSound::get_speaker_level(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSpeakerLevel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSpeakerLevel", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_speaker_level((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.getSpeakerLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeakerLevel(non-const AudioSound this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_speaker_level_46_comment =
    "C++ Interface:\n"
    "getSpeakerLevel(non-const AudioSound this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_get_speaker_level_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7 = (-1), float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3 = (-1), float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
 * virtual void AudioSound::set_speaker_levels(float level1, float level2 = (-1), float level3 = (-1), float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_speaker_levels_47(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2 = (-1), float level3 = (-1), float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            static char * key_word_list[] = {(char *)"level1", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSpeakerLevels", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setSpeakerLevels", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_speaker_levels((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3 = (-1), float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setSpeakerLevels", key_word_list, &param1, &param2))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4 = (-1), float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5 = (-1), float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6 = (-1), float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", (char *)"level5", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7 = (-1), float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", (char *)"level5", (char *)"level6", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(7):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8 = (-1), float level9 = (-1))
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", (char *)"level5", (char *)"level6", (char *)"level7", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(8):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9 = (-1))
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", (char *)"level5", (char *)"level6", (char *)"level7", (char *)"level8", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(9):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioSound::set_speaker_levels(float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            double param9;
            static char * key_word_list[] = {(char *)"level1", (char *)"level2", (char *)"level3", (char *)"level4", (char *)"level5", (char *)"level6", (char *)"level7", (char *)"level8", (char *)"level9", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddd:setSpeakerLevels", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
            {
                (local_this)->set_speaker_levels((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.setSpeakerLevels() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setSpeakerLevels() takes 2, 3, 4, 5, 6, 7, 8, 9, or 10 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setSpeakerLevels(non-const AudioSound this, float level1)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8)\n"
          "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_speaker_levels_47_comment =
    "C++ Interface:\n"
    "setSpeakerLevels(non-const AudioSound this, float level1)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8)\n"
    "setSpeakerLevels(non-const AudioSound this, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_set_speaker_levels_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int AudioSound::get_priority(void)
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_priority_48(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual int AudioSound::get_priority(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPriority", key_word_list));
        else
            (PyArg_Parse(args, ":getPriority"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_priority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.getPriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPriority(non-const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_priority_48_comment =
    "C++ Interface:\n"
    "getPriority(non-const AudioSound this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_get_priority_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::set_priority(int priority)
 *******************************************************************/
static PyObject *Dtool_AudioSound_set_priority_49(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioSound::set_priority(int priority)
        int param1;
        static char * key_word_list[] = {(char *)"priority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPriority", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPriority", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_priority((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioSound.setPriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPriority(non-const AudioSound this, int priority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_set_priority_49_comment =
    "C++ Interface:\n"
    "setPriority(non-const AudioSound this, int priority)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_set_priority_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioSound::configure_filters(FilterProperties *config)
 *******************************************************************/
static PyObject *Dtool_AudioSound_configure_filters_50(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool AudioSound::configure_filters(FilterProperties *config)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"config", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:configureFilters", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:configureFilters", &param1));
            if(!PyErr_Occurred())
            {
                FilterProperties *param1_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FilterProperties, 1, "AudioSound.configureFilters", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->configure_filters(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioSound.configureFilters() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "configureFilters(non-const AudioSound this, non-const FilterProperties config)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_configure_filters_50_comment =
    "C++ Interface:\n"
    "configureFilters(non-const AudioSound this, non-const FilterProperties config)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_configure_filters_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioSound_status_52(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":status", key_word_list));
        else
            (PyArg_Parse(args, ":status"));
        if(!PyErr_Occurred())
        {
            AudioSound::SoundStatus return_value = ((const AudioSound*)local_this)->status();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "status(const AudioSound this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_status_52_comment =
    "C++ Interface:\n"
    "status(const AudioSound this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_status_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AudioSound_output_53(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AudioSound::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AudioSound.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AudioSound*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AudioSound this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_output_53_comment =
    "C++ Interface:\n"
    "output(const AudioSound this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_output_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioSound::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AudioSound_write_54(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AudioSound::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AudioSound.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AudioSound*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const AudioSound this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_write_54_comment =
    "C++ Interface:\n"
    "write(const AudioSound this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_write_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AudioSound::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AudioSound_get_class_type_55(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AudioSound::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AudioSound::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioSound_get_class_type_55_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AudioSound_get_class_type_55_comment = NULL;
#endif

int  Dtool_Init_AudioSound(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AudioSound)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AudioSound(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AudioSound)
    {
        printf("AudioSound ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AudioSound * local_this = (AudioSound *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AudioSound)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AudioSound(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AudioSound)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AudioSound*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AudioSound*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AudioSound*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AudioManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual int AudioManager::getSpeakerSetup(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_getSpeakerSetup_60(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual int AudioManager::getSpeakerSetup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpeakerSetup", key_word_list));
        else
            (PyArg_Parse(args, ":getSpeakerSetup"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->getSpeakerSetup();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.getSpeakerSetup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeakerSetup(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_getSpeakerSetup_60_comment =
    "C++ Interface:\n"
    "getSpeakerSetup(non-const AudioManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_getSpeakerSetup_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::setSpeakerSetup(AudioManager::SpeakerModeCategory cat)
 *******************************************************************/
static PyObject *Dtool_AudioManager_setSpeakerSetup_61(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::setSpeakerSetup(AudioManager::SpeakerModeCategory cat)
        int param1;
        static char * key_word_list[] = {(char *)"cat", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSpeakerSetup", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSpeakerSetup", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->setSpeakerSetup((AudioManager::SpeakerModeCategory)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.setSpeakerSetup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpeakerSetup(non-const AudioManager this, int cat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_setSpeakerSetup_61_comment =
    "C++ Interface:\n"
    "setSpeakerSetup(non-const AudioManager this, int cat)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_setSpeakerSetup_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioManager::configure_filters(FilterProperties *config)
 *******************************************************************/
static PyObject *Dtool_AudioManager_configure_filters_62(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool AudioManager::configure_filters(FilterProperties *config)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"config", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:configureFilters", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:configureFilters", &param1));
            if(!PyErr_Occurred())
            {
                FilterProperties *param1_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_FilterProperties, 1, "AudioManager.configureFilters", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->configure_filters(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioManager.configureFilters() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "configureFilters(non-const AudioManager this, non-const FilterProperties config)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_configure_filters_62_comment =
    "C++ Interface:\n"
    "configureFilters(non-const AudioManager this, non-const FilterProperties config)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_configure_filters_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_create_AudioManager_63(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":createAudioManager", key_word_list))
        {
            PointerTo< AudioManager > return_value = AudioManager::create_AudioManager();
            if (return_value != (AudioManager *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioManager,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "createAudioManager()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_create_AudioManager_63_comment =
    "C++ Interface:\n"
    "createAudioManager()\n"
    "\n"
    "// Create an AudioManager for each category of sounds you have.\n"
    "// E.g.\n"
    "//   MySoundEffects = create_AudioManager::AudioManager();\n"
    "//   MyMusicManager = create_AudioManager::AudioManager();\n"
    "//   ...\n"
    "//   my_sound = MySoundEffects.get_sound(\"neatSfx.mp3\");\n"
    "//   my_music = MyMusicManager.get_sound(\"introTheme.mid\");\n"
    "";
#else
static const char * Dtool_AudioManager_create_AudioManager_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::shutdown(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_shutdown_64(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::shutdown(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":shutdown", key_word_list));
        else
            (PyArg_Parse(args, ":shutdown"));
        if(!PyErr_Occurred())
        {
            (local_this)->shutdown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.shutdown() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shutdown(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_shutdown_64_comment =
    "C++ Interface:\n"
    "shutdown(non-const AudioManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_shutdown_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioManager::is_valid(void) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_is_valid_65(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool AudioManager::is_valid(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.isValid() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_is_valid_65_comment =
    "C++ Interface:\n"
    "isValid(non-const AudioManager this)\n"
    "\n"
    "// If you're interested in knowing whether this audio manager\n"
    "// is valid, here's the call to do it.  It is not necessary\n"
    "// to check whether the audio manager is valid before making other\n"
    "// calls.  You are free to use an invalid sound manager, you\n"
    "// may get silent sounds from it though.  The sound manager and\n"
    "// the sounds it creates should not crash the application even\n"
    "// when the objects are not valid.\n"
    "";
#else
static const char * Dtool_AudioManager_is_valid_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional, int mode) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional, int mode = (SM_heuristic)) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = (0), int mode = (SM_heuristic)) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional, int mode) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional, int mode = (SM_heuristic)) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional = (0), int mode = (SM_heuristic)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_sound_66(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional = (0), int mode = (SM_heuristic)) = 0
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"file_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getSound", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:getSound", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    PointerTo< AudioSound > return_value = (local_this)->get_sound(basic_string<char>(param1_str, param1_len));
                    if (return_value != (AudioSound *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = (0), int mode = (SM_heuristic)) = 0
                PyObject *param1;
                static char * key_word_list[] = {(char *)"source", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSound", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getSound", &param1));
                if(!PyErr_Occurred())
                {
                    MovieAudio *param1_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MovieAudio, 1, "AudioManager.getSound", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< AudioSound > return_value = (local_this)->get_sound(param1_this);
                        if (return_value != (AudioSound *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional, int mode = (SM_heuristic)) = 0
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"file_name", (char *)"positional", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:getSound", key_word_list, &param1_str, &param1_len, &param2))
                {
                    PointerTo< AudioSound > return_value = (local_this)->get_sound(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0));
                    if (return_value != (AudioSound *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional, int mode = (SM_heuristic)) = 0
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"source", (char *)"positional", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSound", key_word_list, &param1, &param2))
                {
                    MovieAudio *param1_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MovieAudio, 1, "AudioManager.getSound", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< AudioSound > return_value = (local_this)->get_sound(param1_this, (PyObject_IsTrue(param2)!=0));
                        if (return_value != (AudioSound *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(basic_string< char > const &file_name, bool positional, int mode) = 0
                char *param1_str; int param1_len;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"file_name", (char *)"positional", (char *)"mode", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oi:getSound", key_word_list, &param1_str, &param1_len, &param2, &param3))
                {
                    PointerTo< AudioSound > return_value = (local_this)->get_sound(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0), (int)param3);
                    if (return_value != (AudioSound *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional, int mode) = 0
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"source", (char *)"positional", (char *)"mode", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:getSound", key_word_list, &param1, &param2, &param3))
                {
                    MovieAudio *param1_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MovieAudio, 1, "AudioManager.getSound", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< AudioSound > return_value = (local_this)->get_sound(param1_this, (PyObject_IsTrue(param2)!=0), (int)param3);
                        if (return_value != (AudioSound *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getSound() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getSound(non-const AudioManager this, string file_name)\n"
          "getSound(non-const AudioManager this, non-const MovieAudio source)\n"
          "getSound(non-const AudioManager this, string file_name, bool positional)\n"
          "getSound(non-const AudioManager this, non-const MovieAudio source, bool positional)\n"
          "getSound(non-const AudioManager this, string file_name, bool positional, int mode)\n"
          "getSound(non-const AudioManager this, non-const MovieAudio source, bool positional, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_sound_66_comment =
    "C++ Interface:\n"
    "getSound(non-const AudioManager this, string file_name)\n"
    "getSound(non-const AudioManager this, non-const MovieAudio source)\n"
    "getSound(non-const AudioManager this, string file_name, bool positional)\n"
    "getSound(non-const AudioManager this, non-const MovieAudio source, bool positional)\n"
    "getSound(non-const AudioManager this, string file_name, bool positional, int mode)\n"
    "getSound(non-const AudioManager this, non-const MovieAudio source, bool positional, int mode)\n"
    "\n"
    "// Get a sound:\n"
    "\n"
    "// Get a sound:\n"
    "";
#else
static const char * Dtool_AudioManager_get_sound_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< AudioSound > AudioManager::get_null_sound(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_null_sound_67(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< AudioSound > AudioManager::get_null_sound(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNullSound", key_word_list));
        else
            (PyArg_Parse(args, ":getNullSound"));
        if(!PyErr_Occurred())
        {
            PointerTo< AudioSound > return_value = (local_this)->get_null_sound();
            if (return_value != (AudioSound *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AudioSound,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.getNullSound() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNullSound(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_null_sound_67_comment =
    "C++ Interface:\n"
    "getNullSound(non-const AudioManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_get_null_sound_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::uncache_sound(basic_string< char > const &file_name) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_uncache_sound_68(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::uncache_sound(basic_string< char > const &file_name) = 0
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"file_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:uncacheSound", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:uncacheSound", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->uncache_sound(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.uncacheSound() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "uncacheSound(non-const AudioManager this, string file_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_uncache_sound_68_comment =
    "C++ Interface:\n"
    "uncacheSound(non-const AudioManager this, string file_name)\n"
    "\n"
    "// Tell the AudioManager there is no need to keep this one cached.\n"
    "// This doesn't break any connection between AudioSounds that have\n"
    "// already given by get_sound() from this manager.  It's\n"
    "// only affecting whether the AudioManager keeps a copy of the sound\n"
    "// in its pool/cache.\n"
    "";
#else
static const char * Dtool_AudioManager_uncache_sound_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::clear_cache(void) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_clear_cache_69(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::clear_cache(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCache", key_word_list));
        else
            (PyArg_Parse(args, ":clearCache"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cache();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.clearCache() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCache(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_clear_cache_69_comment =
    "C++ Interface:\n"
    "clearCache(non-const AudioManager this)\n"
    "\n"
    "// Tell the AudioManager there is no need to keep this one cached.\n"
    "// This doesn't break any connection between AudioSounds that have\n"
    "// already given by get_sound() from this manager.  It's\n"
    "// only affecting whether the AudioManager keeps a copy of the sound\n"
    "// in its pool/cache.\n"
    "";
#else
static const char * Dtool_AudioManager_clear_cache_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::set_cache_limit(unsigned int count) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_set_cache_limit_70(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::set_cache_limit(unsigned int count) = 0
        PyObject *param1;
        static char * key_word_list[] = {(char *)"count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCacheLimit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCacheLimit", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->set_cache_limit(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.setCacheLimit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCacheLimit(non-const AudioManager this, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_set_cache_limit_70_comment =
    "C++ Interface:\n"
    "setCacheLimit(non-const AudioManager this, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_set_cache_limit_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual unsigned int AudioManager::get_cache_limit(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_cache_limit_71(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual unsigned int AudioManager::get_cache_limit(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCacheLimit", key_word_list));
        else
            (PyArg_Parse(args, ":getCacheLimit"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const AudioManager*)local_this)->get_cache_limit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCacheLimit(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_cache_limit_71_comment =
    "C++ Interface:\n"
    "getCacheLimit(const AudioManager this)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_get_cache_limit_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::set_volume(float volume) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_set_volume_72(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::set_volume(float volume) = 0
        double param1;
        static char * key_word_list[] = {(char *)"volume", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVolume", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVolume", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_volume((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.setVolume() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVolume(non-const AudioManager this, float volume)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_set_volume_72_comment =
    "C++ Interface:\n"
    "setVolume(non-const AudioManager this, float volume)\n"
    "\n"
    "// Control volume:\n"
    "// FYI:\n"
    "//   If you start a sound with the volume off and turn the volume \n"
    "//   up later, you'll hear the sound playing at that late point.\n"
    "// 0 = minimum; 1.0 = maximum.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioManager_set_volume_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioManager::get_volume(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_volume_73(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioManager::get_volume(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVolume", key_word_list));
        else
            (PyArg_Parse(args, ":getVolume"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioManager*)local_this)->get_volume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVolume(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_volume_73_comment =
    "C++ Interface:\n"
    "getVolume(const AudioManager this)\n"
    "\n"
    "// Control volume:\n"
    "// FYI:\n"
    "//   If you start a sound with the volume off and turn the volume \n"
    "//   up later, you'll hear the sound playing at that late point.\n"
    "// 0 = minimum; 1.0 = maximum.\n"
    "// inits to 1.0.\n"
    "";
#else
static const char * Dtool_AudioManager_get_volume_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::set_active(bool flag) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_set_active_74(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::set_active(bool flag) = 0
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const AudioManager this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_set_active_74_comment =
    "C++ Interface:\n"
    "setActive(non-const AudioManager this, bool flag)\n"
    "\n"
    "// Turn the manager on or off.\n"
    "// If you play a sound while the manager is inactive, it won't start.\n"
    "// If you deactivate the manager while sounds are playing, they'll\n"
    "// stop.\n"
    "// If you activate the manager while looping sounds are playing\n"
    "// (those that have a loop_count of zero),\n"
    "// they will start playing from the begining of their loop.\n"
    "// inits to true.\n"
    "";
#else
static const char * Dtool_AudioManager_set_active_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool AudioManager::get_active(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_active_75(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool AudioManager::get_active(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AudioManager*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_active_75_comment =
    "C++ Interface:\n"
    "getActive(const AudioManager this)\n"
    "\n"
    "// Turn the manager on or off.\n"
    "// If you play a sound while the manager is inactive, it won't start.\n"
    "// If you deactivate the manager while sounds are playing, they'll\n"
    "// stop.\n"
    "// If you activate the manager while looping sounds are playing\n"
    "// (those that have a loop_count of zero),\n"
    "// they will start playing from the begining of their loop.\n"
    "// inits to true.\n"
    "";
#else
static const char * Dtool_AudioManager_get_active_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit) = 0
 * virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = (0)) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_set_concurrent_sound_limit_76(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = (0)) = 0
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setConcurrentSoundLimit", key_word_list));
            else
                (PyArg_Parse(args, ":setConcurrentSoundLimit"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_concurrent_sound_limit();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioManager.setConcurrentSoundLimit() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"limit", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setConcurrentSoundLimit", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setConcurrentSoundLimit", &param1));
            if(!PyErr_Occurred())
            {
                 PyObject *param1_uint = PyNumber_Long(param1);
                if (!((param1_uint == NULL)))
                {
                    (local_this)->set_concurrent_sound_limit(PyLong_AsUnsignedLong(param1_uint));
                     Py_XDECREF(param1_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AudioManager.setConcurrentSoundLimit() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setConcurrentSoundLimit() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setConcurrentSoundLimit(non-const AudioManager this)\n"
          "setConcurrentSoundLimit(non-const AudioManager this, unsigned int limit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_set_concurrent_sound_limit_76_comment =
    "C++ Interface:\n"
    "setConcurrentSoundLimit(non-const AudioManager this)\n"
    "setConcurrentSoundLimit(non-const AudioManager this, unsigned int limit)\n"
    "\n"
    "// This controls the number of sounds that you allow at once.  This\n"
    "// is more of a user choice -- it avoids talk over and the creation\n"
    "// of a cacophony.\n"
    "// It can also be used to help performance.\n"
    "// 0 == unlimited.\n"
    "// 1 == mutually exclusive (one sound at a time).  Which is an example of:\n"
    "// n == allow n sounds to be playing at the same time.\n"
    "";
#else
static const char * Dtool_AudioManager_set_concurrent_sound_limit_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_concurrent_sound_limit_77(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConcurrentSoundLimit", key_word_list));
        else
            (PyArg_Parse(args, ":getConcurrentSoundLimit"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const AudioManager*)local_this)->get_concurrent_sound_limit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConcurrentSoundLimit(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_concurrent_sound_limit_77_comment =
    "C++ Interface:\n"
    "getConcurrentSoundLimit(const AudioManager this)\n"
    "\n"
    "// This controls the number of sounds that you allow at once.  This\n"
    "// is more of a user choice -- it avoids talk over and the creation\n"
    "// of a cacophony.\n"
    "// It can also be used to help performance.\n"
    "// 0 == unlimited.\n"
    "// 1 == mutually exclusive (one sound at a time).  Which is an example of:\n"
    "// n == allow n sounds to be playing at the same time.\n"
    "";
#else
static const char * Dtool_AudioManager_get_concurrent_sound_limit_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_reduce_sounds_playing_to_78(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
        PyObject *param1;
        static char * key_word_list[] = {(char *)"count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:reduceSoundsPlayingTo", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:reduceSoundsPlayingTo", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->reduce_sounds_playing_to(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.reduceSoundsPlayingTo() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reduceSoundsPlayingTo(non-const AudioManager this, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_reduce_sounds_playing_to_78_comment =
    "C++ Interface:\n"
    "reduceSoundsPlayingTo(non-const AudioManager this, unsigned int count)\n"
    "\n"
    "// This is likely to be a utility function for the concurrent_sound_limit\n"
    "// options.  It is exposed as an API, because it's reasonable that it\n"
    "// may be useful to be here.  It reduces the number of concurrently\n"
    "// playing sounds to count by some implementation specific means.\n"
    "// If the number of sounds currently playing is at or below count then\n"
    "// there is no effect.\n"
    "";
#else
static const char * Dtool_AudioManager_reduce_sounds_playing_to_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::stop_all_sounds(void) = 0
 *******************************************************************/
static PyObject *Dtool_AudioManager_stop_all_sounds_79(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::stop_all_sounds(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stopAllSounds", key_word_list));
        else
            (PyArg_Parse(args, ":stopAllSounds"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop_all_sounds();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.stopAllSounds() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stopAllSounds(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_stop_all_sounds_79_comment =
    "C++ Interface:\n"
    "stopAllSounds(non-const AudioManager this)\n"
    "\n"
    "// Stop playback on all sounds managed by this manager.\n"
    "// This is effectively the same as reduce_sounds_playing_to(0), but\n"
    "// this call may be for efficient on some implementations.\n"
    "";
#else
static const char * Dtool_AudioManager_stop_all_sounds_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::update(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_update_80(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_update_80_comment =
    "C++ Interface:\n"
    "update(non-const AudioManager this)\n"
    "\n"
    "// This should be called every frame.  Failure to call could\n"
    "// cause problems.\n"
    "";
#else
static const char * Dtool_AudioManager_update_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::audio_3d_set_listener_attributes(float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_set_listener_attributes_81(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::audio_3d_set_listener_attributes(float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        double param9;
        double param10;
        double param11;
        double param12;
        static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", (char *)"vx", (char *)"vy", (char *)"vz", (char *)"fx", (char *)"fy", (char *)"fz", (char *)"ux", (char *)"uy", (char *)"uz", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddddddd:audio3dSetListenerAttributes", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12))
        {
            (local_this)->audio_3d_set_listener_attributes((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.audio3dSetListenerAttributes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dSetListenerAttributes(non-const AudioManager this, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment =
    "C++ Interface:\n"
    "audio3dSetListenerAttributes(non-const AudioManager this, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n"
    "\n"
    "// This controls the \"set of ears\" that listens to 3D spacialized sound\n"
    "// px, py, pz are position coordinates. \n"
    "// vx, vy, vz are a velocity vector in UNITS PER SECOND (default: meters). \n"
    "// fx, fy and fz are the respective components of a unit forward-vector\n"
    "// ux, uy and uz are the respective components of a unit up-vector\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::audio_3d_set_distance_factor(float factor)
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_set_distance_factor_83(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::audio_3d_set_distance_factor(float factor)
        double param1;
        static char * key_word_list[] = {(char *)"factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:audio3dSetDistanceFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:audio3dSetDistanceFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->audio_3d_set_distance_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.audio3dSetDistanceFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dSetDistanceFactor(non-const AudioManager this, float factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_set_distance_factor_83_comment =
    "C++ Interface:\n"
    "audio3dSetDistanceFactor(non-const AudioManager this, float factor)\n"
    "\n"
    "// Control the \"relative scale that sets the distance factor\" units for 3D spacialized audio. Default is 1.0\n"
    "// Fmod uses meters internally, so give a float in Units-per meter\n"
    "// Don't know what Miles uses.\n"
    "// Default is 1.0 which is adjust in panda to be feet.\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_set_distance_factor_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioManager::audio_3d_get_distance_factor(void) const
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_get_distance_factor_84(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioManager::audio_3d_get_distance_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":audio3dGetDistanceFactor", key_word_list));
        else
            (PyArg_Parse(args, ":audio3dGetDistanceFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioManager*)local_this)->audio_3d_get_distance_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dGetDistanceFactor(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_get_distance_factor_84_comment =
    "C++ Interface:\n"
    "audio3dGetDistanceFactor(const AudioManager this)\n"
    "\n"
    "// Control the \"relative scale that sets the distance factor\" units for 3D spacialized audio. Default is 1.0\n"
    "// Fmod uses meters internally, so give a float in Units-per meter\n"
    "// Don't know what Miles uses.\n"
    "// Default is 1.0 which is adjust in panda to be feet.\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_get_distance_factor_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::audio_3d_set_doppler_factor(float factor)
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_set_doppler_factor_85(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::audio_3d_set_doppler_factor(float factor)
        double param1;
        static char * key_word_list[] = {(char *)"factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:audio3dSetDopplerFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:audio3dSetDopplerFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->audio_3d_set_doppler_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.audio3dSetDopplerFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dSetDopplerFactor(non-const AudioManager this, float factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment =
    "C++ Interface:\n"
    "audio3dSetDopplerFactor(non-const AudioManager this, float factor)\n"
    "\n"
    "// Control the presence of the Doppler effect. Default is 1.0\n"
    "// Exaggerated Doppler, use >1.0\n"
    "// Diminshed Doppler, use <1.0\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioManager::audio_3d_get_doppler_factor(void) const
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_get_doppler_factor_86(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioManager::audio_3d_get_doppler_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":audio3dGetDopplerFactor", key_word_list));
        else
            (PyArg_Parse(args, ":audio3dGetDopplerFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioManager*)local_this)->audio_3d_get_doppler_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dGetDopplerFactor(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment =
    "C++ Interface:\n"
    "audio3dGetDopplerFactor(const AudioManager this)\n"
    "\n"
    "// Control the presence of the Doppler effect. Default is 1.0\n"
    "// Exaggerated Doppler, use >1.0\n"
    "// Diminshed Doppler, use <1.0\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::audio_3d_set_drop_off_factor(float factor)
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_set_drop_off_factor_87(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void AudioManager::audio_3d_set_drop_off_factor(float factor)
        double param1;
        static char * key_word_list[] = {(char *)"factor", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:audio3dSetDropOffFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:audio3dSetDropOffFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->audio_3d_set_drop_off_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AudioManager.audio3dSetDropOffFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dSetDropOffFactor(non-const AudioManager this, float factor)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment =
    "C++ Interface:\n"
    "audio3dSetDropOffFactor(non-const AudioManager this, float factor)\n"
    "\n"
    "// Exaggerate or diminish the effect of distance on sound. Default is 1.0\n"
    "// Valid range is 0 to 10\n"
    "// Faster drop off, use >1.0\n"
    "// Slower drop off, use <1.0\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float AudioManager::audio_3d_get_drop_off_factor(void) const
 *******************************************************************/
static PyObject *Dtool_AudioManager_audio_3d_get_drop_off_factor_88(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float AudioManager::audio_3d_get_drop_off_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":audio3dGetDropOffFactor", key_word_list));
        else
            (PyArg_Parse(args, ":audio3dGetDropOffFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AudioManager*)local_this)->audio_3d_get_drop_off_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audio3dGetDropOffFactor(const AudioManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment =
    "C++ Interface:\n"
    "audio3dGetDropOffFactor(const AudioManager this)\n"
    "\n"
    "// Exaggerate or diminish the effect of distance on sound. Default is 1.0\n"
    "// Valid range is 0 to 10\n"
    "// Faster drop off, use >1.0\n"
    "// Slower drop off, use <1.0\n"
    "";
#else
static const char * Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Filename AudioManager::get_dls_pathname(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_dls_pathname_89(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Filename AudioManager::get_dls_pathname(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDlsPathname", key_word_list))
        {
            Filename result = AudioManager::get_dls_pathname();
            Filename *return_value = new Filename(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDlsPathname()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_dls_pathname_89_comment =
    "C++ Interface:\n"
    "getDlsPathname()\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_get_dls_pathname_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AudioManager_output_90(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AudioManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AudioManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AudioManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AudioManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_output_90_comment =
    "C++ Interface:\n"
    "output(const AudioManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_output_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AudioManager_write_91(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AudioManager::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AudioManager.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AudioManager*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const AudioManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_write_91_comment =
    "C++ Interface:\n"
    "write(const AudioManager this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_write_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8, LVecBase3f *speaker9)
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8, LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3 = ((void *)(0)), LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 * virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2 = ((void *)(0)), LVecBase3f *speaker3 = ((void *)(0)), LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_AudioManager_set_speaker_configuration_92(PyObject *self, PyObject *args,PyObject *kwds) {
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2 = ((void *)(0)), LVecBase3f *speaker3 = ((void *)(0)), LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"speaker1", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpeakerConfiguration", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setSpeakerConfiguration", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3 = ((void *)(0)), LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setSpeakerConfiguration", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4 = ((void *)(0)), LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5 = ((void *)(0)), LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6 = ((void *)(0)), LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", (char *)"speaker5", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7 = ((void *)(0)), LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", (char *)"speaker5", (char *)"speaker6", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param6_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase3f, 6, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this, param6_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8 = ((void *)(0)), LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                PyObject *param7;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", (char *)"speaker5", (char *)"speaker6", (char *)"speaker7", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param6_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase3f, 6, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param7_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVecBase3f, 7, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this, param6_this, param7_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8, LVecBase3f *speaker9 = ((void *)(0)))
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                PyObject *param7;
                PyObject *param8;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", (char *)"speaker5", (char *)"speaker6", (char *)"speaker7", (char *)"speaker8", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param6_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase3f, 6, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param7_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVecBase3f, 7, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param8_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_LVecBase3f, 8, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)|| (param8_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this, param6_this, param7_this, param8_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(9):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3f *speaker1, LVecBase3f *speaker2, LVecBase3f *speaker3, LVecBase3f *speaker4, LVecBase3f *speaker5, LVecBase3f *speaker6, LVecBase3f *speaker7, LVecBase3f *speaker8, LVecBase3f *speaker9)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                PyObject *param7;
                PyObject *param8;
                PyObject *param9;
                static char * key_word_list[] = {(char *)"speaker1", (char *)"speaker2", (char *)"speaker3", (char *)"speaker4", (char *)"speaker5", (char *)"speaker6", (char *)"speaker7", (char *)"speaker8", (char *)"speaker9", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOOOO:setSpeakerConfiguration", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param6_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase3f, 6, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param7_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LVecBase3f, 7, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param8_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_LVecBase3f, 8, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);
LVecBase3f *param9_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_LVecBase3f, 9, "AudioManager.setSpeakerConfiguration", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)|| (param8_this == NULL)|| (param9_this == NULL)))
                    {
                        (local_this)->set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this, param6_this, param7_this, param8_this, param9_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call AudioManager.setSpeakerConfiguration() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setSpeakerConfiguration() takes 2, 3, 4, 5, 6, 7, 8, 9, or 10 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7, non-const VBase3 speaker8)\n"
          "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7, non-const VBase3 speaker8, non-const VBase3 speaker9)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_set_speaker_configuration_92_comment =
    "C++ Interface:\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7, non-const VBase3 speaker8)\n"
    "setSpeakerConfiguration(non-const AudioManager this, non-const VBase3 speaker1, non-const VBase3 speaker2, non-const VBase3 speaker3, non-const VBase3 speaker4, non-const VBase3 speaker5, non-const VBase3 speaker6, non-const VBase3 speaker7, non-const VBase3 speaker8, non-const VBase3 speaker9)\n"
    "\n"
    "// set_speaker_configuration is a Miles only method.\n"
    "";
#else
static const char * Dtool_AudioManager_set_speaker_configuration_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AudioManager::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AudioManager_get_class_type_93(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AudioManager::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AudioManager::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AudioManager_get_class_type_93_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AudioManager_get_class_type_93_comment = NULL;
#endif

int  Dtool_Init_AudioManager(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AudioManager)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AudioManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AudioManager)
    {
        printf("AudioManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AudioManager * local_this = (AudioManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AudioManager)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AudioManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AudioManager)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AudioManager*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AudioManager*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AudioManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. FilterProperties | FilterProperties
//********************************************************************
PyMethodDef Dtool_Methods_FilterProperties[]= {
  { "clear",(PyCFunction ) &Dtool_FilterProperties_clear_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_clear_4_comment},
  { "addLowpass",(PyCFunction ) &Dtool_FilterProperties_add_lowpass_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_lowpass_5_comment},
  { "addHighpass",(PyCFunction ) &Dtool_FilterProperties_add_highpass_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_highpass_6_comment},
  { "addEcho",(PyCFunction ) &Dtool_FilterProperties_add_echo_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_echo_7_comment},
  { "addFlange",(PyCFunction ) &Dtool_FilterProperties_add_flange_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_flange_8_comment},
  { "addDistort",(PyCFunction ) &Dtool_FilterProperties_add_distort_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_distort_9_comment},
  { "addNormalize",(PyCFunction ) &Dtool_FilterProperties_add_normalize_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_normalize_10_comment},
  { "addParameq",(PyCFunction ) &Dtool_FilterProperties_add_parameq_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_parameq_11_comment},
  { "addPitchshift",(PyCFunction ) &Dtool_FilterProperties_add_pitchshift_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_pitchshift_12_comment},
  { "addChorus",(PyCFunction ) &Dtool_FilterProperties_add_chorus_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_chorus_13_comment},
  { "addReverb",(PyCFunction ) &Dtool_FilterProperties_add_reverb_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_reverb_14_comment},
  { "addCompress",(PyCFunction ) &Dtool_FilterProperties_add_compress_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_add_compress_15_comment},
  { "getClassType",(PyCFunction ) &Dtool_FilterProperties_get_class_type_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FilterProperties_get_class_type_16_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FilterProperties(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FilterProperties.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FilterProperties\n"
          "// Description : Stores a configuration for a set of audio DSP filters.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_FilterProperties.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_FilterProperties.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FilterProperties.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FilterProperties.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FilterProperties.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FilterProperties)");
             printf(" Error In PyType_ReadyFilterProperties");
             return;
        }
        Py_INCREF(&Dtool_FilterProperties.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FilterProperties.As_PyTypeObject().tp_dict,"FilterProperties",&Dtool_FilterProperties.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FilterProperties.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FilterProperties[12],&Dtool_FilterProperties.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FilterProperties,FilterProperties::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FilterProperties.As_PyTypeObject());
        PyModule_AddObject(module, "FilterProperties",(PyObject *)&Dtool_FilterProperties.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AudioSound | AudioSound
//********************************************************************
PyMethodDef Dtool_Methods_AudioSound[]= {
  { "play",(PyCFunction ) &Dtool_AudioSound_play_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_play_18_comment},
  { "stop",(PyCFunction ) &Dtool_AudioSound_stop_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_stop_19_comment},
  { "setLoop",(PyCFunction ) &Dtool_AudioSound_set_loop_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_loop_20_comment},
  { "getLoop",(PyCFunction ) &Dtool_AudioSound_get_loop_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_loop_21_comment},
  { "setLoopCount",(PyCFunction ) &Dtool_AudioSound_set_loop_count_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_loop_count_22_comment},
  { "getLoopCount",(PyCFunction ) &Dtool_AudioSound_get_loop_count_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_loop_count_23_comment},
  { "setTime",(PyCFunction ) &Dtool_AudioSound_set_time_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_time_24_comment},
  { "getTime",(PyCFunction ) &Dtool_AudioSound_get_time_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_time_25_comment},
  { "setVolume",(PyCFunction ) &Dtool_AudioSound_set_volume_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_volume_26_comment},
  { "getVolume",(PyCFunction ) &Dtool_AudioSound_get_volume_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_volume_27_comment},
  { "setBalance",(PyCFunction ) &Dtool_AudioSound_set_balance_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_balance_28_comment},
  { "getBalance",(PyCFunction ) &Dtool_AudioSound_get_balance_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_balance_29_comment},
  { "setPlayRate",(PyCFunction ) &Dtool_AudioSound_set_play_rate_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_play_rate_30_comment},
  { "getPlayRate",(PyCFunction ) &Dtool_AudioSound_get_play_rate_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_play_rate_31_comment},
  { "setActive",(PyCFunction ) &Dtool_AudioSound_set_active_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_active_32_comment},
  { "getActive",(PyCFunction ) &Dtool_AudioSound_get_active_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_active_33_comment},
  { "setFinishedEvent",(PyCFunction ) &Dtool_AudioSound_set_finished_event_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_finished_event_34_comment},
  { "getFinishedEvent",(PyCFunction ) &Dtool_AudioSound_get_finished_event_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_finished_event_35_comment},
  { "getName",(PyCFunction ) &Dtool_AudioSound_get_name_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_name_36_comment},
  { "length",(PyCFunction ) &Dtool_AudioSound_length_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_length_37_comment},
  { "set3dAttributes",(PyCFunction ) &Dtool_AudioSound_set_3d_attributes_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_3d_attributes_38_comment},
  { "set3dMinDistance",(PyCFunction ) &Dtool_AudioSound_set_3d_min_distance_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_3d_min_distance_40_comment},
  { "get3dMinDistance",(PyCFunction ) &Dtool_AudioSound_get_3d_min_distance_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_3d_min_distance_41_comment},
  { "set3dMaxDistance",(PyCFunction ) &Dtool_AudioSound_set_3d_max_distance_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_3d_max_distance_42_comment},
  { "get3dMaxDistance",(PyCFunction ) &Dtool_AudioSound_get_3d_max_distance_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_3d_max_distance_43_comment},
  { "getSpeakerMix",(PyCFunction ) &Dtool_AudioSound_get_speaker_mix_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_speaker_mix_44_comment},
  { "setSpeakerMix",(PyCFunction ) &Dtool_AudioSound_set_speaker_mix_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_speaker_mix_45_comment},
  { "getSpeakerLevel",(PyCFunction ) &Dtool_AudioSound_get_speaker_level_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_speaker_level_46_comment},
  { "setSpeakerLevels",(PyCFunction ) &Dtool_AudioSound_set_speaker_levels_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_speaker_levels_47_comment},
  { "getPriority",(PyCFunction ) &Dtool_AudioSound_get_priority_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_priority_48_comment},
  { "setPriority",(PyCFunction ) &Dtool_AudioSound_set_priority_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_set_priority_49_comment},
  { "configureFilters",(PyCFunction ) &Dtool_AudioSound_configure_filters_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_configure_filters_50_comment},
  { "status",(PyCFunction ) &Dtool_AudioSound_status_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_status_52_comment},
  { "output",(PyCFunction ) &Dtool_AudioSound_output_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_output_53_comment},
  { "write",(PyCFunction ) &Dtool_AudioSound_write_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_write_54_comment},
  { "getClassType",(PyCFunction ) &Dtool_AudioSound_get_class_type_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioSound_get_class_type_55_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AudioSound
//////////////////
static PyObject *  Dtool_Repr_AudioSound(PyObject * self)
{
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AudioSound
//////////////////
static PyObject *  Dtool_Str_AudioSound(PyObject * self)
{
    AudioSound * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioSound,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AudioSound(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_AudioSound.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_AudioSound.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AudioSound.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AudioSound.As_PyTypeObject().tp_repr = & Dtool_Repr_AudioSound;
        // __str__
        Dtool_AudioSound.As_PyTypeObject().tp_str = & Dtool_Str_AudioSound;
        // Enum  AudioSound::SoundStatus;
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"BAD",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"READY",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"PLAYING",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_AudioSound.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AudioSound)");
             printf(" Error In PyType_ReadyAudioSound");
             return;
        }
        Py_INCREF(&Dtool_AudioSound.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"AudioSound",&Dtool_AudioSound.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AudioSound.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AudioSound[35],&Dtool_AudioSound.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AudioSound,AudioSound::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AudioSound.As_PyTypeObject());
        PyModule_AddObject(module, "AudioSound",(PyObject *)&Dtool_AudioSound.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AudioManager | AudioManager
//********************************************************************
PyMethodDef Dtool_Methods_AudioManager[]= {
  { "getSpeakerSetup",(PyCFunction ) &Dtool_AudioManager_getSpeakerSetup_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_getSpeakerSetup_60_comment},
  { "setSpeakerSetup",(PyCFunction ) &Dtool_AudioManager_setSpeakerSetup_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_setSpeakerSetup_61_comment},
  { "configureFilters",(PyCFunction ) &Dtool_AudioManager_configure_filters_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_configure_filters_62_comment},
  { "createAudioManager",(PyCFunction ) &Dtool_AudioManager_create_AudioManager_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_create_AudioManager_63_comment},
  { "shutdown",(PyCFunction ) &Dtool_AudioManager_shutdown_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_shutdown_64_comment},
  { "isValid",(PyCFunction ) &Dtool_AudioManager_is_valid_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_is_valid_65_comment},
  { "getSound",(PyCFunction ) &Dtool_AudioManager_get_sound_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_sound_66_comment},
  { "getNullSound",(PyCFunction ) &Dtool_AudioManager_get_null_sound_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_null_sound_67_comment},
  { "uncacheSound",(PyCFunction ) &Dtool_AudioManager_uncache_sound_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_uncache_sound_68_comment},
  { "clearCache",(PyCFunction ) &Dtool_AudioManager_clear_cache_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_clear_cache_69_comment},
  { "setCacheLimit",(PyCFunction ) &Dtool_AudioManager_set_cache_limit_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_set_cache_limit_70_comment},
  { "getCacheLimit",(PyCFunction ) &Dtool_AudioManager_get_cache_limit_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_cache_limit_71_comment},
  { "setVolume",(PyCFunction ) &Dtool_AudioManager_set_volume_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_set_volume_72_comment},
  { "getVolume",(PyCFunction ) &Dtool_AudioManager_get_volume_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_volume_73_comment},
  { "setActive",(PyCFunction ) &Dtool_AudioManager_set_active_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_set_active_74_comment},
  { "getActive",(PyCFunction ) &Dtool_AudioManager_get_active_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_active_75_comment},
  { "setConcurrentSoundLimit",(PyCFunction ) &Dtool_AudioManager_set_concurrent_sound_limit_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_set_concurrent_sound_limit_76_comment},
  { "getConcurrentSoundLimit",(PyCFunction ) &Dtool_AudioManager_get_concurrent_sound_limit_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_concurrent_sound_limit_77_comment},
  { "reduceSoundsPlayingTo",(PyCFunction ) &Dtool_AudioManager_reduce_sounds_playing_to_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_reduce_sounds_playing_to_78_comment},
  { "stopAllSounds",(PyCFunction ) &Dtool_AudioManager_stop_all_sounds_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_stop_all_sounds_79_comment},
  { "update",(PyCFunction ) &Dtool_AudioManager_update_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_update_80_comment},
  { "audio3dSetListenerAttributes",(PyCFunction ) &Dtool_AudioManager_audio_3d_set_listener_attributes_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment},
  { "audio3dSetDistanceFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_set_distance_factor_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_set_distance_factor_83_comment},
  { "audio3dGetDistanceFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_get_distance_factor_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_get_distance_factor_84_comment},
  { "audio3dSetDopplerFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_set_doppler_factor_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment},
  { "audio3dGetDopplerFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_get_doppler_factor_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment},
  { "audio3dSetDropOffFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_set_drop_off_factor_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment},
  { "audio3dGetDropOffFactor",(PyCFunction ) &Dtool_AudioManager_audio_3d_get_drop_off_factor_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment},
  { "getDlsPathname",(PyCFunction ) &Dtool_AudioManager_get_dls_pathname_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_dls_pathname_89_comment},
  { "output",(PyCFunction ) &Dtool_AudioManager_output_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_output_90_comment},
  { "write",(PyCFunction ) &Dtool_AudioManager_write_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_write_91_comment},
  { "setSpeakerConfiguration",(PyCFunction ) &Dtool_AudioManager_set_speaker_configuration_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_set_speaker_configuration_92_comment},
  { "getClassType",(PyCFunction ) &Dtool_AudioManager_get_class_type_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AudioManager_get_class_type_93_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AudioManager
//////////////////
static PyObject *  Dtool_Repr_AudioManager(PyObject * self)
{
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AudioManager
//////////////////
static PyObject *  Dtool_Str_AudioManager(PyObject * self)
{
    AudioManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AudioManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AudioManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_AudioManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_AudioManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AudioManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AudioManager.As_PyTypeObject().tp_repr = & Dtool_Repr_AudioManager;
        // __str__
        Dtool_AudioManager.As_PyTypeObject().tp_str = & Dtool_Str_AudioManager;
        // Enum  AudioManager::SpeakerModeCategory;
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODERaw",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODEMono",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODEStereo",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODEQuad",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODESurround",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODE5point1",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODE7point1",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODEPrologic",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODEMax",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPEAKERMODECOUNT",PyInt_FromLong(9));
        // Enum  AudioManager::SpeakerId;
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKFrontleft",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKFrontright",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKCenter",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKSub",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKBackleft",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKBackright",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKSideleft",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKSideright",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SPKCOUNT",PyInt_FromLong(9));
        // Enum  AudioManager::StreamMode;
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SMHeuristic",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SMSample",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"SMStream",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_AudioManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AudioManager)");
             printf(" Error In PyType_ReadyAudioManager");
             return;
        }
        Py_INCREF(&Dtool_AudioManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"AudioManager",&Dtool_AudioManager.As_PyObject());
        //  Static Method createAudioManager
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"createAudioManager",PyCFunction_New(&Dtool_Methods_AudioManager[3],&Dtool_AudioManager.As_PyObject()));
        //  Static Method getDlsPathname
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"getDlsPathname",PyCFunction_New(&Dtool_Methods_AudioManager[28],&Dtool_AudioManager.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AudioManager.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AudioManager[32],&Dtool_AudioManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AudioManager,AudioManager::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AudioManager.As_PyTypeObject());
        PyModule_AddObject(module, "AudioManager",(PyObject *)&Dtool_AudioManager.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..FilterProperties
//********************************************************************
   Dtool_PyModuleClassInit_FilterProperties(module);
//********************************************************************
//*** Module Init Updcall ..AudioSound
//********************************************************************
   Dtool_PyModuleClassInit_AudioSound(module);
//********************************************************************
//*** Module Init Updcall ..AudioManager
//********************************************************************
   Dtool_PyModuleClassInit_AudioManager(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libaudio_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212822,  /* file_identifier */
  "libaudio",  /* library_name */
  "MC2_",  /* library_hash_name */
  "panda",  /* module_name */
  "libaudio.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  231  /* next_index */
};

Configure(_in_configure_libaudio);
ConfigureFn(_in_configure_libaudio) {
  interrogate_request_module(&_in_module_def);
}

