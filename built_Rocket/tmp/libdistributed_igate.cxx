/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/distributed -Idirect/src/distributed -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdistributed_igate.cxx -od built_Rocket/pandac/input/libdistributed.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/distributed -Idirect/src/dcparser -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/openssl/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWITHIN_PANDA=1 -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libdistributed cConnectionRepository.cxx cConnectionRepository.h cDistributedSmoothNodeBase.cxx cDistributedSmoothNodeBase.h config_distributed.cxx config_distributed.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdistributed
#include "py_panda.h"  

#include "cConnectionRepository.h"
#include "cDistributedSmoothNodeBase.h"
#include "config_distributed.h"
#include "config_downloader.h"
#include "datagramIterator.h"
#include "dcClass.h"
#include "dcField.h"
#include "dcPacker.h"
#include "dcmsgtypes.h"
#include "dconfig.h"
#include "httpChannel.h"
#include "pStatTimer.h"
#include "stringStream.h"
#include "throw_event.h"
#include "urlSpec.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CConnectionRepository
//********************************************************************
typedef  CConnectionRepository  CConnectionRepository_localtype;
Define_Module_Class(p3direct,CConnectionRepository,CConnectionRepository_localtype,CConnectionRepository);
//********************************************************************
//*** prototypes for .. CDistributedSmoothNodeBase
//********************************************************************
typedef  CDistributedSmoothNodeBase  CDistributedSmoothNodeBase_localtype;
Define_Module_Class(p3direct,CDistributedSmoothNodeBase,CDistributedSmoothNodeBase_localtype,CDistributedSmoothNodeBase);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Buffered_DatagramConnection;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ClockObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConnectionWriter;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DCClass;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DCFile;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramIterator;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_HTTPChannel;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_QueuedConnectionManager;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_QueuedConnectionReader;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_SocketStream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_URLSpec;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CConnectionRepository 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DCFile &CConnectionRepository::get_dc_file(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_dc_file_4(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline DCFile &CConnectionRepository::get_dc_file(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDcFile", key_word_list));
        else
            (PyArg_Parse(args, ":getDcFile"));
        if(!PyErr_Occurred())
        {
            DCFile *return_value = &((local_this)->get_dc_file());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCFile,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getDcFile() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDcFile(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_dc_file_4_comment =
    "C++ Interface:\n"
    "getDcFile(non-const CConnectionRepository this)\n"
    "\n"
    "// Any methods of this class that acquire _lock (which is most of\n"
    "// them) *must* be tagged BLOCKING, to avoid risk of a race\n"
    "// condition in Python when running in true threaded mode.  The\n"
    "// BLOCKING tag releases the Python GIL during the function call,\n"
    "// and we re-acquire it when needed within these functions to call\n"
    "// out to Python.  If any functions acquire _lock while already\n"
    "// holding the Python GIL, there could be a deadlock between these\n"
    "// functions and the ones that are acquiring the GIL while already\n"
    "// holding _lock.\n"
    "\n"
    "// Filename: cConnectionRepository.I\n"
    "// Created by:  drose (17May04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_dc_file\n"
    "//       Access: Published\n"
    "//  Description: Returns the DCFile object associated with this\n"
    "//               repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_dc_file_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::has_owner_view(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_has_owner_view_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::has_owner_view(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasOwnerView", key_word_list));
        else
            (PyArg_Parse(args, ":hasOwnerView"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->has_owner_view();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasOwnerView(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_has_owner_view_5_comment =
    "C++ Interface:\n"
    "hasOwnerView(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::has_owner_view\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this repository can have 'owner'\n"
    "//               views of distributed objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_has_owner_view_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_handle_c_updates_6(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"handle_c_updates", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHandleCUpdates", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHandleCUpdates", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_handle_c_updates((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setHandleCUpdates() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHandleCUpdates(non-const CConnectionRepository this, bool handle_c_updates)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_handle_c_updates_6_comment =
    "C++ Interface:\n"
    "setHandleCUpdates(non-const CConnectionRepository this, bool handle_c_updates)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_handle_c_updates\n"
    "//       Access: Published\n"
    "//  Description: Set true to specify this repository should process\n"
    "//               distributed updates internally in C++ code, or false\n"
    "//               if it should return them to Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_handle_c_updates_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_handle_c_updates(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_handle_c_updates_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_handle_c_updates(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHandleCUpdates", key_word_list));
        else
            (PyArg_Parse(args, ":getHandleCUpdates"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_handle_c_updates();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHandleCUpdates(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_handle_c_updates_7_comment =
    "C++ Interface:\n"
    "getHandleCUpdates(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_handle_c_updates\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this repository will process\n"
    "//               distributed updates internally in C++ code, or false\n"
    "//               if it will return them to Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_handle_c_updates_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_client_datagram(bool client_datagram)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_client_datagram_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_client_datagram(bool client_datagram)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"client_datagram", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClientDatagram", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClientDatagram", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_client_datagram((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setClientDatagram() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClientDatagram(non-const CConnectionRepository this, bool client_datagram)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_client_datagram_8_comment =
    "C++ Interface:\n"
    "setClientDatagram(non-const CConnectionRepository this, bool client_datagram)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_client_datagram\n"
    "//       Access: Published\n"
    "//  Description: Sets the client_datagram flag.  If this is true,\n"
    "//               incoming datagrams are not expected to be prefixed\n"
    "//               with the server routing information like message\n"
    "//               sender, channel number, etc.; otherwise, these server\n"
    "//               fields are parsed and removed from each incoming\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_client_datagram_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_client_datagram(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_client_datagram_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_client_datagram(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClientDatagram", key_word_list));
        else
            (PyArg_Parse(args, ":getClientDatagram"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_client_datagram();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClientDatagram(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_client_datagram_9_comment =
    "C++ Interface:\n"
    "getClientDatagram(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_client_datagram\n"
    "//       Access: Published\n"
    "//  Description: Returns the client_datagram flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_client_datagram_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_handle_datagrams_internally_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"handle_datagrams_internally", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHandleDatagramsInternally", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHandleDatagramsInternally", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_handle_datagrams_internally((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setHandleDatagramsInternally() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHandleDatagramsInternally(non-const CConnectionRepository this, bool handle_datagrams_internally)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment =
    "C++ Interface:\n"
    "setHandleDatagramsInternally(non-const CConnectionRepository this, bool handle_datagrams_internally)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_handle_datagrams_internally\n"
    "//       Access: Published\n"
    "//  Description: Sets the handle_datagrams_internally flag.  When\n"
    "//               true, certain message types can be handled by the C++\n"
    "//               code in in this module.  When false, all datagrams,\n"
    "//               regardless of message type, are passed up to Python\n"
    "//               for processing.\n"
    "//\n"
    "//               The CMU distributed-object implementation requires\n"
    "//               this to be set false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_handle_datagrams_internally_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHandleDatagramsInternally", key_word_list));
        else
            (PyArg_Parse(args, ":getHandleDatagramsInternally"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_handle_datagrams_internally();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHandleDatagramsInternally(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment =
    "C++ Interface:\n"
    "getHandleDatagramsInternally(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_handle_datagrams_internally\n"
    "//       Access: Published\n"
    "//  Description: Returns the handle_datagrams_internally flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_track_clsends(bool track_clsends)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_track_clsends_12(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_track_clsends(bool track_clsends)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"track_clsends", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTrackClsends", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTrackClsends", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_track_clsends((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setTrackClsends() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTrackClsends(non-const CConnectionRepository this, bool track_clsends)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_track_clsends_12_comment =
    "C++ Interface:\n"
    "setTrackClsends(non-const CConnectionRepository this, bool track_clsends)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_handle_datagrams_internally\n"
    "//       Access: Published\n"
    "//  Description: Sets the handle_datagrams_internally flag.  When\n"
    "//               true, certain message types can be handled by the C++\n"
    "//               code in in this module.  When false, all datagrams,\n"
    "//               regardless of message type, are passed up to Python\n"
    "//               for processing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_track_clsends_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_track_clsends(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_track_clsends_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_track_clsends(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrackClsends", key_word_list));
        else
            (PyArg_Parse(args, ":getTrackClsends"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_track_clsends();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrackClsends(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_track_clsends_13_comment =
    "C++ Interface:\n"
    "getTrackClsends(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_handle_datagrams_internally\n"
    "//       Access: Published\n"
    "//  Description: Returns the handle_datagrams_internally flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_track_clsends_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_tcp_header_size_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
        int param1;
        static char * key_word_list[] = {(char *)"tcp_header_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setTcpHeaderSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setTcpHeaderSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tcp_header_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setTcpHeaderSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTcpHeaderSize(non-const CConnectionRepository this, int tcp_header_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_tcp_header_size_14_comment =
    "C++ Interface:\n"
    "setTcpHeaderSize(non-const CConnectionRepository this, int tcp_header_size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_tcp_header_size\n"
    "//       Access: Public\n"
    "//  Description: Sets the header size of TCP packets.  At the present,\n"
    "//               legal values for this are 0, 2, or 4; this specifies\n"
    "//               the number of bytes to use encode the datagram length\n"
    "//               at the start of each TCP datagram.  Sender and\n"
    "//               receiver must independently agree on this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_tcp_header_size_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CConnectionRepository::get_tcp_header_size(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_tcp_header_size_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CConnectionRepository::get_tcp_header_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTcpHeaderSize", key_word_list));
        else
            (PyArg_Parse(args, ":getTcpHeaderSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CConnectionRepository*)local_this)->get_tcp_header_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTcpHeaderSize(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_tcp_header_size_15_comment =
    "C++ Interface:\n"
    "getTcpHeaderSize(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_tcp_header_size\n"
    "//       Access: Public\n"
    "//  Description: Returns the current setting of TCP header size.\n"
    "//               See set_tcp_header_size().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_tcp_header_size_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_python_repository_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"python_repository", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPythonRepository", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPythonRepository", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_python_repository(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setPythonRepository() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPythonRepository(non-const CConnectionRepository this, any python_repository)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_python_repository_16_comment =
    "C++ Interface:\n"
    "setPythonRepository(non-const CConnectionRepository this, any python_repository)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_python_repository\n"
    "//       Access: Published\n"
    "//  Description: Records the pointer to the Python class that derives\n"
    "//               from CConnectionRepository.  This allows the C++\n"
    "//               implementation to directly manipulation some python\n"
    "//               structures on the repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_python_repository_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::set_connection_http(HTTPChannel *channel)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_connection_http_17(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CConnectionRepository::set_connection_http(HTTPChannel *channel)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"channel", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setConnectionHttp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setConnectionHttp", &param1));
            if(!PyErr_Occurred())
            {
                HTTPChannel *param1_this = (HTTPChannel *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_HTTPChannel, 1, "CConnectionRepository.setConnectionHttp", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    (local_this)->set_connection_http(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.setConnectionHttp() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setConnectionHttp(non-const CConnectionRepository this, non-const HTTPChannel channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_connection_http_17_comment =
    "C++ Interface:\n"
    "setConnectionHttp(non-const CConnectionRepository this, non-const HTTPChannel channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_connection_http\n"
    "//       Access: Published\n"
    "//  Description: Once a connection has been established via the HTTP\n"
    "//               interface, gets the connection and uses it.  The\n"
    "//               supplied HTTPChannel object must have a connection\n"
    "//               available via get_connection().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_connection_http_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SocketStream *CConnectionRepository::get_stream(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_stream_18(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SocketStream *CConnectionRepository::get_stream(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStream", key_word_list));
        else
            (PyArg_Parse(args, ":getStream"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            SocketStream *return_value = (local_this)->get_stream();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SocketStream,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getStream() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStream(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_stream_18_comment =
    "C++ Interface:\n"
    "getStream(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_stream\n"
    "//       Access: Published\n"
    "//  Description: Returns the SocketStream that internally represents\n"
    "//               the already-established HTTP connection.  Returns\n"
    "//               NULL if there is no current HTTP connection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_stream_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::try_connect_net(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_try_connect_net_19(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CConnectionRepository::try_connect_net(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:tryConnectNet", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:tryConnectNet", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "CConnectionRepository.tryConnectNet", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->try_connect_net(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.tryConnectNet() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tryConnectNet(non-const CConnectionRepository this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_try_connect_net_19_comment =
    "C++ Interface:\n"
    "tryConnectNet(non-const CConnectionRepository this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::try_connect_net\n"
    "//       Access: Published\n"
    "//  Description: Uses Panda's \"net\" library to try to connect to the\n"
    "//               server and port named in the indicated URL.  Returns\n"
    "//               true if successful, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_try_connect_net_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_qcm_20(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQcm", key_word_list));
        else
            (PyArg_Parse(args, ":getQcm"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionManager *return_value = &((local_this)->get_qcm());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionManager,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getQcm() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQcm(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_qcm_20_comment =
    "C++ Interface:\n"
    "getQcm(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_qcm\n"
    "//       Access: Published\n"
    "//  Description: Returns the QueuedConnectionManager object associated\n"
    "//               with the repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_qcm_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConnectionWriter &CConnectionRepository::get_cw(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_cw_21(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline ConnectionWriter &CConnectionRepository::get_cw(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCw", key_word_list));
        else
            (PyArg_Parse(args, ":getCw"));
        if(!PyErr_Occurred())
        {
            ConnectionWriter *return_value = &((local_this)->get_cw());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConnectionWriter,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getCw() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCw(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_cw_21_comment =
    "C++ Interface:\n"
    "getCw(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_cw\n"
    "//       Access: Published\n"
    "//  Description: Returns the ConnectionWriter object associated\n"
    "//               with the repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_cw_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_qcr_22(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQcr", key_word_list));
        else
            (PyArg_Parse(args, ":getQcr"));
        if(!PyErr_Occurred())
        {
            QueuedConnectionReader *return_value = &((local_this)->get_qcr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_QueuedConnectionReader,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getQcr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQcr(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_qcr_22_comment =
    "C++ Interface:\n"
    "getQcr(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_qcr\n"
    "//       Access: Published\n"
    "//  Description: Returns the QueuedConnectionReader object associated\n"
    "//               with the repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_qcr_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::connect_native(URLSpec const &url)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_connect_native_23(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CConnectionRepository::connect_native(URLSpec const &url)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"url", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:connectNative", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:connectNative", &param1));
            if(!PyErr_Occurred())
            {
                URLSpec *param1_this = (URLSpec *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_URLSpec, 1, "CConnectionRepository.connectNative", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->connect_native(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.connectNative() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "connectNative(non-const CConnectionRepository this, const URLSpec url)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_connect_native_23_comment =
    "C++ Interface:\n"
    "connectNative(non-const CConnectionRepository this, const URLSpec url)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::connect_native\n"
    "//       Access: Published\n"
    "//  Description: Connects to the server using Panda's low-level and\n"
    "//               fast \"native net\" library.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_connect_native_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Buffered_DatagramConnection &CConnectionRepository::get_bdc(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_bdc_24(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline Buffered_DatagramConnection &CConnectionRepository::get_bdc(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBdc", key_word_list));
        else
            (PyArg_Parse(args, ":getBdc"));
        if(!PyErr_Occurred())
        {
            Buffered_DatagramConnection *return_value = &((local_this)->get_bdc());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Buffered_DatagramConnection,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.getBdc() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBdc(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_bdc_24_comment =
    "C++ Interface:\n"
    "getBdc(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_bdc\n"
    "//       Access: Published\n"
    "//  Description: Returns the Buffered_DatagramConnection object associated\n"
    "//               with the repository.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_bdc_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::check_datagram(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_check_datagram_25(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CConnectionRepository::check_datagram(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":checkDatagram", key_word_list));
        else
            (PyArg_Parse(args, ":checkDatagram"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->check_datagram();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.checkDatagram() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkDatagram(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_check_datagram_25_comment =
    "C++ Interface:\n"
    "checkDatagram(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::check_datagram\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a new datagram is available, false\n"
    "//               otherwise.  If the return value is true, the new\n"
    "//               datagram may be retrieved via get_datagram(), or\n"
    "//               preferably, with get_datagram_iterator() and\n"
    "//               get_msg_type().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_check_datagram_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::check_datagram_ai(PyObject *PycallBackFunction)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_check_datagram_ai_26(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CConnectionRepository::check_datagram_ai(PyObject *PycallBackFunction)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"PycallBackFunction", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:checkDatagramAi", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:checkDatagramAi", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->check_datagram_ai(param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.checkDatagramAi() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "checkDatagramAi(non-const CConnectionRepository this, any PycallBackFunction)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_check_datagram_ai_26_comment =
    "C++ Interface:\n"
    "checkDatagramAi(non-const CConnectionRepository this, any PycallBackFunction)\n"
    "\n"
    "";
#else
static const char * Dtool_CConnectionRepository_check_datagram_ai_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::network_based_reader_and_yielder(PyObject *PycallBackFunction, ClockObject &clock, float returnBy)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_network_based_reader_and_yielder_27(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CConnectionRepository::network_based_reader_and_yielder(PyObject *PycallBackFunction, ClockObject &clock, float returnBy)
            PyObject *param1;
            PyObject *param2;
            double param3;
            static char * key_word_list[] = {(char *)"PycallBackFunction", (char *)"clock", (char *)"returnBy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOd:networkBasedReaderAndYielder", key_word_list, &param1, &param2, &param3))
            {
                ClockObject *param2_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ClockObject, 2, "CConnectionRepository.networkBasedReaderAndYielder", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->network_based_reader_and_yielder(param1, *param2_this, (float)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.networkBasedReaderAndYielder() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "networkBasedReaderAndYielder(non-const CConnectionRepository this, any PycallBackFunction, non-const ClockObject clock, float returnBy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_network_based_reader_and_yielder_27_comment =
    "C++ Interface:\n"
    "networkBasedReaderAndYielder(non-const CConnectionRepository this, any PycallBackFunction, non-const ClockObject clock, float returnBy)\n"
    "\n"
    "";
#else
static const char * Dtool_CConnectionRepository_network_based_reader_and_yielder_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::get_datagram(Datagram &dg)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_datagram_28(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CConnectionRepository::get_datagram(Datagram &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "CConnectionRepository.getDatagram", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    (local_this)->get_datagram(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.getDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDatagram(non-const CConnectionRepository this, non-const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_datagram_28_comment =
    "C++ Interface:\n"
    "getDatagram(non-const CConnectionRepository this, non-const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_datagram\n"
    "//       Access: Published\n"
    "//  Description: Fills the datagram object with the datagram most\n"
    "//               recently retrieved by check_datagram().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_datagram_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_datagram_iterator_29(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"di", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDatagramIterator", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getDatagramIterator", &param1));
            if(!PyErr_Occurred())
            {
                DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramIterator, 1, "CConnectionRepository.getDatagramIterator", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    (local_this)->get_datagram_iterator(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.getDatagramIterator() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDatagramIterator(non-const CConnectionRepository this, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_datagram_iterator_29_comment =
    "C++ Interface:\n"
    "getDatagramIterator(non-const CConnectionRepository this, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_datagram_iterator\n"
    "//       Access: Published\n"
    "//  Description: Fills the DatagramIterator object with the iterator\n"
    "//               for the datagram most recently retrieved by\n"
    "//               check_datagram().  This iterator has already read\n"
    "//               past the datagram header and the message type, and is\n"
    "//               positioned at the beginning of data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_datagram_iterator_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 CConnectionRepository::get_msg_channel(int offset) const
 * inline unsigned __int64 CConnectionRepository::get_msg_channel(int offset = (0)) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_msg_channel_30(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline unsigned __int64 CConnectionRepository::get_msg_channel(int offset = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getMsgChannel", key_word_list));
            else
                (PyArg_Parse(args, ":getMsgChannel"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                unsigned __int64 return_value = ((const CConnectionRepository*)local_this)->get_msg_channel();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLong_FromUnsignedLongLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline unsigned __int64 CConnectionRepository::get_msg_channel(int offset) const
            int param1;
            static char * key_word_list[] = {(char *)"offset", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getMsgChannel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getMsgChannel", &param1));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                unsigned __int64 return_value = ((const CConnectionRepository*)local_this)->get_msg_channel((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyLong_FromUnsignedLongLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getMsgChannel() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getMsgChannel(const CConnectionRepository this)\n"
          "getMsgChannel(const CConnectionRepository this, int offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_msg_channel_30_comment =
    "C++ Interface:\n"
    "getMsgChannel(const CConnectionRepository this)\n"
    "getMsgChannel(const CConnectionRepository this, int offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_msg_channel\n"
    "//       Access: Published\n"
    "//  Description: Returns the channel(s) to which the current message\n"
    "//               was sent, according to the datagram headers.  This\n"
    "//               information is not available to the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_msg_channel_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CConnectionRepository::get_msg_channel_count(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_msg_channel_count_31(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CConnectionRepository::get_msg_channel_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMsgChannelCount", key_word_list));
        else
            (PyArg_Parse(args, ":getMsgChannelCount"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            int return_value = ((const CConnectionRepository*)local_this)->get_msg_channel_count();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMsgChannelCount(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_msg_channel_count_31_comment =
    "C++ Interface:\n"
    "getMsgChannelCount(const CConnectionRepository this)\n"
    "\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_msg_channel_count_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 CConnectionRepository::get_msg_sender(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_msg_sender_32(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned __int64 CConnectionRepository::get_msg_sender(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMsgSender", key_word_list));
        else
            (PyArg_Parse(args, ":getMsgSender"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned __int64 return_value = ((const CConnectionRepository*)local_this)->get_msg_sender();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMsgSender(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_msg_sender_32_comment =
    "C++ Interface:\n"
    "getMsgSender(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_msg_sender\n"
    "//       Access: Published\n"
    "//  Description: Returns the sender ID of the current message,\n"
    "//               according to the datagram headers.  This information\n"
    "//               is not available to the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_msg_sender_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int CConnectionRepository::get_msg_type(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_msg_type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int CConnectionRepository::get_msg_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMsgType", key_word_list));
        else
            (PyArg_Parse(args, ":getMsgType"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            unsigned int return_value = ((const CConnectionRepository*)local_this)->get_msg_type();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMsgType(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_msg_type_33_comment =
    "C++ Interface:\n"
    "getMsgType(const CConnectionRepository this)\n"
    "\n"
    "//  INLINE unsigned char get_sec_code() const;\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_sec_code\n"
    "//       Access: Published\n"
    "//  Description: Returns the security code associated with the current\n"
    "//               message, according to the datagram headers.  This\n"
    "//               information is not available to the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//INLINE unsigned char CConnectionRepository::\n"
    "//get_sec_code() const {\n"
    "//  return _sec_code;\n"
    "//}\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_msg_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type ID of the current message,\n"
    "//               according to the datagram headers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_msg_type_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline basic_string< char > const &CConnectionRepository::get_overflow_event_name(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_overflow_event_name_34(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline basic_string< char > const &CConnectionRepository::get_overflow_event_name(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverflowEventName", key_word_list))
        {
            basic_string< char > const &return_value = CConnectionRepository::get_overflow_event_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverflowEventName()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_overflow_event_name_34_comment =
    "C++ Interface:\n"
    "getOverflowEventName()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_overflow_event_name\n"
    "//       Access: Published\n"
    "//  Description: Returns event string that will be thrown if the\n"
    "//               datagram reader queue overflows.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_overflow_event_name_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::is_connected(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_is_connected_35(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CConnectionRepository::is_connected(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isConnected", key_word_list));
        else
            (PyArg_Parse(args, ":isConnected"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->is_connected();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.isConnected() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConnected(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_is_connected_35_comment =
    "C++ Interface:\n"
    "isConnected(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::is_connected\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the connection to the gameserver is\n"
    "//               established and still good, false if we are not\n"
    "//               connected.  A false value means either (a) we never\n"
    "//               successfully connected, (b) we explicitly called\n"
    "//               disconnect(), or (c) we were connected, but the\n"
    "//               connection was spontaneously lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_is_connected_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::send_datagram(Datagram const &dg)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_send_datagram_36(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CConnectionRepository::send_datagram(Datagram const &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:sendDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:sendDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "CConnectionRepository.sendDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    bool return_value = (local_this)->send_datagram(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.sendDatagram() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendDatagram(non-const CConnectionRepository this, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_send_datagram_36_comment =
    "C++ Interface:\n"
    "sendDatagram(non-const CConnectionRepository this, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::send_datagram\n"
    "//       Access: Published\n"
    "//  Description: Queues the indicated datagram for sending to the\n"
    "//               server.  It may not get sent immediately if\n"
    "//               collect_tcp is in effect; call flush() to guarantee\n"
    "//               it is sent now.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_send_datagram_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_want_message_bundling(bool flag)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_want_message_bundling_37(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_want_message_bundling(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWantMessageBundling", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setWantMessageBundling", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->set_want_message_bundling((PyObject_IsTrue(param1)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setWantMessageBundling() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWantMessageBundling(non-const CConnectionRepository this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_want_message_bundling_37_comment =
    "C++ Interface:\n"
    "setWantMessageBundling(non-const CConnectionRepository this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_want_message_bundling\n"
    "//       Access: Published\n"
    "//  Description: Enable/disable outbound message bundling\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_want_message_bundling_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_want_message_bundling(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_want_message_bundling_38(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_want_message_bundling(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWantMessageBundling", key_word_list));
        else
            (PyArg_Parse(args, ":getWantMessageBundling"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((const CConnectionRepository*)local_this)->get_want_message_bundling();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWantMessageBundling(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_want_message_bundling_38_comment =
    "C++ Interface:\n"
    "getWantMessageBundling(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_want_message_bundling\n"
    "//       Access: Published\n"
    "//  Description: Returns true if message bundling enabled\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_want_message_bundling_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_in_quiet_zone(bool flag)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_in_quiet_zone_39(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_in_quiet_zone(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInQuietZone", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInQuietZone", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->set_in_quiet_zone((PyObject_IsTrue(param1)!=0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setInQuietZone() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInQuietZone(non-const CConnectionRepository this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_in_quiet_zone_39_comment =
    "C++ Interface:\n"
    "setInQuietZone(non-const CConnectionRepository this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_in_quiet_zone\n"
    "//       Access: Published\n"
    "//  Description: Enables/disables quiet zone mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_in_quiet_zone_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_in_quiet_zone(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_in_quiet_zone_40(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_in_quiet_zone(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInQuietZone", key_word_list));
        else
            (PyArg_Parse(args, ":getInQuietZone"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((const CConnectionRepository*)local_this)->get_in_quiet_zone();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInQuietZone(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_in_quiet_zone_40_comment =
    "C++ Interface:\n"
    "getInQuietZone(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_in_quiet_zone\n"
    "//       Access: Published\n"
    "//  Description: Returns true if repository is in quiet zone mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_in_quiet_zone_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::start_message_bundle(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_start_message_bundle_41(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::start_message_bundle(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":startMessageBundle", key_word_list));
        else
            (PyArg_Parse(args, ":startMessageBundle"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->start_message_bundle();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.startMessageBundle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "startMessageBundle(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_start_message_bundle_41_comment =
    "C++ Interface:\n"
    "startMessageBundle(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::start_message_bundle\n"
    "//       Access: Published\n"
    "//  Description: Send a set of messages to the state server that will\n"
    "//               be processed atomically.  For instance, you can do a\n"
    "//               combined setLocation/setPos and prevent race\n"
    "//               conditions where clients briefly get the setLocation\n"
    "//               but not the setPos, because the state server hasn't\n"
    "//               processed the setPos yet\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_start_message_bundle_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::is_bundling_messages(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_is_bundling_messages_42(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::is_bundling_messages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBundlingMessages", key_word_list));
        else
            (PyArg_Parse(args, ":isBundlingMessages"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((const CConnectionRepository*)local_this)->is_bundling_messages();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBundlingMessages(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_is_bundling_messages_42_comment =
    "C++ Interface:\n"
    "isBundlingMessages(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::is_bundling_messages\n"
    "//       Access: Published\n"
    "//  Description: Returns true if repository is queueing outgoing messages\n"
    "//               into a message bundle\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_is_bundling_messages_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_send_message_bundle_43(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"channel", (char *)"sender_channel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:sendMessageBundle", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->send_message_bundle(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.sendMessageBundle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendMessageBundle(non-const CConnectionRepository this, unsigned int channel, unsigned int sender_channel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_send_message_bundle_43_comment =
    "C++ Interface:\n"
    "sendMessageBundle(non-const CConnectionRepository this, unsigned int channel, unsigned int sender_channel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::send_message_bundle\n"
    "//       Access: Published\n"
    "//  Description: Send network messages queued up since\n"
    "//               startMessageBundle was called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_send_message_bundle_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::abandon_message_bundles(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_abandon_message_bundles_44(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::abandon_message_bundles(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":abandonMessageBundles", key_word_list));
        else
            (PyArg_Parse(args, ":abandonMessageBundles"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->abandon_message_bundles();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.abandonMessageBundles() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "abandonMessageBundles(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_abandon_message_bundles_44_comment =
    "C++ Interface:\n"
    "abandonMessageBundles(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::abandon_message_bundles\n"
    "//       Access: Published\n"
    "//  Description: throw out any msgs that have been queued up for\n"
    "//               message bundles\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_abandon_message_bundles_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::bundle_msg(Datagram const &dg)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_bundle_msg_45(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CConnectionRepository::bundle_msg(Datagram const &dg)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:bundleMsg", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:bundleMsg", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "CConnectionRepository.bundleMsg", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    PyThreadState *_save;
                    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    (local_this)->bundle_msg(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CConnectionRepository.bundleMsg() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bundleMsg(non-const CConnectionRepository this, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_bundle_msg_45_comment =
    "C++ Interface:\n"
    "bundleMsg(non-const CConnectionRepository this, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::bundle_msg\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_bundle_msg_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::consider_flush(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_consider_flush_46(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CConnectionRepository::consider_flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":considerFlush", key_word_list));
        else
            (PyArg_Parse(args, ":considerFlush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->consider_flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.considerFlush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerFlush(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_consider_flush_46_comment =
    "C++ Interface:\n"
    "considerFlush(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::consider_flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data if enough time\n"
    "//               has elapsed.  This only has meaning if\n"
    "//               set_collect_tcp() has been set to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_consider_flush_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CConnectionRepository::flush(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_flush_47(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CConnectionRepository::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_flush_47_comment =
    "C++ Interface:\n"
    "flush(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::flush\n"
    "//       Access: Published\n"
    "//  Description: Sends the most recently queued data now.  This only\n"
    "//               has meaning if set_collect_tcp() has been set to\n"
    "//               true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_flush_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::disconnect(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_disconnect_48(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::disconnect(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":disconnect", key_word_list));
        else
            (PyArg_Parse(args, ":disconnect"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->disconnect();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.disconnect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disconnect(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_disconnect_48_comment =
    "C++ Interface:\n"
    "disconnect(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::disconnect\n"
    "//       Access: Published\n"
    "//  Description: Closes the connection to the server.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_disconnect_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::shutdown(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_shutdown_49(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CConnectionRepository::shutdown(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":shutdown", key_word_list));
        else
            (PyArg_Parse(args, ":shutdown"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->shutdown();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.shutdown() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "shutdown(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_shutdown_49_comment =
    "C++ Interface:\n"
    "shutdown(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::shutdown\n"
    "//       Access: Published\n"
    "//  Description: May be called at application shutdown to ensure all\n"
    "//               threads are cleaned up.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_shutdown_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_simulated_disconnect_50(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"simulated_disconnect", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSimulatedDisconnect", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSimulatedDisconnect", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_simulated_disconnect((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setSimulatedDisconnect() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSimulatedDisconnect(non-const CConnectionRepository this, bool simulated_disconnect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_simulated_disconnect_50_comment =
    "C++ Interface:\n"
    "setSimulatedDisconnect(non-const CConnectionRepository this, bool simulated_disconnect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_simulated_disconnect\n"
    "//       Access: Published\n"
    "//  Description: Sets the simulated disconnect flag.  While this is\n"
    "//               true, no datagrams will be retrieved from or sent to\n"
    "//               the server.  The idea is to simulate a temporary\n"
    "//               network outage.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_simulated_disconnect_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_simulated_disconnect(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_simulated_disconnect_51(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_simulated_disconnect(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSimulatedDisconnect", key_word_list));
        else
            (PyArg_Parse(args, ":getSimulatedDisconnect"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_simulated_disconnect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSimulatedDisconnect(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_simulated_disconnect_51_comment =
    "C++ Interface:\n"
    "getSimulatedDisconnect(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_simulated_disconnect\n"
    "//       Access: Published\n"
    "//  Description: Returns the simulated disconnect flag.  While this is\n"
    "//               true, no datagrams will be retrieved from or sent to\n"
    "//               the server.  The idea is to simulate a temporary\n"
    "//               network outage.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_simulated_disconnect_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::toggle_verbose(void)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_toggle_verbose_52(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::toggle_verbose(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":toggleVerbose", key_word_list));
        else
            (PyArg_Parse(args, ":toggleVerbose"));
        if(!PyErr_Occurred())
        {
            (local_this)->toggle_verbose();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.toggleVerbose() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "toggleVerbose(non-const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_toggle_verbose_52_comment =
    "C++ Interface:\n"
    "toggleVerbose(non-const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::toggle_verbose\n"
    "//       Access: Published\n"
    "//  Description: Toggles the current setting of the verbose flag.\n"
    "//               When true, this describes every message going back\n"
    "//               and forth on the wire.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_toggle_verbose_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_verbose(bool verbose)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_verbose_53(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_verbose(bool verbose)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"verbose", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVerbose", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setVerbose", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_verbose((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setVerbose() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerbose(non-const CConnectionRepository this, bool verbose)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_verbose_53_comment =
    "C++ Interface:\n"
    "setVerbose(non-const CConnectionRepository this, bool verbose)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_verbose\n"
    "//       Access: Published\n"
    "//  Description: Directly sets the verbose flag.  When true, this\n"
    "//               describes every message going back and forth on the\n"
    "//               wire.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_verbose_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CConnectionRepository::get_verbose(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_verbose_54(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CConnectionRepository::get_verbose(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerbose", key_word_list));
        else
            (PyArg_Parse(args, ":getVerbose"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CConnectionRepository*)local_this)->get_verbose();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerbose(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_verbose_54_comment =
    "C++ Interface:\n"
    "getVerbose(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_verbose\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the verbose flag.\n"
    "//               When true, this describes every message going back\n"
    "//               and forth on the wire.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_verbose_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::set_time_warning(float time_warning)
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_set_time_warning_55(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CConnectionRepository::set_time_warning(float time_warning)
        double param1;
        static char * key_word_list[] = {(char *)"time_warning", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTimeWarning", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTimeWarning", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_time_warning((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CConnectionRepository.setTimeWarning() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimeWarning(non-const CConnectionRepository this, float time_warning)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_set_time_warning_55_comment =
    "C++ Interface:\n"
    "setTimeWarning(non-const CConnectionRepository this, float time_warning)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::set_time_warning\n"
    "//       Access: Published\n"
    "//  Description: Directly sets the time_warning field.  When non zero, this\n"
    "//               describes every message going back and forth on the\n"
    "//               wire when the msg handling time is over it\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_set_time_warning_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CConnectionRepository::get_time_warning(void) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_get_time_warning_56(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CConnectionRepository::get_time_warning(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimeWarning", key_word_list));
        else
            (PyArg_Parse(args, ":getTimeWarning"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CConnectionRepository*)local_this)->get_time_warning();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimeWarning(const CConnectionRepository this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_get_time_warning_56_comment =
    "C++ Interface:\n"
    "getTimeWarning(const CConnectionRepository this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::get_time_warning\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the time_warning field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_get_time_warning_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CConnectionRepository::describe_datagram(Datagram const &dg) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_describe_datagram_57(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void CConnectionRepository::describe_datagram(Datagram const &dg) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:describeDatagram", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:describeDatagram", &param1));
            if(!PyErr_Occurred())
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "CConnectionRepository.describeDatagram", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CConnectionRepository*)local_this)->describe_datagram(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "describeDatagram(const CConnectionRepository this, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_describe_datagram_57_comment =
    "C++ Interface:\n"
    "describeDatagram(const CConnectionRepository this, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::describe_datagram\n"
    "//       Access: Published\n"
    "//  Description: Prints user-friendly description of a datagram\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_describe_datagram_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CConnectionRepository::describe_message(ostream &out, basic_string< char > const &prefix, Datagram const &dg) const
 *******************************************************************/
static PyObject *Dtool_CConnectionRepository_describe_message_58(PyObject *self, PyObject *args,PyObject *kwds) {
    CConnectionRepository * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConnectionRepository,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CConnectionRepository::describe_message(ostream &out, basic_string< char > const &prefix, Datagram const &dg) const
            PyObject *param1;
            char *param2_str; int param2_len;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"out", (char *)"prefix", (char *)"dg", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#O:describeMessage", key_word_list, &param1, &param2_str, &param2_len, &param3))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CConnectionRepository.describeMessage", 0, coerced_ptr, report_errors);
Datagram *param3_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Datagram, 3, "CConnectionRepository.describeMessage", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param3_this == NULL)))
                {
                    ((const CConnectionRepository*)local_this)->describe_message(*param1_this, basic_string<char>(param2_str, param2_len), *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "describeMessage(const CConnectionRepository this, non-const Ostream out, string prefix, const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConnectionRepository_describe_message_58_comment =
    "C++ Interface:\n"
    "describeMessage(const CConnectionRepository this, non-const Ostream out, string prefix, const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConnectionRepository::describe_message\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the message and reformats it for user\n"
    "//               consumption, writing a description on the indicated\n"
    "//               output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConnectionRepository_describe_message_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
 * CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net = (0))
 * CConnectionRepository::CConnectionRepository(bool has_owner_view = (0), bool threaded_net = (0))
 *******************************************************************/
int  Dtool_Init_CConnectionRepository(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view = (0), bool threaded_net = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CConnectionRepository", key_word_list))
            {
                CConnectionRepository *return_value = new CConnectionRepository();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CConnectionRepository,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net = (0))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"has_owner_view", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:CConnectionRepository", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:CConnectionRepository", &param0));
            if(!PyErr_Occurred())
            {
                CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CConnectionRepository,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"has_owner_view", (char *)"threaded_net", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CConnectionRepository", key_word_list, &param0, &param1))
            {
                CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0)!=0), (PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CConnectionRepository,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CConnectionRepository() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CConnectionRepository()\n"
          "CConnectionRepository(bool has_owner_view)\n"
          "CConnectionRepository(bool has_owner_view, bool threaded_net)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CConnectionRepository(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConnectionRepository)
    {
        printf("CConnectionRepository ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConnectionRepository * local_this = (CConnectionRepository *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConnectionRepository)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConnectionRepository(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConnectionRepository)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CDistributedSmoothNodeBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, unsigned __int64 ai_id)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_set_repository_62(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, unsigned __int64 ai_id)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"repository", (char *)"is_ai", (char *)"ai_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setRepository", key_word_list, &param0, &param1, &param2))
            {
                CConnectionRepository *param0_this = (CConnectionRepository *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_CConnectionRepository, 0, "CDistributedSmoothNodeBase.setRepository", 0, coerced_ptr, report_errors);
 PyObject *param2_long = PyNumber_Long(param2);
                if (!((param0_this == NULL)|| (param2_long == NULL)))
                {
                    CDistributedSmoothNodeBase::set_repository(param0_this, (PyObject_IsTrue(param1)!=0), PyLong_AsUnsignedLongLong(param2_long));
                     Py_XDECREF(param2_long);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRepository(non-const CConnectionRepository repository, bool is_ai, unsigned long long ai_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_set_repository_62_comment =
    "C++ Interface:\n"
    "setRepository(non-const CConnectionRepository repository, bool is_ai, unsigned long long ai_id)\n"
    "\n"
    "// Filename: cDistributedSmoothNodeBase.I\n"
    "// Created by:  drose (03Sep04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::set_repository\n"
    "//       Access: Published, Static\n"
    "//  Description: Tells the C++ class definition about the AI or Client\n"
    "//               repository, used for sending datagrams.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_set_repository_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_set_clock_delta_63(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"clock_delta", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClockDelta", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setClockDelta", &param0));
        if(!PyErr_Occurred())
        {
            CDistributedSmoothNodeBase::set_clock_delta(param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClockDelta(any clock_delta)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_set_clock_delta_63_comment =
    "C++ Interface:\n"
    "setClockDelta(any clock_delta)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::set_clock_delta\n"
    "//       Access: Published, Static\n"
    "//  Description: Tells the C++ class definition about the global\n"
    "//               ClockDelta object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_set_clock_delta_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, unsigned __int64 do_id)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_initialize_64(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, unsigned __int64 do_id)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"node_path", (char *)"dclass", (char *)"do_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:initialize", key_word_list, &param1, &param2, &param3))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CDistributedSmoothNodeBase.initialize", 1, coerced_ptr, report_errors);
DCClass *param2_this = (DCClass *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DCClass, 2, "CDistributedSmoothNodeBase.initialize", 0, coerced_ptr, report_errors);
 PyObject *param3_long = PyNumber_Long(param3);
                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_long == NULL)))
                {
                    (local_this)->initialize(*param1_this, param2_this, PyLong_AsUnsignedLongLong(param3_long));
                     Py_XDECREF(param3_long);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CDistributedSmoothNodeBase.initialize() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initialize(non-const CDistributedSmoothNodeBase this, const NodePath node_path, non-const DCClass dclass, unsigned long long do_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_initialize_64_comment =
    "C++ Interface:\n"
    "initialize(non-const CDistributedSmoothNodeBase this, const NodePath node_path, non-const DCClass dclass, unsigned long long do_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::initialize\n"
    "//       Access: Published\n"
    "//  Description: Initializes the internal structures from some\n"
    "//               constructs that are normally stored only in Python.\n"
    "//               Also reads the current node's pos & hpr values in\n"
    "//               preparation for transmitting them via one of the\n"
    "//               broadcast_pos_hpr_*() methods.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_initialize_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::send_everything(void)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_send_everything_65(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::send_everything(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sendEverything", key_word_list));
        else
            (PyArg_Parse(args, ":sendEverything"));
        if(!PyErr_Occurred())
        {
            (local_this)->send_everything();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.sendEverything() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sendEverything(non-const CDistributedSmoothNodeBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_send_everything_65_comment =
    "C++ Interface:\n"
    "sendEverything(non-const CDistributedSmoothNodeBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::send_everything\n"
    "//       Access: Published\n"
    "//  Description: Broadcasts the current pos/hpr in its complete form.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_send_everything_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_66(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":broadcastPosHprFull", key_word_list));
        else
            (PyArg_Parse(args, ":broadcastPosHprFull"));
        if(!PyErr_Occurred())
        {
            (local_this)->broadcast_pos_hpr_full();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.broadcastPosHprFull() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "broadcastPosHprFull(non-const CDistributedSmoothNodeBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_66_comment =
    "C++ Interface:\n"
    "broadcastPosHprFull(non-const CDistributedSmoothNodeBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::broadcast_pos_hpr_full\n"
    "//       Access: Published\n"
    "//  Description: Examines the complete pos/hpr information to see\n"
    "//               which of the six elements have changed, and\n"
    "//               broadcasts the appropriate messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_67(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":broadcastPosHprXyh", key_word_list));
        else
            (PyArg_Parse(args, ":broadcastPosHprXyh"));
        if(!PyErr_Occurred())
        {
            (local_this)->broadcast_pos_hpr_xyh();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.broadcastPosHprXyh() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "broadcastPosHprXyh(non-const CDistributedSmoothNodeBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_67_comment =
    "C++ Interface:\n"
    "broadcastPosHprXyh(non-const CDistributedSmoothNodeBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh\n"
    "//       Access: Published\n"
    "//  Description: Examines only X, Y, and H of the pos/hpr information,\n"
    "//               and broadcasts the appropriate messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_68(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":broadcastPosHprXy", key_word_list));
        else
            (PyArg_Parse(args, ":broadcastPosHprXy"));
        if(!PyErr_Occurred())
        {
            (local_this)->broadcast_pos_hpr_xy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.broadcastPosHprXy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "broadcastPosHprXy(non-const CDistributedSmoothNodeBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_68_comment =
    "C++ Interface:\n"
    "broadcastPosHprXy(non-const CDistributedSmoothNodeBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::broadcast_pos_hpr_xy\n"
    "//       Access: Published\n"
    "//  Description: Examines only X and Y of the pos/hpr information,\n"
    "//               and broadcasts the appropriate messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::set_curr_l(unsigned __int64 l)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_set_curr_l_69(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::set_curr_l(unsigned __int64 l)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"l", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCurrL", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCurrL", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->set_curr_l(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.setCurrL() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCurrL(non-const CDistributedSmoothNodeBase this, unsigned long long l)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_set_curr_l_69_comment =
    "C++ Interface:\n"
    "setCurrL(non-const CDistributedSmoothNodeBase this, unsigned long long l)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CDistributedSmoothNodeBase::set_curr_l\n"
    "//                 published function to set current location for\n"
    "//                 this object, this location is then sent out along\n"
    "//                 with the next position broadcast\n"
    "//       Access: Private\n"
    "//  Description: Appends the timestamp and sends the update.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_set_curr_l_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CDistributedSmoothNodeBase::print_curr_l(void)
 *******************************************************************/
static PyObject *Dtool_CDistributedSmoothNodeBase_print_curr_l_70(PyObject *self, PyObject *args,PyObject *kwds) {
    CDistributedSmoothNodeBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CDistributedSmoothNodeBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CDistributedSmoothNodeBase::print_curr_l(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printCurrL", key_word_list));
        else
            (PyArg_Parse(args, ":printCurrL"));
        if(!PyErr_Occurred())
        {
            (local_this)->print_curr_l();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CDistributedSmoothNodeBase.printCurrL() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printCurrL(non-const CDistributedSmoothNodeBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CDistributedSmoothNodeBase_print_curr_l_70_comment =
    "C++ Interface:\n"
    "printCurrL(non-const CDistributedSmoothNodeBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_CDistributedSmoothNodeBase_print_curr_l_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
 *******************************************************************/
int  Dtool_Init_CDistributedSmoothNodeBase(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CDistributedSmoothNodeBase", key_word_list))
        {
            CDistributedSmoothNodeBase *return_value = new CDistributedSmoothNodeBase();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CDistributedSmoothNodeBase,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CDistributedSmoothNodeBase()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CDistributedSmoothNodeBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CDistributedSmoothNodeBase)
    {
        printf("CDistributedSmoothNodeBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CDistributedSmoothNodeBase * local_this = (CDistributedSmoothNodeBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CDistributedSmoothNodeBase)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CDistributedSmoothNodeBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CDistributedSmoothNodeBase)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CConnectionRepository | CConnectionRepository
//********************************************************************
PyMethodDef Dtool_Methods_CConnectionRepository[]= {
  { "getDcFile",(PyCFunction ) &Dtool_CConnectionRepository_get_dc_file_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_dc_file_4_comment},
  { "hasOwnerView",(PyCFunction ) &Dtool_CConnectionRepository_has_owner_view_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_has_owner_view_5_comment},
  { "setHandleCUpdates",(PyCFunction ) &Dtool_CConnectionRepository_set_handle_c_updates_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_handle_c_updates_6_comment},
  { "getHandleCUpdates",(PyCFunction ) &Dtool_CConnectionRepository_get_handle_c_updates_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_handle_c_updates_7_comment},
  { "setClientDatagram",(PyCFunction ) &Dtool_CConnectionRepository_set_client_datagram_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_client_datagram_8_comment},
  { "getClientDatagram",(PyCFunction ) &Dtool_CConnectionRepository_get_client_datagram_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_client_datagram_9_comment},
  { "setHandleDatagramsInternally",(PyCFunction ) &Dtool_CConnectionRepository_set_handle_datagrams_internally_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment},
  { "getHandleDatagramsInternally",(PyCFunction ) &Dtool_CConnectionRepository_get_handle_datagrams_internally_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment},
  { "setTrackClsends",(PyCFunction ) &Dtool_CConnectionRepository_set_track_clsends_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_track_clsends_12_comment},
  { "getTrackClsends",(PyCFunction ) &Dtool_CConnectionRepository_get_track_clsends_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_track_clsends_13_comment},
  { "setTcpHeaderSize",(PyCFunction ) &Dtool_CConnectionRepository_set_tcp_header_size_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_tcp_header_size_14_comment},
  { "getTcpHeaderSize",(PyCFunction ) &Dtool_CConnectionRepository_get_tcp_header_size_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_tcp_header_size_15_comment},
  { "setPythonRepository",(PyCFunction ) &Dtool_CConnectionRepository_set_python_repository_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_python_repository_16_comment},
  { "setConnectionHttp",(PyCFunction ) &Dtool_CConnectionRepository_set_connection_http_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_connection_http_17_comment},
  { "getStream",(PyCFunction ) &Dtool_CConnectionRepository_get_stream_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_stream_18_comment},
  { "tryConnectNet",(PyCFunction ) &Dtool_CConnectionRepository_try_connect_net_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_try_connect_net_19_comment},
  { "getQcm",(PyCFunction ) &Dtool_CConnectionRepository_get_qcm_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_qcm_20_comment},
  { "getCw",(PyCFunction ) &Dtool_CConnectionRepository_get_cw_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_cw_21_comment},
  { "getQcr",(PyCFunction ) &Dtool_CConnectionRepository_get_qcr_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_qcr_22_comment},
  { "connectNative",(PyCFunction ) &Dtool_CConnectionRepository_connect_native_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_connect_native_23_comment},
  { "getBdc",(PyCFunction ) &Dtool_CConnectionRepository_get_bdc_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_bdc_24_comment},
  { "checkDatagram",(PyCFunction ) &Dtool_CConnectionRepository_check_datagram_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_check_datagram_25_comment},
  { "checkDatagramAi",(PyCFunction ) &Dtool_CConnectionRepository_check_datagram_ai_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_check_datagram_ai_26_comment},
  { "networkBasedReaderAndYielder",(PyCFunction ) &Dtool_CConnectionRepository_network_based_reader_and_yielder_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_network_based_reader_and_yielder_27_comment},
  { "getDatagram",(PyCFunction ) &Dtool_CConnectionRepository_get_datagram_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_datagram_28_comment},
  { "getDatagramIterator",(PyCFunction ) &Dtool_CConnectionRepository_get_datagram_iterator_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_datagram_iterator_29_comment},
  { "getMsgChannel",(PyCFunction ) &Dtool_CConnectionRepository_get_msg_channel_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_msg_channel_30_comment},
  { "getMsgChannelCount",(PyCFunction ) &Dtool_CConnectionRepository_get_msg_channel_count_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_msg_channel_count_31_comment},
  { "getMsgSender",(PyCFunction ) &Dtool_CConnectionRepository_get_msg_sender_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_msg_sender_32_comment},
  { "getMsgType",(PyCFunction ) &Dtool_CConnectionRepository_get_msg_type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_msg_type_33_comment},
  { "getOverflowEventName",(PyCFunction ) &Dtool_CConnectionRepository_get_overflow_event_name_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_overflow_event_name_34_comment},
  { "isConnected",(PyCFunction ) &Dtool_CConnectionRepository_is_connected_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_is_connected_35_comment},
  { "sendDatagram",(PyCFunction ) &Dtool_CConnectionRepository_send_datagram_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_send_datagram_36_comment},
  { "setWantMessageBundling",(PyCFunction ) &Dtool_CConnectionRepository_set_want_message_bundling_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_want_message_bundling_37_comment},
  { "getWantMessageBundling",(PyCFunction ) &Dtool_CConnectionRepository_get_want_message_bundling_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_want_message_bundling_38_comment},
  { "setInQuietZone",(PyCFunction ) &Dtool_CConnectionRepository_set_in_quiet_zone_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_in_quiet_zone_39_comment},
  { "getInQuietZone",(PyCFunction ) &Dtool_CConnectionRepository_get_in_quiet_zone_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_in_quiet_zone_40_comment},
  { "startMessageBundle",(PyCFunction ) &Dtool_CConnectionRepository_start_message_bundle_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_start_message_bundle_41_comment},
  { "isBundlingMessages",(PyCFunction ) &Dtool_CConnectionRepository_is_bundling_messages_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_is_bundling_messages_42_comment},
  { "sendMessageBundle",(PyCFunction ) &Dtool_CConnectionRepository_send_message_bundle_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_send_message_bundle_43_comment},
  { "abandonMessageBundles",(PyCFunction ) &Dtool_CConnectionRepository_abandon_message_bundles_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_abandon_message_bundles_44_comment},
  { "bundleMsg",(PyCFunction ) &Dtool_CConnectionRepository_bundle_msg_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_bundle_msg_45_comment},
  { "considerFlush",(PyCFunction ) &Dtool_CConnectionRepository_consider_flush_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_consider_flush_46_comment},
  { "flush",(PyCFunction ) &Dtool_CConnectionRepository_flush_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_flush_47_comment},
  { "disconnect",(PyCFunction ) &Dtool_CConnectionRepository_disconnect_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_disconnect_48_comment},
  { "shutdown",(PyCFunction ) &Dtool_CConnectionRepository_shutdown_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_shutdown_49_comment},
  { "setSimulatedDisconnect",(PyCFunction ) &Dtool_CConnectionRepository_set_simulated_disconnect_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_simulated_disconnect_50_comment},
  { "getSimulatedDisconnect",(PyCFunction ) &Dtool_CConnectionRepository_get_simulated_disconnect_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_simulated_disconnect_51_comment},
  { "toggleVerbose",(PyCFunction ) &Dtool_CConnectionRepository_toggle_verbose_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_toggle_verbose_52_comment},
  { "setVerbose",(PyCFunction ) &Dtool_CConnectionRepository_set_verbose_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_verbose_53_comment},
  { "getVerbose",(PyCFunction ) &Dtool_CConnectionRepository_get_verbose_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_verbose_54_comment},
  { "setTimeWarning",(PyCFunction ) &Dtool_CConnectionRepository_set_time_warning_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_set_time_warning_55_comment},
  { "getTimeWarning",(PyCFunction ) &Dtool_CConnectionRepository_get_time_warning_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_get_time_warning_56_comment},
  { "describeDatagram",(PyCFunction ) &Dtool_CConnectionRepository_describe_datagram_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_describe_datagram_57_comment},
  { "describeMessage",(PyCFunction ) &Dtool_CConnectionRepository_describe_message_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConnectionRepository_describe_message_58_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConnectionRepository(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConnectionRepository.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConnectionRepository\n"
          "// Description : This class implements the C++ side of the\n"
          "//               ConnectionRepository object.  In particular, it\n"
          "//               manages the connection to the server once it has been\n"
          "//               opened (but does not open it directly).  It manages\n"
          "//               reading and writing datagrams on the connection and\n"
          "//               monitoring for unexpected disconnects as well as\n"
          "//               handling intentional disconnects.\n"
          "//\n"
          "//               Certain server messages, like field updates, are\n"
          "//               handled entirely within the C++ layer, while server\n"
          "//               messages that are not understood by the C++ layer are\n"
          "//               returned up to the Python layer for processing.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_CConnectionRepository.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_CConnectionRepository.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConnectionRepository.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConnectionRepository.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConnectionRepository.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConnectionRepository)");
             printf(" Error In PyType_ReadyCConnectionRepository");
             return;
        }
        Py_INCREF(&Dtool_CConnectionRepository.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConnectionRepository.As_PyTypeObject().tp_dict,"CConnectionRepository",&Dtool_CConnectionRepository.As_PyObject());
        //  Static Method getOverflowEventName
        PyDict_SetItemString(Dtool_CConnectionRepository.As_PyTypeObject().tp_dict,"getOverflowEventName",PyCFunction_New(&Dtool_Methods_CConnectionRepository[30],&Dtool_CConnectionRepository.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConnectionRepository,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConnectionRepository.As_PyTypeObject());
        PyModule_AddObject(module, "CConnectionRepository",(PyObject *)&Dtool_CConnectionRepository.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CDistributedSmoothNodeBase | CDistributedSmoothNodeBase
//********************************************************************
PyMethodDef Dtool_Methods_CDistributedSmoothNodeBase[]= {
  { "setRepository",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_set_repository_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_set_repository_62_comment},
  { "setClockDelta",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_set_clock_delta_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_set_clock_delta_63_comment},
  { "initialize",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_initialize_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_initialize_64_comment},
  { "sendEverything",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_send_everything_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_send_everything_65_comment},
  { "broadcastPosHprFull",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_66_comment},
  { "broadcastPosHprXyh",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_67_comment},
  { "broadcastPosHprXy",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_68_comment},
  { "setCurrL",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_set_curr_l_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_set_curr_l_69_comment},
  { "printCurrL",(PyCFunction ) &Dtool_CDistributedSmoothNodeBase_print_curr_l_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CDistributedSmoothNodeBase_print_curr_l_70_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CDistributedSmoothNodeBase\n"
          "// Description : This class defines some basic methods of\n"
          "//               DistributedSmoothNodeBase which have been moved into\n"
          "//               C++ as a performance optimization.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CDistributedSmoothNodeBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CDistributedSmoothNodeBase)");
             printf(" Error In PyType_ReadyCDistributedSmoothNodeBase");
             return;
        }
        Py_INCREF(&Dtool_CDistributedSmoothNodeBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict,"CDistributedSmoothNodeBase",&Dtool_CDistributedSmoothNodeBase.As_PyObject());
        //  Static Method setRepository
        PyDict_SetItemString(Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict,"setRepository",PyCFunction_New(&Dtool_Methods_CDistributedSmoothNodeBase[0],&Dtool_CDistributedSmoothNodeBase.As_PyObject()));
        //  Static Method setClockDelta
        PyDict_SetItemString(Dtool_CDistributedSmoothNodeBase.As_PyTypeObject().tp_dict,"setClockDelta",PyCFunction_New(&Dtool_Methods_CDistributedSmoothNodeBase[1],&Dtool_CDistributedSmoothNodeBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CDistributedSmoothNodeBase,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CDistributedSmoothNodeBase.As_PyTypeObject());
        PyModule_AddObject(module, "CDistributedSmoothNodeBase",(PyObject *)&Dtool_CDistributedSmoothNodeBase.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CConnectionRepository
//********************************************************************
   Dtool_PyModuleClassInit_CConnectionRepository(module);
//********************************************************************
//*** Module Init Updcall ..CDistributedSmoothNodeBase
//********************************************************************
   Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdistributed_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213742,  /* file_identifier */
  "libdistributed",  /* library_name */
  "iutg",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libdistributed.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  187  /* next_index */
};

Configure(_in_configure_libdistributed);
ConfigureFn(_in_configure_libdistributed) {
  interrogate_request_module(&_in_module_def);
}

