/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/movies -Ipanda/src/movies -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libmovies_igate.cxx -od built_Rocket/pandac/input/libmovies.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/movies -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/ffmpeg/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libmovies config_movies.h ffmpegAudio.h ffmpegAudioCursor.h ffmpegVideo.h ffmpegVideoCursor.h ffmpegVirtualFile.h inkblotVideo.h inkblotVideoCursor.h microphoneAudio.h movieAudio.h movieAudioCursor.h movieVideo.h movieVideoCursor.h movies_composite.cxx userDataAudio.h userDataAudioCursor.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libmovies
#include "py_panda.h"  

#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "config_movies.h"
#include "dconfig.h"
#include "ffmpegAudio.h"
#include "ffmpegAudioCursor.h"
#include "ffmpegVideo.h"
#include "ffmpegVideoCursor.h"
#include "ffmpegVirtualFile.h"
#include "inkblotVideo.h"
#include "inkblotVideoCursor.h"
#include "microphoneAudio.h"
#include "movieAudio.h"
#include "movieAudioCursor.h"
#include "movieVideo.h"
#include "movieVideoCursor.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "userDataAudio.h"
#include "userDataAudioCursor.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. MovieVideo
//********************************************************************
typedef  MovieVideo  MovieVideo_localtype;
Define_Module_ClassRef(panda,MovieVideo,MovieVideo_localtype,MovieVideo);
//********************************************************************
//*** prototypes for .. MovieVideoCursor
//********************************************************************
typedef  MovieVideoCursor  MovieVideoCursor_localtype;
Define_Module_ClassRef(panda,MovieVideoCursor,MovieVideoCursor_localtype,MovieVideoCursor);
//********************************************************************
//*** prototypes for .. MovieAudio
//********************************************************************
typedef  MovieAudio  MovieAudio_localtype;
Define_Module_ClassRef(panda,MovieAudio,MovieAudio_localtype,MovieAudio);
//********************************************************************
//*** prototypes for .. MovieAudioCursor
//********************************************************************
typedef  MovieAudioCursor  MovieAudioCursor_localtype;
Define_Module_ClassRef(panda,MovieAudioCursor,MovieAudioCursor_localtype,MovieAudioCursor);
//********************************************************************
//*** prototypes for .. InkblotVideo
//********************************************************************
typedef  InkblotVideo  InkblotVideo_localtype;
Define_Module_ClassRef(panda,InkblotVideo,InkblotVideo_localtype,InkblotVideo);
//********************************************************************
//*** prototypes for .. InkblotVideoCursor
//********************************************************************
typedef  InkblotVideoCursor  InkblotVideoCursor_localtype;
Define_Module_ClassRef(panda,InkblotVideoCursor,InkblotVideoCursor_localtype,InkblotVideoCursor);
//********************************************************************
//*** prototypes for .. FfmpegVideo
//********************************************************************
typedef  FfmpegVideo  FfmpegVideo_localtype;
Define_Module_ClassRef(panda,FfmpegVideo,FfmpegVideo_localtype,FfmpegVideo);
//********************************************************************
//*** prototypes for .. FfmpegVideoCursor
//********************************************************************
typedef  FfmpegVideoCursor  FfmpegVideoCursor_localtype;
Define_Module_ClassRef(panda,FfmpegVideoCursor,FfmpegVideoCursor_localtype,FfmpegVideoCursor);
//********************************************************************
//*** prototypes for .. FfmpegAudio
//********************************************************************
typedef  FfmpegAudio  FfmpegAudio_localtype;
Define_Module_ClassRef(panda,FfmpegAudio,FfmpegAudio_localtype,FfmpegAudio);
//********************************************************************
//*** prototypes for .. FfmpegAudioCursor
//********************************************************************
typedef  FfmpegAudioCursor  FfmpegAudioCursor_localtype;
Define_Module_ClassRef(panda,FfmpegAudioCursor,FfmpegAudioCursor_localtype,FfmpegAudioCursor);
//********************************************************************
//*** prototypes for .. MicrophoneAudio
//********************************************************************
typedef  MicrophoneAudio  MicrophoneAudio_localtype;
Define_Module_ClassRef(panda,MicrophoneAudio,MicrophoneAudio_localtype,MicrophoneAudio);
//********************************************************************
//*** prototypes for .. UserDataAudio
//********************************************************************
typedef  UserDataAudio  UserDataAudio_localtype;
Define_Module_ClassRef(panda,UserDataAudio,UserDataAudio_localtype,UserDataAudio);
//********************************************************************
//*** prototypes for .. UserDataAudioCursor
//********************************************************************
typedef  UserDataAudioCursor  UserDataAudioCursor_localtype;
Define_Module_ClassRef(panda,UserDataAudioCursor,UserDataAudioCursor_localtype,UserDataAudioCursor);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramIterator;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. MovieVideo 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieVideoCursor > MovieVideo::open(void)
 *******************************************************************/
static PyObject *Dtool_MovieVideo_open_10(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieVideoCursor > MovieVideo::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieVideoCursor > return_value = (local_this)->open();
            if (return_value != (MovieVideoCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideoCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieVideo.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const MovieVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_open_10_comment =
    "C++ Interface:\n"
    "open(non-const MovieVideo this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideo::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this video, returning a MovieVideoCursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideo_open_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< MovieVideo > MovieVideo::get(Filename const &name)
 *******************************************************************/
static PyObject *Dtool_MovieVideo_get_11(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static PointerTo< MovieVideo > MovieVideo::get(Filename const &name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:get", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:get", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "MovieVideo.get", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PointerTo< MovieVideo > return_value = MovieVideo::get(*param0_this);
                    if (return_value != (MovieVideo *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideo,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get(const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_get_11_comment =
    "C++ Interface:\n"
    "get(const Filename name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideo::get\n"
    "//       Access: Published, Static\n"
    "//  Description: Obtains a MovieVideo that references a file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideo_get_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &MovieVideo::get_filename(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideo_get_filename_12(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &MovieVideo::get_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const MovieVideo*)local_this)->get_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const MovieVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_get_filename_12_comment =
    "C++ Interface:\n"
    "getFilename(const MovieVideo this)\n"
    "\n"
    "// Filename: movieVideo.I\n"
    "// Created by: jyelon (02Jul07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideo::get_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the movie's filename.  A movie is not\n"
    "//               guaranteed to have a filename, if not, then this\n"
    "//               function returns a null filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideo_get_filename_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovieVideo::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovieVideo_get_class_type_13(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovieVideo::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovieVideo::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_get_class_type_13_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovieVideo_get_class_type_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_3(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieVideo.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const MovieVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_3_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const MovieVideo this)\n"
    "\n"
    "upcast from MovieVideo to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *MovieVideo::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_MovieVideo_upcast_to_Namable_6(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *MovieVideo::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieVideo.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const MovieVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideo_upcast_to_Namable_6_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const MovieVideo this)\n"
    "\n"
    "upcast from MovieVideo to Namable\n"
    "";
#else
static const char * Dtool_MovieVideo_upcast_to_Namable_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MovieVideo::MovieVideo(basic_string< char > const &name)
 * MovieVideo::MovieVideo(basic_string< char > const &name = ("Blank Video"))
 *******************************************************************/
int  Dtool_Init_MovieVideo(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-MovieVideo::MovieVideo(basic_string< char > const &name = ("Blank Video"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":MovieVideo", key_word_list))
            {
                MovieVideo *return_value = new MovieVideo();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieVideo,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-MovieVideo::MovieVideo(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MovieVideo", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:MovieVideo", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                MovieVideo *return_value = new MovieVideo(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieVideo,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "MovieVideo() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "MovieVideo()\n"
          "MovieVideo(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MovieVideo(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovieVideo)
    {
        printf("MovieVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovieVideo * local_this = (MovieVideo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovieVideo)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovieVideo(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovieVideo)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovieVideo*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovieVideo*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovieVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovieVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovieVideo*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovieVideoCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_get_source_16(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSource", key_word_list));
        else
            (PyArg_Parse(args, ":getSource"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieVideo > return_value = ((const MovieVideoCursor*)local_this)->get_source();
            if (return_value != (MovieVideo *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideo,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSource(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_get_source_16_comment =
    "C++ Interface:\n"
    "getSource(const MovieVideoCursor this)\n"
    "\n"
    "// Filename: movieVideoCursor.I\n"
    "// Created by: jyelon (02Jul07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::get_source\n"
    "//       Access: Published\n"
    "//  Description: Get the MovieVideo which this cursor references.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_get_source_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieVideoCursor::size_x(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_size_x_17(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieVideoCursor::size_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sizeX", key_word_list));
        else
            (PyArg_Parse(args, ":sizeX"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieVideoCursor*)local_this)->size_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sizeX(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_size_x_17_comment =
    "C++ Interface:\n"
    "sizeX(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::size_x\n"
    "//       Access: Published\n"
    "//  Description: Get the horizontal size of the movie.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_size_x_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieVideoCursor::size_y(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_size_y_18(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieVideoCursor::size_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sizeY", key_word_list));
        else
            (PyArg_Parse(args, ":sizeY"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieVideoCursor*)local_this)->size_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sizeY(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_size_y_18_comment =
    "C++ Interface:\n"
    "sizeY(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::size_y\n"
    "//       Access: Published\n"
    "//  Description: Get the vertical size of the movie.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_size_y_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieVideoCursor::get_num_components(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_get_num_components_19(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieVideoCursor::get_num_components(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumComponents", key_word_list));
        else
            (PyArg_Parse(args, ":getNumComponents"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieVideoCursor*)local_this)->get_num_components();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumComponents(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_get_num_components_19_comment =
    "C++ Interface:\n"
    "getNumComponents(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::get_num_components\n"
    "//       Access: Published\n"
    "//  Description: Returns 4 if the movie has an alpha\n"
    "//               channel, 3 otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_get_num_components_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MovieVideoCursor::length(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_length_20(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieVideoCursor::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieVideoCursor*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_length_20_comment =
    "C++ Interface:\n"
    "length(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::length\n"
    "//       Access: Published\n"
    "//  Description: Returns the length of the movie.\n"
    "//\n"
    "//               Some kinds of Movie, such as internet TV station, \n"
    "//               might not have a predictable length.  In that case,\n"
    "//               the length will be set to a very large number: 1.0E10.\n"
    "//               If the internet TV station goes offline, the video\n"
    "//               or audio stream will set its abort flag.  Reaching the\n"
    "//               end of the movie (ie, the specified length) normally\n"
    "//               does not cause the abort flag to be set.\n"
    "//\n"
    "//               The video and audio streams produced by get_video and\n"
    "//               get_audio are always of unlimited duration - you can\n"
    "//               always read another video frame or another audio\n"
    "//               sample.  This is true even if the specified length\n"
    "//               is reached, or an abort is flagged. If either stream\n"
    "//               runs out of data, it will synthesize blank video\n"
    "//               frames and silent audio samples as necessary to\n"
    "//               satisfy read requests.\n"
    "//\n"
    "//               Some AVI files have incorrect length values encoded\n"
    "//               into them - usually, they're a second or two long or\n"
    "//               short.  When playing such an AVI using the Movie class,\n"
    "//               you may see a slightly truncated video, or a slightly\n"
    "//               elongated video (padded with black frames).  There are\n"
    "//               utilities out there to fix the length values in AVI\n"
    "//               files.\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_length_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieVideoCursor::can_seek(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_can_seek_21(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieVideoCursor::can_seek(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":canSeek", key_word_list));
        else
            (PyArg_Parse(args, ":canSeek"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieVideoCursor*)local_this)->can_seek();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "canSeek(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_can_seek_21_comment =
    "C++ Interface:\n"
    "canSeek(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::can_seek\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the movie can seek.  If this is\n"
    "//               true, seeking is still not guaranteed to be fast:\n"
    "//               for some movies, seeking is implemented by rewinding\n"
    "//               to the beginning and then fast-forwarding to the\n"
    "//               desired location.  Even if the movie cannot seek,\n"
    "//               the fetch methods can still advance to an arbitrary\n"
    "//               location by reading frames and discarding them.\n"
    "//               However, to move backward, can_seek must return true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_can_seek_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieVideoCursor::can_seek_fast(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_can_seek_fast_22(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieVideoCursor::can_seek_fast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":canSeekFast", key_word_list));
        else
            (PyArg_Parse(args, ":canSeekFast"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieVideoCursor*)local_this)->can_seek_fast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "canSeekFast(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_can_seek_fast_22_comment =
    "C++ Interface:\n"
    "canSeekFast(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::can_seek_fast\n"
    "//       Access: Published\n"
    "//  Description: Returns true if seek operations are constant time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_can_seek_fast_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieVideoCursor::aborted(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_aborted_23(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieVideoCursor::aborted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":aborted", key_word_list));
        else
            (PyArg_Parse(args, ":aborted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieVideoCursor*)local_this)->aborted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aborted(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_aborted_23_comment =
    "C++ Interface:\n"
    "aborted(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::aborted\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the video has aborted prematurely.\n"
    "//               For example, this could occur if the Movie was actually\n"
    "//               an internet TV station, and the connection was lost.\n"
    "//               Reaching the normal end of the video does not\n"
    "//               constitute an 'abort' condition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_aborted_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MovieVideoCursor::last_start(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_last_start_24(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieVideoCursor::last_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":lastStart", key_word_list));
        else
            (PyArg_Parse(args, ":lastStart"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieVideoCursor*)local_this)->last_start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "lastStart(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_last_start_24_comment =
    "C++ Interface:\n"
    "lastStart(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::last_start\n"
    "//       Access: Published\n"
    "//  Description: Returns the start time of the last frame you read.\n"
    "//\n"
    "//               MovieVideoCursor streams have variable frame rates.  Each\n"
    "//               frame will specify how long it is to be displayed.\n"
    "//               These lengths may not be equal from frame to frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_last_start_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MovieVideoCursor::next_start(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_next_start_25(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieVideoCursor::next_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":nextStart", key_word_list));
        else
            (PyArg_Parse(args, ":nextStart"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieVideoCursor*)local_this)->next_start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "nextStart(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_next_start_25_comment =
    "C++ Interface:\n"
    "nextStart(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::next_start\n"
    "//       Access: Published\n"
    "//  Description: Returns the start time of the next frame you can read.\n"
    "//\n"
    "//               MovieVideoCursor streams have variable frame rates.  Each\n"
    "//               frame will specify how long it is to be displayed.\n"
    "//               These lengths may not be equal from frame to frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_next_start_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieVideoCursor::ready(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_ready_26(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieVideoCursor::ready(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ready", key_word_list));
        else
            (PyArg_Parse(args, ":ready"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieVideoCursor*)local_this)->ready();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ready(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_ready_26_comment =
    "C++ Interface:\n"
    "ready(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::ready\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the cursor is a streaming source, and\n"
    "//               if a video frame is ready to be read.  For non-\n"
    "//               streaming sources, this is always false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_ready_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieVideoCursor::streaming(void) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_streaming_27(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieVideoCursor::streaming(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":streaming", key_word_list));
        else
            (PyArg_Parse(args, ":streaming"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieVideoCursor*)local_this)->streaming();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "streaming(const MovieVideoCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_streaming_27_comment =
    "C++ Interface:\n"
    "streaming(const MovieVideoCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::streaming\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the video frames are being \"pushed\"\n"
    "//               at us by something that operates at its own speed - \n"
    "//               for example, a webcam.  In this case, the frames come\n"
    "//               when they're ready to come.  Attempting to read too\n"
    "//               soon will produce nothing, reading too late will cause\n"
    "//               frames to be dropped.  In this case, the ready flag\n"
    "//               can be used to determine whether or not a frame is\n"
    "//               ready for reading.\n"
    "//\n"
    "//               When streaming, you should still pay attention to\n"
    "//               last_start, but the value of next_start is only a\n"
    "//               guess.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_streaming_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MovieVideoCursor::setup_texture(Texture *tex) const
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_setup_texture_28(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MovieVideoCursor::setup_texture(Texture *tex) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tex", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setupTexture", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setupTexture", &param1));
            if(!PyErr_Occurred())
            {
                Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "MovieVideoCursor.setupTexture", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MovieVideoCursor*)local_this)->setup_texture(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupTexture(const MovieVideoCursor this, non-const Texture tex)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_setup_texture_28_comment =
    "C++ Interface:\n"
    "setupTexture(const MovieVideoCursor this, non-const Texture tex)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::setup_texture\n"
    "//       Access: Published\n"
    "//  Description: Set up the specified Texture object to contain\n"
    "//               content from this movie.  This should be called\n"
    "//               once, not every frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_setup_texture_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovieVideoCursor::fetch_into_bitbucket(double time)
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_fetch_into_bitbucket_29(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void MovieVideoCursor::fetch_into_bitbucket(double time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:fetchIntoBitbucket", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:fetchIntoBitbucket", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->fetch_into_bitbucket((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieVideoCursor.fetchIntoBitbucket() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fetchIntoBitbucket(non-const MovieVideoCursor this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_fetch_into_bitbucket_29_comment =
    "C++ Interface:\n"
    "fetchIntoBitbucket(non-const MovieVideoCursor this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::fetch_into_bitbucket\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Discards the next video frame.  Still sets\n"
    "//               last_start and next_start.\n"
    "//\n"
    "//               See fetch_into_buffer for more details.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_fetch_into_bitbucket_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovieVideoCursor::fetch_into_texture(double time, Texture *t, int page)
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_fetch_into_texture_30(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void MovieVideoCursor::fetch_into_texture(double time, Texture *t, int page)
            double param1;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"time", (char *)"t", (char *)"page", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dOi:fetchIntoTexture", key_word_list, &param1, &param2, &param3))
            {
                Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "MovieVideoCursor.fetchIntoTexture", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->fetch_into_texture((double)param1, param2_this, (int)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MovieVideoCursor.fetchIntoTexture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fetchIntoTexture(non-const MovieVideoCursor this, float time, non-const Texture t, int page)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_fetch_into_texture_30_comment =
    "C++ Interface:\n"
    "fetchIntoTexture(non-const MovieVideoCursor this, float time, non-const Texture t, int page)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::fetch_into_texture\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Reads the specified video frame into \n"
    "//               the specified texture.\n"
    "//\n"
    "//               See fetch_into_buffer for more details.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_fetch_into_texture_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovieVideoCursor::fetch_into_texture_rgb(double time, Texture *t, int page)
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_fetch_into_texture_rgb_31(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void MovieVideoCursor::fetch_into_texture_rgb(double time, Texture *t, int page)
            double param1;
            PyObject *param2;
            int param3;
            static char * key_word_list[] = {(char *)"time", (char *)"t", (char *)"page", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dOi:fetchIntoTextureRgb", key_word_list, &param1, &param2, &param3))
            {
                Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "MovieVideoCursor.fetchIntoTextureRgb", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->fetch_into_texture_rgb((double)param1, param2_this, (int)param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MovieVideoCursor.fetchIntoTextureRgb() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fetchIntoTextureRgb(non-const MovieVideoCursor this, float time, non-const Texture t, int page)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_fetch_into_texture_rgb_31_comment =
    "C++ Interface:\n"
    "fetchIntoTextureRgb(non-const MovieVideoCursor this, float time, non-const Texture t, int page)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::fetch_into_texture_rgb\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Reads the specified video frame into\n"
    "//               the RGB channels of the supplied texture.  The alpha\n"
    "//               channel of the texture is not touched.\n"
    "//\n"
    "//               See fetch_into_buffer for more details.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_fetch_into_texture_rgb_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovieVideoCursor::fetch_into_texture_alpha(double time, Texture *t, int page, int alpha_src)
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_fetch_into_texture_alpha_32(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieVideoCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieVideoCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void MovieVideoCursor::fetch_into_texture_alpha(double time, Texture *t, int page, int alpha_src)
            double param1;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"time", (char *)"t", (char *)"page", (char *)"alpha_src", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dOii:fetchIntoTextureAlpha", key_word_list, &param1, &param2, &param3, &param4))
            {
                Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "MovieVideoCursor.fetchIntoTextureAlpha", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->fetch_into_texture_alpha((double)param1, param2_this, (int)param3, (int)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MovieVideoCursor.fetchIntoTextureAlpha() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fetchIntoTextureAlpha(non-const MovieVideoCursor this, float time, non-const Texture t, int page, int alpha_src)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_fetch_into_texture_alpha_32_comment =
    "C++ Interface:\n"
    "fetchIntoTextureAlpha(non-const MovieVideoCursor this, float time, non-const Texture t, int page, int alpha_src)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieVideoCursor::fetch_into_texture_alpha\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Reads the specified video frame into \n"
    "//               the alpha channel of the supplied texture.  The\n"
    "//               RGB channels of the texture are not touched.\n"
    "//\n"
    "//               See fetch_into_buffer for more details.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_fetch_into_texture_alpha_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovieVideoCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovieVideoCursor_get_class_type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovieVideoCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovieVideoCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieVideoCursor_get_class_type_33_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovieVideoCursor_get_class_type_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MovieVideoCursor::MovieVideoCursor(MovieVideo *src)
 *******************************************************************/
int  Dtool_Init_MovieVideoCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-MovieVideoCursor::MovieVideoCursor(MovieVideo *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:MovieVideoCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:MovieVideoCursor", &param0));
            if(!PyErr_Occurred())
            {
                MovieVideo *param0_this = (MovieVideo *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_MovieVideo, 0, "MovieVideoCursor.MovieVideoCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    MovieVideoCursor *return_value = new MovieVideoCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieVideoCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MovieVideoCursor(non-const MovieVideo src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MovieVideoCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovieVideoCursor)
    {
        printf("MovieVideoCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovieVideoCursor * local_this = (MovieVideoCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovieVideoCursor)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovieVideoCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovieVideoCursor)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovieVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovieVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovieVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovieVideoCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovieAudio 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieAudioCursor > MovieAudio::open(void)
 *******************************************************************/
static PyObject *Dtool_MovieAudio_open_41(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieAudioCursor > MovieAudio::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieAudioCursor > return_value = (local_this)->open();
            if (return_value != (MovieAudioCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudioCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieAudio.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const MovieAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_open_41_comment =
    "C++ Interface:\n"
    "open(non-const MovieAudio this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudio::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this audio, returning a MovieAudioCursor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudio_open_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< MovieAudio > MovieAudio::get(Filename const &name)
 *******************************************************************/
static PyObject *Dtool_MovieAudio_get_42(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static PointerTo< MovieAudio > MovieAudio::get(Filename const &name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:get", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:get", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "MovieAudio.get", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PointerTo< MovieAudio > return_value = MovieAudio::get(*param0_this);
                    if (return_value != (MovieAudio *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudio,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get(const Filename name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_get_42_comment =
    "C++ Interface:\n"
    "get(const Filename name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudio::get\n"
    "//       Access: Published, Static\n"
    "//  Description: Obtains a MovieAudio that references a file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudio_get_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &MovieAudio::get_filename(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudio_get_filename_43(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &MovieAudio::get_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const MovieAudio*)local_this)->get_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFilename(const MovieAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_get_filename_43_comment =
    "C++ Interface:\n"
    "getFilename(const MovieAudio this)\n"
    "\n"
    "// Filename: movieAudio.I\n"
    "// Created by: jyelon (02Jul07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudio::get_filename\n"
    "//       Access: Published\n"
    "//  Description: Returns the movie's filename.  A movie is not\n"
    "//               guaranteed to have a filename, if not, then this\n"
    "//               function returns a null filename.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudio_get_filename_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovieAudio::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovieAudio_get_class_type_44(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovieAudio::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovieAudio::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_get_class_type_44_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovieAudio_get_class_type_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_35(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieAudio.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const MovieAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_35_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const MovieAudio this)\n"
    "\n"
    "upcast from MovieAudio to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *MovieAudio::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_MovieAudio_upcast_to_Namable_37(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *MovieAudio::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieAudio.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const MovieAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudio_upcast_to_Namable_37_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const MovieAudio this)\n"
    "\n"
    "upcast from MovieAudio to Namable\n"
    "";
#else
static const char * Dtool_MovieAudio_upcast_to_Namable_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MovieAudio::MovieAudio(basic_string< char > const &name)
 * MovieAudio::MovieAudio(basic_string< char > const &name = ("Blank Audio"))
 *******************************************************************/
int  Dtool_Init_MovieAudio(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-MovieAudio::MovieAudio(basic_string< char > const &name = ("Blank Audio"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":MovieAudio", key_word_list))
            {
                MovieAudio *return_value = new MovieAudio();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieAudio,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-MovieAudio::MovieAudio(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MovieAudio", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:MovieAudio", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                MovieAudio *return_value = new MovieAudio(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieAudio,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "MovieAudio() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "MovieAudio()\n"
          "MovieAudio(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MovieAudio(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovieAudio)
    {
        printf("MovieAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovieAudio * local_this = (MovieAudio *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovieAudio)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovieAudio(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovieAudio)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovieAudio*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovieAudio*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovieAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovieAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovieAudio*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovieAudioCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_get_source_47(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSource", key_word_list));
        else
            (PyArg_Parse(args, ":getSource"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieAudio > return_value = ((const MovieAudioCursor*)local_this)->get_source();
            if (return_value != (MovieAudio *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudio,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSource(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_get_source_47_comment =
    "C++ Interface:\n"
    "getSource(const MovieAudioCursor this)\n"
    "\n"
    "// Filename: movieAudioCursor.I\n"
    "// Created by: jyelon (02Jul07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::get_source\n"
    "//       Access: Public\n"
    "//  Description: Returns the MovieAudio which this cursor references.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_get_source_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieAudioCursor::audio_rate(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_audio_rate_48(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieAudioCursor::audio_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":audioRate", key_word_list));
        else
            (PyArg_Parse(args, ":audioRate"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieAudioCursor*)local_this)->audio_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audioRate(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_audio_rate_48_comment =
    "C++ Interface:\n"
    "audioRate(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::audio_rate\n"
    "//       Access: Public\n"
    "//  Description: Returns the audio sample rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_audio_rate_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MovieAudioCursor::audio_channels(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_audio_channels_49(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovieAudioCursor::audio_channels(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":audioChannels", key_word_list));
        else
            (PyArg_Parse(args, ":audioChannels"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieAudioCursor*)local_this)->audio_channels();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "audioChannels(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_audio_channels_49_comment =
    "C++ Interface:\n"
    "audioChannels(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::audio_channels\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of audio channels (ie, two for\n"
    "//               stereo, one for mono).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_audio_channels_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MovieAudioCursor::length(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_length_50(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieAudioCursor::length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":length", key_word_list));
        else
            (PyArg_Parse(args, ":length"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieAudioCursor*)local_this)->length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "length(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_length_50_comment =
    "C++ Interface:\n"
    "length(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::length\n"
    "//       Access: Public\n"
    "//  Description: Returns the length of the movie.  Attempting to read\n"
    "//               audio samples beyond the specified length will produce \n"
    "//               silent samples.\n"
    "//\n"
    "//               Some kinds of Movie, such as internet TV station, \n"
    "//               might not have a predictable length.  In that case,\n"
    "//               the length will be set to a very large number: 1.0E10.\n"
    "//\n"
    "//               Some AVI files have incorrect length values encoded\n"
    "//               into them - they may be a second or two long or\n"
    "//               short.  When playing such an AVI using the Movie class,\n"
    "//               you may see a slightly truncated video, or a slightly\n"
    "//               elongated video (padded with black frames).  There are\n"
    "//               utilities out there to fix the length values in AVI\n"
    "//               files.\n"
    "//\n"
    "//               An audio consumer needs to check the length, the\n"
    "//               ready status, and the aborted flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_length_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieAudioCursor::can_seek(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_can_seek_51(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieAudioCursor::can_seek(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":canSeek", key_word_list));
        else
            (PyArg_Parse(args, ":canSeek"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieAudioCursor*)local_this)->can_seek();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "canSeek(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_can_seek_51_comment =
    "C++ Interface:\n"
    "canSeek(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::can_seek\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the movie can seek.  If this is\n"
    "//               true, seeking is still not guaranteed to be fast:\n"
    "//               for some movies, seeking is implemented by rewinding\n"
    "//               to the beginning and then fast-forwarding to the\n"
    "//               desired location.  Even if the movie cannot seek,\n"
    "//               the seek method can still advance to an arbitrary\n"
    "//               location by reading samples and discarding them.\n"
    "//               However, to move backward, can_seek must return true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_can_seek_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieAudioCursor::can_seek_fast(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_can_seek_fast_52(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieAudioCursor::can_seek_fast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":canSeekFast", key_word_list));
        else
            (PyArg_Parse(args, ":canSeekFast"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieAudioCursor*)local_this)->can_seek_fast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "canSeekFast(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_can_seek_fast_52_comment =
    "C++ Interface:\n"
    "canSeekFast(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::can_seek_fast\n"
    "//       Access: Public\n"
    "//  Description: Returns true if seek operations are constant time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_can_seek_fast_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MovieAudioCursor::tell(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_tell_53(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MovieAudioCursor::tell(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tell", key_word_list));
        else
            (PyArg_Parse(args, ":tell"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MovieAudioCursor*)local_this)->tell();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tell(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_tell_53_comment =
    "C++ Interface:\n"
    "tell(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::tell\n"
    "//       Access: Public\n"
    "//  Description: Returns the current offset within the file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_tell_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MovieAudioCursor::skip_samples(int n)
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_skip_samples_54(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MovieAudioCursor::skip_samples(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:skipSamples", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:skipSamples", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->skip_samples((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieAudioCursor.skipSamples() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "skipSamples(non-const MovieAudioCursor this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_skip_samples_54_comment =
    "C++ Interface:\n"
    "skipSamples(non-const MovieAudioCursor this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::skip_samples\n"
    "//       Access: Published\n"
    "//  Description: Skip audio samples from the stream.  This is mostly\n"
    "//               for debugging purposes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_skip_samples_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MovieAudioCursor::aborted(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_aborted_55(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MovieAudioCursor::aborted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":aborted", key_word_list));
        else
            (PyArg_Parse(args, ":aborted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MovieAudioCursor*)local_this)->aborted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aborted(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_aborted_55_comment =
    "C++ Interface:\n"
    "aborted(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::aborted\n"
    "//       Access: Public\n"
    "//  Description: If aborted is true, it means that the \"ready\" samples\n"
    "//               are not being replenished.  See the method \"ready\"\n"
    "//               for an explanation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_aborted_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int MovieAudioCursor::ready(void) const
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_ready_56(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int MovieAudioCursor::ready(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ready", key_word_list));
        else
            (PyArg_Parse(args, ":ready"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovieAudioCursor*)local_this)->ready();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ready(const MovieAudioCursor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_ready_56_comment =
    "C++ Interface:\n"
    "ready(const MovieAudioCursor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::ready\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of audio samples that are ready\n"
    "//               to read.  This is primarily relevant for sources like\n"
    "//               microphones which produce samples at a fixed rate.\n"
    "//               If you try to read more samples than are ready, the\n"
    "//               result will be silent samples.  \n"
    "//\n"
    "//               Some audio streams do not have a limit on how fast \n"
    "//               they can produce samples.  Such streams will always\n"
    "//               return 0x40000000 as the ready-count.  This may well\n"
    "//               exceed the length of the audio stream.  You therefore\n"
    "//               need to check length separately.\n"
    "//\n"
    "//               If the aborted flag is set, that means the ready count\n"
    "//               is no longer being replenished.  For example, a\n"
    "//               MovieAudioCursor might be reading from an internet\n"
    "//               radio station, and it might buffer data to avoid \n"
    "//               underruns.  If it loses connection to the radio\n"
    "//               station, it will set the aborted flag to indicate that\n"
    "//               the buffer is no longer being replenished.  But it is\n"
    "//               still ok to read the samples that are in the buffer,\n"
    "//               at least until they run out.  Once those are gone,\n"
    "//               there will be no more.\n"
    "//\n"
    "//               An audio consumer needs to check the length, the\n"
    "//               ready status, and the aborted flag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_ready_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovieAudioCursor::seek(double offset)
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_seek_57(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void MovieAudioCursor::seek(double offset)
        double param1;
        static char * key_word_list[] = {(char *)"offset", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:seek", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:seek", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->seek((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MovieAudioCursor.seek() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "seek(non-const MovieAudioCursor this, float offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_seek_57_comment =
    "C++ Interface:\n"
    "seek(non-const MovieAudioCursor this, float offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::seek\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Skips to the specified offset within the file.\n"
    "//\n"
    "//               If the movie reports that it cannot seek, then\n"
    "//               this method can still advance by reading samples\n"
    "//               and discarding them.  However, to move backward,\n"
    "//               can_seek must be true.\n"
    "//\n"
    "//               If the movie reports that it can_seek, it doesn't\n"
    "//               mean that it can do so quickly.  It may have to\n"
    "//               rewind the movie and then fast forward to the\n"
    "//               desired location.  Only if can_seek_fast returns\n"
    "//               true can seek operations be done in constant time.\n"
    "//\n"
    "//               Seeking may not be precise, because AVI files \n"
    "//               often have inaccurate indices.  After\n"
    "//               seeking, tell will indicate that the cursor is\n"
    "//               at the target location. However, in truth, the data\n"
    "//               you read may come from a slightly offset location.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_seek_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > MovieAudioCursor::read_samples(int n)
 * void MovieAudioCursor::read_samples(int n, Datagram *dg)
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_read_samples_58(PyObject *self, PyObject *args,PyObject *kwds) {
    MovieAudioCursor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovieAudioCursor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > MovieAudioCursor::read_samples(int n)
            int param1;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:readSamples", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:readSamples", &param1));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = (local_this)->read_samples((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MovieAudioCursor.readSamples() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void MovieAudioCursor::read_samples(int n, Datagram *dg)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"n", (char *)"dg", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:readSamples", key_word_list, &param1, &param2))
                {
                    Datagram *param2_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Datagram, 2, "MovieAudioCursor.readSamples", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->read_samples((int)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MovieAudioCursor.readSamples() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "readSamples() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "readSamples(non-const MovieAudioCursor this, int n)\n"
          "readSamples(non-const MovieAudioCursor this, int n, non-const Datagram dg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_read_samples_58_comment =
    "C++ Interface:\n"
    "readSamples(non-const MovieAudioCursor this, int n)\n"
    "readSamples(non-const MovieAudioCursor this, int n, non-const Datagram dg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::read_samples\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Read audio samples from the stream.  N is the\n"
    "//               number of samples you wish to read.  Your buffer\n"
    "//               must be equal in size to N * channels.  \n"
    "//               Multiple-channel audio will be interleaved. \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::read_samples\n"
    "//       Access: Published\n"
    "//  Description: Read audio samples from the stream into a \n"
    "//               Datagram.  N is the number of samples you wish\n"
    "//               to read. Multiple-channel audio will be interleaved. \n"
    "//\n"
    "//               This is not particularly efficient, but it may be\n"
    "//               a convenient way to manipulate samples in python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovieAudioCursor::read_samples\n"
    "//       Access: Published\n"
    "//  Description: Read audio samples from the stream and returns\n"
    "//               them as a string.  The samples are stored little-endian\n"
    "//               in the string.  N is the number of samples you wish\n"
    "//               to read.  Multiple-channel audio will be interleaved. \n"
    "//\n"
    "//               This is not particularly efficient, but it may be\n"
    "//               a convenient way to manipulate samples in python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_read_samples_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovieAudioCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovieAudioCursor_get_class_type_59(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovieAudioCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovieAudioCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovieAudioCursor_get_class_type_59_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovieAudioCursor_get_class_type_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
 *******************************************************************/
int  Dtool_Init_MovieAudioCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-MovieAudioCursor::MovieAudioCursor(MovieAudio *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:MovieAudioCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:MovieAudioCursor", &param0));
            if(!PyErr_Occurred())
            {
                MovieAudio *param0_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_MovieAudio, 0, "MovieAudioCursor.MovieAudioCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    MovieAudioCursor *return_value = new MovieAudioCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_MovieAudioCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MovieAudioCursor(non-const MovieAudio src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MovieAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovieAudioCursor)
    {
        printf("MovieAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovieAudioCursor * local_this = (MovieAudioCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovieAudioCursor)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovieAudioCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovieAudioCursor)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovieAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovieAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovieAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovieAudioCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. InkblotVideo 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieVideoCursor > InkblotVideo::open(void)
 *******************************************************************/
static PyObject *Dtool_InkblotVideo_open_62(PyObject *self, PyObject *args,PyObject *kwds) {
    InkblotVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_InkblotVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieVideoCursor > InkblotVideo::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieVideoCursor > return_value = (local_this)->open();
            if (return_value != (MovieVideoCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideoCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call InkblotVideo.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const InkblotVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_InkblotVideo_open_62_comment =
    "C++ Interface:\n"
    "open(non-const InkblotVideo this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: InkblotVideo::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this video, returning a MovieVideoCursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_InkblotVideo_open_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle InkblotVideo::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_InkblotVideo_get_class_type_63(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle InkblotVideo::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = InkblotVideo::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_InkblotVideo_get_class_type_63_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_InkblotVideo_get_class_type_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * InkblotVideo::InkblotVideo(int x, int y, int fps)
 *******************************************************************/
int  Dtool_Init_InkblotVideo(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-InkblotVideo::InkblotVideo(int x, int y, int fps)
        int param0;
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"fps", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:InkblotVideo", key_word_list, &param0, &param1, &param2))
        {
            InkblotVideo *return_value = new InkblotVideo((int)param0, (int)param1, (int)param2);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_InkblotVideo,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InkblotVideo(int x, int y, int fps)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_InkblotVideo(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_InkblotVideo)
    {
        printf("InkblotVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    InkblotVideo * local_this = (InkblotVideo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_InkblotVideo)
        return local_this;
    if(requested_type == &Dtool_MovieVideo)
        return ( MovieVideo *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_InkblotVideo(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_InkblotVideo)
        return from_this;
    if(from_type == &Dtool_MovieVideo)
    {
          MovieVideo* other_this = (MovieVideo*)from_this;
          return (InkblotVideo*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (InkblotVideo*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (InkblotVideo*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (InkblotVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (InkblotVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (InkblotVideo*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. InkblotVideoCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle InkblotVideoCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_InkblotVideoCursor_get_class_type_66(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle InkblotVideoCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = InkblotVideoCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_InkblotVideoCursor_get_class_type_66_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_InkblotVideoCursor_get_class_type_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
 *******************************************************************/
int  Dtool_Init_InkblotVideoCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:InkblotVideoCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:InkblotVideoCursor", &param0));
            if(!PyErr_Occurred())
            {
                InkblotVideo *param0_this = (InkblotVideo *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_InkblotVideo, 0, "InkblotVideoCursor.InkblotVideoCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    InkblotVideoCursor *return_value = new InkblotVideoCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_InkblotVideoCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "InkblotVideoCursor(non-const InkblotVideo src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_InkblotVideoCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_InkblotVideoCursor)
    {
        printf("InkblotVideoCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    InkblotVideoCursor * local_this = (InkblotVideoCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_InkblotVideoCursor)
        return local_this;
    if(requested_type == &Dtool_MovieVideoCursor)
        return ( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_InkblotVideoCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_InkblotVideoCursor)
        return from_this;
    if(from_type == &Dtool_MovieVideoCursor)
    {
          MovieVideoCursor* other_this = (MovieVideoCursor*)from_this;
          return (InkblotVideoCursor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (InkblotVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (InkblotVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (InkblotVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (InkblotVideoCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FfmpegVideo 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieVideoCursor > FfmpegVideo::open(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegVideo_open_69(PyObject *self, PyObject *args,PyObject *kwds) {
    FfmpegVideo * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FfmpegVideo,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieVideoCursor > FfmpegVideo::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieVideoCursor > return_value = (local_this)->open();
            if (return_value != (MovieVideoCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieVideoCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FfmpegVideo.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const FfmpegVideo this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegVideo_open_69_comment =
    "C++ Interface:\n"
    "open(non-const FfmpegVideo this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FfmpegVideo::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this video, returning a MovieVideoCursor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FfmpegVideo_open_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FfmpegVideo::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegVideo_get_class_type_70(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FfmpegVideo::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FfmpegVideo::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegVideo_get_class_type_70_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FfmpegVideo_get_class_type_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FfmpegVideo::FfmpegVideo(Filename const &name)
 *******************************************************************/
int  Dtool_Init_FfmpegVideo(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-FfmpegVideo::FfmpegVideo(Filename const &name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:FfmpegVideo", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:FfmpegVideo", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "FfmpegVideo.FfmpegVideo", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FfmpegVideo *return_value = new FfmpegVideo(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_FfmpegVideo,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FfmpegVideo(const Filename name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FfmpegVideo(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FfmpegVideo)
    {
        printf("FfmpegVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FfmpegVideo * local_this = (FfmpegVideo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FfmpegVideo)
        return local_this;
    if(requested_type == &Dtool_MovieVideo)
        return ( MovieVideo *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieVideo *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FfmpegVideo(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FfmpegVideo)
        return from_this;
    if(from_type == &Dtool_MovieVideo)
    {
          MovieVideo* other_this = (MovieVideo*)from_this;
          return (FfmpegVideo*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FfmpegVideo*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FfmpegVideo*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FfmpegVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FfmpegVideo*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FfmpegVideo*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FfmpegVideoCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FfmpegVideoCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegVideoCursor_get_class_type_73(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FfmpegVideoCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FfmpegVideoCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegVideoCursor_get_class_type_73_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FfmpegVideoCursor_get_class_type_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FfmpegVideoCursor::FfmpegVideoCursor(FfmpegVideo *src)
 *******************************************************************/
int  Dtool_Init_FfmpegVideoCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-FfmpegVideoCursor::FfmpegVideoCursor(FfmpegVideo *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:FfmpegVideoCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:FfmpegVideoCursor", &param0));
            if(!PyErr_Occurred())
            {
                FfmpegVideo *param0_this = (FfmpegVideo *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_FfmpegVideo, 0, "FfmpegVideoCursor.FfmpegVideoCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FfmpegVideoCursor *return_value = new FfmpegVideoCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_FfmpegVideoCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FfmpegVideoCursor(non-const FfmpegVideo src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FfmpegVideoCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FfmpegVideoCursor)
    {
        printf("FfmpegVideoCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FfmpegVideoCursor * local_this = (FfmpegVideoCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FfmpegVideoCursor)
        return local_this;
    if(requested_type == &Dtool_MovieVideoCursor)
        return ( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieVideoCursor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FfmpegVideoCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FfmpegVideoCursor)
        return from_this;
    if(from_type == &Dtool_MovieVideoCursor)
    {
          MovieVideoCursor* other_this = (MovieVideoCursor*)from_this;
          return (FfmpegVideoCursor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FfmpegVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FfmpegVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FfmpegVideoCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FfmpegVideoCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FfmpegAudio 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieAudioCursor > FfmpegAudio::open(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegAudio_open_76(PyObject *self, PyObject *args,PyObject *kwds) {
    FfmpegAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FfmpegAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieAudioCursor > FfmpegAudio::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieAudioCursor > return_value = (local_this)->open();
            if (return_value != (MovieAudioCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudioCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FfmpegAudio.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const FfmpegAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegAudio_open_76_comment =
    "C++ Interface:\n"
    "open(non-const FfmpegAudio this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FfmpegAudio::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this audio, returning a MovieAudioCursor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FfmpegAudio_open_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FfmpegAudio::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegAudio_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FfmpegAudio::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FfmpegAudio::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegAudio_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FfmpegAudio_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FfmpegAudio::FfmpegAudio(Filename const &name)
 *******************************************************************/
int  Dtool_Init_FfmpegAudio(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-FfmpegAudio::FfmpegAudio(Filename const &name)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:FfmpegAudio", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:FfmpegAudio", &param0));
            if(!PyErr_Occurred())
            {
                Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "FfmpegAudio.FfmpegAudio", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FfmpegAudio *return_value = new FfmpegAudio(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_FfmpegAudio,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FfmpegAudio(const Filename name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FfmpegAudio(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FfmpegAudio)
    {
        printf("FfmpegAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FfmpegAudio * local_this = (FfmpegAudio *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FfmpegAudio)
        return local_this;
    if(requested_type == &Dtool_MovieAudio)
        return ( MovieAudio *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FfmpegAudio(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FfmpegAudio)
        return from_this;
    if(from_type == &Dtool_MovieAudio)
    {
          MovieAudio* other_this = (MovieAudio*)from_this;
          return (FfmpegAudio*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FfmpegAudio*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FfmpegAudio*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FfmpegAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FfmpegAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FfmpegAudio*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FfmpegAudioCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FfmpegAudioCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FfmpegAudioCursor_get_class_type_80(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FfmpegAudioCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FfmpegAudioCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FfmpegAudioCursor_get_class_type_80_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FfmpegAudioCursor_get_class_type_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FfmpegAudioCursor::FfmpegAudioCursor(FfmpegAudio *src)
 *******************************************************************/
int  Dtool_Init_FfmpegAudioCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-FfmpegAudioCursor::FfmpegAudioCursor(FfmpegAudio *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:FfmpegAudioCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:FfmpegAudioCursor", &param0));
            if(!PyErr_Occurred())
            {
                FfmpegAudio *param0_this = (FfmpegAudio *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_FfmpegAudio, 0, "FfmpegAudioCursor.FfmpegAudioCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    FfmpegAudioCursor *return_value = new FfmpegAudioCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_FfmpegAudioCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FfmpegAudioCursor(non-const FfmpegAudio src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FfmpegAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FfmpegAudioCursor)
    {
        printf("FfmpegAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FfmpegAudioCursor * local_this = (FfmpegAudioCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FfmpegAudioCursor)
        return local_this;
    if(requested_type == &Dtool_MovieAudioCursor)
        return ( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FfmpegAudioCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FfmpegAudioCursor)
        return from_this;
    if(from_type == &Dtool_MovieAudioCursor)
    {
          MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
          return (FfmpegAudioCursor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FfmpegAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FfmpegAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FfmpegAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FfmpegAudioCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MicrophoneAudio 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static int MicrophoneAudio::get_num_options(void)
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_get_num_options_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int MicrophoneAudio::get_num_options(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOptions", key_word_list))
        {
            int return_value = MicrophoneAudio::get_num_options();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOptions()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_get_num_options_82_comment =
    "C++ Interface:\n"
    "getNumOptions()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MicrophoneAudio::get_num_options\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of microphone options.  An \"option\"\n"
    "//               consists of a device plus a set of configuration\n"
    "//               parameters.  For example, \"Soundblaster Audigy Line in\n"
    "//               at 44,100 samples/sec\" would be an option.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_get_num_options_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n)
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_get_option_83(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n)
        int param0;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getOption", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getOption", &param0));
        if(!PyErr_Occurred())
        {
            PointerTo< MicrophoneAudio > return_value = MicrophoneAudio::get_option((int)param0);
            if (return_value != (MicrophoneAudio *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MicrophoneAudio,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOption(int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_get_option_83_comment =
    "C++ Interface:\n"
    "getOption(int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MicrophoneAudio::get_option\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth microphone option.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_get_option_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MicrophoneAudio::get_channels(void) const
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_get_channels_84(PyObject *self, PyObject *args,PyObject *kwds) {
    MicrophoneAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MicrophoneAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MicrophoneAudio::get_channels(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChannels", key_word_list));
        else
            (PyArg_Parse(args, ":getChannels"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MicrophoneAudio*)local_this)->get_channels();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChannels(const MicrophoneAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_get_channels_84_comment =
    "C++ Interface:\n"
    "getChannels(const MicrophoneAudio this)\n"
    "\n"
    "// Filename: microphoneAudio.I\n"
    "// Created by: jyelon (02Jul07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MicrophoneAudio::get_channels\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of channels.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_get_channels_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MicrophoneAudio::get_rate(void) const
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_get_rate_85(PyObject *self, PyObject *args,PyObject *kwds) {
    MicrophoneAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MicrophoneAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MicrophoneAudio::get_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRate", key_word_list));
        else
            (PyArg_Parse(args, ":getRate"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MicrophoneAudio*)local_this)->get_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRate(const MicrophoneAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_get_rate_85_comment =
    "C++ Interface:\n"
    "getRate(const MicrophoneAudio this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MicrophoneAudio::get_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the sample rate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_get_rate_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieAudioCursor > MicrophoneAudio::open(void) = 0
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_open_86(PyObject *self, PyObject *args,PyObject *kwds) {
    MicrophoneAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MicrophoneAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieAudioCursor > MicrophoneAudio::open(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieAudioCursor > return_value = (local_this)->open();
            if (return_value != (MovieAudioCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudioCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MicrophoneAudio.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const MicrophoneAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_open_86_comment =
    "C++ Interface:\n"
    "open(non-const MicrophoneAudio this)\n"
    "\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_open_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MicrophoneAudio::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MicrophoneAudio_get_class_type_87(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MicrophoneAudio::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MicrophoneAudio::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MicrophoneAudio_get_class_type_87_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MicrophoneAudio_get_class_type_87_comment = NULL;
#endif

int  Dtool_Init_MicrophoneAudio(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MicrophoneAudio)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_MicrophoneAudio_get_options(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumOptions", "getOption");
}
inline void  * Dtool_UpcastInterface_MicrophoneAudio(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MicrophoneAudio)
    {
        printf("MicrophoneAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MicrophoneAudio * local_this = (MicrophoneAudio *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MicrophoneAudio)
        return local_this;
    if(requested_type == &Dtool_MovieAudio)
        return ( MovieAudio *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MicrophoneAudio(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MicrophoneAudio)
        return from_this;
    if(from_type == &Dtool_MovieAudio)
    {
          MovieAudio* other_this = (MovieAudio*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MicrophoneAudio*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. UserDataAudio 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual PointerTo< MovieAudioCursor > UserDataAudio::open(void)
 *******************************************************************/
static PyObject *Dtool_UserDataAudio_open_90(PyObject *self, PyObject *args,PyObject *kwds) {
    UserDataAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UserDataAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual PointerTo< MovieAudioCursor > UserDataAudio::open(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":open", key_word_list));
        else
            (PyArg_Parse(args, ":open"));
        if(!PyErr_Occurred())
        {
            PointerTo< MovieAudioCursor > return_value = (local_this)->open();
            if (return_value != (MovieAudioCursor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_MovieAudioCursor,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UserDataAudio.open() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "open(non-const UserDataAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UserDataAudio_open_90_comment =
    "C++ Interface:\n"
    "open(non-const UserDataAudio this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UserDataAudio::open\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Open this audio, returning a UserDataAudioCursor.  A\n"
    "//               UserDataAudio can only be opened by one consumer\n"
    "//               at a time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UserDataAudio_open_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UserDataAudio::append(DatagramIterator *src, int len)
 * void UserDataAudio::append(DatagramIterator *src, int len = (1073741824))
 * void UserDataAudio::append(basic_string< char > const &str)
 *******************************************************************/
static PyObject *Dtool_UserDataAudio_append_91(PyObject *self, PyObject *args,PyObject *kwds) {
    UserDataAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UserDataAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void UserDataAudio::append(DatagramIterator *src, int len = (1073741824))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"src", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:append", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:append", &param1));
                if(!PyErr_Occurred())
                {
                    DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramIterator, 1, "UserDataAudio.append", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->append(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void UserDataAudio::append(basic_string< char > const &str)
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"str", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:append", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:append", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    (local_this)->append(basic_string<char>(param1_str, param1_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void UserDataAudio::append(DatagramIterator *src, int len)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"src", (char *)"len", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:append", key_word_list, &param1, &param2))
                {
                    DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DatagramIterator, 1, "UserDataAudio.append", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->append(param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call UserDataAudio.append() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "append() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "append(non-const UserDataAudio this, non-const DatagramIterator src)\n"
          "append(non-const UserDataAudio this, string str)\n"
          "append(non-const UserDataAudio this, non-const DatagramIterator src, int len)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UserDataAudio_append_91_comment =
    "C++ Interface:\n"
    "append(non-const UserDataAudio this, non-const DatagramIterator src)\n"
    "append(non-const UserDataAudio this, string str)\n"
    "append(non-const UserDataAudio this, non-const DatagramIterator src, int len)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UserDataAudio::append\n"
    "//       Access: Public\n"
    "//  Description: Appends audio samples to the buffer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UserDataAudio::append\n"
    "//       Access: Published\n"
    "//  Description: Appends audio samples to the buffer from a \n"
    "//               datagram.  This is intended to make it easy to \n"
    "//               send streaming raw audio over a network.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UserDataAudio::append\n"
    "//       Access: Published\n"
    "//  Description: Appends audio samples to the buffer from a \n"
    "//               string.  The samples must be stored little-endian\n"
    "//               in the string.  This is not particularly efficient,\n"
    "//               but it may be convenient to deal with samples in\n"
    "//               python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UserDataAudio_append_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void UserDataAudio::done(void)
 *******************************************************************/
static PyObject *Dtool_UserDataAudio_done_92(PyObject *self, PyObject *args,PyObject *kwds) {
    UserDataAudio * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UserDataAudio,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void UserDataAudio::done(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":done", key_word_list));
        else
            (PyArg_Parse(args, ":done"));
        if(!PyErr_Occurred())
        {
            (local_this)->done();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UserDataAudio.done() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "done(non-const UserDataAudio this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UserDataAudio_done_92_comment =
    "C++ Interface:\n"
    "done(non-const UserDataAudio this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UserDataAudio::done\n"
    "//       Access: Published\n"
    "//  Description: Promises not to append any more samples, ie, this\n"
    "//               marks the end of the audio stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UserDataAudio_done_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle UserDataAudio::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_UserDataAudio_get_class_type_93(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle UserDataAudio::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = UserDataAudio::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UserDataAudio_get_class_type_93_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_UserDataAudio_get_class_type_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * UserDataAudio::UserDataAudio(int rate, int channels)
 *******************************************************************/
int  Dtool_Init_UserDataAudio(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-UserDataAudio::UserDataAudio(int rate, int channels)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"rate", (char *)"channels", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:UserDataAudio", key_word_list, &param0, &param1))
        {
            UserDataAudio *return_value = new UserDataAudio((int)param0, (int)param1);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_UserDataAudio,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "UserDataAudio(int rate, int channels)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_UserDataAudio(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_UserDataAudio)
    {
        printf("UserDataAudio ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    UserDataAudio * local_this = (UserDataAudio *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_UserDataAudio)
        return local_this;
    if(requested_type == &Dtool_MovieAudio)
        return ( MovieAudio *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieAudio *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_UserDataAudio(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_UserDataAudio)
        return from_this;
    if(from_type == &Dtool_MovieAudio)
    {
          MovieAudio* other_this = (MovieAudio*)from_this;
          return (UserDataAudio*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (UserDataAudio*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (UserDataAudio*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (UserDataAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (UserDataAudio*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (UserDataAudio*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. UserDataAudioCursor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle UserDataAudioCursor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_UserDataAudioCursor_get_class_type_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle UserDataAudioCursor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = UserDataAudioCursor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UserDataAudioCursor_get_class_type_96_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_UserDataAudioCursor_get_class_type_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
 *******************************************************************/
int  Dtool_Init_UserDataAudioCursor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"src", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:UserDataAudioCursor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:UserDataAudioCursor", &param0));
            if(!PyErr_Occurred())
            {
                UserDataAudio *param0_this = (UserDataAudio *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_UserDataAudio, 0, "UserDataAudioCursor.UserDataAudioCursor", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    UserDataAudioCursor *return_value = new UserDataAudioCursor(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_UserDataAudioCursor,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "UserDataAudioCursor(non-const UserDataAudio src)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_UserDataAudioCursor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_UserDataAudioCursor)
    {
        printf("UserDataAudioCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    UserDataAudioCursor * local_this = (UserDataAudioCursor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_UserDataAudioCursor)
        return local_this;
    if(requested_type == &Dtool_MovieAudioCursor)
        return ( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( MovieAudioCursor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_UserDataAudioCursor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_UserDataAudioCursor)
        return from_this;
    if(from_type == &Dtool_MovieAudioCursor)
    {
          MovieAudioCursor* other_this = (MovieAudioCursor*)from_this;
          return (UserDataAudioCursor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (UserDataAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (UserDataAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (UserDataAudioCursor*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (UserDataAudioCursor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. MovieVideo | MovieVideo
//********************************************************************
PyMethodDef Dtool_Methods_MovieVideo[]= {
  { "open",(PyCFunction ) &Dtool_MovieVideo_open_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_open_10_comment},
  { "get",(PyCFunction ) &Dtool_MovieVideo_get_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_get_11_comment},
  { "getFilename",(PyCFunction ) &Dtool_MovieVideo_get_filename_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_get_filename_12_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovieVideo_get_class_type_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_get_class_type_13_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_upcast_to_TypedWritableReferenceCount_3_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_MovieVideo_upcast_to_Namable_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideo_upcast_to_Namable_6_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovieVideo(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovieVideo.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovieVideo\n"
          "// Description : A MovieVideo is actually any source that provides\n"
          "//               a sequence of video frames.  That could include an\n"
          "//               AVI file, a digital camera, or an internet TV station.\n"
          "//\n"
          "//               The difference between a MovieVideo and a\n"
          "//               MovieVideoCursor is like the difference between a\n"
          "//               filename and a file handle.  The MovieVideo just\n"
          "//               indicates a particular movie.  The MovieVideoCursor\n"
          "//               is what allows access.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_MovieVideo.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_MovieVideo.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovieVideo.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovieVideo.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovieVideo.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovieVideo)");
             printf(" Error In PyType_ReadyMovieVideo");
             return;
        }
        Py_INCREF(&Dtool_MovieVideo.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovieVideo.As_PyTypeObject().tp_dict,"MovieVideo",&Dtool_MovieVideo.As_PyObject());
        //  Static Method get
        PyDict_SetItemString(Dtool_MovieVideo.As_PyTypeObject().tp_dict,"get",PyCFunction_New(&Dtool_Methods_MovieVideo[1],&Dtool_MovieVideo.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovieVideo.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovieVideo[3],&Dtool_MovieVideo.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovieVideo,MovieVideo::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovieVideo.As_PyTypeObject());
        PyModule_AddObject(module, "MovieVideo",(PyObject *)&Dtool_MovieVideo.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovieVideoCursor | MovieVideoCursor
//********************************************************************
PyMethodDef Dtool_Methods_MovieVideoCursor[]= {
  { "getSource",(PyCFunction ) &Dtool_MovieVideoCursor_get_source_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_get_source_16_comment},
  { "sizeX",(PyCFunction ) &Dtool_MovieVideoCursor_size_x_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_size_x_17_comment},
  { "sizeY",(PyCFunction ) &Dtool_MovieVideoCursor_size_y_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_size_y_18_comment},
  { "getNumComponents",(PyCFunction ) &Dtool_MovieVideoCursor_get_num_components_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_get_num_components_19_comment},
  { "length",(PyCFunction ) &Dtool_MovieVideoCursor_length_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_length_20_comment},
  { "canSeek",(PyCFunction ) &Dtool_MovieVideoCursor_can_seek_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_can_seek_21_comment},
  { "canSeekFast",(PyCFunction ) &Dtool_MovieVideoCursor_can_seek_fast_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_can_seek_fast_22_comment},
  { "aborted",(PyCFunction ) &Dtool_MovieVideoCursor_aborted_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_aborted_23_comment},
  { "lastStart",(PyCFunction ) &Dtool_MovieVideoCursor_last_start_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_last_start_24_comment},
  { "nextStart",(PyCFunction ) &Dtool_MovieVideoCursor_next_start_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_next_start_25_comment},
  { "ready",(PyCFunction ) &Dtool_MovieVideoCursor_ready_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_ready_26_comment},
  { "streaming",(PyCFunction ) &Dtool_MovieVideoCursor_streaming_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_streaming_27_comment},
  { "setupTexture",(PyCFunction ) &Dtool_MovieVideoCursor_setup_texture_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_setup_texture_28_comment},
  { "fetchIntoBitbucket",(PyCFunction ) &Dtool_MovieVideoCursor_fetch_into_bitbucket_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_fetch_into_bitbucket_29_comment},
  { "fetchIntoTexture",(PyCFunction ) &Dtool_MovieVideoCursor_fetch_into_texture_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_fetch_into_texture_30_comment},
  { "fetchIntoTextureRgb",(PyCFunction ) &Dtool_MovieVideoCursor_fetch_into_texture_rgb_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_fetch_into_texture_rgb_31_comment},
  { "fetchIntoTextureAlpha",(PyCFunction ) &Dtool_MovieVideoCursor_fetch_into_texture_alpha_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_fetch_into_texture_alpha_32_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovieVideoCursor_get_class_type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieVideoCursor_get_class_type_33_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovieVideoCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovieVideoCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovieVideoCursor\n"
          "// Description : A MovieVideo is actually any source that provides\n"
          "//               a sequence of video frames.  That could include an\n"
          "//               AVI file, a digital camera, or an internet TV station.\n"
          "//               A MovieVideoCursor is a handle that lets you read\n"
          "//               data sequentially from a MovieVideo.\n"
          "//\n"
          "//               Thread safety: each individual MovieVideoCursor\n"
          "//               must be owned and accessed by a single thread.\n"
          "//               It is OK for two different threads to open\n"
          "//               the same file at the same time, as long as they\n"
          "//               use separate MovieVideoCursor objects.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_MovieVideoCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_MovieVideoCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovieVideoCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovieVideoCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovieVideoCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovieVideoCursor)");
             printf(" Error In PyType_ReadyMovieVideoCursor");
             return;
        }
        Py_INCREF(&Dtool_MovieVideoCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovieVideoCursor.As_PyTypeObject().tp_dict,"MovieVideoCursor",&Dtool_MovieVideoCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovieVideoCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovieVideoCursor[17],&Dtool_MovieVideoCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovieVideoCursor,MovieVideoCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovieVideoCursor.As_PyTypeObject());
        PyModule_AddObject(module, "MovieVideoCursor",(PyObject *)&Dtool_MovieVideoCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovieAudio | MovieAudio
//********************************************************************
PyMethodDef Dtool_Methods_MovieAudio[]= {
  { "open",(PyCFunction ) &Dtool_MovieAudio_open_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_open_41_comment},
  { "get",(PyCFunction ) &Dtool_MovieAudio_get_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_get_42_comment},
  { "getFilename",(PyCFunction ) &Dtool_MovieAudio_get_filename_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_get_filename_43_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovieAudio_get_class_type_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_get_class_type_44_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_upcast_to_TypedWritableReferenceCount_35_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_MovieAudio_upcast_to_Namable_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudio_upcast_to_Namable_37_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovieAudio(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovieAudio.As_PyTypeObject().tp_doc =
          "//]\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovieAudio\n"
          "// Description : A MovieAudio is actually any source that provides\n"
          "//               a sequence of audio samples.  That could include an\n"
          "//               AVI file, a microphone, or an internet TV station.\n"
          "//\n"
          "//               The difference between a MovieAudio and a\n"
          "//               MovieAudioCursor is like the difference between a\n"
          "//               filename and a file handle.  The MovieAudio just\n"
          "//               indicates a particular movie.  The MovieAudioCursor\n"
          "//               is what allows access.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_MovieAudio.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_MovieAudio.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovieAudio.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovieAudio.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovieAudio.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovieAudio)");
             printf(" Error In PyType_ReadyMovieAudio");
             return;
        }
        Py_INCREF(&Dtool_MovieAudio.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovieAudio.As_PyTypeObject().tp_dict,"MovieAudio",&Dtool_MovieAudio.As_PyObject());
        //  Static Method get
        PyDict_SetItemString(Dtool_MovieAudio.As_PyTypeObject().tp_dict,"get",PyCFunction_New(&Dtool_Methods_MovieAudio[1],&Dtool_MovieAudio.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovieAudio.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovieAudio[3],&Dtool_MovieAudio.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovieAudio,MovieAudio::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovieAudio.As_PyTypeObject());
        PyModule_AddObject(module, "MovieAudio",(PyObject *)&Dtool_MovieAudio.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovieAudioCursor | MovieAudioCursor
//********************************************************************
PyMethodDef Dtool_Methods_MovieAudioCursor[]= {
  { "getSource",(PyCFunction ) &Dtool_MovieAudioCursor_get_source_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_get_source_47_comment},
  { "audioRate",(PyCFunction ) &Dtool_MovieAudioCursor_audio_rate_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_audio_rate_48_comment},
  { "audioChannels",(PyCFunction ) &Dtool_MovieAudioCursor_audio_channels_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_audio_channels_49_comment},
  { "length",(PyCFunction ) &Dtool_MovieAudioCursor_length_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_length_50_comment},
  { "canSeek",(PyCFunction ) &Dtool_MovieAudioCursor_can_seek_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_can_seek_51_comment},
  { "canSeekFast",(PyCFunction ) &Dtool_MovieAudioCursor_can_seek_fast_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_can_seek_fast_52_comment},
  { "tell",(PyCFunction ) &Dtool_MovieAudioCursor_tell_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_tell_53_comment},
  { "skipSamples",(PyCFunction ) &Dtool_MovieAudioCursor_skip_samples_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_skip_samples_54_comment},
  { "aborted",(PyCFunction ) &Dtool_MovieAudioCursor_aborted_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_aborted_55_comment},
  { "ready",(PyCFunction ) &Dtool_MovieAudioCursor_ready_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_ready_56_comment},
  { "seek",(PyCFunction ) &Dtool_MovieAudioCursor_seek_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_seek_57_comment},
  { "readSamples",(PyCFunction ) &Dtool_MovieAudioCursor_read_samples_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_read_samples_58_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovieAudioCursor_get_class_type_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovieAudioCursor_get_class_type_59_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovieAudioCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovieAudioCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovieAudioCursor\n"
          "// Description : A MovieAudio is actually any source that provides\n"
          "//               a sequence of audio samples.  That could include an\n"
          "//               AVI file, a microphone, or an internet TV station.\n"
          "//               A MovieAudioCursor is a handle that lets you read\n"
          "//               data sequentially from a MovieAudio.\n"
          "//\n"
          "//               Thread safety: each individual MovieAudioCursor\n"
          "//               must be owned and accessed by a single thread.\n"
          "//               It is OK for two different threads to open\n"
          "//               the same file at the same time, as long as they\n"
          "//               use separate MovieAudioCursor objects.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_MovieAudioCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_MovieAudioCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovieAudioCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovieAudioCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovieAudioCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovieAudioCursor)");
             printf(" Error In PyType_ReadyMovieAudioCursor");
             return;
        }
        Py_INCREF(&Dtool_MovieAudioCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovieAudioCursor.As_PyTypeObject().tp_dict,"MovieAudioCursor",&Dtool_MovieAudioCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovieAudioCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovieAudioCursor[12],&Dtool_MovieAudioCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovieAudioCursor,MovieAudioCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovieAudioCursor.As_PyTypeObject());
        PyModule_AddObject(module, "MovieAudioCursor",(PyObject *)&Dtool_MovieAudioCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. InkblotVideo | InkblotVideo
//********************************************************************
PyMethodDef Dtool_Methods_InkblotVideo[]= {
  { "open",(PyCFunction ) &Dtool_InkblotVideo_open_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_InkblotVideo_open_62_comment},
  { "getClassType",(PyCFunction ) &Dtool_InkblotVideo_get_class_type_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_InkblotVideo_get_class_type_63_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_InkblotVideo(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_InkblotVideo.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : InkblotVideo\n"
          "// Description : A cellular automaton that generates an amusing\n"
          "//               pattern of swirling colors.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieVideo._Dtool_ClassInit(NULL);
        Dtool_InkblotVideo.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieVideo.As_PyTypeObject());
        Dtool_InkblotVideo.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_InkblotVideo.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_InkblotVideo.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_InkblotVideo.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(InkblotVideo)");
             printf(" Error In PyType_ReadyInkblotVideo");
             return;
        }
        Py_INCREF(&Dtool_InkblotVideo.As_PyTypeObject());
        PyDict_SetItemString(Dtool_InkblotVideo.As_PyTypeObject().tp_dict,"InkblotVideo",&Dtool_InkblotVideo.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_InkblotVideo.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_InkblotVideo[1],&Dtool_InkblotVideo.As_PyObject()));
        RegisterRuntimeClass(&Dtool_InkblotVideo,InkblotVideo::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_InkblotVideo.As_PyTypeObject());
        PyModule_AddObject(module, "InkblotVideo",(PyObject *)&Dtool_InkblotVideo.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. InkblotVideoCursor | InkblotVideoCursor
//********************************************************************
PyMethodDef Dtool_Methods_InkblotVideoCursor[]= {
  { "getClassType",(PyCFunction ) &Dtool_InkblotVideoCursor_get_class_type_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_InkblotVideoCursor_get_class_type_66_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_InkblotVideoCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_InkblotVideoCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : InkblotVideoCursor\n"
          "// Description : A cellular automaton that generates an amusing\n"
          "//               pattern of swirling colors.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieVideoCursor._Dtool_ClassInit(NULL);
        Dtool_InkblotVideoCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieVideoCursor.As_PyTypeObject());
        Dtool_InkblotVideoCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_InkblotVideoCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_InkblotVideoCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_InkblotVideoCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(InkblotVideoCursor)");
             printf(" Error In PyType_ReadyInkblotVideoCursor");
             return;
        }
        Py_INCREF(&Dtool_InkblotVideoCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_InkblotVideoCursor.As_PyTypeObject().tp_dict,"InkblotVideoCursor",&Dtool_InkblotVideoCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_InkblotVideoCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_InkblotVideoCursor[0],&Dtool_InkblotVideoCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_InkblotVideoCursor,InkblotVideoCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_InkblotVideoCursor.As_PyTypeObject());
        PyModule_AddObject(module, "InkblotVideoCursor",(PyObject *)&Dtool_InkblotVideoCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FfmpegVideo | FfmpegVideo
//********************************************************************
PyMethodDef Dtool_Methods_FfmpegVideo[]= {
  { "open",(PyCFunction ) &Dtool_FfmpegVideo_open_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegVideo_open_69_comment},
  { "getClassType",(PyCFunction ) &Dtool_FfmpegVideo_get_class_type_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegVideo_get_class_type_70_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FfmpegVideo(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FfmpegVideo.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FfmpegVideo\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieVideo._Dtool_ClassInit(NULL);
        Dtool_FfmpegVideo.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieVideo.As_PyTypeObject());
        Dtool_FfmpegVideo.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FfmpegVideo.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FfmpegVideo.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FfmpegVideo.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FfmpegVideo)");
             printf(" Error In PyType_ReadyFfmpegVideo");
             return;
        }
        Py_INCREF(&Dtool_FfmpegVideo.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FfmpegVideo.As_PyTypeObject().tp_dict,"FfmpegVideo",&Dtool_FfmpegVideo.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FfmpegVideo.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FfmpegVideo[1],&Dtool_FfmpegVideo.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FfmpegVideo,FfmpegVideo::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FfmpegVideo.As_PyTypeObject());
        PyModule_AddObject(module, "FfmpegVideo",(PyObject *)&Dtool_FfmpegVideo.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FfmpegVideoCursor | FfmpegVideoCursor
//********************************************************************
PyMethodDef Dtool_Methods_FfmpegVideoCursor[]= {
  { "getClassType",(PyCFunction ) &Dtool_FfmpegVideoCursor_get_class_type_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegVideoCursor_get_class_type_73_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FfmpegVideoCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FfmpegVideoCursor\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieVideoCursor._Dtool_ClassInit(NULL);
        Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieVideoCursor.As_PyTypeObject());
        Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FfmpegVideoCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FfmpegVideoCursor)");
             printf(" Error In PyType_ReadyFfmpegVideoCursor");
             return;
        }
        Py_INCREF(&Dtool_FfmpegVideoCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_dict,"FfmpegVideoCursor",&Dtool_FfmpegVideoCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FfmpegVideoCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FfmpegVideoCursor[0],&Dtool_FfmpegVideoCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FfmpegVideoCursor,FfmpegVideoCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FfmpegVideoCursor.As_PyTypeObject());
        PyModule_AddObject(module, "FfmpegVideoCursor",(PyObject *)&Dtool_FfmpegVideoCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FfmpegAudio | FfmpegAudio
//********************************************************************
PyMethodDef Dtool_Methods_FfmpegAudio[]= {
  { "open",(PyCFunction ) &Dtool_FfmpegAudio_open_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegAudio_open_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_FfmpegAudio_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegAudio_get_class_type_77_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FfmpegAudio(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FfmpegAudio.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FfmpegAudio\n"
          "// Description : A stream that generates a sequence of audio samples.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieAudio._Dtool_ClassInit(NULL);
        Dtool_FfmpegAudio.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieAudio.As_PyTypeObject());
        Dtool_FfmpegAudio.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FfmpegAudio.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FfmpegAudio.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FfmpegAudio.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FfmpegAudio)");
             printf(" Error In PyType_ReadyFfmpegAudio");
             return;
        }
        Py_INCREF(&Dtool_FfmpegAudio.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FfmpegAudio.As_PyTypeObject().tp_dict,"FfmpegAudio",&Dtool_FfmpegAudio.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FfmpegAudio.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FfmpegAudio[1],&Dtool_FfmpegAudio.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FfmpegAudio,FfmpegAudio::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FfmpegAudio.As_PyTypeObject());
        PyModule_AddObject(module, "FfmpegAudio",(PyObject *)&Dtool_FfmpegAudio.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FfmpegAudioCursor | FfmpegAudioCursor
//********************************************************************
PyMethodDef Dtool_Methods_FfmpegAudioCursor[]= {
  { "getClassType",(PyCFunction ) &Dtool_FfmpegAudioCursor_get_class_type_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FfmpegAudioCursor_get_class_type_80_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FfmpegAudioCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FfmpegAudioCursor\n"
          "// Description : A stream that generates a sequence of audio samples.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieAudioCursor._Dtool_ClassInit(NULL);
        Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieAudioCursor.As_PyTypeObject());
        Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FfmpegAudioCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FfmpegAudioCursor)");
             printf(" Error In PyType_ReadyFfmpegAudioCursor");
             return;
        }
        Py_INCREF(&Dtool_FfmpegAudioCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_dict,"FfmpegAudioCursor",&Dtool_FfmpegAudioCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FfmpegAudioCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FfmpegAudioCursor[0],&Dtool_FfmpegAudioCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FfmpegAudioCursor,FfmpegAudioCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FfmpegAudioCursor.As_PyTypeObject());
        PyModule_AddObject(module, "FfmpegAudioCursor",(PyObject *)&Dtool_FfmpegAudioCursor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MicrophoneAudio | MicrophoneAudio
//********************************************************************
PyMethodDef Dtool_Methods_MicrophoneAudio[]= {
  { "getNumOptions",(PyCFunction ) &Dtool_MicrophoneAudio_get_num_options_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_get_num_options_82_comment},
  { "getOption",(PyCFunction ) &Dtool_MicrophoneAudio_get_option_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_get_option_83_comment},
  { "getChannels",(PyCFunction ) &Dtool_MicrophoneAudio_get_channels_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_get_channels_84_comment},
  { "getRate",(PyCFunction ) &Dtool_MicrophoneAudio_get_rate_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_get_rate_85_comment},
  { "open",(PyCFunction ) &Dtool_MicrophoneAudio_open_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_open_86_comment},
  { "getClassType",(PyCFunction ) &Dtool_MicrophoneAudio_get_class_type_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MicrophoneAudio_get_class_type_87_comment},
  { "getOptions",(PyCFunction) &MakeSeq_MicrophoneAudio_get_options, METH_NOARGS|METH_CLASS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MicrophoneAudio(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MicrophoneAudio.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MicrophoneAudio\n"
          "// Description : Class MicrophoneAudio provides the means to read\n"
          "//               raw audio samples from a microphone.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieAudio._Dtool_ClassInit(NULL);
        Dtool_MicrophoneAudio.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieAudio.As_PyTypeObject());
        Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MicrophoneAudio.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MicrophoneAudio)");
             printf(" Error In PyType_ReadyMicrophoneAudio");
             return;
        }
        Py_INCREF(&Dtool_MicrophoneAudio.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict,"MicrophoneAudio",&Dtool_MicrophoneAudio.As_PyObject());
        //  Static Method getNumOptions
        PyDict_SetItemString(Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict,"getNumOptions",PyCFunction_New(&Dtool_Methods_MicrophoneAudio[0],&Dtool_MicrophoneAudio.As_PyObject()));
        //  Static Method getOption
        PyDict_SetItemString(Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict,"getOption",PyCFunction_New(&Dtool_Methods_MicrophoneAudio[1],&Dtool_MicrophoneAudio.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MicrophoneAudio.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MicrophoneAudio[5],&Dtool_MicrophoneAudio.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MicrophoneAudio,MicrophoneAudio::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MicrophoneAudio.As_PyTypeObject());
        PyModule_AddObject(module, "MicrophoneAudio",(PyObject *)&Dtool_MicrophoneAudio.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. UserDataAudio | UserDataAudio
//********************************************************************
PyMethodDef Dtool_Methods_UserDataAudio[]= {
  { "open",(PyCFunction ) &Dtool_UserDataAudio_open_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UserDataAudio_open_90_comment},
  { "append",(PyCFunction ) &Dtool_UserDataAudio_append_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UserDataAudio_append_91_comment},
  { "done",(PyCFunction ) &Dtool_UserDataAudio_done_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UserDataAudio_done_92_comment},
  { "getClassType",(PyCFunction ) &Dtool_UserDataAudio_get_class_type_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UserDataAudio_get_class_type_93_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_UserDataAudio(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_UserDataAudio.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : UserDataAudio\n"
          "// Description : A UserDataAudio is a way for the user to manually\n"
          "//               supply raw audio samples. \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieAudio._Dtool_ClassInit(NULL);
        Dtool_UserDataAudio.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieAudio.As_PyTypeObject());
        Dtool_UserDataAudio.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_UserDataAudio.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_UserDataAudio.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_UserDataAudio.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(UserDataAudio)");
             printf(" Error In PyType_ReadyUserDataAudio");
             return;
        }
        Py_INCREF(&Dtool_UserDataAudio.As_PyTypeObject());
        PyDict_SetItemString(Dtool_UserDataAudio.As_PyTypeObject().tp_dict,"UserDataAudio",&Dtool_UserDataAudio.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_UserDataAudio.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_UserDataAudio[3],&Dtool_UserDataAudio.As_PyObject()));
        RegisterRuntimeClass(&Dtool_UserDataAudio,UserDataAudio::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_UserDataAudio.As_PyTypeObject());
        PyModule_AddObject(module, "UserDataAudio",(PyObject *)&Dtool_UserDataAudio.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. UserDataAudioCursor | UserDataAudioCursor
//********************************************************************
PyMethodDef Dtool_Methods_UserDataAudioCursor[]= {
  { "getClassType",(PyCFunction ) &Dtool_UserDataAudioCursor_get_class_type_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UserDataAudioCursor_get_class_type_96_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_UserDataAudioCursor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_UserDataAudioCursor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : UserDataAudioCursor\n"
          "// Description : A UserDataAudioCursor is a means to manually\n"
          "//               supply a sequence of raw audio samples.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovieAudioCursor._Dtool_ClassInit(NULL);
        Dtool_UserDataAudioCursor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovieAudioCursor.As_PyTypeObject());
        Dtool_UserDataAudioCursor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_UserDataAudioCursor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_UserDataAudioCursor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_UserDataAudioCursor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(UserDataAudioCursor)");
             printf(" Error In PyType_ReadyUserDataAudioCursor");
             return;
        }
        Py_INCREF(&Dtool_UserDataAudioCursor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_UserDataAudioCursor.As_PyTypeObject().tp_dict,"UserDataAudioCursor",&Dtool_UserDataAudioCursor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_UserDataAudioCursor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_UserDataAudioCursor[0],&Dtool_UserDataAudioCursor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_UserDataAudioCursor,UserDataAudioCursor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_UserDataAudioCursor.As_PyTypeObject());
        PyModule_AddObject(module, "UserDataAudioCursor",(PyObject *)&Dtool_UserDataAudioCursor.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..MovieVideo
//********************************************************************
   Dtool_PyModuleClassInit_MovieVideo(module);
//********************************************************************
//*** Module Init Updcall ..MovieVideoCursor
//********************************************************************
   Dtool_PyModuleClassInit_MovieVideoCursor(module);
//********************************************************************
//*** Module Init Updcall ..MovieAudio
//********************************************************************
   Dtool_PyModuleClassInit_MovieAudio(module);
//********************************************************************
//*** Module Init Updcall ..MovieAudioCursor
//********************************************************************
   Dtool_PyModuleClassInit_MovieAudioCursor(module);
//********************************************************************
//*** Module Init Updcall ..InkblotVideo
//********************************************************************
   Dtool_PyModuleClassInit_InkblotVideo(module);
//********************************************************************
//*** Module Init Updcall ..InkblotVideoCursor
//********************************************************************
   Dtool_PyModuleClassInit_InkblotVideoCursor(module);
//********************************************************************
//*** Module Init Updcall ..FfmpegVideo
//********************************************************************
   Dtool_PyModuleClassInit_FfmpegVideo(module);
//********************************************************************
//*** Module Init Updcall ..FfmpegVideoCursor
//********************************************************************
   Dtool_PyModuleClassInit_FfmpegVideoCursor(module);
//********************************************************************
//*** Module Init Updcall ..FfmpegAudio
//********************************************************************
   Dtool_PyModuleClassInit_FfmpegAudio(module);
//********************************************************************
//*** Module Init Updcall ..FfmpegAudioCursor
//********************************************************************
   Dtool_PyModuleClassInit_FfmpegAudioCursor(module);
//********************************************************************
//*** Module Init Updcall ..MicrophoneAudio
//********************************************************************
   Dtool_PyModuleClassInit_MicrophoneAudio(module);
//********************************************************************
//*** Module Init Updcall ..UserDataAudio
//********************************************************************
   Dtool_PyModuleClassInit_UserDataAudio(module);
//********************************************************************
//*** Module Init Updcall ..UserDataAudioCursor
//********************************************************************
   Dtool_PyModuleClassInit_UserDataAudioCursor(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libmovies_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212888,  /* file_identifier */
  "libmovies",  /* library_name */
  "mouF",  /* library_hash_name */
  "panda",  /* module_name */
  "libmovies.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  224  /* next_index */
};

Configure(_in_configure_libmovies);
ConfigureFn(_in_configure_libmovies) {
  interrogate_request_module(&_in_module_def);
}

